---
lang: zh-CN
title: 项目中得到的问题
description: 关键功能
collapsible: true
---
# 项目中得到的问题

## 1.埋点API多平台调用

描述：当用户点击时触发一个埋点方法，发送多个平台，常规方法怎么做？如下`logerA.send()`,`logerB.send()`，但是页面可能很多地方都会调用，每次都写还是很恶心的，用proxy代理

~~~js
const arr = [
    {
        send(val) {
            console.log(val)
        }
    },
    {
        send(val) {
            console.log(val)
        }
    },
]
const obj = new Proxy(arr, {
    get(target, key, receiver) {
        return function () {
            target.forEach(item => {
                item[key] && item[key].call(receiver,...arguments)
            })
        }
    }
})
obj.send(val)
~~~

这样只需要`obj.send`就可以直接调用数组里的`send API`而且如果假设还有其他平台的加入，直接在数组中继续加，页面中的其他使用了的就自动调用，这就是实现了解耦。



## 2.高度自动过度

~~~js
const btn = document.querySelector('.btn')
const content = document.querySelector('.detail')

btn.onmouseenter = function(){
    content.style.height = 'auto'
    const {height} = content.getBoundingClientRect()
    content.style.height = 0
    content.offsetHeight  //强制渲染
    content.style.height = height
}
btn.onmouseleave = function(){
    content.style.height = 0;
    content.style.transition = '.3s'
}
~~~



## 3.SEO

Vue项目`prerender-spa-plugin`

~~~js
plugins: [
    new PrerenderSPAPlugin({
     // 生成文件的路径，要与webpakc打包输出的路径的一致。
     // 这个目录只能有一级，如果目录层次大于一级，在生成的时候不会有任何错误提示，在预渲染的时候会卡着不动。
     staticDir: path.join(__dirname,'dist'),
     // 对应自己的路由文件，比如a有参数，就需要写成 /a/param1。
     routes: ['/', '/product','/about'],
     // 这个很重要，如果没有配置这段，也不会进行预编译
     minify: {
        minifyCSS: true, // css压缩
        removeComments: true // 移除注释
     },
     renderer: new Renderer({
      	// __PRERENDER_INJECTED这个属性名会添加到window对象上，作为inject的内容
      	injectProperty: '__PRERENDER_INJECTED',
      	inject: {
       		foo: 'bar'
      	},
      	headless: false,//渲染时显示到浏览器窗口用于调试
      	// 在 main.js 中 document.dispatchEvent(new Event('custom-render-trigger'))，两者的事件名称要对应上。
      	renderAfterDocumentEvent: 'custom-render-trigger',
      	//等到document.querSelector('my-app-element')检查到该元素开始渲染
      	renderAfterElementExists:'my-app-element'
     })
    }),
   ],
~~~



原理，`prerender-spa-plugin` 利用了 `Puppeteer`的爬取页面的功能。 `Puppeteer` 是一个 `Chrome`官方出品的 `headlessChromenode` 库。它提供了一系列的 API, 可以在无 UI 的情况下调用 `Chrome` 的功能, 适用于爬虫、自动化处理等各种场景。它很强大，所以很简单就能将运行时的 `HTML` 打包到文件中。原理是在 `Webpack` 构建阶段的最后，在本地启动一个 `Puppeteer` 的服务，访问配置了预渲染的路由，然后将 `Puppeteer` 中渲染的页面输出到 `HTML` 文件中，并建立路由对应的目录。





<CommentService/>