---
lang: zh-CN
title: 微前端
description: 关键功能
collapsible: true
---
# 微前端

## 什么是微前端

微前端是一种多个团队通过独立发布功能的方式来共同构建现代化 web 应用的技术手段及方法策略。通俗来说，**就是在一个`web`应用中可以独立的运行另一个`web`应用**

摘自wujie官网的一段话。为前端需要具备什么能力？

* **子应用的加载和卸载能力**

  页面需要从一个子应用切换到另一个子应用，框架必须具备加载、渲染、切换的能力

* **子应用独立运行的能力**

  子应用运行会污染全局的 window 对象，样式会污染其他应用，必须有效的隔离起来

* **子应用路由状态保持能力**

  激活子应用后，浏览器刷新、前进、后退子应用的路由都应该可以正常工作

* **应用间通信的能力**

  应用间可以方便、**快捷的通信**。（通信的三种方式①事件订阅例如$bus，②全局window上的属性读取和写入，③框架提供props的接口）





## 微前端的技术方案

### iframe

**优点**

* 非常简单，使用没有任何心智负担
* `web`应用隔离的非常完美，无论是`js`、`css`、`dom`都完全隔离开来

**iframe的缺点：**

1. url 不同步。浏览器刷新 iframe url 状态丢失、后退前进按钮无法使用。
2. UI 不同步，DOM 结构不共享。想象一下屏幕右下角 1/4 的 iframe 里来一个带遮罩层的弹框，同时我们要求这个弹框要浏览器居中显示，还要浏览器 resize 时自动居中。
3. 全局上下文完全隔离，内存变量不共享。iframe 内外系统的通信、数据同步等需求，主应用的 cookie 要透传到根域名都不同的子应用中实现免登效果。
4. 慢。每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程。

### SPA

[single-spa](https://zh-hans.single-spa.js.org/docs/getting-started-overview)主要实现思路：

* 预先注册子应用(激活路由、子应用资源、生命周期函数)
* 监听路由的变化，匹配到了激活的路由则加载子应用资源，顺序调用生命周期函数并最终渲染到容器

**优点**

* 监听路由自动的加载、卸载当前路由对应的子应用
* 完备的沙箱方案，`js`沙箱做了`SnapshotSandbox`、`LegacySandbox`、`ProxySandbox`三套渐进增强方案，`css`沙箱做了两套`strictStyleIsolation`、`experimentalStyleIsolation`两套适用不同场景的方案
* 路由保持，浏览器刷新、前进、后退，都可以作用到子应用
* 应用间通信简单，全局注入

缺点

* 基于路由匹配，无法同时**激活多个子应用，也不支持子应用保活**。
* 改造成本较大，从 `webpack`、代码、路由等等都要做一系列的适配
* `css` 沙箱无法绝对的隔离，`js` 沙箱在某些场景下执行性能下降严重
* **无法支持 `vite` 等 `ESM` 脚本运行**



## 1.微前端解决了什么问题？

1.随着应用程序的规模不断增大，代码库也会变得越来越复杂，导致开发人员难以理解和维护。

2.在传统的前端应用程序中，所有的开发人员都必须使用相同的技术栈和框架进行开发，这限制了开发人员的选择和自由度。

微前端的优点

1.**大型应用程序的可维护性：**微前端将应用程序拆分成小块，每个小块都有自己的职责和功能，使得代码库更加清晰和易于维护。

2.**团队协作便利性**：微前端允许每个小块使用不同的技术栈和框架，使得开发人员可以选择最适合自己的工具和技术进行开发，从而提高团队协作的效率和质量。

3.**可独立部署和扩展：**微前端允许每个小块独立地进行部署和扩展，这样可以避免整个应用程序的停机时间和风险，并且可以更加灵活地扩展应用程序的功能。此外，微前端还可以让不同的小块在不同的服务器上运行，从而提高应用程序的性能和可用性。

4.**适应不同的场景和需求**：微前端可以将应用程序拆分成小块，每个小块都可以被设计为不同的场景和需求。

下面两个问题是微前端需要考虑的问题。

1.JS沙箱问题

2.样式隔离问题



## 2.JS沙盒

JS沙盒是一种安全的JavaScript执行环境，可以限制脚本的访问权限，从而保护宿主环境免受恶意脚本的攻击。在微前端中，我们需要给子应用提供沙盒环境，**防止应用之间互相污染以及污染全局变量。**

**with() + new Function(code) + Proxy**

`with` 语法用于改变作用域链，这里用来拦截写访问全局变量时对 window 的查找，如直接访问 `Array.from` 而不是 `window.Array.from` 写法时；

`new Function` 执行 code 作用等同于 eval，但 eval 能访问到当前局部作用域变量，new Function 返回函数不管哪里执行，都只能访问全局作用域，正是我们想要的。

而 `Proxy` 提供的是 with 和 new Function 闭包中用到的充当 window 作用域的对象，通过白名单属性限制能访问真正 window 上的部分元素，通过 Proxy 让删除 / 添加全局变量 / api 时不会对真正全局 window 产生影响；

同时对 document / history / localtion 上各类操作做劫持，比如把 document.body 上插入元素乾坤大挪移、把 history.push 改写再同步到 url、把 localtion path 拦截让子应用只获取内部路由， 等等，这些种种限制组成沙箱环境；

~~~js
// 简化伪代码示例
window = new Proxy(pick(window, whiteListProperties), { ... })
document = new Proxy(document, { ... })
...

sandbox = new Function(`
  return function ({ window, location, history, document }, code){
    with(window) {
      ${code}
    }
}`)

sandbox().call(window, { window, location, history, document }, code)
~~~



### 2.1、快照沙箱

**把主应用的 `window` 对象做浅拷贝，将 `window` 的键值对存成一个 `Hash Map`。之后无论微应用对 `window` 做任何改动，当要在恢复环境时，把这个 `Hash Map` 又应用到 `window` 上就可以了**



~~~js
function iter(obj: typeof window, callbackFn: (prop: any) => void) {
  // eslint-disable-next-line guard-for-in, no-restricted-syntax
  for (const prop in obj) {
    if (obj.hasOwnProperty(prop)) {
      callbackFn(prop);
    }
  }
}

/**
 * 基于 diff 方式实现的沙箱，用于不支持 Proxy 的低版本浏览器
 */
export default class SnapshotSandbox implements SandBox {
  proxy: WindowProxy;

  name: string;

  type: SandBoxType;

  sandboxRunning = true;

  private windowSnapshot!: Window;

  private modifyPropsMap: Record<any, any> = {};

  constructor(name: string) {
    this.name = name;
    this.proxy = window;
    this.type = SandBoxType.Snapshot;
  }

  active() {
    // 记录当前快照
    this.windowSnapshot = {} as Window;
    iter(window, (prop) => {
      this.windowSnapshot[prop] = window[prop];
    });

    // 恢复之前的变更
    Object.keys(this.modifyPropsMap).forEach((p: any) => {
      window[p] = this.modifyPropsMap[p];
    });

    this.sandboxRunning = true;
  }

  inactive() {
    this.modifyPropsMap = {};

    iter(window, (prop) => {
      if (window[prop] !== this.windowSnapshot[prop]) {
        // 记录变更，恢复环境
        this.modifyPropsMap[prop] = window[prop];
        window[prop] = this.windowSnapshot[prop];
      }
    });

    if (process.env.NODE_ENV === 'development') {
      console.info(`[qiankun:sandbox] ${this.name} origin window restore...`, Object.keys(this.modifyPropsMap));
    }

    this.sandboxRunning = false;
  }
}

~~~

::: tip

子应用 `mount` 时

* 先把上一次记录的变更 `modifyPropsMap` 应用到子应用的全局 `window`，没有则跳过
* 浅复制主应用的 `window` key-value 快照，用于下次恢复全局环境

子应用  `unmount` 时

* 将当前子应用  `window` 的 `key-value` 和 `快照` 的 `key-value` 进行 Diff，Diff 出来的结果用于下次恢复微应用环境的依据
* 将上次快照的 `key-value` 拷贝到主应用的 `window` 上，以此恢复环境

:::

**快照沙箱存在的问题**：

1.会改变全局window的属性，如果同时运行多个微应用，多个应用同时改写window上的属性，势必会出现状态混乱，**支持多应用的代理沙箱**可以很好的解决这个问题；

2.会通过`for(prop in window){}`的方式来遍历window上的所有属性，window属性众多，这其实是一件很耗费性能的事情。关于这个问题**支持单应用的代理沙箱**和**支持多应用的代理沙箱**都可以规避。

### 2.2、代理沙箱

实现原理：

1. 用`fakewindow`做一个代理，当写入某个属性值时判断window身上是否存在该属性，如果不存在则将该属性和值放入`addedmap`中如果存在也就意味着客户在做修改，就将该属性原始值放入`modifiedmap`中，将修改后的值放入`currentMap`中

~~~js
class Legacy {
  constructor() {
    // 沙箱期间新增的全局变量
    this.addedPropsMapInSandbox = {};
    // 沙箱期间更新的全局变量
    this.modifiedPropsOriginalValueMapInSandbox = {};
    // 持续记录更新的(新增和修改的)全局变量的 map，用于在任意时刻做 snapshot
    this.currentUpdatedPropsValueMap = {};
    const rawWindow = window;
    const fakeWindow = Object.create(null);
    this.sandboxRunning = true;
    const proxy = new Proxy(fakeWindow, {
      set: (target, prop, value) => {
        // 如果是激活状态
        if(this.sandboxRunning) {
          // 判断当前window上存不存在该属性
          if(!rawWindow.hasOwnProperty(prop)) {
            // 记录新增值
            this.addedPropsMapInSandbox[prop] = value;
          } else if(!this.modifiedPropsOriginalValueMapInSandbox[prop]) {
            // 记录更新值的初始值
            const originValue = rawWindow[prop]
            this.modifiedPropsOriginalValueMapInSandbox[prop] = originValue;
          }
          // 纪录此次修改的属性
          this.currentUpdatedPropsValueMap[prop] = value;
          // 将设置的属性和值赋给了当前window，还是污染了全局window变量
          rawWindow[prop] = value;
          return true;
        }
        return true;
      },
      get: (target, prop) => {
        return rawWindow[prop];
      }
    })
    this.proxy = proxy;
  }
  active() {
    if (!this.sandboxRunning) {
      // 还原上次修改的值
      for(const key in this.currentUpdatedPropsValueMap) {
        window[key] = this.currentUpdatedPropsValueMap[key];
      }
    }

    this.sandboxRunning = true;
  }
  inactive() {
    // 将更新值的初始值还原给window
    for(const key in this.modifiedPropsOriginalValueMapInSandbox) {
      window[key] = this.modifiedPropsOriginalValueMapInSandbox[key];
    }
    // 将新增的值删掉
    for(const key in this.addedPropsMapInSandbox) {
      delete window[key];
    }

    this.sandboxRunning = false;
  }
}
~~~

通过三个变量来记住沙箱激活后window发生变化过的所有属性，这样在后续的状态还原时候就不再需要遍历window的所有属性来进行对比，提升了程序运行的性能。但是这仍然改变不了这种机制仍然污染了window的状态的事实，因此也就无法承担起同时支持多个微应用运行的任务。





### 2.3、多应用代理沙箱

**不会污染全局window，支持多个子应用同时加载。**

激活沙箱后，每次对`window`取值的时候，先从自己沙箱环境的`fakeWindow`里面找，如果不存在，就从`rawWindow`(外部的`window`)里去找；当对沙箱内部的`window`对象赋值的时候，会直接操作`fakeWindow`，而不会影响到`rawWindow`。

~~~js

/**
 * 基于 Proxy 实现的沙箱
 */
export default class ProxySandbox implements SandBox {
  /** window 值变更记录 */
  private updatedValueSet = new Set<PropertyKey>();

  name: string;

  type: SandBoxType;

  proxy: WindowProxy;

  sandboxRunning = true;

  latestSetProp: PropertyKey | null = null;

  active() {
    if (!this.sandboxRunning) activeSandboxCount++;
    this.sandboxRunning = true;
  }

  inactive() {
    if (process.env.NODE_ENV === 'development') {
      console.info(`[qiankun:sandbox] ${this.name} modified global properties restore...`, [
        ...this.updatedValueSet.keys(),
      ]);
    }

    if (--activeSandboxCount === 0) {
      variableWhiteList.forEach((p) => {
        if (this.proxy.hasOwnProperty(p)) {
          // @ts-ignore
          delete window[p];
        }
      });
    }

    this.sandboxRunning = false;
  }

  constructor(name: string) {
    this.name = name;
    this.type = SandBoxType.Proxy;
    const { updatedValueSet } = this;

    const rawWindow = window;
    const { fakeWindow, propertiesWithGetter } = createFakeWindow(rawWindow);

    const descriptorTargetMap = new Map<PropertyKey, SymbolTarget>();
    const hasOwnProperty = (key: PropertyKey) => fakeWindow.hasOwnProperty(key) || rawWindow.hasOwnProperty(key);

    const proxy = new Proxy(fakeWindow, {
      set: (target: FakeWindow, p: PropertyKey, value: any): boolean => {
        if (this.sandboxRunning) {
          // We must kept its description while the property existed in rawWindow before
          if (!target.hasOwnProperty(p) && rawWindow.hasOwnProperty(p)) {
            const descriptor = Object.getOwnPropertyDescriptor(rawWindow, p);
            const { writable, configurable, enumerable } = descriptor!;
            if (writable) {
              Object.defineProperty(target, p, {
                configurable,
                enumerable,
                writable,
                value,
              });
            }
          } else {
            // @ts-ignore
            target[p] = value;
          }

          if (variableWhiteList.indexOf(p) !== -1) {
            // @ts-ignore
            rawWindow[p] = value;
          }

          updatedValueSet.add(p);

          this.latestSetProp = p;

          return true;
        }

        if (process.env.NODE_ENV === 'development') {
          console.warn(`[qiankun] Set window.${p.toString()} while sandbox destroyed or inactive in ${name}!`);
        }

        // 在 strict-mode 下，Proxy 的 handler.set 返回 false 会抛出 TypeError，在沙箱卸载的情况下应该忽略错误
        return true;
      },

      get(target: FakeWindow, p: PropertyKey): any {
        if (p === Symbol.unscopables) return unscopables;

        // avoid who using window.window or window.self to escape the sandbox environment to touch the really window
        // see https://github.com/eligrey/FileSaver.js/blob/master/src/FileSaver.js#L13
        if (p === 'window' || p === 'self') {
          return proxy;
        }

        if (
          p === 'top' ||
          p === 'parent' ||
          (process.env.NODE_ENV === 'test' && (p === 'mockTop' || p === 'mockSafariTop'))
        ) {
          // if your master app in an iframe context, allow these props escape the sandbox
          if (rawWindow === rawWindow.parent) {
            return proxy;
          }
          return (rawWindow as any)[p];
        }

        // proxy.hasOwnProperty would invoke getter firstly, then its value represented as rawWindow.hasOwnProperty
        if (p === 'hasOwnProperty') {
          return hasOwnProperty;
        }

        // mark the symbol to document while accessing as document.createElement could know is invoked by which sandbox for dynamic append patcher
        if (p === 'document' || p === 'eval') {
          setCurrentRunningSandboxProxy(proxy);
          // FIXME if you have any other good ideas
          // remove the mark in next tick, thus we can identify whether it in micro app or not
          // this approach is just a workaround, it could not cover all complex cases, such as the micro app runs in the same task context with master in some case
          nextTick(() => setCurrentRunningSandboxProxy(null));
          switch (p) {
            case 'document':
              return document;
            case 'eval':
              // eslint-disable-next-line no-eval
              return eval;
            // no default
          }
        }

        // eslint-disable-next-line no-nested-ternary
        const value = propertiesWithGetter.has(p)
          ? (rawWindow as any)[p]
          : p in target
          ? (target as any)[p]
          : (rawWindow as any)[p];
        return getTargetValue(rawWindow, value);
      }
    });

    this.proxy = proxy;

    activeSandboxCount++;
  }
}
function createFakeWindow(global: Window) {
  // map always has the fastest performance in has check scenario
  // see https://jsperf.com/array-indexof-vs-set-has/23
  const propertiesWithGetter = new Map<PropertyKey, boolean>();
  const fakeWindow = {} as FakeWindow;

  /*
   copy the non-configurable property of global to fakeWindow
   see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor
   > A property cannot be reported as non-configurable, if it does not exists as an own property of the target object or if it exists as a configurable own property of the target object.
   */
  Object.getOwnPropertyNames(global)
    .filter((p) => {
      const descriptor = Object.getOwnPropertyDescriptor(global, p);
      return !descriptor?.configurable;
    })
    .forEach((p) => {
      const descriptor = Object.getOwnPropertyDescriptor(global, p);
      if (descriptor) {
        const hasGetter = Object.prototype.hasOwnProperty.call(descriptor, 'get');

        /*
         make top/self/window property configurable and writable, otherwise it will cause TypeError while get trap return.
         see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/get
         > The value reported for a property must be the same as the value of the corresponding target object property if the target object property is a non-writable, non-configurable data property.
         */
        if (
          p === 'top' ||
          p === 'parent' ||
          p === 'self' ||
          p === 'window' ||
          (process.env.NODE_ENV === 'test' && (p === 'mockTop' || p === 'mockSafariTop'))
        ) {
          descriptor.configurable = true;
          /*
           The descriptor of window.window/window.top/window.self in Safari/FF are accessor descriptors, we need to avoid adding a data descriptor while it was
           Example:
            Safari/FF: Object.getOwnPropertyDescriptor(window, 'top') -> {get: function, set: undefined, enumerable: true, configurable: false}
            Chrome: Object.getOwnPropertyDescriptor(window, 'top') -> {value: Window, writable: false, enumerable: true, configurable: false}
           */
          if (!hasGetter) {
            descriptor.writable = true;
          }
        }

        if (hasGetter) propertiesWithGetter.set(p, true);

        // freeze the descriptor to avoid being modified by zone.js
        // see https://github.com/angular/zone.js/blob/a5fe09b0fac27ac5df1fa746042f96f05ccb6a00/lib/browser/define-property.ts#L71
        rawObjectDefineProperty(fakeWindow, p, Object.freeze(descriptor));
      }
    });

  return {
    fakeWindow,
    propertiesWithGetter,
  };
}

~~~

将window的属性复制到各个子应用的window副本(fakeWindow)，子应用里面的环境和外面的环境完全隔离。因为这种模式不直接操作window，所以在激活和卸载时也不需要操作状态池去更新/还原主子应用的环境状态了，同时也支持了统一url下多个子应用的场景。

## 3.样式隔离

1. 利用了 shadow DoM，可以做到css完全隔离，但是有很多问题（1、弹窗由于挂在到document.Body下导致样式失效 2、shadowdom下不能注册字体）。
2. 类似于Vue的scoped给每一个子应用的css添加前缀

## qiankun使用

qiankun 方案是基于 single-spa 的微前端方案。

**优点：**

* html entry 的方式引入子应用，相比 js entry 极大的降低了应用改造的成本；

* 完备的沙箱方案，js 沙箱做了 SnapshotSandbox、LegacySandbox、ProxySandbox 三套渐进增强方案，css 沙箱做了 strictStyleIsolation、experimentalStyleIsolation 两套适用不同场景的方案；

* 做了静态资源预加载能力；

**缺点：**

* 适配成本比较高，工程化、生命周期、静态资源路径、路由等都要做一系列的适配工作；

* css 沙箱采用严格隔离会有各种问题，js 沙箱在某些场景下执行性能下降严重；

* 无法同时激活多个子应用，也不支持子应用保活；

* 无法支持 vite 等 esmodule 脚本运行；

~~~shell
pnpm add qiankun -S
~~~

### 在主应用中注册微应用

~~~js
import { registerMicroApps, start } from 'qiankun';

registerMicroApps([
  {
    name: 'react app', // app name registered
    entry: '//localhost:7100',
    container: '#yourContainer',
    activeRule: '/yourActiveRule',
  },
  {
    name: 'vue app',
    entry: { scripts: ['//localhost:7100/main.js'] },
    container: '#yourContainer2',
    activeRule: '/yourActiveRule2',
  },
]);

start();
~~~



### 微应用配置

微应用分为有 `webpack` 构建和无 `webpack` 构建项目，有 `webpack` 的微应用（主要是指 Vue、React、Angular）需要做的事情有：

1. 新增 `public-path.js` 文件，用于修改运行时的 `publicPath`。[什么是运行时的 publicPath ？](https://webpack.docschina.org/guides/public-path/#on-the-fly)。

注意：运行时的 publicPath 和构建时的 publicPath 是不同的，两者不能等价替代。

1. 微应用建议使用 `history` 模式的路由，需要设置路由 `base`，值和它的 `activeRule` 是一样的。
2. 在入口文件最顶部引入 `public-path.js`，修改并导出三个生命周期函数。
3. 修改 `webpack` 打包，允许开发环境跨域和 `umd` 打包。

主要的修改就是以上四个，可能会根据项目的不同情况而改变。例如，你的项目是 `index.html` 和其他的所有文件分开部署的，说明你们已经将构建时的 `publicPath` 设置为了完整路径，则不用修改运行时的 `publicPath` （第一步操作可省）。

无 `webpack` 构建的微应用直接将 `lifecycles` 挂载到 `window` 上即可。

微应用需要在自己的入口 js (通常就是你配置的 webpack 的 entry js) 导出 `bootstrap`、`mount`、`unmount` 三个生命周期钩子，以供主应用在适当的时机调用。

以 `vue-cli 3+` 生成的 `vue 2.x` 项目为例，`vue 3` 版本等稳定后再补充。

1. 在 `src` 目录新增 `public-path.js`：

   ```js
   if (window.__POWERED_BY_QIANKUN__) {
     __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;
   }
   ```

2. 入口文件 `main.js` 修改，为了避免根 id `#app` 与其他的 DOM 冲突，需要限制查找范围。

   ```js
   import './public-path';
   import Vue from 'vue';
   import VueRouter from 'vue-router';
   import App from './App.vue';
   import routes from './router';
   import store from './store';
   
   
   Vue.config.productionTip = false;
   
   
   let router = null;
   let instance = null;
   function render(props = {}) {
     const { container } = props;
     router = new VueRouter({
       base: window.__POWERED_BY_QIANKUN__ ? '/app-vue/' : '/',
       mode: 'history',
       routes,
     });
   
   
     instance = new Vue({
       router,
       store,
       render: (h) => h(App),
     }).$mount(container ? container.querySelector('#app') : '#app');
   }
   
   
   // 独立运行时
   if (!window.__POWERED_BY_QIANKUN__) {
     render();
   }
   
   
   export async function bootstrap() {
     console.log('[vue] vue app bootstraped');
   }
   export async function mount(props) {
     console.log('[vue] props from main framework', props);
     render(props);
   }
   export async function unmount() {
     instance.$destroy();
     instance.$el.innerHTML = '';
     instance = null;
     router = null;
   }
   ```

3. 打包配置修改（`vue.config.js`）：

   ```js
   const { name } = require('./package');
   module.exports = {
     devServer: {
       headers: {
         'Access-Control-Allow-Origin': '*',
       },
     },
     configureWebpack: {
       output: {
         library: `${name}-[name]`,
         libraryTarget: 'umd', // 把微应用打包成 umd 库格式
         jsonpFunction: `webpackJsonp_${name}`, // webpack 5 需要把 jsonpFunction 替换成 chunkLoadingGlobal
       },
     },
   };
   ```

#### 微应用打包配置

webpack v5:

```js
const packageName = require('./package.json').name;
module.exports = {
  output: {
    library: `${packageName}-[name]`,
    libraryTarget: 'umd',
    chunkLoadingGlobal: `webpackJsonp_${packageName}`,
  },
};
```

webpack v4:

~~~js
const packageName = require('./package.json').name;
module.exports = {
  output: {
    library: `${packageName}-[name]`,
    libraryTarget: 'umd',
    jsonpFunction: `webpackJsonp_${packageName}`,
  },
};
~~~



## 无界

**wujie优点：**

* **多应用同时激活在线**

  框架具备同时激活多应用，并保持这些应用路由同步的能力

* **组件式的使用方式**

  无需注册，更无需路由适配，在组件内使用，跟随组件装载、卸载

* **应用级别的 keep-alive**

  子应用开启[保活模式](https://wujie-micro.github.io/doc/api/startApp.html#alive)后，应用发生切换时整个子应用的状态可以保存下来不丢失，结合[预执行模式](https://wujie-micro.github.io/doc/api/preloadApp.html#exec)可以获得类似`ssr`的打开体验

* **纯净无污染**

  * 无界利用`iframe`和`webcomponent`来搭建天然的`js`隔离沙箱和`css`隔离沙箱
  * 利用`iframe`的`history`和主应用的`history`在同一个[top-level browsing context](https://html.spec.whatwg.org/multipage/browsers.html#top-level-browsing-context)来搭建天然的路由同步机制
  * 副作用局限在沙箱内部，子应用切换无需任何清理工作，没有额外的切换成本

* **性能和体积兼具**

  * 子应用执行性能和原生一致，子应用实例`instance`运行在`iframe`的`window`上下文中，避免`with(proxyWindow){code}`这样指定代码执行上下文导致的性能下降，但是多了实例化`iframe`的一次性的开销，可以通过 [preload](https://wujie-micro.github.io/doc/api/preloadApp.html) 提前实例化
  * 体积比较轻量，借助`iframe`和`webcomponent`来实现沙箱，有效的减小了代码量

* **开箱即用**

  不管是样式的兼容、路由的处理、弹窗的处理、热更新的加载，子应用完成接入即可开箱即用无需额外处理，应用[接入成本](https://wujie-micro.github.io/doc/guide/start.html#子应用改造)也极低

**缺点：**

* 隔离js使用一个空的iframe进行隔离

* 子应用axios需要自行适配

* iframe沙箱的src设置了主应用的host，初始化iframe的时候需要等待iframe的location.orign从'about:blank'初始化为主应用的host，这个采用的计时器去等待的不是很悠亚。



[文档](https://wujie-micro.github.io/doc/guide/start.html)

如果是Vue3作为基座，安装`pnpm i wujie-vue3 -S `,react就执行`pnpm i wujie-react -S`

然后在main.js中注册

```js
import { createApp } from 'vue'
import './style.css'
import App from './App.vue'
import WujieVue from 'wujie-vue3'
const app = createApp(App)
    
app.use(WujieVue)    
    
app.mount('#app')

<WujieVue
  width="100%"
  height="100%"
  name="xxx" //必传子应用的唯一id
  :url="xxx"//必传子应用的url
  :sync="true"
  :fetch="fetch"
  :props="props"
  :beforeLoad="beforeLoad"
  :beforeMount="beforeMount"
  :afterMount="afterMount"
  :beforeUnmount="beforeUnmount"
  :afterUnmount="afterUnmount"
></WujieVue>

```

### wujie实现原理

①js方面wujie将子应用的js代码注入到主应用的iframe中运行

**优点**

* **组件方式来使用微前端**

  不用注册，不用改造路由，直接使用无界组件，化繁为简

* **一个页面可以同时激活多个子应用**

  子应用采用 iframe 的路由，不用关心路由占用的问题

* **天然 js 沙箱，不会污染主应用环境**

  不用修改主应用`window`任何属性，只在`iframe`内部进行修改

* **应用切换没有清理成本**

  由于不污染主应用，子应用销毁也无需做任何清理工作

②html上wujie使用`webcomponent`将子应用的html结构渲染在里面，并通过代理iframe的document到webcomponent实现两者关联。

③应用保活原理。当子应用发生切换，`iframe`保留下来，子应用的容器可能销毁，但`webcomponent`依然可以选择保留，这样等应用切换回来将`webcomponent`再挂载回容器上，子应用可以获得类似`vue`的`keep-alive`的能力.

**优点**

* **天然 css 沙箱**

  直接物理隔离，样式隔离子应用不用做任何修改

* **天然适配弹窗问题**

  `document.body`的`appendChild`或者`insertBefore`会代理直接插入到`webcomponent`，子应用不用做任何改造

* **子应用保活**

  子应用保留`iframe`和`webcomponent`，应用内部的`state`不会丢失

* **完整的 DOM 结构**

  `webcomponent`保留了子应用完整的`html`结构，样式和结构完全对应，子应用不用做任何修改

④css利用shadowDOM隔离CSS

### 通信方式

承载子应用的`iframe`和主应用是同域的，所以主、子应用天然就可以很好的进行通信，在无界我们提供三种通信方式

* **props 注入机制**

子应用通过`$wujie.props`可以轻松拿到主应用注入的数据

* **window.parent 通信机制**

子应用`iframe`沙箱和主应用同源，子应用可以直接通过`window.parent`和主应用通信

* **去中心化的通信机制**

无界提供了`EventBus`实例，注入到主应用和子应用，所有的应用可以去中心化的进行通信





### 源码

#### 学前知识

#### base标签

**HTML <base> 元素** 指定用于一个文档中包含的所有相对 URL 的根 URL。一份中只能有一个 <base> 元素。

一个文档的基本 URL，可以通过使用 [`document.baseURI` (en-US)](https://developer.mozilla.org/en-US/docs/Web/API/Node/baseURI) 的 JS 脚本查询。如果文档不包含 `<base>` 元素，`baseURI` 默认为 `document.location.href`。



#### 1.启动应用

startApp

1. 调用`getWujieById`和`getOptionsById`从map结构中拿到子应用实例和子应用配置，如果刚启动应用则为null。然后调用`mergeOptions`合并配置项

   ~~~ts
   export async function startApp(startOptions: startOptions): Promise<Function | void> {
     //在map结构中注册该子应用id 也就是子应用传入的name，
     const sandbox = getWujieById(startOptions.name); //从map结构中取出该子应用实例  首次为null
     const cacheOptions = getOptionsById(startOptions.name); //从map结构中取出该子应用的配置项  首次为null
     const options = mergeOptions(startOptions, cacheOptions);
       ....
   }
   ~~~

2. 如果`sandbox`存在也就是说已经创建过子应用实例了。

3. 如果不存在则执行`new WuJie`创建沙箱环境。

   ~~~ts
   const newSandbox = new WuJie({ name, url, attrs, degradeAttrs, fiber, degrade, plugins, lifecycles });
   ~~~



#### 2.创建沙箱环境

①先解析子应用的路径。调用`iframeGenerator`创建iframe

~~~ts
// 创建目标地址的解析
    const { urlElement, appHostPath, appRoutePath } = appRouteParse(url);
    const { mainHostPath } = this.inject;
    // 创建iframe
    this.iframe = iframeGenerator(this, attrs, mainHostPath, appHostPath, appRoutePath);


~~~

②创建iframe，

~~~ts
export function iframeGenerator(  
  sandbox: WuJie,
  attrs: { [key: string]: any },
  mainHostPath: string,
  appHostPath: string,
  appRoutePath: string)
{
           const iframe = window.document.createElement("iframe");
  const attrsMerge = { src: mainHostPath, style: "display: none", ...attrs, name: sandbox.id, [WUJIE_DATA_FLAG]: "" };
  setAttrsToElement(iframe, attrsMerge);
  window.document.body.appendChild(iframe);    
    

}
~~~

③得到iframe的window并注入一些属性

~~~ts
iframeGenerator{
   const iframeWindow = iframe.contentWindow;
  // 变量需要提前注入，在入口函数通过变量防止死循环
  patchIframeVariable(iframeWindow, sandbox, appHostPath);
}
function patchIframeVariable(iframeWindow: Window, wujie: WuJie, appHostPath: string): void {
  iframeWindow.__WUJIE = wujie;
  iframeWindow.__WUJIE_PUBLIC_PATH__ = appHostPath + "/";
  iframeWindow.$wujie = wujie.provide;
  iframeWindow.__WUJIE_RAW_WINDOW__ = iframeWindow;
}
~~~

④为了防止运行主应用的js代码，给子应用带来很多副作用，用定时器去停止ifrm的widnow

~~~ts
iframeGenerator{
  sandbox.iframeReady = stopIframeLoading(iframeWindow).then(() => { ... });
    
  return iframe;
}
function stopIframeLoading(iframeWindow: Window) {
  const oldDoc = iframeWindow.document;
  return new Promise<void>((resolve) => {
    function loop() {
      setTimeout(() => {
        let newDoc;
        try {
          newDoc = iframeWindow.document;
        } catch (err) {
          newDoc = null;
        }
        // wait for document ready
        if (!newDoc || newDoc == oldDoc) {
          loop();
        } else {
          iframeWindow.stop ? iframeWindow.stop() : iframeWindow.document.execCommand("Stop");
          resolve();
        }
      }, 1);
    }
    loop();
  });
}
~~~

⑤在停止了子iframe的window加载后，初始化iframe的dom

~~~ts
  sandbox.iframeReady = stopIframeLoading(iframeWindow).then(() => {
    initIframeDom(iframeWindow, sandbox, mainHostPath, appHostPath);
  });
~~~

⑥用全局window创建一个新的 HTML 文档，并拷贝一份，然后把这个拷贝的节点插入到iframe的文档中。如果`iframe.documentElement`存在就用新的替代旧的

~~~ts
function initIframeDom(iframeWindow: Window, wujie: WuJie, mainHostPath: string, appHostPath: string): void {
  const iframeDocument = iframeWindow.document;
  const newDoc = window.document.implementation.createHTMLDocument("");
  const newDocumentElement = iframeDocument.importNode(newDoc.documentElement, true);
  iframeDocument.documentElement
    ? iframeDocument.replaceChild(newDocumentElement, iframeDocument.documentElement)
    : iframeDocument.appendChild(newDocumentElement);
}
~~~

⑦注入文档对象的查询和创建元素方法

~~~ts
  iframeWindow.__WUJIE_RAW_DOCUMENT_HEAD__ = iframeDocument.head;
  iframeWindow.__WUJIE_RAW_DOCUMENT_QUERY_SELECTOR__ = iframeWindow.Document.prototype.querySelector;
  iframeWindow.__WUJIE_RAW_DOCUMENT_QUERY_SELECTOR_ALL__ = iframeWindow.Document.prototype.querySelectorAll;
  iframeWindow.__WUJIE_RAW_DOCUMENT_CREATE_ELEMENT__ = iframeWindow.Document.prototype.createElement;
  iframeWindow.__WUJIE_RAW_DOCUMENT_CREATE_TEXT_NODE__ = iframeWindow.Document.prototype.createTextNode;
~~~

⑧初始化base标签，将base标签url设置为子应用的url，

~~~ts
 initBase(iframeWindow, wujie.url);
export function initBase(iframeWindow: Window, url: string): void {
  const iframeDocument = iframeWindow.document;
  const baseElement = iframeDocument.createElement("base");
  const iframeUrlElement = anchorElementGenerator(iframeWindow.location.href);
  const appUrlElement = anchorElementGenerator(url);
  baseElement.setAttribute("href", appUrlElement.protocol + "//" + appUrlElement.host + iframeUrlElement.pathname);
  iframeDocument.head.appendChild(baseElement);
}
~~~

⑨重写History中的api`pushState`和`replaceState`保证iframe的url变化同步到Window中

~~~ts
function patchIframeHistory(iframeWindow: Window, appHostPath: string, mainHostPath: string): void {
  const history = iframeWindow.history;
  const rawHistoryPushState = history.pushState;
  const rawHistoryReplaceState = history.replaceState;
  history.pushState = function (data: any, title: string, url?: string): void {
    const baseUrl =
      mainHostPath + iframeWindow.location.pathname + iframeWindow.location.search + iframeWindow.location.hash;
    const mainUrl = getAbsolutePath(url?.replace(appHostPath, ""), baseUrl);
    const ignoreFlag = url === undefined;

    rawHistoryPushState.call(history, data, title, ignoreFlag ? undefined : mainUrl);
    if (ignoreFlag) return;
    updateBase(iframeWindow, appHostPath, mainHostPath);
    syncUrlToWindow(iframeWindow);
  };
  history.replaceState = function (data: any, title: string, url?: string): void {
    const baseUrl =
      mainHostPath + iframeWindow.location.pathname + iframeWindow.location.search + iframeWindow.location.hash;
    const mainUrl = getAbsolutePath(url?.replace(appHostPath, ""), baseUrl);
    const ignoreFlag = url === undefined;

    rawHistoryReplaceState.call(history, data, title, ignoreFlag ? undefined : mainUrl);
    if (ignoreFlag) return;
    updateBase(iframeWindow, appHostPath, mainHostPath);
    syncUrlToWindow(iframeWindow);
  };
}
~~~

## 模块联邦Module Federation

多个独立的构建可以组成一个应用程序，这些独立的构建之间不应该存在依赖关系，因此可以单独开发和部署它们。这通常被称作微前端，但并不仅限于此。比如a应用如果想使用b应用中form的组件，通过模块联邦可以直接在a中进行import('b/form')非常的方便。

模块联邦优点：可以单独部署对模块的更改，而不需要重新部署所有应用程序。应用程序自动使用组件库的最新版本。（例如将公共依赖发布到npm，其他依赖的项目安装即可，但是存在问题，如果依赖升级，所有项目都需要重新安装依赖。而模块联邦中，项目利用CDN共享，我们永远访问的是最新的代码。）

### ModuleFederationPlugin (high level)

[文档](https://www.webpackjs.com/plugins/module-federation-plugin/)

~~~js
new ModuleFederationPlugin({
      // 模块联邦名字，提供给其他模块使用
      name: 'app1',
      // 提供给外部访问的资源入口
      filename: 'App1RemoteEntry.js',
      // 引用的外部资源列表
      remotes: {
        /**
         *  App2 引用其他应用模块的资源别名
         *  app2 是 APP2 的模块联邦名字
         *  http://localhost:3001 是 APP2 运行的地址
         *  App2RemoteEntry.js 是 APP2 提供的外部访问的资源名字
         *  可以访问到 APP2 通过 exposes 暴露给外部的资源
         */
        App2: 'app2@http://localhost:3001/App2RemoteEntry.js',
      },
      // 暴露给外部的资源列表
      exposes: {},
      // 共享模块，pinia
      shared: {},
    }),

~~~



### 基本概念

1. 本地模块：本地模块就是我们当前开发的代码模块。
2. 远程模块：不属于当前开发代码，远程模块在运行时加载。
3. 容器：就是构建的项目。每个构建的充当一个容器，也可以将其他构建作为容器。通过这种方式每个构建都能从对应容器中加载暴露的模块。
4. 一个被引用得容器或称为remote，引用者被称为host，remote暴露模块给host，host则可以使用这些暴露的模块，这些模块被称为remote模块。



<CommentService/>