---
lang: zh-CN
title: 数据结构
description: 关键功能
collapsible: true
---
# 数据结构

## 树

 名字概念：

**度**：节点拥有的最大分支数量就是树的度。

**叶子/终端节点**：没有子节点节点。

**树的深度**：树的高度

**森林**：m（m》=0）颗互不相交的树的集合（树一定是森林，森林不一定是树）

**二叉树**：每个节点最多两个分支（也就是说不存在度大于2的结点）



### 二叉树的一些性质

1. 在第i层最多有结点数量如下
   $$
   2^{i-1}
   $$

2. 深度为K的二叉树最多有结点数量如下，最少有K个结点
   $$
   2^k-1
   $$

3.  叶子节点数为n0，度为2的节点数为n2
   $$
   n_{0}=n_{2}+1
   $$
   ![](/Algorithms/leaf.png)

   总结点数n = n2 × 2 + n1 × 1 +1 = n2 + n1 + n0 （这是推导过程） 



### 森林和二叉树转换

**森林转二叉树**

兄弟相连留长子，树变二叉根相连，保留根，将根的兄弟旋转45度（旋转45就是变右孩）

![](/Algorithms/Ttree.png)

**二叉树转森林**

去掉全部右孩线，左孩的右孩子变兄弟，右孩子的右孩子也变左孩子兄弟

![](/Algorithms/Ttree2.png)

​	

​	

### 哈夫曼树

给定N个权值作为N个叶子结点，构造一棵二叉树，**若该树的带权路径长度达到最小**，称这样的二叉树为`最优二叉树`，也称为`哈夫曼树(Huffman Tree)`。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。

**哈夫曼树的结点度只有0或2没有度为1的结点；包含n个叶子结点的哈夫曼树共有2n-1个结点**

![](/Algorithms/hafuman.png)

构造哈夫曼树的步骤

1. 根据n个权值构造n个根节点
2. 选用两个最小的权值，作为左右子树，根节点权值为两小权值的和
3. 然后将（2）造的树添加上，重复2 3

![](/Algorithms/hafuman2.png)



## 排序

### 冒泡排序

两两比较将大的放后面，每一次排序后都能够将最大的元素不断放到后面像冒泡一样。

~~~js

    var arr = [29,4,5,51,6,8,72,9,7];
    //外层循环，控制趟数，每一次找到一个最大值
    for (var i = 0; i < arr.length - 1; i++) {
        // 内层循环,控制比较的次数，并且判断两个数的大小
        for (var j = 0; j < arr.length - 1 - i; j++) {
            // 白话解释：如果前面的数大，放到后面(当然是从小到大的冒泡排序)
            if (arr[j] > arr[j + 1]) {
                var temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
 
    }
    console.log(arr);//[2, 4, 5, 12, 31, 32, 45, 52, 78, 89]
~~~









### 快排

~~~js
function quickSort(arr){
    if(arr.length<=1)return arr;
    let left=[];
    let right=[];
    let base=arr.splice(0,1)[0];
    for(let i=0;i<arr.length;i++){
        if(arr[i]<base){
            left.push(arr[i]);
        }else{
            right.push(arr[i]);
        }
    }
    return quickSort(left).concat([base],quickSort(right));
}
~~~



### 直接插入排序

~~~js
        function insertSort(arr) {
            const array = []
            // 抓第一项
            array.push(arr[0])
            for (let i = 1; i < arr.length; i++) {
                // 比第一项之后的
                let cur = arr[i]
                for (let j = array.length - 1; j >= 0; j--) {
                    if (cur > array[j]) {
                        array.splice(j + 1, 0, cur)
                        break
                    }
                    if (j === 0) {
                        array.unshift(cur)
                    }
                }
            }
            console.log(array)
        }
        insertSort([12, 8, 24, 16, 1])
~~~

### 选择排序（堆排序）

小/大根堆

1. 输出堆顶元素（根节点）
2. 根节点值与左右子树的根节点值进行比较，并与其中小的进行交换、
3. 重复上面步骤直到叶子节点

每次选择最大/最小放在前面

![](/Algorithms/dui.png)









### 基数排序

思想：先设置0-9个桶，然后将数字按位排序，从个位到十位。。。基数排序只能对数字进行排序

例如  17   21  32  53  94  50  31

第一次排序按照个位  50  21 31 32 53 94 17

|  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   | 9    |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | ---- |
|  50  |  21  |  32  |  53  |  94  |      |      |  17  |      |      |
|      |  31  |      |      |      |      |      |      |      |      |

第二次排序按照十位  17 21 31 32 50 53 94

|  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |  9   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|      |  17  |  21  |  31  |      |  50  |      |      |      |  94  |
|      |      |      |  32  |      |  53  |      |      |      |      |



### 归并排序

~~~js
function mergeSort(arr){
    function merge(left,right){
        const tmp = []
    	while(left.length && right.length){
            tmp.push(left[0]<right[0] ? left.shift():right.shift() )
        }
        return [...tmp,...left,...right]
    }
    if(arr.length===1) return arr
    const mid = arr.length >> 1
    const left = mergeSort(arr.slice(0,mid))
    const right = mergeSort(arr.slice(mid))
    return merge(left,right)
}
~~~



### 希尔排序

![](/Algorithms/xier.png)

把数组按照一定的增量分组，对每组使用直接插入排序算法排序，希尔建议的间距是N/2，每一趟排序分成两半，也就是说，对于N=10的数组，增量间隔序列为5、2、1；

然后缩小增量继续分组排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个数组被分成一组，再次排序，就可以完成整个数组的排序；
~~~js

function shellSort(array) {
  //每次向下得到一半的增量
    let gap = array.length >> 1
  for (gap; gap > 0; gap = gap >> 1) {
    //每个分组进行插入排序
    for (let i = gap; i < array.length; i++) {
      let j = i;
      let tmp = array[j];
      // 如果同一组中 前数大于后数，则交换他们
      if (array[j] < array[j - gap]) {
        while (j - gap >= 0 && array[j - gap] > tmp) {
          array[j] = array[j - gap];
          j = j - gap;
        }
        array[j] = tmp;
      }
    }
  }
}
shellSort([2, 4, 7, 9, 0, 1, 2, 3, 5, 6, 8]);


~~~









<CommentService/>