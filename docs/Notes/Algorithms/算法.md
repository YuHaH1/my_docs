---
lang: zh-CN
title: 算法
description: 关键功能
collapsible: true
---
# 算法

## 1.最长递增子序列

思路：

1. 先初始化一个数组全部记录为1
2. 双重循环，当后一个比前一个大，将后一个记录为之前的值+1
3. arr[i]比arr[j]大记录值record[i]=record[j]+1

~~~js
const arr = [1,5,4,7,2,6,8,9,4]  
const getList = (arr)=>{
            if(arr.length === 1){
                return 1
            }
            const record = new Array(arr.length).fill(1)
            let len = 0
            for(let i=0;i<arr.length;i++){
                for(let j=0;j<i;j++){
                    if(arr[j]<arr[i]){
                        record[i] = Math.max(record[j]+1,record[i])
                    }
                }
                len = Math.max(record[i],len)    
            }
        }
getList(arr)
//[1,2,2,3,2,3,4,5,2]
~~~

![](/Algorithms/1.png)

## 2.二分查找

~~~ts
const arr = [1,7,2,5,9,7,5,6,7,44]
const findByBinary = (arr:Array<any>,value:any)=>{
    if (arr.length <= 0) {
        return arr
    }
    let start = 0,
        end = arr.length - 1
    while (start <= end) { 
        const mid = Math.floor((start + end) / 2)
        if (value > arr[mid]) { 
            start = mid+1
        } else if(value < arr[mid]) {
            end = mid-1
        } else if(value === arr[mid]) {
            return mid
        } else {
            return 'cant find'
        }
    }
}
~~~



## 3.最少字符

~~~js
const str1 = 'aabbac'
const str2 = 'aaabbbccddee'

const removeLessStr = (str: string): string => {
    const mapping = {} as any
    for (const st of str) {
        if (mapping[st] !== undefined) {
            mapping[st] += 1
        } else {
            mapping[st] = 1
        }
    }
    // 找出出现最少的字符
    const res_arr = (Object.values(mapping) as number[]).sort((a, b) => a - b)
    const remove_strs = Object.keys(mapping).filter(key => {
        if (mapping[key] === res_arr[0]) {
            return true
        }
    })
    const length = str.length
    for (let i = 0; i < length; i++) {
        if (remove_strs.includes(str[i])) {
            str = str.replace(str[i], '')
            i--
        }
    }
    return str
}
removeLessStr(str2)

~~~



## 4.公司营业额

根据员工的销售额，求解部门-》分公司-》总公司的营业额。



~~~js
const data = [{
            "name":"总公司",
            "sales":0,
            "children":[{
                name:"分公司1",
                sales:0,
                children:[
                    {
                        name:'部门1',
                        sales:0,
                        children:[
                            {
                                name:'员工1',
                                sales:10,
                            },
                            {
                                name:'员工2',
                                sales:20,
                            }
                        ]
                    },
                    {
                        name:'部门2',
                        sales:0,
                        children:[
                            {
                                name:'员工3',
                                sales:30,
                            },
                            {
                                name:'员工4',
                                sales:40,
                            }
                        ]
                    },
                ]
            },
            {
                name:"分公司2",
                sales:0,
                children:[
                    {
                        name:'部门1',
                        sales:0,
                        children:[
                            {
                                name:'员工1',
                                sales:31,
                            },
                            {
                                name:'员工2',
                                sales:222,
                            }
                        ]
                    },
                    {
                        name:'部门2',
                        sales:0,
                        children:[
                            {
                                name:'员工3',
                                sales:355,
                            },
                            {
                                name:'员工4',
                                sales:460,
                            }
                        ]
                    },
                ]
            }]
        }]

        const computedData = (data)=>{
            let sales = 0
            const res = data.map(v=>{
                if(v.children && v.children.length){
                    v.sales = computedData(v.children)
                }
                sales += v.sales
            })
            return sales
        }
        computedData(data)
~~~

## 5.简单题

### 两数之和

最初笨方法

~~~ts
function twoSum(nums: number[], target: number): number[] {
    const result = []
            if(nums.length === 2 && nums[0]+nums[1] === target){
                result.push(0,1)
                return result
            }

            nums.forEach((value,index)=>{
                const diffValue = target - value
                const ind = nums.findIndex((value,i)=>{
                    return index!==i && diffValue ==value
                }) 
                if(ind !== -1){
                    result.push(ind)
                }
            })
            return result.sort()
};
~~~

哈希表优化

~~~ts
        function twoSum(nums：number[], target:number):number[]{
            const map = {}
            if(nums.length === 2 && nums[0]+nums[1] === target){
                return [0,1]
            }
            nums.forEach((v,i)=>{
                map[v] = i
            })
            for(let i = 0; i < nums.length; i++){
                const diffValue = target - nums[i]
                if(map[diffValue]!== undefined && map[diffValue]!==i){
                    return [
                        Math.min(map[diffValue],i),
                        Math.max(map[diffValue],i)
                    ]
                }
            }
        };
~~~

### 移动0

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

**示例 1:**

```
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**示例 2:**

```
输入: nums = [0]
输出: [0]
```

~~~ts
function moveZeroes(nums: number[]): void {
let count = 0
            for(let i = 0; i < nums.length; i++){
                if(nums[i] === 0){
                    count ++
                    nums.splice(i, 1)
                    i--
                }
            }
            for(let i = 0; i < count; i++){
                nums.push(0)
            }
};
// 2
    let length = nums.length;
    let i = 0;
    while (i < length) {
        if (nums[i] === 0) {
            nums.splice(i, 1);
            nums.push(0);
            length--;
        } else {
            i++;
        }
    }
~~~



### [有效的括号](https://leetcode.cn/problems/valid-parentheses/)

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号

**示例 1：**

```
输入：s = "()"
输出：true
```

**示例 2：**

```
输入：s = "()[]{}"
输出：true
```

**示例 3：**

```
输入：s = "(]"
输出：false
```



~~~js
 var isValid = function (str) {
      const n = str.length;
      if (n % 2 === 1) {//如果字符串能组成有效的括号，则长度一定是偶数
        return false;
      }
      const pairs = {
        ')': '(',
        ']': '[',
        '}': '{'
      }
      const stack = []
      for (let i = 0; i < str.length; i++) {
        const s = str[i]
        console.log(s)
        if (pairs[s]) {
          if (!stack.length || stack[stack.length - 1] !== pairs[s]) {
            return false
          }
          stack.pop()
        } else {
          stack.push(s)
        }
      }
      return !stack.length
    };
~~~









## 6.中等题

### 最长连续序列

~~~ts
import {describe, expect, test} from '@jest/globals';
export function longestConsecutive(nums: number[]): number {
    // 做一个哈希表来   然后遍历数组并计算value+1是否存在如果存在将哈希表对应key的值++
    const map: Record<number, { index: number, value: number, checked: boolean }> = {}
    if (nums.length == 1) {
        return 1
    }
    if (!nums.length) return 0
    // 排序
    nums.sort((a,b)=>a-b)
    // 建立哈希表
    nums.forEach((v, i) => {
        map[v] = {
            index: i,
            value:1,
            checked:false
        }
    })
    let result = 1
    for (let i = 0; i < nums.length;) { 
        const currentValue = nums[i]
        const consecutiveValue = currentValue + 1
        if (map[consecutiveValue] && !map[consecutiveValue].checked) {
            result++
            i =  map[consecutiveValue].index
            map[consecutiveValue].value = result 
            map[consecutiveValue].checked = true
            console.log(result,map[consecutiveValue].value )
        } else {
            result = 1
            i++
        }
    }
    const values = Object.values(map).map(v=>v.value)
    return Math.max(...values)
};
describe('最长连续序列', () => {
    test('[100,4,200,1,3,2]', () => {
      expect(longestConsecutive([100,4,200,1,3,2])).toBe(4);
    });
});
describe('最长连续序列', () => {
    test('[0,0]', () => {
      expect(longestConsecutive([0,0])).toBe(1);
    });
});



~~~

优化后

~~~ts
function longestConsecutive(nums: number[]): number {

    const map:Record<number,{index:number,value:number,checked:boolean}> = {}
    if(!nums.length ) return 0
    if (nums.length == 1) {
        return 1
    }
    nums.sort((a,b)=>a-b)
    let res = 1
    let result = 1
    for (let i = 1; i < nums.length;i++) { 
        const currentValue = nums[i]
        const consecutiveValue = nums[i-1]
        if (nums[i] === nums[i - 1]) continue;
        if (currentValue - consecutiveValue  === 1) {
            result ++
        } else {
            result = 1
        }
        res = Math.max(res, result);
    }

    return res
};


~~~



### 盛水最多的容器

给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。

找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

**说明：**你不能倾斜容器。

**示例 1：**

```
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```

**示例 2：**

```
输入：height = [1,1]
输出：1
```

~~~ts
function maxArea(height: number[]): number {
    let area = 0
  for (let i = 0, j = height.length - 1; i < j;) {
    const width = j - i
    area = Math.max(area, Math.min(height[i], height[j]) * width)
    height[i] < height[j] ? i++ : j--
  }
  return area
};
~~~

### 三数之和

笨方法-该方法超出时间限制

~~~js
    function threeSum(nums) {
      const result = new Set()
      if (!nums.length) {
        return nums
      }
      nums.sort((a, b) => a - b)
      const minus = nums.filter(v => v < 0)
      const zeros = nums.filter(v => v === 0)
      const max = nums.filter(v => v > 0)
      // 全0
      if (zeros.length === nums.length) {
        return [[0, 0, 0]]
      }
      // 没负数
      if (!minus.length) {
        return []
      }
      // 没正数
      if (!max.length) {
        return []
      }
      if (zeros.length >= 3) {
        result.add(JSON.stringify([0, 0, 0]))
      }
      for (let i = 0; i < minus.length; i++) {
        // 一正 一负 一0
        const lowNum = minus[i]
        const maxIndex = max.indexOf(lowNum * -1)
        if (maxIndex !== -1 && zeros.length > 0) {
          const res = [minus[i], 0, max[maxIndex]].sort()
          result.add(JSON.stringify(res))
        }
        for (let j = 0; j < minus.length; j++) {
          // 两负数 + 正数 === 0
          if (i === j) continue
          const lowNum = minus[i] + minus[j]
          const positioveNum = lowNum * -1
          console.log(positioveNum)
          const maxIndex = max.indexOf(positioveNum)
          if (maxIndex !== -1) {
            const res = [minus[i], minus[j], max[maxIndex]].sort()
            result.add(JSON.stringify(res))
          }
        }
      }
      for (let i = 0; i < max.length; i++) {
        for (let j = 0; j < max.length; j++) {
          // 两负数 + 正数 === 0
          if (i === j) continue
          const maxNum = max[i] + max[j]
          const lowIndex = minus.indexOf(maxNum * -1)
          if (lowIndex !== -1) {
            const res = [max[i], max[j], minus[lowIndex]].sort()
            result.add(JSON.stringify(res))
          }
        }
      }
      // 去重
      const array = []
      result.forEach(v => {
        array.push(JSON.parse(v))
      })
      return array
    };
~~~

优化

~~~js
   function threeSum(nums) {
      const result = new Set()
      if (!nums.length) {
        return nums
      }
      nums.sort((a, b) => a - b)
      console.log(nums)
      const map = {}
      nums.forEach((v, i) => {
        if (map[v]) {
          map[v].push(i)
        } else {
          map[v] = [i]
        }
      })
      let zeroIndex = nums.findIndex(v => v === 0),
        left = zeroIndex;
      // right = nums.findLastIndex(v => v === 0);
      right = 0
      for (let i = nums.length - 1; i >= 0; i--) {
        if (nums[i] === 0) {
          right = i
          break
        }
      }

      //超过三个0
      if ((right - left + 1) >= 3) {
        result.add(JSON.stringify([0, 0, 0]))
      }

      // 去重
      for (let i = 0; i < nums.length; i++) {
        let positive = right + (i + 1)
        let minus = left - (i + 1)
        const currentLeft = nums[minus]
        const currentRight = nums[positive]
        if (minus < 0) minus = 0
        if (positive > nums.length - 1) positive = nums.length - 1

        for (let j = 0; j < nums.length; j++) {
          const moveLeftIndex = left - (j + 1),
            moveRightIndex = right + (j + 1),
            leftMapValue = (currentLeft + nums[moveLeftIndex]) * -1,
            rightMapValue = (currentRight + nums[moveRightIndex]) * -1
          // 一正 + 一负 + 一0 = 0
          if (zeroIndex !== -1 && currentLeft * -1 === nums[moveRightIndex]) {
            result.add(JSON.stringify([currentLeft, 0, nums[moveRightIndex]]))
          }
          // 两负数 + 一正 = 0

          if (minus !== moveLeftIndex && moveLeftIndex > 0 && map[leftMapValue]) {
            result.add(JSON.stringify([currentLeft, nums[moveLeftIndex], leftMapValue].sort()))
          }
          // 两正数 + 一负 = 0
          if (positive !== moveRightIndex && moveRightIndex < nums.length && map[rightMapValue]) {
            result.add(JSON.stringify([currentRight, nums[moveRightIndex], rightMapValue].sort()))
          }
        }
      }

      const array = []
      result.forEach(v => {
        array.push(JSON.parse(v))
      })

      return array
    };
~~~

最终版

~~~ts
function threeSum(nums: number[]): number[][] | number[] {
  const resultSet = new Set<string>()
  nums.sort((a, b) => a - b)
  console.log(nums)
  let result = [] as number[][] | number[]
  for (let i = 0; i < nums.length; i++) {
     // 大于0没必要求和了
    if (nums[i] > 0) break;
      //这个值和下一个值相等跳过
    if (i > 0 && nums[i] === nums[i - 1]) continue;
    let left = i + 1;
    let right = nums.length - 1;
    while (right > left) {
        // 当前值 + 较小值 + 较大值 如果大于0 说明较大值太大，right--
      if (nums[i] + nums[left] + nums[right] > 0) {
        right--
                  // 当前值 + 较小值 + 较大值 如果小于0 说明较小值太小，left++
      } else if (nums[i] + nums[left] + nums[right] < 0) {
        left++
      } else {
        resultSet.add(JSON.stringify([nums[i], nums[left], nums[right]].sort()))
        left++
        right--
      }
    }
  }
  resultSet.forEach(v => {
    result.push(JSON.parse(v))
  })
  return result
};
~~~





<CommentService/>