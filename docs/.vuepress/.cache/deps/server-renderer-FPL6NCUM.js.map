{
  "version": 3,
  "sources": ["../../../../node_modules/.pnpm/@vue+server-renderer@3.2.47_vue@3.2.47/node_modules/@vue/server-renderer/dist/server-renderer.esm-bundler.js"],
  "sourcesContent": ["import { createVNode, ssrContextKey, warn as warn$1, Fragment, Static, Comment, Text, mergeProps, ssrUtils, createApp, initDirectivesForSSR } from 'vue';\nimport { makeMap, isOn, isSVGTag, propsToAttrMap, isBooleanAttr, includeBooleanAttr, isSSRSafeAttrName, escapeHtml, normalizeClass, isString, normalizeStyle, stringifyStyle, isArray, toDisplayString, isFunction, isObject, looseEqual, looseIndexOf, isPromise, NOOP, escapeHtmlComment, isVoidTag } from '@vue/shared';\nexport { includeBooleanAttr as ssrIncludeBooleanAttr } from '@vue/shared';\n\n// leading comma for empty string \"\"\nconst shouldIgnoreProp = makeMap(`,key,ref,innerHTML,textContent,ref_key,ref_for`);\nfunction ssrRenderAttrs(props, tag) {\n    let ret = '';\n    for (const key in props) {\n        if (shouldIgnoreProp(key) ||\n            isOn(key) ||\n            (tag === 'textarea' && key === 'value')) {\n            continue;\n        }\n        const value = props[key];\n        if (key === 'class') {\n            ret += ` class=\"${ssrRenderClass(value)}\"`;\n        }\n        else if (key === 'style') {\n            ret += ` style=\"${ssrRenderStyle(value)}\"`;\n        }\n        else {\n            ret += ssrRenderDynamicAttr(key, value, tag);\n        }\n    }\n    return ret;\n}\n// render an attr with dynamic (unknown) key.\nfunction ssrRenderDynamicAttr(key, value, tag) {\n    if (!isRenderableValue(value)) {\n        return ``;\n    }\n    const attrKey = tag && (tag.indexOf('-') > 0 || isSVGTag(tag))\n        ? key // preserve raw name on custom elements and svg\n        : propsToAttrMap[key] || key.toLowerCase();\n    if (isBooleanAttr(attrKey)) {\n        return includeBooleanAttr(value) ? ` ${attrKey}` : ``;\n    }\n    else if (isSSRSafeAttrName(attrKey)) {\n        return value === '' ? ` ${attrKey}` : ` ${attrKey}=\"${escapeHtml(value)}\"`;\n    }\n    else {\n        console.warn(`[@vue/server-renderer] Skipped rendering unsafe attribute name: ${attrKey}`);\n        return ``;\n    }\n}\n// Render a v-bind attr with static key. The key is pre-processed at compile\n// time and we only need to check and escape value.\nfunction ssrRenderAttr(key, value) {\n    if (!isRenderableValue(value)) {\n        return ``;\n    }\n    return ` ${key}=\"${escapeHtml(value)}\"`;\n}\nfunction isRenderableValue(value) {\n    if (value == null) {\n        return false;\n    }\n    const type = typeof value;\n    return type === 'string' || type === 'number' || type === 'boolean';\n}\nfunction ssrRenderClass(raw) {\n    return escapeHtml(normalizeClass(raw));\n}\nfunction ssrRenderStyle(raw) {\n    if (!raw) {\n        return '';\n    }\n    if (isString(raw)) {\n        return escapeHtml(raw);\n    }\n    const styles = normalizeStyle(raw);\n    return escapeHtml(stringifyStyle(styles));\n}\n\nfunction ssrRenderComponent(comp, props = null, children = null, parentComponent = null, slotScopeId) {\n    return renderComponentVNode(createVNode(comp, props, children), parentComponent, slotScopeId);\n}\n\nfunction ssrRenderSlot(slots, slotName, slotProps, fallbackRenderFn, push, parentComponent, slotScopeId) {\n    // template-compiled slots are always rendered as fragments\n    push(`<!--[-->`);\n    ssrRenderSlotInner(slots, slotName, slotProps, fallbackRenderFn, push, parentComponent, slotScopeId);\n    push(`<!--]-->`);\n}\nfunction ssrRenderSlotInner(slots, slotName, slotProps, fallbackRenderFn, push, parentComponent, slotScopeId, transition) {\n    const slotFn = slots[slotName];\n    if (slotFn) {\n        const slotBuffer = [];\n        const bufferedPush = (item) => {\n            slotBuffer.push(item);\n        };\n        const ret = slotFn(slotProps, bufferedPush, parentComponent, slotScopeId ? ' ' + slotScopeId : '');\n        if (isArray(ret)) {\n            // normal slot\n            renderVNodeChildren(push, ret, parentComponent, slotScopeId);\n        }\n        else {\n            // ssr slot.\n            // check if the slot renders all comments, in which case use the fallback\n            let isEmptySlot = true;\n            if (transition) {\n                isEmptySlot = false;\n            }\n            else {\n                for (let i = 0; i < slotBuffer.length; i++) {\n                    if (!isComment(slotBuffer[i])) {\n                        isEmptySlot = false;\n                        break;\n                    }\n                }\n            }\n            if (isEmptySlot) {\n                if (fallbackRenderFn) {\n                    fallbackRenderFn();\n                }\n            }\n            else {\n                for (let i = 0; i < slotBuffer.length; i++) {\n                    push(slotBuffer[i]);\n                }\n            }\n        }\n    }\n    else if (fallbackRenderFn) {\n        fallbackRenderFn();\n    }\n}\nconst commentTestRE = /^<!--.*-->$/s;\nconst commentRE = /<!--[^]*?-->/gm;\nfunction isComment(item) {\n    if (typeof item !== 'string' || !commentTestRE.test(item))\n        return false;\n    // if item is '<!---->' or '<!--[-->' or '<!--]-->', return true directly\n    if (item.length <= 8)\n        return true;\n    return !item.replace(commentRE, '').trim();\n}\n\nfunction ssrRenderTeleport(parentPush, contentRenderFn, target, disabled, parentComponent) {\n    parentPush('<!--teleport start-->');\n    const context = parentComponent.appContext.provides[ssrContextKey];\n    const teleportBuffers = context.__teleportBuffers || (context.__teleportBuffers = {});\n    const targetBuffer = teleportBuffers[target] || (teleportBuffers[target] = []);\n    // record current index of the target buffer to handle nested teleports\n    // since the parent needs to be rendered before the child\n    const bufferIndex = targetBuffer.length;\n    let teleportContent;\n    if (disabled) {\n        contentRenderFn(parentPush);\n        teleportContent = `<!--teleport anchor-->`;\n    }\n    else {\n        const { getBuffer, push } = createBuffer();\n        contentRenderFn(push);\n        push(`<!--teleport anchor-->`);\n        teleportContent = getBuffer();\n    }\n    targetBuffer.splice(bufferIndex, 0, teleportContent);\n    parentPush('<!--teleport end-->');\n}\n\nfunction ssrInterpolate(value) {\n    return escapeHtml(toDisplayString(value));\n}\n\nSymbol((process.env.NODE_ENV !== 'production') ? 'iterate' : '');\nSymbol((process.env.NODE_ENV !== 'production') ? 'Map key iterate' : '');\nlet shouldTrack = true;\nconst trackStack = [];\nfunction pauseTracking() {\n    trackStack.push(shouldTrack);\n    shouldTrack = false;\n}\nfunction resetTracking() {\n    const last = trackStack.pop();\n    shouldTrack = last === undefined ? true : last;\n}\n\nfunction toRaw(observed) {\n    const raw = observed && observed[\"__v_raw\" /* ReactiveFlags.RAW */];\n    return raw ? toRaw(raw) : observed;\n}\n\nfunction isRef(r) {\n    return !!(r && r.__v_isRef === true);\n}\n\nconst stack = [];\nfunction pushWarningContext(vnode) {\n    stack.push(vnode);\n}\nfunction popWarningContext() {\n    stack.pop();\n}\nfunction warn(msg, ...args) {\n    if (!(process.env.NODE_ENV !== 'production'))\n        return;\n    // avoid props formatting or warn handler tracking deps that might be mutated\n    // during patch, leading to infinite recursion.\n    pauseTracking();\n    const instance = stack.length ? stack[stack.length - 1].component : null;\n    const appWarnHandler = instance && instance.appContext.config.warnHandler;\n    const trace = getComponentTrace();\n    if (appWarnHandler) {\n        callWithErrorHandling(appWarnHandler, instance, 11 /* ErrorCodes.APP_WARN_HANDLER */, [\n            msg + args.join(''),\n            instance && instance.proxy,\n            trace\n                .map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`)\n                .join('\\n'),\n            trace\n        ]);\n    }\n    else {\n        const warnArgs = [`[Vue warn]: ${msg}`, ...args];\n        /* istanbul ignore if */\n        if (trace.length &&\n            // avoid spamming console during tests\n            !false) {\n            warnArgs.push(`\\n`, ...formatTrace(trace));\n        }\n        console.warn(...warnArgs);\n    }\n    resetTracking();\n}\nfunction getComponentTrace() {\n    let currentVNode = stack[stack.length - 1];\n    if (!currentVNode) {\n        return [];\n    }\n    // we can't just use the stack because it will be incomplete during updates\n    // that did not start from the root. Re-construct the parent chain using\n    // instance parent pointers.\n    const normalizedStack = [];\n    while (currentVNode) {\n        const last = normalizedStack[0];\n        if (last && last.vnode === currentVNode) {\n            last.recurseCount++;\n        }\n        else {\n            normalizedStack.push({\n                vnode: currentVNode,\n                recurseCount: 0\n            });\n        }\n        const parentInstance = currentVNode.component && currentVNode.component.parent;\n        currentVNode = parentInstance && parentInstance.vnode;\n    }\n    return normalizedStack;\n}\n/* istanbul ignore next */\nfunction formatTrace(trace) {\n    const logs = [];\n    trace.forEach((entry, i) => {\n        logs.push(...(i === 0 ? [] : [`\\n`]), ...formatTraceEntry(entry));\n    });\n    return logs;\n}\nfunction formatTraceEntry({ vnode, recurseCount }) {\n    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;\n    const isRoot = vnode.component ? vnode.component.parent == null : false;\n    const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;\n    const close = `>` + postfix;\n    return vnode.props\n        ? [open, ...formatProps(vnode.props), close]\n        : [open + close];\n}\n/* istanbul ignore next */\nfunction formatProps(props) {\n    const res = [];\n    const keys = Object.keys(props);\n    keys.slice(0, 3).forEach(key => {\n        res.push(...formatProp(key, props[key]));\n    });\n    if (keys.length > 3) {\n        res.push(` ...`);\n    }\n    return res;\n}\n/* istanbul ignore next */\nfunction formatProp(key, value, raw) {\n    if (isString(value)) {\n        value = JSON.stringify(value);\n        return raw ? value : [`${key}=${value}`];\n    }\n    else if (typeof value === 'number' ||\n        typeof value === 'boolean' ||\n        value == null) {\n        return raw ? value : [`${key}=${value}`];\n    }\n    else if (isRef(value)) {\n        value = formatProp(key, toRaw(value.value), true);\n        return raw ? value : [`${key}=Ref<`, value, `>`];\n    }\n    else if (isFunction(value)) {\n        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];\n    }\n    else {\n        value = toRaw(value);\n        return raw ? value : [`${key}=`, value];\n    }\n}\n\nconst ErrorTypeStrings = {\n    [\"sp\" /* LifecycleHooks.SERVER_PREFETCH */]: 'serverPrefetch hook',\n    [\"bc\" /* LifecycleHooks.BEFORE_CREATE */]: 'beforeCreate hook',\n    [\"c\" /* LifecycleHooks.CREATED */]: 'created hook',\n    [\"bm\" /* LifecycleHooks.BEFORE_MOUNT */]: 'beforeMount hook',\n    [\"m\" /* LifecycleHooks.MOUNTED */]: 'mounted hook',\n    [\"bu\" /* LifecycleHooks.BEFORE_UPDATE */]: 'beforeUpdate hook',\n    [\"u\" /* LifecycleHooks.UPDATED */]: 'updated',\n    [\"bum\" /* LifecycleHooks.BEFORE_UNMOUNT */]: 'beforeUnmount hook',\n    [\"um\" /* LifecycleHooks.UNMOUNTED */]: 'unmounted hook',\n    [\"a\" /* LifecycleHooks.ACTIVATED */]: 'activated hook',\n    [\"da\" /* LifecycleHooks.DEACTIVATED */]: 'deactivated hook',\n    [\"ec\" /* LifecycleHooks.ERROR_CAPTURED */]: 'errorCaptured hook',\n    [\"rtc\" /* LifecycleHooks.RENDER_TRACKED */]: 'renderTracked hook',\n    [\"rtg\" /* LifecycleHooks.RENDER_TRIGGERED */]: 'renderTriggered hook',\n    [0 /* ErrorCodes.SETUP_FUNCTION */]: 'setup function',\n    [1 /* ErrorCodes.RENDER_FUNCTION */]: 'render function',\n    [2 /* ErrorCodes.WATCH_GETTER */]: 'watcher getter',\n    [3 /* ErrorCodes.WATCH_CALLBACK */]: 'watcher callback',\n    [4 /* ErrorCodes.WATCH_CLEANUP */]: 'watcher cleanup function',\n    [5 /* ErrorCodes.NATIVE_EVENT_HANDLER */]: 'native event handler',\n    [6 /* ErrorCodes.COMPONENT_EVENT_HANDLER */]: 'component event handler',\n    [7 /* ErrorCodes.VNODE_HOOK */]: 'vnode hook',\n    [8 /* ErrorCodes.DIRECTIVE_HOOK */]: 'directive hook',\n    [9 /* ErrorCodes.TRANSITION_HOOK */]: 'transition hook',\n    [10 /* ErrorCodes.APP_ERROR_HANDLER */]: 'app errorHandler',\n    [11 /* ErrorCodes.APP_WARN_HANDLER */]: 'app warnHandler',\n    [12 /* ErrorCodes.FUNCTION_REF */]: 'ref function',\n    [13 /* ErrorCodes.ASYNC_COMPONENT_LOADER */]: 'async component loader',\n    [14 /* ErrorCodes.SCHEDULER */]: 'scheduler flush. This is likely a Vue internals bug. ' +\n        'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core'\n};\nfunction callWithErrorHandling(fn, instance, type, args) {\n    let res;\n    try {\n        res = args ? fn(...args) : fn();\n    }\n    catch (err) {\n        handleError(err, instance, type);\n    }\n    return res;\n}\nfunction handleError(err, instance, type, throwInDev = true) {\n    const contextVNode = instance ? instance.vnode : null;\n    if (instance) {\n        let cur = instance.parent;\n        // the exposed instance is the render proxy to keep it consistent with 2.x\n        const exposedInstance = instance.proxy;\n        // in production the hook receives only the error code\n        const errorInfo = (process.env.NODE_ENV !== 'production') ? ErrorTypeStrings[type] : type;\n        while (cur) {\n            const errorCapturedHooks = cur.ec;\n            if (errorCapturedHooks) {\n                for (let i = 0; i < errorCapturedHooks.length; i++) {\n                    if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {\n                        return;\n                    }\n                }\n            }\n            cur = cur.parent;\n        }\n        // app-level handling\n        const appErrorHandler = instance.appContext.config.errorHandler;\n        if (appErrorHandler) {\n            callWithErrorHandling(appErrorHandler, null, 10 /* ErrorCodes.APP_ERROR_HANDLER */, [err, exposedInstance, errorInfo]);\n            return;\n        }\n    }\n    logError(err, type, contextVNode, throwInDev);\n}\nfunction logError(err, type, contextVNode, throwInDev = true) {\n    if ((process.env.NODE_ENV !== 'production')) {\n        const info = ErrorTypeStrings[type];\n        if (contextVNode) {\n            pushWarningContext(contextVNode);\n        }\n        warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);\n        if (contextVNode) {\n            popWarningContext();\n        }\n        // crash in dev by default so it's more noticeable\n        if (throwInDev) {\n            throw err;\n        }\n        else {\n            console.error(err);\n        }\n    }\n    else {\n        // recover in prod to reduce the impact on end-user\n        console.error(err);\n    }\n}\n\nconst classifyRE = /(?:^|[-_])(\\w)/g;\nconst classify = (str) => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');\nfunction getComponentName(Component, includeInferred = true) {\n    return isFunction(Component)\n        ? Component.displayName || Component.name\n        : Component.name || (includeInferred && Component.__name);\n}\n/* istanbul ignore next */\nfunction formatComponentName(instance, Component, isRoot = false) {\n    let name = getComponentName(Component);\n    if (!name && Component.__file) {\n        const match = Component.__file.match(/([^/\\\\]+)\\.\\w+$/);\n        if (match) {\n            name = match[1];\n        }\n    }\n    if (!name && instance && instance.parent) {\n        // try to infer the name based on reverse resolution\n        const inferFromRegistry = (registry) => {\n            for (const key in registry) {\n                if (registry[key] === Component) {\n                    return key;\n                }\n            }\n        };\n        name =\n            inferFromRegistry(instance.components ||\n                instance.parent.type.components) || inferFromRegistry(instance.appContext.components);\n    }\n    return name ? classify(name) : isRoot ? `App` : `Anonymous`;\n}\n\nfunction ssrRenderList(source, renderItem) {\n    if (isArray(source) || isString(source)) {\n        for (let i = 0, l = source.length; i < l; i++) {\n            renderItem(source[i], i);\n        }\n    }\n    else if (typeof source === 'number') {\n        if ((process.env.NODE_ENV !== 'production') && !Number.isInteger(source)) {\n            warn(`The v-for range expect an integer value but got ${source}.`);\n            return;\n        }\n        for (let i = 0; i < source; i++) {\n            renderItem(i + 1, i);\n        }\n    }\n    else if (isObject(source)) {\n        if (source[Symbol.iterator]) {\n            const arr = Array.from(source);\n            for (let i = 0, l = arr.length; i < l; i++) {\n                renderItem(arr[i], i);\n            }\n        }\n        else {\n            const keys = Object.keys(source);\n            for (let i = 0, l = keys.length; i < l; i++) {\n                const key = keys[i];\n                renderItem(source[key], key, i);\n            }\n        }\n    }\n}\n\nasync function ssrRenderSuspense(push, { default: renderContent }) {\n    if (renderContent) {\n        renderContent();\n    }\n    else {\n        push(`<!---->`);\n    }\n}\n\nfunction ssrGetDirectiveProps(instance, dir, value, arg, modifiers = {}) {\n    if (typeof dir !== 'function' && dir.getSSRProps) {\n        return (dir.getSSRProps({\n            dir,\n            instance,\n            value,\n            oldValue: undefined,\n            arg,\n            modifiers\n        }, null) || {});\n    }\n    return {};\n}\n\nconst ssrLooseEqual = looseEqual;\nfunction ssrLooseContain(arr, value) {\n    return looseIndexOf(arr, value) > -1;\n}\n// for <input :type=\"type\" v-model=\"model\" value=\"value\">\nfunction ssrRenderDynamicModel(type, model, value) {\n    switch (type) {\n        case 'radio':\n            return looseEqual(model, value) ? ' checked' : '';\n        case 'checkbox':\n            return (isArray(model) ? ssrLooseContain(model, value) : model)\n                ? ' checked'\n                : '';\n        default:\n            // text types\n            return ssrRenderAttr('value', model);\n    }\n}\n// for <input v-bind=\"obj\" v-model=\"model\">\nfunction ssrGetDynamicModelProps(existingProps = {}, model) {\n    const { type, value } = existingProps;\n    switch (type) {\n        case 'radio':\n            return looseEqual(model, value) ? { checked: true } : null;\n        case 'checkbox':\n            return (isArray(model) ? ssrLooseContain(model, value) : model)\n                ? { checked: true }\n                : null;\n        default:\n            // text types\n            return { value: model };\n    }\n}\n\nfunction ssrCompile(template, instance) {\n    // TODO: this branch should now work in ESM builds, enable it in a minor\n    {\n        throw new Error(`On-the-fly template compilation is not supported in the ESM build of ` +\n            `@vue/server-renderer. All templates must be pre-compiled into ` +\n            `render functions.`);\n    }\n}\n\nconst { createComponentInstance, setCurrentRenderingInstance, setupComponent, renderComponentRoot, normalizeVNode } = ssrUtils;\n// Each component has a buffer array.\n// A buffer array can contain one of the following:\n// - plain string\n// - A resolved buffer (recursive arrays of strings that can be unrolled\n//   synchronously)\n// - An async buffer (a Promise that resolves to a resolved buffer)\nfunction createBuffer() {\n    let appendable = false;\n    const buffer = [];\n    return {\n        getBuffer() {\n            // Return static buffer and await on items during unroll stage\n            return buffer;\n        },\n        push(item) {\n            const isStringItem = isString(item);\n            if (appendable && isStringItem) {\n                buffer[buffer.length - 1] += item;\n            }\n            else {\n                buffer.push(item);\n            }\n            appendable = isStringItem;\n            if (isPromise(item) || (isArray(item) && item.hasAsync)) {\n                // promise, or child buffer with async, mark as async.\n                // this allows skipping unnecessary await ticks during unroll stage\n                buffer.hasAsync = true;\n            }\n        }\n    };\n}\nfunction renderComponentVNode(vnode, parentComponent = null, slotScopeId) {\n    const instance = createComponentInstance(vnode, parentComponent, null);\n    const res = setupComponent(instance, true /* isSSR */);\n    const hasAsyncSetup = isPromise(res);\n    const prefetches = instance.sp; /* LifecycleHooks.SERVER_PREFETCH */\n    if (hasAsyncSetup || prefetches) {\n        let p = hasAsyncSetup\n            ? res\n            : Promise.resolve();\n        if (prefetches) {\n            p = p\n                .then(() => Promise.all(prefetches.map(prefetch => prefetch.call(instance.proxy))))\n                // Note: error display is already done by the wrapped lifecycle hook function.\n                .catch(() => { });\n        }\n        return p.then(() => renderComponentSubTree(instance, slotScopeId));\n    }\n    else {\n        return renderComponentSubTree(instance, slotScopeId);\n    }\n}\nfunction renderComponentSubTree(instance, slotScopeId) {\n    const comp = instance.type;\n    const { getBuffer, push } = createBuffer();\n    if (isFunction(comp)) {\n        let root = renderComponentRoot(instance);\n        // #5817 scope ID attrs not falling through if functional component doesn't\n        // have props\n        if (!comp.props) {\n            for (const key in instance.attrs) {\n                if (key.startsWith(`data-v-`)) {\n                    (root.props || (root.props = {}))[key] = ``;\n                }\n            }\n        }\n        renderVNode(push, (instance.subTree = root), instance, slotScopeId);\n    }\n    else {\n        if ((!instance.render || instance.render === NOOP) &&\n            !instance.ssrRender &&\n            !comp.ssrRender &&\n            isString(comp.template)) {\n            comp.ssrRender = ssrCompile(comp.template);\n        }\n        // perf: enable caching of computed getters during render\n        // since there cannot be state mutations during render.\n        for (const e of instance.scope.effects) {\n            if (e.computed)\n                e.computed._cacheable = true;\n        }\n        const ssrRender = instance.ssrRender || comp.ssrRender;\n        if (ssrRender) {\n            // optimized\n            // resolve fallthrough attrs\n            let attrs = instance.inheritAttrs !== false ? instance.attrs : undefined;\n            let hasCloned = false;\n            let cur = instance;\n            while (true) {\n                const scopeId = cur.vnode.scopeId;\n                if (scopeId) {\n                    if (!hasCloned) {\n                        attrs = { ...attrs };\n                        hasCloned = true;\n                    }\n                    attrs[scopeId] = '';\n                }\n                const parent = cur.parent;\n                if (parent && parent.subTree && parent.subTree === cur.vnode) {\n                    // parent is a non-SSR compiled component and is rendering this\n                    // component as root. inherit its scopeId if present.\n                    cur = parent;\n                }\n                else {\n                    break;\n                }\n            }\n            if (slotScopeId) {\n                if (!hasCloned)\n                    attrs = { ...attrs };\n                attrs[slotScopeId.trim()] = '';\n            }\n            // set current rendering instance for asset resolution\n            const prev = setCurrentRenderingInstance(instance);\n            try {\n                ssrRender(instance.proxy, push, instance, attrs, \n                // compiler-optimized bindings\n                instance.props, instance.setupState, instance.data, instance.ctx);\n            }\n            finally {\n                setCurrentRenderingInstance(prev);\n            }\n        }\n        else if (instance.render && instance.render !== NOOP) {\n            renderVNode(push, (instance.subTree = renderComponentRoot(instance)), instance, slotScopeId);\n        }\n        else {\n            const componentName = comp.name || comp.__file || `<Anonymous>`;\n            warn$1(`Component ${componentName} is missing template or render function.`);\n            push(`<!---->`);\n        }\n    }\n    return getBuffer();\n}\nfunction renderVNode(push, vnode, parentComponent, slotScopeId) {\n    const { type, shapeFlag, children } = vnode;\n    switch (type) {\n        case Text:\n            push(escapeHtml(children));\n            break;\n        case Comment:\n            push(children ? `<!--${escapeHtmlComment(children)}-->` : `<!---->`);\n            break;\n        case Static:\n            push(children);\n            break;\n        case Fragment:\n            if (vnode.slotScopeIds) {\n                slotScopeId =\n                    (slotScopeId ? slotScopeId + ' ' : '') + vnode.slotScopeIds.join(' ');\n            }\n            push(`<!--[-->`); // open\n            renderVNodeChildren(push, children, parentComponent, slotScopeId);\n            push(`<!--]-->`); // close\n            break;\n        default:\n            if (shapeFlag & 1 /* ShapeFlags.ELEMENT */) {\n                renderElementVNode(push, vnode, parentComponent, slotScopeId);\n            }\n            else if (shapeFlag & 6 /* ShapeFlags.COMPONENT */) {\n                push(renderComponentVNode(vnode, parentComponent, slotScopeId));\n            }\n            else if (shapeFlag & 64 /* ShapeFlags.TELEPORT */) {\n                renderTeleportVNode(push, vnode, parentComponent, slotScopeId);\n            }\n            else if (shapeFlag & 128 /* ShapeFlags.SUSPENSE */) {\n                renderVNode(push, vnode.ssContent, parentComponent, slotScopeId);\n            }\n            else {\n                warn$1('[@vue/server-renderer] Invalid VNode type:', type, `(${typeof type})`);\n            }\n    }\n}\nfunction renderVNodeChildren(push, children, parentComponent, slotScopeId) {\n    for (let i = 0; i < children.length; i++) {\n        renderVNode(push, normalizeVNode(children[i]), parentComponent, slotScopeId);\n    }\n}\nfunction renderElementVNode(push, vnode, parentComponent, slotScopeId) {\n    const tag = vnode.type;\n    let { props, children, shapeFlag, scopeId, dirs } = vnode;\n    let openTag = `<${tag}`;\n    if (dirs) {\n        props = applySSRDirectives(vnode, props, dirs);\n    }\n    if (props) {\n        openTag += ssrRenderAttrs(props, tag);\n    }\n    if (scopeId) {\n        openTag += ` ${scopeId}`;\n    }\n    // inherit parent chain scope id if this is the root node\n    let curParent = parentComponent;\n    let curVnode = vnode;\n    while (curParent && curVnode === curParent.subTree) {\n        curVnode = curParent.vnode;\n        if (curVnode.scopeId) {\n            openTag += ` ${curVnode.scopeId}`;\n        }\n        curParent = curParent.parent;\n    }\n    if (slotScopeId) {\n        openTag += ` ${slotScopeId}`;\n    }\n    push(openTag + `>`);\n    if (!isVoidTag(tag)) {\n        let hasChildrenOverride = false;\n        if (props) {\n            if (props.innerHTML) {\n                hasChildrenOverride = true;\n                push(props.innerHTML);\n            }\n            else if (props.textContent) {\n                hasChildrenOverride = true;\n                push(escapeHtml(props.textContent));\n            }\n            else if (tag === 'textarea' && props.value) {\n                hasChildrenOverride = true;\n                push(escapeHtml(props.value));\n            }\n        }\n        if (!hasChildrenOverride) {\n            if (shapeFlag & 8 /* ShapeFlags.TEXT_CHILDREN */) {\n                push(escapeHtml(children));\n            }\n            else if (shapeFlag & 16 /* ShapeFlags.ARRAY_CHILDREN */) {\n                renderVNodeChildren(push, children, parentComponent, slotScopeId);\n            }\n        }\n        push(`</${tag}>`);\n    }\n}\nfunction applySSRDirectives(vnode, rawProps, dirs) {\n    const toMerge = [];\n    for (let i = 0; i < dirs.length; i++) {\n        const binding = dirs[i];\n        const { dir: { getSSRProps } } = binding;\n        if (getSSRProps) {\n            const props = getSSRProps(binding, vnode);\n            if (props)\n                toMerge.push(props);\n        }\n    }\n    return mergeProps(rawProps || {}, ...toMerge);\n}\nfunction renderTeleportVNode(push, vnode, parentComponent, slotScopeId) {\n    const target = vnode.props && vnode.props.to;\n    const disabled = vnode.props && vnode.props.disabled;\n    if (!target) {\n        if (!disabled) {\n            warn$1(`[@vue/server-renderer] Teleport is missing target prop.`);\n        }\n        return [];\n    }\n    if (!isString(target)) {\n        warn$1(`[@vue/server-renderer] Teleport target must be a query selector string.`);\n        return [];\n    }\n    ssrRenderTeleport(push, push => {\n        renderVNodeChildren(push, vnode.children, parentComponent, slotScopeId);\n    }, target, disabled || disabled === '', parentComponent);\n}\n\nconst { isVNode: isVNode$1 } = ssrUtils;\nasync function unrollBuffer$1(buffer) {\n    if (buffer.hasAsync) {\n        let ret = '';\n        for (let i = 0; i < buffer.length; i++) {\n            let item = buffer[i];\n            if (isPromise(item)) {\n                item = await item;\n            }\n            if (isString(item)) {\n                ret += item;\n            }\n            else {\n                ret += await unrollBuffer$1(item);\n            }\n        }\n        return ret;\n    }\n    else {\n        // sync buffer can be more efficiently unrolled without unnecessary await\n        // ticks\n        return unrollBufferSync$1(buffer);\n    }\n}\nfunction unrollBufferSync$1(buffer) {\n    let ret = '';\n    for (let i = 0; i < buffer.length; i++) {\n        let item = buffer[i];\n        if (isString(item)) {\n            ret += item;\n        }\n        else {\n            // since this is a sync buffer, child buffers are never promises\n            ret += unrollBufferSync$1(item);\n        }\n    }\n    return ret;\n}\nasync function renderToString(input, context = {}) {\n    if (isVNode$1(input)) {\n        // raw vnode, wrap with app (for context)\n        return renderToString(createApp({ render: () => input }), context);\n    }\n    // rendering an app\n    const vnode = createVNode(input._component, input._props);\n    vnode.appContext = input._context;\n    // provide the ssr context to the tree\n    input.provide(ssrContextKey, context);\n    const buffer = await renderComponentVNode(vnode);\n    const result = await unrollBuffer$1(buffer);\n    await resolveTeleports(context);\n    if (context.__watcherHandles) {\n        for (const unwatch of context.__watcherHandles) {\n            unwatch();\n        }\n    }\n    return result;\n}\nasync function resolveTeleports(context) {\n    if (context.__teleportBuffers) {\n        context.teleports = context.teleports || {};\n        for (const key in context.__teleportBuffers) {\n            // note: it's OK to await sequentially here because the Promises were\n            // created eagerly in parallel.\n            context.teleports[key] = await unrollBuffer$1(await Promise.all([context.__teleportBuffers[key]]));\n        }\n    }\n}\n\nconst { isVNode } = ssrUtils;\nasync function unrollBuffer(buffer, stream) {\n    if (buffer.hasAsync) {\n        for (let i = 0; i < buffer.length; i++) {\n            let item = buffer[i];\n            if (isPromise(item)) {\n                item = await item;\n            }\n            if (isString(item)) {\n                stream.push(item);\n            }\n            else {\n                await unrollBuffer(item, stream);\n            }\n        }\n    }\n    else {\n        // sync buffer can be more efficiently unrolled without unnecessary await\n        // ticks\n        unrollBufferSync(buffer, stream);\n    }\n}\nfunction unrollBufferSync(buffer, stream) {\n    for (let i = 0; i < buffer.length; i++) {\n        let item = buffer[i];\n        if (isString(item)) {\n            stream.push(item);\n        }\n        else {\n            // since this is a sync buffer, child buffers are never promises\n            unrollBufferSync(item, stream);\n        }\n    }\n}\nfunction renderToSimpleStream(input, context, stream) {\n    if (isVNode(input)) {\n        // raw vnode, wrap with app (for context)\n        return renderToSimpleStream(createApp({ render: () => input }), context, stream);\n    }\n    // rendering an app\n    const vnode = createVNode(input._component, input._props);\n    vnode.appContext = input._context;\n    // provide the ssr context to the tree\n    input.provide(ssrContextKey, context);\n    Promise.resolve(renderComponentVNode(vnode))\n        .then(buffer => unrollBuffer(buffer, stream))\n        .then(() => resolveTeleports(context))\n        .then(() => {\n        if (context.__watcherHandles) {\n            for (const unwatch of context.__watcherHandles) {\n                unwatch();\n            }\n        }\n    })\n        .then(() => stream.push(null))\n        .catch(error => {\n        stream.destroy(error);\n    });\n    return stream;\n}\n/**\n * @deprecated\n */\nfunction renderToStream(input, context = {}) {\n    console.warn(`[@vue/server-renderer] renderToStream is deprecated - use renderToNodeStream instead.`);\n    return renderToNodeStream(input, context);\n}\nfunction renderToNodeStream(input, context = {}) {\n    {\n        throw new Error(`ESM build of renderToStream() does not support renderToNodeStream(). ` +\n            `Use pipeToNodeWritable() with an existing Node.js Writable stream ` +\n            `instance instead.`);\n    }\n}\nfunction pipeToNodeWritable(input, context = {}, writable) {\n    renderToSimpleStream(input, context, {\n        push(content) {\n            if (content != null) {\n                writable.write(content);\n            }\n            else {\n                writable.end();\n            }\n        },\n        destroy(err) {\n            writable.destroy(err);\n        }\n    });\n}\nfunction renderToWebStream(input, context = {}) {\n    if (typeof ReadableStream !== 'function') {\n        throw new Error(`ReadableStream constructor is not available in the global scope. ` +\n            `If the target environment does support web streams, consider using ` +\n            `pipeToWebWritable() with an existing WritableStream instance instead.`);\n    }\n    const encoder = new TextEncoder();\n    let cancelled = false;\n    return new ReadableStream({\n        start(controller) {\n            renderToSimpleStream(input, context, {\n                push(content) {\n                    if (cancelled)\n                        return;\n                    if (content != null) {\n                        controller.enqueue(encoder.encode(content));\n                    }\n                    else {\n                        controller.close();\n                    }\n                },\n                destroy(err) {\n                    controller.error(err);\n                }\n            });\n        },\n        cancel() {\n            cancelled = true;\n        }\n    });\n}\nfunction pipeToWebWritable(input, context = {}, writable) {\n    const writer = writable.getWriter();\n    const encoder = new TextEncoder();\n    // #4287 CloudFlare workers do not implement `ready` property\n    let hasReady = false;\n    try {\n        hasReady = isPromise(writer.ready);\n    }\n    catch (e) { }\n    renderToSimpleStream(input, context, {\n        async push(content) {\n            if (hasReady) {\n                await writer.ready;\n            }\n            if (content != null) {\n                return writer.write(encoder.encode(content));\n            }\n            else {\n                return writer.close();\n            }\n        },\n        destroy(err) {\n            // TODO better error handling?\n            console.log(err);\n            writer.close();\n        }\n    });\n}\n\ninitDirectivesForSSR();\n\nexport { pipeToNodeWritable, pipeToWebWritable, renderToNodeStream, renderToSimpleStream, renderToStream, renderToString, renderToWebStream, ssrGetDirectiveProps, ssrGetDynamicModelProps, ssrInterpolate, ssrLooseContain, ssrLooseEqual, ssrRenderAttr, ssrRenderAttrs, ssrRenderClass, ssrRenderComponent, ssrRenderDynamicAttr, ssrRenderDynamicModel, ssrRenderList, ssrRenderSlot, ssrRenderSlotInner, ssrRenderStyle, ssrRenderSuspense, ssrRenderTeleport, renderVNode as ssrRenderVNode };\n"],
  "mappings": "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",
  "names": ["warn", "push"]
}
