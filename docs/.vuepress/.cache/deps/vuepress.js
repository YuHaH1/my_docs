import "./chunk-AWNJX4WY.js";
import {
  require_resolve
} from "./chunk-MU42OGIQ.js";
import {
  commonjsGlobal,
  getAugmentedNamespace,
  getDefaultExportFromCjs,
  require_crypto
} from "./chunk-GFW77JQX.js";
import {
  require_node_module,
  require_node_url
} from "./chunk-OXA5KGHY.js";
import {
  require_picocolors_browser,
  require_postcss,
  require_url
} from "./chunk-2QDG3FGG.js";
import {
  ensureEndingSlash,
  ensureLeadingSlash,
  formatDateString,
  isLinkExternal,
  omit,
  removeLeadingSlash,
  resolveLocalePath
} from "./chunk-U67Z5K23.js";
import {
  ssrContextKey
} from "./chunk-6IAFD24R.js";
import {
  isFunction,
  isString
} from "./chunk-GBQKLBS3.js";
import {
  require_node_http
} from "./chunk-HYFDUA4V.js";
import {
  require_node_https
} from "./chunk-A4UJUNLL.js";
import {
  require_events,
  require_node_os,
  require_stream
} from "./chunk-HYUQWE67.js";
import {
  require_node_crypto,
  require_node_perf_hooks,
  require_node_process,
  require_tty,
  version$1
} from "./chunk-2XPR2NR5.js";
import {
  require_os
} from "./chunk-A5KRL73I.js";
import {
  require_util
} from "./chunk-PVYF5JI5.js";
import {
  require_node_path
} from "./chunk-NUJLYLOZ.js";
import {
  require_fs
} from "./chunk-77WKV5WC.js";
import {
  require_path
} from "./chunk-CYFUJJFB.js";
import {
  __commonJS,
  __esm,
  __export,
  __privateAdd,
  __privateGet,
  __privateSet,
  __privateWrapper,
  __publicField,
  __reExport,
  __require,
  __toCommonJS,
  __toESM
} from "./chunk-OF4ZU3BS.js";

// node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/.pnpm/ms@2.1.2/node_modules/ms/index.js"(exports3, module2) {
    var s2 = 1e3;
    var m = s2 * 60;
    var h = m * 60;
    var d2 = h * 24;
    var w = d2 * 7;
    var y = d2 * 365.25;
    module2.exports = function(val, options3) {
      options3 = options3 || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse7(val);
      } else if (type === "number" && isFinite(val)) {
        return options3.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse7(str2) {
      str2 = String(str2);
      if (str2.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str2
      );
      if (!match) {
        return;
      }
      var n3 = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n3 * y;
        case "weeks":
        case "week":
        case "w":
          return n3 * w;
        case "days":
        case "day":
        case "d":
          return n3 * d2;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n3 * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n3 * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n3 * s2;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n3;
        default:
          return void 0;
      }
    }
    function fmtShort(ms3) {
      var msAbs = Math.abs(ms3);
      if (msAbs >= d2) {
        return Math.round(ms3 / d2) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms3 / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms3 / m) + "m";
      }
      if (msAbs >= s2) {
        return Math.round(ms3 / s2) + "s";
      }
      return ms3 + "ms";
    }
    function fmtLong(ms3) {
      var msAbs = Math.abs(ms3);
      if (msAbs >= d2) {
        return plural(ms3, msAbs, d2, "day");
      }
      if (msAbs >= h) {
        return plural(ms3, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms3, msAbs, m, "minute");
      }
      if (msAbs >= s2) {
        return plural(ms3, msAbs, s2, "second");
      }
      return ms3 + " ms";
    }
    function plural(ms3, msAbs, n3, name2) {
      var isPlural = msAbs >= n3 * 1.5;
      return Math.round(ms3 / n3) + " " + name2 + (isPlural ? "s" : "");
    }
  }
});

// node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/common.js"(exports3, module2) {
    function setup(env2) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env2).forEach((key) => {
        createDebug[key] = env2[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash2 = 0;
        for (let i2 = 0; i2 < namespace.length; i2++) {
          hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i2);
          hash2 |= 0;
        }
        return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug4(...args) {
          if (!debug4.enabled) {
            return;
          }
          const self2 = debug4;
          const curr = Number(new Date());
          const ms3 = curr - (prevTime || curr);
          self2.diff = ms3;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index2 = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
            if (match === "%%") {
              return "%";
            }
            index2++;
            const formatter2 = createDebug.formatters[format2];
            if (typeof formatter2 === "function") {
              const val = args[index2];
              match = formatter2.call(self2, val);
              args.splice(index2, 1);
              index2--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug4.namespace = namespace;
        debug4.useColors = createDebug.useColors();
        debug4.color = createDebug.selectColor(namespace);
        debug4.extend = extend2;
        debug4.destroy = createDebug.destroy;
        Object.defineProperty(debug4, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug4);
        }
        return debug4;
      }
      function extend2(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i2;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i2 = 0; i2 < len; i2++) {
          if (!split[i2]) {
            continue;
          }
          namespaces = split[i2].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name2) {
        if (name2[name2.length - 1] === "*") {
          return true;
        }
        let i2;
        let len;
        for (i2 = 0, len = createDebug.skips.length; i2 < len; i2++) {
          if (createDebug.skips[i2].test(name2)) {
            return false;
          }
        }
        for (i2 = 0, len = createDebug.names.length; i2 < len; i2++) {
          if (createDebug.names[i2].test(name2)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/.pnpm/debug@4.3.4/node_modules/debug/src/browser.js"(exports3, module2) {
    exports3.formatArgs = formatArgs;
    exports3.save = save;
    exports3.load = load2;
    exports3.useColors = useColors;
    exports3.storage = localstorage();
    exports3.destroy = (() => {
      let warned2 = false;
      return () => {
        if (!warned2) {
          warned2 = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports3.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c2 = "color: " + this.color;
      args.splice(1, 0, c2, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index2++;
        if (match === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c2);
    }
    exports3.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports3.storage.setItem("debug", namespaces);
        } else {
          exports3.storage.removeItem("debug");
        }
      } catch (error3) {
      }
    }
    function load2() {
      let r3;
      try {
        r3 = exports3.storage.getItem("debug");
      } catch (error3) {
      }
      if (!r3 && typeof process !== "undefined" && "env" in process) {
        r3 = process.env.DEBUG;
      }
      return r3;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error3) {
      }
    }
    module2.exports = require_common()(exports3);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error3) {
        return "[UnexpectedJSONParseError]: " + error3.message;
      }
    };
  }
});

// node_modules/.pnpm/universalify@2.0.0/node_modules/universalify/index.js
var require_universalify = __commonJS({
  "node_modules/.pnpm/universalify@2.0.0/node_modules/universalify/index.js"(exports3) {
    "use strict";
    exports3.fromCallback = function(fn) {
      return Object.defineProperty(function(...args) {
        if (typeof args[args.length - 1] === "function")
          fn.apply(this, args);
        else {
          return new Promise((resolve4, reject) => {
            fn.call(
              this,
              ...args,
              (err2, res) => err2 != null ? reject(err2) : resolve4(res)
            );
          });
        }
      }, "name", { value: fn.name });
    };
    exports3.fromPromise = function(fn) {
      return Object.defineProperty(function(...args) {
        const cb = args[args.length - 1];
        if (typeof cb !== "function")
          return fn.apply(this, args);
        else
          fn.apply(this, args.slice(0, -1)).then((r3) => cb(null, r3), cb);
      }, "name", { value: fn.name });
    };
  }
});

// browser-external:constants
var require_constants = __commonJS({
  "browser-external:constants"(exports3, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "constants" has been externalized for browser compatibility. Cannot access "constants.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  "node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/polyfills.js"(exports3, module2) {
    var constants2 = require_constants();
    var origCwd = process.cwd;
    var cwd = null;
    var platform2 = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process);
      return cwd;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    if (typeof process.chdir === "function") {
      chdir = process.chdir;
      process.chdir = function(d2) {
        cwd = null;
        chdir.call(process, d2);
      };
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(process.chdir, chdir);
    }
    var chdir;
    module2.exports = patch;
    function patch(fs6) {
      if (constants2.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs6);
      }
      if (!fs6.lutimes) {
        patchLutimes(fs6);
      }
      fs6.chown = chownFix(fs6.chown);
      fs6.fchown = chownFix(fs6.fchown);
      fs6.lchown = chownFix(fs6.lchown);
      fs6.chmod = chmodFix(fs6.chmod);
      fs6.fchmod = chmodFix(fs6.fchmod);
      fs6.lchmod = chmodFix(fs6.lchmod);
      fs6.chownSync = chownFixSync(fs6.chownSync);
      fs6.fchownSync = chownFixSync(fs6.fchownSync);
      fs6.lchownSync = chownFixSync(fs6.lchownSync);
      fs6.chmodSync = chmodFixSync(fs6.chmodSync);
      fs6.fchmodSync = chmodFixSync(fs6.fchmodSync);
      fs6.lchmodSync = chmodFixSync(fs6.lchmodSync);
      fs6.stat = statFix(fs6.stat);
      fs6.fstat = statFix(fs6.fstat);
      fs6.lstat = statFix(fs6.lstat);
      fs6.statSync = statFixSync(fs6.statSync);
      fs6.fstatSync = statFixSync(fs6.fstatSync);
      fs6.lstatSync = statFixSync(fs6.lstatSync);
      if (fs6.chmod && !fs6.lchmod) {
        fs6.lchmod = function(path8, mode2, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs6.lchmodSync = function() {
        };
      }
      if (fs6.chown && !fs6.lchown) {
        fs6.lchown = function(path8, uid, gid, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs6.lchownSync = function() {
        };
      }
      if (platform2 === "win32") {
        fs6.rename = typeof fs6.rename !== "function" ? fs6.rename : function(fs$rename) {
          function rename(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs6.stat(to, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from, to, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb)
                cb(er);
            });
          }
          if (Object.setPrototypeOf)
            Object.setPrototypeOf(rename, fs$rename);
          return rename;
        }(fs6.rename);
      }
      fs6.read = typeof fs6.read !== "function" ? fs6.read : function(fs$read) {
        function read2(fd, buffer, offset3, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs6, fd, buffer, offset3, length, position, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs6, fd, buffer, offset3, length, position, callback);
        }
        if (Object.setPrototypeOf)
          Object.setPrototypeOf(read2, fs$read);
        return read2;
      }(fs6.read);
      fs6.readSync = typeof fs6.readSync !== "function" ? fs6.readSync : function(fs$readSync) {
        return function(fd, buffer, offset3, length, position) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs6, fd, buffer, offset3, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      }(fs6.readSync);
      function patchLchmod(fs7) {
        fs7.lchmod = function(path8, mode2, callback) {
          fs7.open(
            path8,
            constants2.O_WRONLY | constants2.O_SYMLINK,
            mode2,
            function(err2, fd) {
              if (err2) {
                if (callback)
                  callback(err2);
                return;
              }
              fs7.fchmod(fd, mode2, function(err3) {
                fs7.close(fd, function(err22) {
                  if (callback)
                    callback(err3 || err22);
                });
              });
            }
          );
        };
        fs7.lchmodSync = function(path8, mode2) {
          var fd = fs7.openSync(path8, constants2.O_WRONLY | constants2.O_SYMLINK, mode2);
          var threw = true;
          var ret;
          try {
            ret = fs7.fchmodSync(fd, mode2);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs7.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs7.closeSync(fd);
            }
          }
          return ret;
        };
      }
      function patchLutimes(fs7) {
        if (constants2.hasOwnProperty("O_SYMLINK") && fs7.futimes) {
          fs7.lutimes = function(path8, at2, mt, cb) {
            fs7.open(path8, constants2.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb)
                  cb(er);
                return;
              }
              fs7.futimes(fd, at2, mt, function(er2) {
                fs7.close(fd, function(er22) {
                  if (cb)
                    cb(er2 || er22);
                });
              });
            });
          };
          fs7.lutimesSync = function(path8, at2, mt) {
            var fd = fs7.openSync(path8, constants2.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs7.futimesSync(fd, at2, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs7.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs7.closeSync(fd);
              }
            }
            return ret;
          };
        } else if (fs7.futimes) {
          fs7.lutimes = function(_a, _b, _c, cb) {
            if (cb)
              process.nextTick(cb);
          };
          fs7.lutimesSync = function() {
          };
        }
      }
      function chmodFix(orig) {
        if (!orig)
          return orig;
        return function(target, mode2, cb) {
          return orig.call(fs6, target, mode2, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, mode2) {
          try {
            return orig.call(fs6, target, mode2);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid, cb) {
          return orig.call(fs6, target, uid, gid, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid) {
          try {
            return orig.call(fs6, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig)
          return orig;
        return function(target, options3, cb) {
          if (typeof options3 === "function") {
            cb = options3;
            options3 = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0)
                stats.uid += 4294967296;
              if (stats.gid < 0)
                stats.gid += 4294967296;
            }
            if (cb)
              cb.apply(this, arguments);
          }
          return options3 ? orig.call(fs6, target, options3, callback) : orig.call(fs6, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, options3) {
          var stats = options3 ? orig.call(fs6, target, options3) : orig.call(fs6, target);
          if (stats) {
            if (stats.uid < 0)
              stats.uid += 4294967296;
            if (stats.gid < 0)
              stats.gid += 4294967296;
          }
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
    }
  }
});

// node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  "node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/legacy-streams.js"(exports3, module2) {
    var Stream2 = require_stream().Stream;
    module2.exports = legacy;
    function legacy(fs6) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path8, options3) {
        if (!(this instanceof ReadStream))
          return new ReadStream(path8, options3);
        Stream2.call(this);
        var self2 = this;
        this.path = path8;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options3 = options3 || {};
        var keys = Object.keys(options3);
        for (var index2 = 0, length = keys.length; index2 < length; index2++) {
          var key = keys[index2];
          this[key] = options3[key];
        }
        if (this.encoding)
          this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if ("number" !== typeof this.end) {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self2._read();
          });
          return;
        }
        fs6.open(this.path, this.flags, this.mode, function(err2, fd) {
          if (err2) {
            self2.emit("error", err2);
            self2.readable = false;
            return;
          }
          self2.fd = fd;
          self2.emit("open", fd);
          self2._read();
        });
      }
      function WriteStream(path8, options3) {
        if (!(this instanceof WriteStream))
          return new WriteStream(path8, options3);
        Stream2.call(this);
        this.path = path8;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options3 = options3 || {};
        var keys = Object.keys(options3);
        for (var index2 = 0, length = keys.length; index2 < length; index2++) {
          var key = keys[index2];
          this[key] = options3[key];
        }
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs6.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  }
});

// node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/clone.js
var require_clone = __commonJS({
  "node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/clone.js"(exports3, module2) {
    "use strict";
    module2.exports = clone;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone(obj) {
      if (obj === null || typeof obj !== "object")
        return obj;
      if (obj instanceof Object)
        var copy = { __proto__: getPrototypeOf(obj) };
      else
        var copy = /* @__PURE__ */ Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy;
    }
  }
});

// browser-external:assert
var require_assert = __commonJS({
  "browser-external:assert"(exports3, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "assert" has been externalized for browser compatibility. Cannot access "assert.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  "node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/graceful-fs.js"(exports3, module2) {
    var fs6 = require_fs();
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var clone = require_clone();
    var util2 = require_util();
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop2() {
    }
    function publishQueue(context, queue3) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue3;
        }
      });
    }
    var debug4 = noop2;
    if (util2.debuglog)
      debug4 = util2.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug4 = function() {
        var m = util2.format.apply(util2, arguments);
        m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
        console.error(m);
      };
    if (!fs6[gracefulQueue]) {
      queue2 = global[gracefulQueue] || [];
      publishQueue(fs6, queue2);
      fs6.close = function(fs$close) {
        function close2(fd, cb) {
          return fs$close.call(fs6, fd, function(err2) {
            if (!err2) {
              resetQueue();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close2, previousSymbol, {
          value: fs$close
        });
        return close2;
      }(fs6.close);
      fs6.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
          fs$closeSync.apply(fs6, arguments);
          resetQueue();
        }
        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync;
      }(fs6.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
          debug4(fs6[gracefulQueue]);
          require_assert().equal(fs6[gracefulQueue].length, 0);
        });
      }
    }
    var queue2;
    if (!global[gracefulQueue]) {
      publishQueue(global, fs6[gracefulQueue]);
    }
    module2.exports = patch(clone(fs6));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs6.__patched) {
      module2.exports = patch(fs6);
      fs6.__patched = true;
    }
    function patch(fs7) {
      polyfills(fs7);
      fs7.gracefulify = patch;
      fs7.createReadStream = createReadStream2;
      fs7.createWriteStream = createWriteStream;
      var fs$readFile = fs7.readFile;
      fs7.readFile = readFile;
      function readFile(path8, options3, cb) {
        if (typeof options3 === "function")
          cb = options3, options3 = null;
        return go$readFile(path8, options3, cb);
        function go$readFile(path9, options4, cb2, startTime) {
          return fs$readFile(path9, options4, function(err2) {
            if (err2 && (err2.code === "EMFILE" || err2.code === "ENFILE"))
              enqueue([go$readFile, [path9, options4, cb2], err2, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$writeFile = fs7.writeFile;
      fs7.writeFile = writeFile2;
      function writeFile2(path8, data2, options3, cb) {
        if (typeof options3 === "function")
          cb = options3, options3 = null;
        return go$writeFile(path8, data2, options3, cb);
        function go$writeFile(path9, data3, options4, cb2, startTime) {
          return fs$writeFile(path9, data3, options4, function(err2) {
            if (err2 && (err2.code === "EMFILE" || err2.code === "ENFILE"))
              enqueue([go$writeFile, [path9, data3, options4, cb2], err2, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$appendFile = fs7.appendFile;
      if (fs$appendFile)
        fs7.appendFile = appendFile;
      function appendFile(path8, data2, options3, cb) {
        if (typeof options3 === "function")
          cb = options3, options3 = null;
        return go$appendFile(path8, data2, options3, cb);
        function go$appendFile(path9, data3, options4, cb2, startTime) {
          return fs$appendFile(path9, data3, options4, function(err2) {
            if (err2 && (err2.code === "EMFILE" || err2.code === "ENFILE"))
              enqueue([go$appendFile, [path9, data3, options4, cb2], err2, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$copyFile = fs7.copyFile;
      if (fs$copyFile)
        fs7.copyFile = copyFile;
      function copyFile(src3, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return go$copyFile(src3, dest, flags, cb);
        function go$copyFile(src4, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src4, dest2, flags2, function(err2) {
            if (err2 && (err2.code === "EMFILE" || err2.code === "ENFILE"))
              enqueue([go$copyFile, [src4, dest2, flags2, cb2], err2, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$readdir = fs7.readdir;
      fs7.readdir = readdir2;
      var noReaddirOptionVersions = /^v[0-5]\./;
      function readdir2(path8, options3, cb) {
        if (typeof options3 === "function")
          cb = options3, options3 = null;
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path9, options4, cb2, startTime) {
          return fs$readdir(path9, fs$readdirCallback(
            path9,
            options4,
            cb2,
            startTime
          ));
        } : function go$readdir2(path9, options4, cb2, startTime) {
          return fs$readdir(path9, options4, fs$readdirCallback(
            path9,
            options4,
            cb2,
            startTime
          ));
        };
        return go$readdir(path8, options3, cb);
        function fs$readdirCallback(path9, options4, cb2, startTime) {
          return function(err2, files) {
            if (err2 && (err2.code === "EMFILE" || err2.code === "ENFILE"))
              enqueue([
                go$readdir,
                [path9, options4, cb2],
                err2,
                startTime || Date.now(),
                Date.now()
              ]);
            else {
              if (files && files.sort)
                files.sort();
              if (typeof cb2 === "function")
                cb2.call(this, err2, files);
            }
          };
        }
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs7);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs7.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs7.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs7, "ReadStream", {
        get: function() {
          return ReadStream;
        },
        set: function(val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs7, "WriteStream", {
        get: function() {
          return WriteStream;
        },
        set: function(val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs7, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs7, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      function ReadStream(path8, options3) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open2(that.path, that.flags, that.mode, function(err2, fd) {
          if (err2) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err2);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream(path8, options3) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open2(that.path, that.flags, that.mode, function(err2, fd) {
          if (err2) {
            that.destroy();
            that.emit("error", err2);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream2(path8, options3) {
        return new fs7.ReadStream(path8, options3);
      }
      function createWriteStream(path8, options3) {
        return new fs7.WriteStream(path8, options3);
      }
      var fs$open = fs7.open;
      fs7.open = open2;
      function open2(path8, flags, mode2, cb) {
        if (typeof mode2 === "function")
          cb = mode2, mode2 = null;
        return go$open(path8, flags, mode2, cb);
        function go$open(path9, flags2, mode3, cb2, startTime) {
          return fs$open(path9, flags2, mode3, function(err2, fd) {
            if (err2 && (err2.code === "EMFILE" || err2.code === "ENFILE"))
              enqueue([go$open, [path9, flags2, mode3, cb2], err2, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      return fs7;
    }
    function enqueue(elem) {
      debug4("ENQUEUE", elem[0].name, elem[1]);
      fs6[gracefulQueue].push(elem);
      retry();
    }
    var retryTimer;
    function resetQueue() {
      var now = Date.now();
      for (var i2 = 0; i2 < fs6[gracefulQueue].length; ++i2) {
        if (fs6[gracefulQueue][i2].length > 2) {
          fs6[gracefulQueue][i2][3] = now;
          fs6[gracefulQueue][i2][4] = now;
        }
      }
      retry();
    }
    function retry() {
      clearTimeout(retryTimer);
      retryTimer = void 0;
      if (fs6[gracefulQueue].length === 0)
        return;
      var elem = fs6[gracefulQueue].shift();
      var fn = elem[0];
      var args = elem[1];
      var err2 = elem[2];
      var startTime = elem[3];
      var lastTime = elem[4];
      if (startTime === void 0) {
        debug4("RETRY", fn.name, args);
        fn.apply(null, args);
      } else if (Date.now() - startTime >= 6e4) {
        debug4("TIMEOUT", fn.name, args);
        var cb = args.pop();
        if (typeof cb === "function")
          cb.call(null, err2);
      } else {
        var sinceAttempt = Date.now() - lastTime;
        var sinceStart = Math.max(lastTime - startTime, 1);
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        if (sinceAttempt >= desiredDelay) {
          debug4("RETRY", fn.name, args);
          fn.apply(null, args.concat([startTime]));
        } else {
          fs6[gracefulQueue].push(elem);
        }
      }
      if (retryTimer === void 0) {
        retryTimer = setTimeout(retry, 0);
      }
    }
  }
});

// node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/fs/index.js
var require_fs2 = __commonJS({
  "node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/fs/index.js"(exports3) {
    "use strict";
    var u2 = require_universalify().fromCallback;
    var fs6 = require_graceful_fs();
    var api = [
      "access",
      "appendFile",
      "chmod",
      "chown",
      "close",
      "copyFile",
      "fchmod",
      "fchown",
      "fdatasync",
      "fstat",
      "fsync",
      "ftruncate",
      "futimes",
      "lchmod",
      "lchown",
      "link",
      "lstat",
      "mkdir",
      "mkdtemp",
      "open",
      "opendir",
      "readdir",
      "readFile",
      "readlink",
      "realpath",
      "rename",
      "rm",
      "rmdir",
      "stat",
      "symlink",
      "truncate",
      "unlink",
      "utimes",
      "writeFile"
    ].filter((key) => {
      return typeof fs6[key] === "function";
    });
    Object.assign(exports3, fs6);
    api.forEach((method) => {
      exports3[method] = u2(fs6[method]);
    });
    exports3.exists = function(filename, callback) {
      if (typeof callback === "function") {
        return fs6.exists(filename, callback);
      }
      return new Promise((resolve4) => {
        return fs6.exists(filename, resolve4);
      });
    };
    exports3.read = function(fd, buffer, offset3, length, position, callback) {
      if (typeof callback === "function") {
        return fs6.read(fd, buffer, offset3, length, position, callback);
      }
      return new Promise((resolve4, reject) => {
        fs6.read(fd, buffer, offset3, length, position, (err2, bytesRead, buffer2) => {
          if (err2)
            return reject(err2);
          resolve4({ bytesRead, buffer: buffer2 });
        });
      });
    };
    exports3.write = function(fd, buffer, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs6.write(fd, buffer, ...args);
      }
      return new Promise((resolve4, reject) => {
        fs6.write(fd, buffer, ...args, (err2, bytesWritten, buffer2) => {
          if (err2)
            return reject(err2);
          resolve4({ bytesWritten, buffer: buffer2 });
        });
      });
    };
    exports3.readv = function(fd, buffers, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs6.readv(fd, buffers, ...args);
      }
      return new Promise((resolve4, reject) => {
        fs6.readv(fd, buffers, ...args, (err2, bytesRead, buffers2) => {
          if (err2)
            return reject(err2);
          resolve4({ bytesRead, buffers: buffers2 });
        });
      });
    };
    exports3.writev = function(fd, buffers, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs6.writev(fd, buffers, ...args);
      }
      return new Promise((resolve4, reject) => {
        fs6.writev(fd, buffers, ...args, (err2, bytesWritten, buffers2) => {
          if (err2)
            return reject(err2);
          resolve4({ bytesWritten, buffers: buffers2 });
        });
      });
    };
    if (typeof fs6.realpath.native === "function") {
      exports3.realpath.native = u2(fs6.realpath.native);
    } else {
      process.emitWarning(
        "fs.realpath.native is not a function. Is fs being monkey-patched?",
        "Warning",
        "fs-extra-WARN0003"
      );
    }
  }
});

// node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/mkdirs/utils.js
var require_utils = __commonJS({
  "node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/mkdirs/utils.js"(exports3, module2) {
    "use strict";
    var path8 = require_path();
    module2.exports.checkPath = function checkPath(pth) {
      if (process.platform === "win32") {
        const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path8.parse(pth).root, ""));
        if (pathHasInvalidWinCharacters) {
          const error3 = new Error(`Path contains invalid characters: ${pth}`);
          error3.code = "EINVAL";
          throw error3;
        }
      }
    };
  }
});

// node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/mkdirs/make-dir.js
var require_make_dir = __commonJS({
  "node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/mkdirs/make-dir.js"(exports3, module2) {
    "use strict";
    var fs6 = require_fs2();
    var { checkPath } = require_utils();
    var getMode = (options3) => {
      const defaults = { mode: 511 };
      if (typeof options3 === "number")
        return options3;
      return { ...defaults, ...options3 }.mode;
    };
    module2.exports.makeDir = async (dir, options3) => {
      checkPath(dir);
      return fs6.mkdir(dir, {
        mode: getMode(options3),
        recursive: true
      });
    };
    module2.exports.makeDirSync = (dir, options3) => {
      checkPath(dir);
      return fs6.mkdirSync(dir, {
        mode: getMode(options3),
        recursive: true
      });
    };
  }
});

// node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/mkdirs/index.js
var require_mkdirs = __commonJS({
  "node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/mkdirs/index.js"(exports3, module2) {
    "use strict";
    var u2 = require_universalify().fromPromise;
    var { makeDir: _makeDir, makeDirSync } = require_make_dir();
    var makeDir = u2(_makeDir);
    module2.exports = {
      mkdirs: makeDir,
      mkdirsSync: makeDirSync,
      // alias
      mkdirp: makeDir,
      mkdirpSync: makeDirSync,
      ensureDir: makeDir,
      ensureDirSync: makeDirSync
    };
  }
});

// node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/path-exists/index.js
var require_path_exists = __commonJS({
  "node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/path-exists/index.js"(exports3, module2) {
    "use strict";
    var u2 = require_universalify().fromPromise;
    var fs6 = require_fs2();
    function pathExists(path8) {
      return fs6.access(path8).then(() => true).catch(() => false);
    }
    module2.exports = {
      pathExists: u2(pathExists),
      pathExistsSync: fs6.existsSync
    };
  }
});

// node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/util/utimes.js
var require_utimes = __commonJS({
  "node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/util/utimes.js"(exports3, module2) {
    "use strict";
    var fs6 = require_graceful_fs();
    function utimesMillis(path8, atime, mtime, callback) {
      fs6.open(path8, "r+", (err2, fd) => {
        if (err2)
          return callback(err2);
        fs6.futimes(fd, atime, mtime, (futimesErr) => {
          fs6.close(fd, (closeErr) => {
            if (callback)
              callback(futimesErr || closeErr);
          });
        });
      });
    }
    function utimesMillisSync(path8, atime, mtime) {
      const fd = fs6.openSync(path8, "r+");
      fs6.futimesSync(fd, atime, mtime);
      return fs6.closeSync(fd);
    }
    module2.exports = {
      utimesMillis,
      utimesMillisSync
    };
  }
});

// node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/util/stat.js
var require_stat = __commonJS({
  "node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/util/stat.js"(exports3, module2) {
    "use strict";
    var fs6 = require_fs2();
    var path8 = require_path();
    var util2 = require_util();
    function getStats(src3, dest, opts) {
      const statFunc = opts.dereference ? (file) => fs6.stat(file, { bigint: true }) : (file) => fs6.lstat(file, { bigint: true });
      return Promise.all([
        statFunc(src3),
        statFunc(dest).catch((err2) => {
          if (err2.code === "ENOENT")
            return null;
          throw err2;
        })
      ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
    }
    function getStatsSync(src3, dest, opts) {
      let destStat;
      const statFunc = opts.dereference ? (file) => fs6.statSync(file, { bigint: true }) : (file) => fs6.lstatSync(file, { bigint: true });
      const srcStat = statFunc(src3);
      try {
        destStat = statFunc(dest);
      } catch (err2) {
        if (err2.code === "ENOENT")
          return { srcStat, destStat: null };
        throw err2;
      }
      return { srcStat, destStat };
    }
    function checkPaths(src3, dest, funcName, opts, cb) {
      util2.callbackify(getStats)(src3, dest, opts, (err2, stats) => {
        if (err2)
          return cb(err2);
        const { srcStat, destStat } = stats;
        if (destStat) {
          if (areIdentical(srcStat, destStat)) {
            const srcBaseName = path8.basename(src3);
            const destBaseName = path8.basename(dest);
            if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
              return cb(null, { srcStat, destStat, isChangingCase: true });
            }
            return cb(new Error("Source and destination must not be the same."));
          }
          if (srcStat.isDirectory() && !destStat.isDirectory()) {
            return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src3}'.`));
          }
          if (!srcStat.isDirectory() && destStat.isDirectory()) {
            return cb(new Error(`Cannot overwrite directory '${dest}' with non-directory '${src3}'.`));
          }
        }
        if (srcStat.isDirectory() && isSrcSubdir(src3, dest)) {
          return cb(new Error(errMsg(src3, dest, funcName)));
        }
        return cb(null, { srcStat, destStat });
      });
    }
    function checkPathsSync(src3, dest, funcName, opts) {
      const { srcStat, destStat } = getStatsSync(src3, dest, opts);
      if (destStat) {
        if (areIdentical(srcStat, destStat)) {
          const srcBaseName = path8.basename(src3);
          const destBaseName = path8.basename(dest);
          if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
            return { srcStat, destStat, isChangingCase: true };
          }
          throw new Error("Source and destination must not be the same.");
        }
        if (srcStat.isDirectory() && !destStat.isDirectory()) {
          throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src3}'.`);
        }
        if (!srcStat.isDirectory() && destStat.isDirectory()) {
          throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src3}'.`);
        }
      }
      if (srcStat.isDirectory() && isSrcSubdir(src3, dest)) {
        throw new Error(errMsg(src3, dest, funcName));
      }
      return { srcStat, destStat };
    }
    function checkParentPaths(src3, srcStat, dest, funcName, cb) {
      const srcParent = path8.resolve(path8.dirname(src3));
      const destParent = path8.resolve(path8.dirname(dest));
      if (destParent === srcParent || destParent === path8.parse(destParent).root)
        return cb();
      fs6.stat(destParent, { bigint: true }, (err2, destStat) => {
        if (err2) {
          if (err2.code === "ENOENT")
            return cb();
          return cb(err2);
        }
        if (areIdentical(srcStat, destStat)) {
          return cb(new Error(errMsg(src3, dest, funcName)));
        }
        return checkParentPaths(src3, srcStat, destParent, funcName, cb);
      });
    }
    function checkParentPathsSync(src3, srcStat, dest, funcName) {
      const srcParent = path8.resolve(path8.dirname(src3));
      const destParent = path8.resolve(path8.dirname(dest));
      if (destParent === srcParent || destParent === path8.parse(destParent).root)
        return;
      let destStat;
      try {
        destStat = fs6.statSync(destParent, { bigint: true });
      } catch (err2) {
        if (err2.code === "ENOENT")
          return;
        throw err2;
      }
      if (areIdentical(srcStat, destStat)) {
        throw new Error(errMsg(src3, dest, funcName));
      }
      return checkParentPathsSync(src3, srcStat, destParent, funcName);
    }
    function areIdentical(srcStat, destStat) {
      return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
    }
    function isSrcSubdir(src3, dest) {
      const srcArr = path8.resolve(src3).split(path8.sep).filter((i2) => i2);
      const destArr = path8.resolve(dest).split(path8.sep).filter((i2) => i2);
      return srcArr.reduce((acc, cur, i2) => acc && destArr[i2] === cur, true);
    }
    function errMsg(src3, dest, funcName) {
      return `Cannot ${funcName} '${src3}' to a subdirectory of itself, '${dest}'.`;
    }
    module2.exports = {
      checkPaths,
      checkPathsSync,
      checkParentPaths,
      checkParentPathsSync,
      isSrcSubdir,
      areIdentical
    };
  }
});

// node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/copy/copy.js
var require_copy = __commonJS({
  "node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/copy/copy.js"(exports3, module2) {
    "use strict";
    var fs6 = require_graceful_fs();
    var path8 = require_path();
    var mkdirs = require_mkdirs().mkdirs;
    var pathExists = require_path_exists().pathExists;
    var utimesMillis = require_utimes().utimesMillis;
    var stat2 = require_stat();
    function copy(src3, dest, opts, cb) {
      if (typeof opts === "function" && !cb) {
        cb = opts;
        opts = {};
      } else if (typeof opts === "function") {
        opts = { filter: opts };
      }
      cb = cb || function() {
      };
      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        process.emitWarning(
          "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
          "Warning",
          "fs-extra-WARN0001"
        );
      }
      stat2.checkPaths(src3, dest, "copy", opts, (err2, stats) => {
        if (err2)
          return cb(err2);
        const { srcStat, destStat } = stats;
        stat2.checkParentPaths(src3, srcStat, dest, "copy", (err3) => {
          if (err3)
            return cb(err3);
          runFilter(src3, dest, opts, (err4, include) => {
            if (err4)
              return cb(err4);
            if (!include)
              return cb();
            checkParentDir(destStat, src3, dest, opts, cb);
          });
        });
      });
    }
    function checkParentDir(destStat, src3, dest, opts, cb) {
      const destParent = path8.dirname(dest);
      pathExists(destParent, (err2, dirExists) => {
        if (err2)
          return cb(err2);
        if (dirExists)
          return getStats(destStat, src3, dest, opts, cb);
        mkdirs(destParent, (err3) => {
          if (err3)
            return cb(err3);
          return getStats(destStat, src3, dest, opts, cb);
        });
      });
    }
    function runFilter(src3, dest, opts, cb) {
      if (!opts.filter)
        return cb(null, true);
      Promise.resolve(opts.filter(src3, dest)).then((include) => cb(null, include), (error3) => cb(error3));
    }
    function getStats(destStat, src3, dest, opts, cb) {
      const stat3 = opts.dereference ? fs6.stat : fs6.lstat;
      stat3(src3, (err2, srcStat) => {
        if (err2)
          return cb(err2);
        if (srcStat.isDirectory())
          return onDir(srcStat, destStat, src3, dest, opts, cb);
        else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
          return onFile(srcStat, destStat, src3, dest, opts, cb);
        else if (srcStat.isSymbolicLink())
          return onLink(destStat, src3, dest, opts, cb);
        else if (srcStat.isSocket())
          return cb(new Error(`Cannot copy a socket file: ${src3}`));
        else if (srcStat.isFIFO())
          return cb(new Error(`Cannot copy a FIFO pipe: ${src3}`));
        return cb(new Error(`Unknown file: ${src3}`));
      });
    }
    function onFile(srcStat, destStat, src3, dest, opts, cb) {
      if (!destStat)
        return copyFile(srcStat, src3, dest, opts, cb);
      return mayCopyFile(srcStat, src3, dest, opts, cb);
    }
    function mayCopyFile(srcStat, src3, dest, opts, cb) {
      if (opts.overwrite) {
        fs6.unlink(dest, (err2) => {
          if (err2)
            return cb(err2);
          return copyFile(srcStat, src3, dest, opts, cb);
        });
      } else if (opts.errorOnExist) {
        return cb(new Error(`'${dest}' already exists`));
      } else
        return cb();
    }
    function copyFile(srcStat, src3, dest, opts, cb) {
      fs6.copyFile(src3, dest, (err2) => {
        if (err2)
          return cb(err2);
        if (opts.preserveTimestamps)
          return handleTimestampsAndMode(srcStat.mode, src3, dest, cb);
        return setDestMode(dest, srcStat.mode, cb);
      });
    }
    function handleTimestampsAndMode(srcMode, src3, dest, cb) {
      if (fileIsNotWritable(srcMode)) {
        return makeFileWritable(dest, srcMode, (err2) => {
          if (err2)
            return cb(err2);
          return setDestTimestampsAndMode(srcMode, src3, dest, cb);
        });
      }
      return setDestTimestampsAndMode(srcMode, src3, dest, cb);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode, cb) {
      return setDestMode(dest, srcMode | 128, cb);
    }
    function setDestTimestampsAndMode(srcMode, src3, dest, cb) {
      setDestTimestamps(src3, dest, (err2) => {
        if (err2)
          return cb(err2);
        return setDestMode(dest, srcMode, cb);
      });
    }
    function setDestMode(dest, srcMode, cb) {
      return fs6.chmod(dest, srcMode, cb);
    }
    function setDestTimestamps(src3, dest, cb) {
      fs6.stat(src3, (err2, updatedSrcStat) => {
        if (err2)
          return cb(err2);
        return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb);
      });
    }
    function onDir(srcStat, destStat, src3, dest, opts, cb) {
      if (!destStat)
        return mkDirAndCopy(srcStat.mode, src3, dest, opts, cb);
      return copyDir2(src3, dest, opts, cb);
    }
    function mkDirAndCopy(srcMode, src3, dest, opts, cb) {
      fs6.mkdir(dest, (err2) => {
        if (err2)
          return cb(err2);
        copyDir2(src3, dest, opts, (err3) => {
          if (err3)
            return cb(err3);
          return setDestMode(dest, srcMode, cb);
        });
      });
    }
    function copyDir2(src3, dest, opts, cb) {
      fs6.readdir(src3, (err2, items) => {
        if (err2)
          return cb(err2);
        return copyDirItems(items, src3, dest, opts, cb);
      });
    }
    function copyDirItems(items, src3, dest, opts, cb) {
      const item = items.pop();
      if (!item)
        return cb();
      return copyDirItem(items, item, src3, dest, opts, cb);
    }
    function copyDirItem(items, item, src3, dest, opts, cb) {
      const srcItem = path8.join(src3, item);
      const destItem = path8.join(dest, item);
      runFilter(srcItem, destItem, opts, (err2, include) => {
        if (err2)
          return cb(err2);
        if (!include)
          return copyDirItems(items, src3, dest, opts, cb);
        stat2.checkPaths(srcItem, destItem, "copy", opts, (err3, stats) => {
          if (err3)
            return cb(err3);
          const { destStat } = stats;
          getStats(destStat, srcItem, destItem, opts, (err4) => {
            if (err4)
              return cb(err4);
            return copyDirItems(items, src3, dest, opts, cb);
          });
        });
      });
    }
    function onLink(destStat, src3, dest, opts, cb) {
      fs6.readlink(src3, (err2, resolvedSrc) => {
        if (err2)
          return cb(err2);
        if (opts.dereference) {
          resolvedSrc = path8.resolve(process.cwd(), resolvedSrc);
        }
        if (!destStat) {
          return fs6.symlink(resolvedSrc, dest, cb);
        } else {
          fs6.readlink(dest, (err3, resolvedDest) => {
            if (err3) {
              if (err3.code === "EINVAL" || err3.code === "UNKNOWN")
                return fs6.symlink(resolvedSrc, dest, cb);
              return cb(err3);
            }
            if (opts.dereference) {
              resolvedDest = path8.resolve(process.cwd(), resolvedDest);
            }
            if (stat2.isSrcSubdir(resolvedSrc, resolvedDest)) {
              return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));
            }
            if (stat2.isSrcSubdir(resolvedDest, resolvedSrc)) {
              return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));
            }
            return copyLink(resolvedSrc, dest, cb);
          });
        }
      });
    }
    function copyLink(resolvedSrc, dest, cb) {
      fs6.unlink(dest, (err2) => {
        if (err2)
          return cb(err2);
        return fs6.symlink(resolvedSrc, dest, cb);
      });
    }
    module2.exports = copy;
  }
});

// node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/copy/copy-sync.js
var require_copy_sync = __commonJS({
  "node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/copy/copy-sync.js"(exports3, module2) {
    "use strict";
    var fs6 = require_graceful_fs();
    var path8 = require_path();
    var mkdirsSync = require_mkdirs().mkdirsSync;
    var utimesMillisSync = require_utimes().utimesMillisSync;
    var stat2 = require_stat();
    function copySync(src3, dest, opts) {
      if (typeof opts === "function") {
        opts = { filter: opts };
      }
      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        process.emitWarning(
          "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
          "Warning",
          "fs-extra-WARN0002"
        );
      }
      const { srcStat, destStat } = stat2.checkPathsSync(src3, dest, "copy", opts);
      stat2.checkParentPathsSync(src3, srcStat, dest, "copy");
      if (opts.filter && !opts.filter(src3, dest))
        return;
      const destParent = path8.dirname(dest);
      if (!fs6.existsSync(destParent))
        mkdirsSync(destParent);
      return getStats(destStat, src3, dest, opts);
    }
    function getStats(destStat, src3, dest, opts) {
      const statSync3 = opts.dereference ? fs6.statSync : fs6.lstatSync;
      const srcStat = statSync3(src3);
      if (srcStat.isDirectory())
        return onDir(srcStat, destStat, src3, dest, opts);
      else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
        return onFile(srcStat, destStat, src3, dest, opts);
      else if (srcStat.isSymbolicLink())
        return onLink(destStat, src3, dest, opts);
      else if (srcStat.isSocket())
        throw new Error(`Cannot copy a socket file: ${src3}`);
      else if (srcStat.isFIFO())
        throw new Error(`Cannot copy a FIFO pipe: ${src3}`);
      throw new Error(`Unknown file: ${src3}`);
    }
    function onFile(srcStat, destStat, src3, dest, opts) {
      if (!destStat)
        return copyFile(srcStat, src3, dest, opts);
      return mayCopyFile(srcStat, src3, dest, opts);
    }
    function mayCopyFile(srcStat, src3, dest, opts) {
      if (opts.overwrite) {
        fs6.unlinkSync(dest);
        return copyFile(srcStat, src3, dest, opts);
      } else if (opts.errorOnExist) {
        throw new Error(`'${dest}' already exists`);
      }
    }
    function copyFile(srcStat, src3, dest, opts) {
      fs6.copyFileSync(src3, dest);
      if (opts.preserveTimestamps)
        handleTimestamps(srcStat.mode, src3, dest);
      return setDestMode(dest, srcStat.mode);
    }
    function handleTimestamps(srcMode, src3, dest) {
      if (fileIsNotWritable(srcMode))
        makeFileWritable(dest, srcMode);
      return setDestTimestamps(src3, dest);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode) {
      return setDestMode(dest, srcMode | 128);
    }
    function setDestMode(dest, srcMode) {
      return fs6.chmodSync(dest, srcMode);
    }
    function setDestTimestamps(src3, dest) {
      const updatedSrcStat = fs6.statSync(src3);
      return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
    }
    function onDir(srcStat, destStat, src3, dest, opts) {
      if (!destStat)
        return mkDirAndCopy(srcStat.mode, src3, dest, opts);
      return copyDir2(src3, dest, opts);
    }
    function mkDirAndCopy(srcMode, src3, dest, opts) {
      fs6.mkdirSync(dest);
      copyDir2(src3, dest, opts);
      return setDestMode(dest, srcMode);
    }
    function copyDir2(src3, dest, opts) {
      fs6.readdirSync(src3).forEach((item) => copyDirItem(item, src3, dest, opts));
    }
    function copyDirItem(item, src3, dest, opts) {
      const srcItem = path8.join(src3, item);
      const destItem = path8.join(dest, item);
      if (opts.filter && !opts.filter(srcItem, destItem))
        return;
      const { destStat } = stat2.checkPathsSync(srcItem, destItem, "copy", opts);
      return getStats(destStat, srcItem, destItem, opts);
    }
    function onLink(destStat, src3, dest, opts) {
      let resolvedSrc = fs6.readlinkSync(src3);
      if (opts.dereference) {
        resolvedSrc = path8.resolve(process.cwd(), resolvedSrc);
      }
      if (!destStat) {
        return fs6.symlinkSync(resolvedSrc, dest);
      } else {
        let resolvedDest;
        try {
          resolvedDest = fs6.readlinkSync(dest);
        } catch (err2) {
          if (err2.code === "EINVAL" || err2.code === "UNKNOWN")
            return fs6.symlinkSync(resolvedSrc, dest);
          throw err2;
        }
        if (opts.dereference) {
          resolvedDest = path8.resolve(process.cwd(), resolvedDest);
        }
        if (stat2.isSrcSubdir(resolvedSrc, resolvedDest)) {
          throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
        }
        if (stat2.isSrcSubdir(resolvedDest, resolvedSrc)) {
          throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
        }
        return copyLink(resolvedSrc, dest);
      }
    }
    function copyLink(resolvedSrc, dest) {
      fs6.unlinkSync(dest);
      return fs6.symlinkSync(resolvedSrc, dest);
    }
    module2.exports = copySync;
  }
});

// node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/copy/index.js
var require_copy2 = __commonJS({
  "node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/copy/index.js"(exports3, module2) {
    "use strict";
    var u2 = require_universalify().fromCallback;
    module2.exports = {
      copy: u2(require_copy()),
      copySync: require_copy_sync()
    };
  }
});

// node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/remove/index.js
var require_remove = __commonJS({
  "node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/remove/index.js"(exports3, module2) {
    "use strict";
    var fs6 = require_graceful_fs();
    var u2 = require_universalify().fromCallback;
    function remove(path8, callback) {
      fs6.rm(path8, { recursive: true, force: true }, callback);
    }
    function removeSync(path8) {
      fs6.rmSync(path8, { recursive: true, force: true });
    }
    module2.exports = {
      remove: u2(remove),
      removeSync
    };
  }
});

// node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/empty/index.js
var require_empty = __commonJS({
  "node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/empty/index.js"(exports3, module2) {
    "use strict";
    var u2 = require_universalify().fromPromise;
    var fs6 = require_fs2();
    var path8 = require_path();
    var mkdir = require_mkdirs();
    var remove = require_remove();
    var emptyDir2 = u2(async function emptyDir3(dir) {
      let items;
      try {
        items = await fs6.readdir(dir);
      } catch {
        return mkdir.mkdirs(dir);
      }
      return Promise.all(items.map((item) => remove.remove(path8.join(dir, item))));
    });
    function emptyDirSync(dir) {
      let items;
      try {
        items = fs6.readdirSync(dir);
      } catch {
        return mkdir.mkdirsSync(dir);
      }
      items.forEach((item) => {
        item = path8.join(dir, item);
        remove.removeSync(item);
      });
    }
    module2.exports = {
      emptyDirSync,
      emptydirSync: emptyDirSync,
      emptyDir: emptyDir2,
      emptydir: emptyDir2
    };
  }
});

// node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/ensure/file.js
var require_file = __commonJS({
  "node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/ensure/file.js"(exports3, module2) {
    "use strict";
    var u2 = require_universalify().fromCallback;
    var path8 = require_path();
    var fs6 = require_graceful_fs();
    var mkdir = require_mkdirs();
    function createFile(file, callback) {
      function makeFile() {
        fs6.writeFile(file, "", (err2) => {
          if (err2)
            return callback(err2);
          callback();
        });
      }
      fs6.stat(file, (err2, stats) => {
        if (!err2 && stats.isFile())
          return callback();
        const dir = path8.dirname(file);
        fs6.stat(dir, (err3, stats2) => {
          if (err3) {
            if (err3.code === "ENOENT") {
              return mkdir.mkdirs(dir, (err4) => {
                if (err4)
                  return callback(err4);
                makeFile();
              });
            }
            return callback(err3);
          }
          if (stats2.isDirectory())
            makeFile();
          else {
            fs6.readdir(dir, (err4) => {
              if (err4)
                return callback(err4);
            });
          }
        });
      });
    }
    function createFileSync(file) {
      let stats;
      try {
        stats = fs6.statSync(file);
      } catch {
      }
      if (stats && stats.isFile())
        return;
      const dir = path8.dirname(file);
      try {
        if (!fs6.statSync(dir).isDirectory()) {
          fs6.readdirSync(dir);
        }
      } catch (err2) {
        if (err2 && err2.code === "ENOENT")
          mkdir.mkdirsSync(dir);
        else
          throw err2;
      }
      fs6.writeFileSync(file, "");
    }
    module2.exports = {
      createFile: u2(createFile),
      createFileSync
    };
  }
});

// node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/ensure/link.js
var require_link = __commonJS({
  "node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/ensure/link.js"(exports3, module2) {
    "use strict";
    var u2 = require_universalify().fromCallback;
    var path8 = require_path();
    var fs6 = require_graceful_fs();
    var mkdir = require_mkdirs();
    var pathExists = require_path_exists().pathExists;
    var { areIdentical } = require_stat();
    function createLink(srcpath, dstpath, callback) {
      function makeLink(srcpath2, dstpath2) {
        fs6.link(srcpath2, dstpath2, (err2) => {
          if (err2)
            return callback(err2);
          callback(null);
        });
      }
      fs6.lstat(dstpath, (_, dstStat) => {
        fs6.lstat(srcpath, (err2, srcStat) => {
          if (err2) {
            err2.message = err2.message.replace("lstat", "ensureLink");
            return callback(err2);
          }
          if (dstStat && areIdentical(srcStat, dstStat))
            return callback(null);
          const dir = path8.dirname(dstpath);
          pathExists(dir, (err3, dirExists) => {
            if (err3)
              return callback(err3);
            if (dirExists)
              return makeLink(srcpath, dstpath);
            mkdir.mkdirs(dir, (err4) => {
              if (err4)
                return callback(err4);
              makeLink(srcpath, dstpath);
            });
          });
        });
      });
    }
    function createLinkSync(srcpath, dstpath) {
      let dstStat;
      try {
        dstStat = fs6.lstatSync(dstpath);
      } catch {
      }
      try {
        const srcStat = fs6.lstatSync(srcpath);
        if (dstStat && areIdentical(srcStat, dstStat))
          return;
      } catch (err2) {
        err2.message = err2.message.replace("lstat", "ensureLink");
        throw err2;
      }
      const dir = path8.dirname(dstpath);
      const dirExists = fs6.existsSync(dir);
      if (dirExists)
        return fs6.linkSync(srcpath, dstpath);
      mkdir.mkdirsSync(dir);
      return fs6.linkSync(srcpath, dstpath);
    }
    module2.exports = {
      createLink: u2(createLink),
      createLinkSync
    };
  }
});

// node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/ensure/symlink-paths.js
var require_symlink_paths = __commonJS({
  "node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/ensure/symlink-paths.js"(exports3, module2) {
    "use strict";
    var path8 = require_path();
    var fs6 = require_graceful_fs();
    var pathExists = require_path_exists().pathExists;
    function symlinkPaths(srcpath, dstpath, callback) {
      if (path8.isAbsolute(srcpath)) {
        return fs6.lstat(srcpath, (err2) => {
          if (err2) {
            err2.message = err2.message.replace("lstat", "ensureSymlink");
            return callback(err2);
          }
          return callback(null, {
            toCwd: srcpath,
            toDst: srcpath
          });
        });
      } else {
        const dstdir = path8.dirname(dstpath);
        const relativeToDst = path8.join(dstdir, srcpath);
        return pathExists(relativeToDst, (err2, exists) => {
          if (err2)
            return callback(err2);
          if (exists) {
            return callback(null, {
              toCwd: relativeToDst,
              toDst: srcpath
            });
          } else {
            return fs6.lstat(srcpath, (err3) => {
              if (err3) {
                err3.message = err3.message.replace("lstat", "ensureSymlink");
                return callback(err3);
              }
              return callback(null, {
                toCwd: srcpath,
                toDst: path8.relative(dstdir, srcpath)
              });
            });
          }
        });
      }
    }
    function symlinkPathsSync(srcpath, dstpath) {
      let exists;
      if (path8.isAbsolute(srcpath)) {
        exists = fs6.existsSync(srcpath);
        if (!exists)
          throw new Error("absolute srcpath does not exist");
        return {
          toCwd: srcpath,
          toDst: srcpath
        };
      } else {
        const dstdir = path8.dirname(dstpath);
        const relativeToDst = path8.join(dstdir, srcpath);
        exists = fs6.existsSync(relativeToDst);
        if (exists) {
          return {
            toCwd: relativeToDst,
            toDst: srcpath
          };
        } else {
          exists = fs6.existsSync(srcpath);
          if (!exists)
            throw new Error("relative srcpath does not exist");
          return {
            toCwd: srcpath,
            toDst: path8.relative(dstdir, srcpath)
          };
        }
      }
    }
    module2.exports = {
      symlinkPaths,
      symlinkPathsSync
    };
  }
});

// node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/ensure/symlink-type.js
var require_symlink_type = __commonJS({
  "node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/ensure/symlink-type.js"(exports3, module2) {
    "use strict";
    var fs6 = require_graceful_fs();
    function symlinkType(srcpath, type, callback) {
      callback = typeof type === "function" ? type : callback;
      type = typeof type === "function" ? false : type;
      if (type)
        return callback(null, type);
      fs6.lstat(srcpath, (err2, stats) => {
        if (err2)
          return callback(null, "file");
        type = stats && stats.isDirectory() ? "dir" : "file";
        callback(null, type);
      });
    }
    function symlinkTypeSync(srcpath, type) {
      let stats;
      if (type)
        return type;
      try {
        stats = fs6.lstatSync(srcpath);
      } catch {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }
    module2.exports = {
      symlinkType,
      symlinkTypeSync
    };
  }
});

// node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/ensure/symlink.js
var require_symlink = __commonJS({
  "node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/ensure/symlink.js"(exports3, module2) {
    "use strict";
    var u2 = require_universalify().fromCallback;
    var path8 = require_path();
    var fs6 = require_fs2();
    var _mkdirs = require_mkdirs();
    var mkdirs = _mkdirs.mkdirs;
    var mkdirsSync = _mkdirs.mkdirsSync;
    var _symlinkPaths = require_symlink_paths();
    var symlinkPaths = _symlinkPaths.symlinkPaths;
    var symlinkPathsSync = _symlinkPaths.symlinkPathsSync;
    var _symlinkType = require_symlink_type();
    var symlinkType = _symlinkType.symlinkType;
    var symlinkTypeSync = _symlinkType.symlinkTypeSync;
    var pathExists = require_path_exists().pathExists;
    var { areIdentical } = require_stat();
    function createSymlink(srcpath, dstpath, type, callback) {
      callback = typeof type === "function" ? type : callback;
      type = typeof type === "function" ? false : type;
      fs6.lstat(dstpath, (err2, stats) => {
        if (!err2 && stats.isSymbolicLink()) {
          Promise.all([
            fs6.stat(srcpath),
            fs6.stat(dstpath)
          ]).then(([srcStat, dstStat]) => {
            if (areIdentical(srcStat, dstStat))
              return callback(null);
            _createSymlink(srcpath, dstpath, type, callback);
          });
        } else
          _createSymlink(srcpath, dstpath, type, callback);
      });
    }
    function _createSymlink(srcpath, dstpath, type, callback) {
      symlinkPaths(srcpath, dstpath, (err2, relative2) => {
        if (err2)
          return callback(err2);
        srcpath = relative2.toDst;
        symlinkType(relative2.toCwd, type, (err3, type2) => {
          if (err3)
            return callback(err3);
          const dir = path8.dirname(dstpath);
          pathExists(dir, (err4, dirExists) => {
            if (err4)
              return callback(err4);
            if (dirExists)
              return fs6.symlink(srcpath, dstpath, type2, callback);
            mkdirs(dir, (err5) => {
              if (err5)
                return callback(err5);
              fs6.symlink(srcpath, dstpath, type2, callback);
            });
          });
        });
      });
    }
    function createSymlinkSync(srcpath, dstpath, type) {
      let stats;
      try {
        stats = fs6.lstatSync(dstpath);
      } catch {
      }
      if (stats && stats.isSymbolicLink()) {
        const srcStat = fs6.statSync(srcpath);
        const dstStat = fs6.statSync(dstpath);
        if (areIdentical(srcStat, dstStat))
          return;
      }
      const relative2 = symlinkPathsSync(srcpath, dstpath);
      srcpath = relative2.toDst;
      type = symlinkTypeSync(relative2.toCwd, type);
      const dir = path8.dirname(dstpath);
      const exists = fs6.existsSync(dir);
      if (exists)
        return fs6.symlinkSync(srcpath, dstpath, type);
      mkdirsSync(dir);
      return fs6.symlinkSync(srcpath, dstpath, type);
    }
    module2.exports = {
      createSymlink: u2(createSymlink),
      createSymlinkSync
    };
  }
});

// node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/ensure/index.js
var require_ensure = __commonJS({
  "node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/ensure/index.js"(exports3, module2) {
    "use strict";
    var { createFile, createFileSync } = require_file();
    var { createLink, createLinkSync } = require_link();
    var { createSymlink, createSymlinkSync } = require_symlink();
    module2.exports = {
      // file
      createFile,
      createFileSync,
      ensureFile: createFile,
      ensureFileSync: createFileSync,
      // link
      createLink,
      createLinkSync,
      ensureLink: createLink,
      ensureLinkSync: createLinkSync,
      // symlink
      createSymlink,
      createSymlinkSync,
      ensureSymlink: createSymlink,
      ensureSymlinkSync: createSymlinkSync
    };
  }
});

// node_modules/.pnpm/jsonfile@6.1.0/node_modules/jsonfile/utils.js
var require_utils2 = __commonJS({
  "node_modules/.pnpm/jsonfile@6.1.0/node_modules/jsonfile/utils.js"(exports3, module2) {
    function stringify5(obj, { EOL = "\n", finalEOL = true, replacer = null, spaces } = {}) {
      const EOF = finalEOL ? EOL : "";
      const str2 = JSON.stringify(obj, replacer, spaces);
      return str2.replace(/\n/g, EOL) + EOF;
    }
    function stripBom2(content) {
      if (Buffer.isBuffer(content))
        content = content.toString("utf8");
      return content.replace(/^\uFEFF/, "");
    }
    module2.exports = { stringify: stringify5, stripBom: stripBom2 };
  }
});

// node_modules/.pnpm/jsonfile@6.1.0/node_modules/jsonfile/index.js
var require_jsonfile = __commonJS({
  "node_modules/.pnpm/jsonfile@6.1.0/node_modules/jsonfile/index.js"(exports3, module2) {
    var _fs;
    try {
      _fs = require_graceful_fs();
    } catch (_) {
      _fs = require_fs();
    }
    var universalify = require_universalify();
    var { stringify: stringify5, stripBom: stripBom2 } = require_utils2();
    async function _readFile(file, options3 = {}) {
      if (typeof options3 === "string") {
        options3 = { encoding: options3 };
      }
      const fs6 = options3.fs || _fs;
      const shouldThrow = "throws" in options3 ? options3.throws : true;
      let data2 = await universalify.fromCallback(fs6.readFile)(file, options3);
      data2 = stripBom2(data2);
      let obj;
      try {
        obj = JSON.parse(data2, options3 ? options3.reviver : null);
      } catch (err2) {
        if (shouldThrow) {
          err2.message = `${file}: ${err2.message}`;
          throw err2;
        } else {
          return null;
        }
      }
      return obj;
    }
    var readFile = universalify.fromPromise(_readFile);
    function readFileSync3(file, options3 = {}) {
      if (typeof options3 === "string") {
        options3 = { encoding: options3 };
      }
      const fs6 = options3.fs || _fs;
      const shouldThrow = "throws" in options3 ? options3.throws : true;
      try {
        let content = fs6.readFileSync(file, options3);
        content = stripBom2(content);
        return JSON.parse(content, options3.reviver);
      } catch (err2) {
        if (shouldThrow) {
          err2.message = `${file}: ${err2.message}`;
          throw err2;
        } else {
          return null;
        }
      }
    }
    async function _writeFile(file, obj, options3 = {}) {
      const fs6 = options3.fs || _fs;
      const str2 = stringify5(obj, options3);
      await universalify.fromCallback(fs6.writeFile)(file, str2, options3);
    }
    var writeFile2 = universalify.fromPromise(_writeFile);
    function writeFileSync(file, obj, options3 = {}) {
      const fs6 = options3.fs || _fs;
      const str2 = stringify5(obj, options3);
      return fs6.writeFileSync(file, str2, options3);
    }
    var jsonfile = {
      readFile,
      readFileSync: readFileSync3,
      writeFile: writeFile2,
      writeFileSync
    };
    module2.exports = jsonfile;
  }
});

// node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/json/jsonfile.js
var require_jsonfile2 = __commonJS({
  "node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/json/jsonfile.js"(exports3, module2) {
    "use strict";
    var jsonFile = require_jsonfile();
    module2.exports = {
      // jsonfile exports
      readJson: jsonFile.readFile,
      readJsonSync: jsonFile.readFileSync,
      writeJson: jsonFile.writeFile,
      writeJsonSync: jsonFile.writeFileSync
    };
  }
});

// node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/output-file/index.js
var require_output_file = __commonJS({
  "node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/output-file/index.js"(exports3, module2) {
    "use strict";
    var u2 = require_universalify().fromCallback;
    var fs6 = require_graceful_fs();
    var path8 = require_path();
    var mkdir = require_mkdirs();
    var pathExists = require_path_exists().pathExists;
    function outputFile(file, data2, encoding, callback) {
      if (typeof encoding === "function") {
        callback = encoding;
        encoding = "utf8";
      }
      const dir = path8.dirname(file);
      pathExists(dir, (err2, itDoes) => {
        if (err2)
          return callback(err2);
        if (itDoes)
          return fs6.writeFile(file, data2, encoding, callback);
        mkdir.mkdirs(dir, (err3) => {
          if (err3)
            return callback(err3);
          fs6.writeFile(file, data2, encoding, callback);
        });
      });
    }
    function outputFileSync(file, ...args) {
      const dir = path8.dirname(file);
      if (fs6.existsSync(dir)) {
        return fs6.writeFileSync(file, ...args);
      }
      mkdir.mkdirsSync(dir);
      fs6.writeFileSync(file, ...args);
    }
    module2.exports = {
      outputFile: u2(outputFile),
      outputFileSync
    };
  }
});

// node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/json/output-json.js
var require_output_json = __commonJS({
  "node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/json/output-json.js"(exports3, module2) {
    "use strict";
    var { stringify: stringify5 } = require_utils2();
    var { outputFile } = require_output_file();
    async function outputJson(file, data2, options3 = {}) {
      const str2 = stringify5(data2, options3);
      await outputFile(file, str2, options3);
    }
    module2.exports = outputJson;
  }
});

// node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/json/output-json-sync.js
var require_output_json_sync = __commonJS({
  "node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/json/output-json-sync.js"(exports3, module2) {
    "use strict";
    var { stringify: stringify5 } = require_utils2();
    var { outputFileSync } = require_output_file();
    function outputJsonSync(file, data2, options3) {
      const str2 = stringify5(data2, options3);
      outputFileSync(file, str2, options3);
    }
    module2.exports = outputJsonSync;
  }
});

// node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/json/index.js
var require_json = __commonJS({
  "node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/json/index.js"(exports3, module2) {
    "use strict";
    var u2 = require_universalify().fromPromise;
    var jsonFile = require_jsonfile2();
    jsonFile.outputJson = u2(require_output_json());
    jsonFile.outputJsonSync = require_output_json_sync();
    jsonFile.outputJSON = jsonFile.outputJson;
    jsonFile.outputJSONSync = jsonFile.outputJsonSync;
    jsonFile.writeJSON = jsonFile.writeJson;
    jsonFile.writeJSONSync = jsonFile.writeJsonSync;
    jsonFile.readJSON = jsonFile.readJson;
    jsonFile.readJSONSync = jsonFile.readJsonSync;
    module2.exports = jsonFile;
  }
});

// node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/move/move.js
var require_move = __commonJS({
  "node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/move/move.js"(exports3, module2) {
    "use strict";
    var fs6 = require_graceful_fs();
    var path8 = require_path();
    var copy = require_copy2().copy;
    var remove = require_remove().remove;
    var mkdirp = require_mkdirs().mkdirp;
    var pathExists = require_path_exists().pathExists;
    var stat2 = require_stat();
    function move(src3, dest, opts, cb) {
      if (typeof opts === "function") {
        cb = opts;
        opts = {};
      }
      opts = opts || {};
      const overwrite = opts.overwrite || opts.clobber || false;
      stat2.checkPaths(src3, dest, "move", opts, (err2, stats) => {
        if (err2)
          return cb(err2);
        const { srcStat, isChangingCase = false } = stats;
        stat2.checkParentPaths(src3, srcStat, dest, "move", (err3) => {
          if (err3)
            return cb(err3);
          if (isParentRoot(dest))
            return doRename(src3, dest, overwrite, isChangingCase, cb);
          mkdirp(path8.dirname(dest), (err4) => {
            if (err4)
              return cb(err4);
            return doRename(src3, dest, overwrite, isChangingCase, cb);
          });
        });
      });
    }
    function isParentRoot(dest) {
      const parent = path8.dirname(dest);
      const parsedPath = path8.parse(parent);
      return parsedPath.root === parent;
    }
    function doRename(src3, dest, overwrite, isChangingCase, cb) {
      if (isChangingCase)
        return rename(src3, dest, overwrite, cb);
      if (overwrite) {
        return remove(dest, (err2) => {
          if (err2)
            return cb(err2);
          return rename(src3, dest, overwrite, cb);
        });
      }
      pathExists(dest, (err2, destExists) => {
        if (err2)
          return cb(err2);
        if (destExists)
          return cb(new Error("dest already exists."));
        return rename(src3, dest, overwrite, cb);
      });
    }
    function rename(src3, dest, overwrite, cb) {
      fs6.rename(src3, dest, (err2) => {
        if (!err2)
          return cb();
        if (err2.code !== "EXDEV")
          return cb(err2);
        return moveAcrossDevice(src3, dest, overwrite, cb);
      });
    }
    function moveAcrossDevice(src3, dest, overwrite, cb) {
      const opts = {
        overwrite,
        errorOnExist: true,
        preserveTimestamps: true
      };
      copy(src3, dest, opts, (err2) => {
        if (err2)
          return cb(err2);
        return remove(src3, cb);
      });
    }
    module2.exports = move;
  }
});

// node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/move/move-sync.js
var require_move_sync = __commonJS({
  "node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/move/move-sync.js"(exports3, module2) {
    "use strict";
    var fs6 = require_graceful_fs();
    var path8 = require_path();
    var copySync = require_copy2().copySync;
    var removeSync = require_remove().removeSync;
    var mkdirpSync = require_mkdirs().mkdirpSync;
    var stat2 = require_stat();
    function moveSync(src3, dest, opts) {
      opts = opts || {};
      const overwrite = opts.overwrite || opts.clobber || false;
      const { srcStat, isChangingCase = false } = stat2.checkPathsSync(src3, dest, "move", opts);
      stat2.checkParentPathsSync(src3, srcStat, dest, "move");
      if (!isParentRoot(dest))
        mkdirpSync(path8.dirname(dest));
      return doRename(src3, dest, overwrite, isChangingCase);
    }
    function isParentRoot(dest) {
      const parent = path8.dirname(dest);
      const parsedPath = path8.parse(parent);
      return parsedPath.root === parent;
    }
    function doRename(src3, dest, overwrite, isChangingCase) {
      if (isChangingCase)
        return rename(src3, dest, overwrite);
      if (overwrite) {
        removeSync(dest);
        return rename(src3, dest, overwrite);
      }
      if (fs6.existsSync(dest))
        throw new Error("dest already exists.");
      return rename(src3, dest, overwrite);
    }
    function rename(src3, dest, overwrite) {
      try {
        fs6.renameSync(src3, dest);
      } catch (err2) {
        if (err2.code !== "EXDEV")
          throw err2;
        return moveAcrossDevice(src3, dest, overwrite);
      }
    }
    function moveAcrossDevice(src3, dest, overwrite) {
      const opts = {
        overwrite,
        errorOnExist: true,
        preserveTimestamps: true
      };
      copySync(src3, dest, opts);
      return removeSync(src3);
    }
    module2.exports = moveSync;
  }
});

// node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/move/index.js
var require_move2 = __commonJS({
  "node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/move/index.js"(exports3, module2) {
    "use strict";
    var u2 = require_universalify().fromCallback;
    module2.exports = {
      move: u2(require_move()),
      moveSync: require_move_sync()
    };
  }
});

// node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/index.js
var require_lib = __commonJS({
  "node_modules/.pnpm/fs-extra@11.1.1/node_modules/fs-extra/lib/index.js"(exports3, module2) {
    "use strict";
    module2.exports = {
      // Export promiseified graceful-fs:
      ...require_fs2(),
      // Export extra methods:
      ...require_copy2(),
      ...require_empty(),
      ...require_ensure(),
      ...require_json(),
      ...require_mkdirs(),
      ...require_move2(),
      ...require_output_file(),
      ...require_path_exists(),
      ...require_remove()
    };
  }
});

// browser-external:node:fs
var require_node_fs = __commonJS({
  "browser-external:node:fs"(exports3, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:fs" has been externalized for browser compatibility. Cannot access "node:fs.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/.pnpm/merge2@1.4.1/node_modules/merge2/index.js
var require_merge2 = __commonJS({
  "node_modules/.pnpm/merge2@1.4.1/node_modules/merge2/index.js"(exports3, module2) {
    "use strict";
    var Stream2 = require_stream();
    var PassThrough2 = Stream2.PassThrough;
    var slice2 = Array.prototype.slice;
    module2.exports = merge23;
    function merge23() {
      const streamsQueue = [];
      const args = slice2.call(arguments);
      let merging = false;
      let options3 = args[args.length - 1];
      if (options3 && !Array.isArray(options3) && options3.pipe == null) {
        args.pop();
      } else {
        options3 = {};
      }
      const doEnd = options3.end !== false;
      const doPipeError = options3.pipeError === true;
      if (options3.objectMode == null) {
        options3.objectMode = true;
      }
      if (options3.highWaterMark == null) {
        options3.highWaterMark = 64 * 1024;
      }
      const mergedStream = PassThrough2(options3);
      function addStream() {
        for (let i2 = 0, len = arguments.length; i2 < len; i2++) {
          streamsQueue.push(pauseStreams2(arguments[i2], options3));
        }
        mergeStream();
        return this;
      }
      function mergeStream() {
        if (merging) {
          return;
        }
        merging = true;
        let streams = streamsQueue.shift();
        if (!streams) {
          process.nextTick(endStream);
          return;
        }
        if (!Array.isArray(streams)) {
          streams = [streams];
        }
        let pipesCount = streams.length + 1;
        function next() {
          if (--pipesCount > 0) {
            return;
          }
          merging = false;
          mergeStream();
        }
        function pipe(stream4) {
          function onend() {
            stream4.removeListener("merge2UnpipeEnd", onend);
            stream4.removeListener("end", onend);
            if (doPipeError) {
              stream4.removeListener("error", onerror);
            }
            next();
          }
          function onerror(err2) {
            mergedStream.emit("error", err2);
          }
          if (stream4._readableState.endEmitted) {
            return next();
          }
          stream4.on("merge2UnpipeEnd", onend);
          stream4.on("end", onend);
          if (doPipeError) {
            stream4.on("error", onerror);
          }
          stream4.pipe(mergedStream, { end: false });
          stream4.resume();
        }
        for (let i2 = 0; i2 < streams.length; i2++) {
          pipe(streams[i2]);
        }
        next();
      }
      function endStream() {
        merging = false;
        mergedStream.emit("queueDrain");
        if (doEnd) {
          mergedStream.end();
        }
      }
      mergedStream.setMaxListeners(0);
      mergedStream.add = addStream;
      mergedStream.on("unpipe", function(stream4) {
        stream4.emit("merge2UnpipeEnd");
      });
      if (args.length) {
        addStream.apply(null, args);
      }
      return mergedStream;
    }
    function pauseStreams2(streams, options3) {
      if (!Array.isArray(streams)) {
        if (!streams._readableState && streams.pipe) {
          streams = streams.pipe(PassThrough2(options3));
        }
        if (!streams._readableState || !streams.pause || !streams.pipe) {
          throw new Error("Only readable stream can be merged.");
        }
        streams.pause();
      } else {
        for (let i2 = 0, len = streams.length; i2 < len; i2++) {
          streams[i2] = pauseStreams2(streams[i2], options3);
        }
      }
      return streams;
    }
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/array.js
var require_array = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/array.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    exports3.splitWhen = exports3.flatten = void 0;
    function flatten2(items) {
      return items.reduce((collection, item) => [].concat(collection, item), []);
    }
    exports3.flatten = flatten2;
    function splitWhen2(items, predicate) {
      const result = [[]];
      let groupIndex = 0;
      for (const item of items) {
        if (predicate(item)) {
          groupIndex++;
          result[groupIndex] = [];
        } else {
          result[groupIndex].push(item);
        }
      }
      return result;
    }
    exports3.splitWhen = splitWhen2;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/errno.js
var require_errno = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/errno.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    exports3.isEnoentCodeError = void 0;
    function isEnoentCodeError2(error3) {
      return error3.code === "ENOENT";
    }
    exports3.isEnoentCodeError = isEnoentCodeError2;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/fs.js
var require_fs3 = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/fs.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    exports3.createDirentFromStats = void 0;
    var DirentFromStats3 = class {
      constructor(name2, stats) {
        this.name = name2;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats2(name2, stats) {
      return new DirentFromStats3(name2, stats);
    }
    exports3.createDirentFromStats = createDirentFromStats2;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/path.js
var require_path2 = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/path.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    exports3.removeLeadingDotSegment = exports3.escape = exports3.makeAbsolute = exports3.unixify = void 0;
    var path8 = require_path();
    var LEADING_DOT_SEGMENT_CHARACTERS_COUNT2 = 2;
    var UNESCAPED_GLOB_SYMBOLS_RE2 = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\())/g;
    function unixify2(filepath) {
      return filepath.replace(/\\/g, "/");
    }
    exports3.unixify = unixify2;
    function makeAbsolute2(cwd, filepath) {
      return path8.resolve(cwd, filepath);
    }
    exports3.makeAbsolute = makeAbsolute2;
    function escape2(pattern2) {
      return pattern2.replace(UNESCAPED_GLOB_SYMBOLS_RE2, "\\$2");
    }
    exports3.escape = escape2;
    function removeLeadingDotSegment2(entry2) {
      if (entry2.charAt(0) === ".") {
        const secondCharactery = entry2.charAt(1);
        if (secondCharactery === "/" || secondCharactery === "\\") {
          return entry2.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT2);
        }
      }
      return entry2;
    }
    exports3.removeLeadingDotSegment = removeLeadingDotSegment2;
  }
});

// node_modules/.pnpm/is-extglob@2.1.1/node_modules/is-extglob/index.js
var require_is_extglob = __commonJS({
  "node_modules/.pnpm/is-extglob@2.1.1/node_modules/is-extglob/index.js"(exports3, module2) {
    module2.exports = function isExtglob3(str2) {
      if (typeof str2 !== "string" || str2 === "") {
        return false;
      }
      var match;
      while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str2)) {
        if (match[2])
          return true;
        str2 = str2.slice(match.index + match[0].length);
      }
      return false;
    };
  }
});

// node_modules/.pnpm/is-glob@4.0.3/node_modules/is-glob/index.js
var require_is_glob = __commonJS({
  "node_modules/.pnpm/is-glob@4.0.3/node_modules/is-glob/index.js"(exports3, module2) {
    var isExtglob3 = require_is_extglob();
    var chars3 = { "{": "}", "(": ")", "[": "]" };
    var strictCheck2 = function(str2) {
      if (str2[0] === "!") {
        return true;
      }
      var index2 = 0;
      var pipeIndex = -2;
      var closeSquareIndex = -2;
      var closeCurlyIndex = -2;
      var closeParenIndex = -2;
      var backSlashIndex = -2;
      while (index2 < str2.length) {
        if (str2[index2] === "*") {
          return true;
        }
        if (str2[index2 + 1] === "?" && /[\].+)]/.test(str2[index2])) {
          return true;
        }
        if (closeSquareIndex !== -1 && str2[index2] === "[" && str2[index2 + 1] !== "]") {
          if (closeSquareIndex < index2) {
            closeSquareIndex = str2.indexOf("]", index2);
          }
          if (closeSquareIndex > index2) {
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
            backSlashIndex = str2.indexOf("\\", index2);
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
          }
        }
        if (closeCurlyIndex !== -1 && str2[index2] === "{" && str2[index2 + 1] !== "}") {
          closeCurlyIndex = str2.indexOf("}", index2);
          if (closeCurlyIndex > index2) {
            backSlashIndex = str2.indexOf("\\", index2);
            if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
              return true;
            }
          }
        }
        if (closeParenIndex !== -1 && str2[index2] === "(" && str2[index2 + 1] === "?" && /[:!=]/.test(str2[index2 + 2]) && str2[index2 + 3] !== ")") {
          closeParenIndex = str2.indexOf(")", index2);
          if (closeParenIndex > index2) {
            backSlashIndex = str2.indexOf("\\", index2);
            if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
              return true;
            }
          }
        }
        if (pipeIndex !== -1 && str2[index2] === "(" && str2[index2 + 1] !== "|") {
          if (pipeIndex < index2) {
            pipeIndex = str2.indexOf("|", index2);
          }
          if (pipeIndex !== -1 && str2[pipeIndex + 1] !== ")") {
            closeParenIndex = str2.indexOf(")", pipeIndex);
            if (closeParenIndex > pipeIndex) {
              backSlashIndex = str2.indexOf("\\", pipeIndex);
              if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
                return true;
              }
            }
          }
        }
        if (str2[index2] === "\\") {
          var open2 = str2[index2 + 1];
          index2 += 2;
          var close2 = chars3[open2];
          if (close2) {
            var n3 = str2.indexOf(close2, index2);
            if (n3 !== -1) {
              index2 = n3 + 1;
            }
          }
          if (str2[index2] === "!") {
            return true;
          }
        } else {
          index2++;
        }
      }
      return false;
    };
    var relaxedCheck2 = function(str2) {
      if (str2[0] === "!") {
        return true;
      }
      var index2 = 0;
      while (index2 < str2.length) {
        if (/[*?{}()[\]]/.test(str2[index2])) {
          return true;
        }
        if (str2[index2] === "\\") {
          var open2 = str2[index2 + 1];
          index2 += 2;
          var close2 = chars3[open2];
          if (close2) {
            var n3 = str2.indexOf(close2, index2);
            if (n3 !== -1) {
              index2 = n3 + 1;
            }
          }
          if (str2[index2] === "!") {
            return true;
          }
        } else {
          index2++;
        }
      }
      return false;
    };
    module2.exports = function isGlob3(str2, options3) {
      if (typeof str2 !== "string" || str2 === "") {
        return false;
      }
      if (isExtglob3(str2)) {
        return true;
      }
      var check = strictCheck2;
      if (options3 && options3.strict === false) {
        check = relaxedCheck2;
      }
      return check(str2);
    };
  }
});

// node_modules/.pnpm/glob-parent@5.1.2/node_modules/glob-parent/index.js
var require_glob_parent = __commonJS({
  "node_modules/.pnpm/glob-parent@5.1.2/node_modules/glob-parent/index.js"(exports3, module2) {
    "use strict";
    var isGlob3 = require_is_glob();
    var pathPosixDirname2 = require_path().posix.dirname;
    var isWin322 = require_os().platform() === "win32";
    var slash4 = "/";
    var backslash2 = /\\/g;
    var enclosure2 = /[\{\[].*[\}\]]$/;
    var globby3 = /(^|[^\\])([\{\[]|\([^\)]+$)/;
    var escaped2 = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
    module2.exports = function globParent3(str2, opts) {
      var options3 = Object.assign({ flipBackslashes: true }, opts);
      if (options3.flipBackslashes && isWin322 && str2.indexOf(slash4) < 0) {
        str2 = str2.replace(backslash2, slash4);
      }
      if (enclosure2.test(str2)) {
        str2 += slash4;
      }
      str2 += "a";
      do {
        str2 = pathPosixDirname2(str2);
      } while (isGlob3(str2) || globby3.test(str2));
      return str2.replace(escaped2, "$1");
    };
  }
});

// node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/utils.js
var require_utils3 = __commonJS({
  "node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/utils.js"(exports3) {
    "use strict";
    exports3.isInteger = (num) => {
      if (typeof num === "number") {
        return Number.isInteger(num);
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isInteger(Number(num));
      }
      return false;
    };
    exports3.find = (node3, type) => node3.nodes.find((node4) => node4.type === type);
    exports3.exceedsLimit = (min2, max, step = 1, limit) => {
      if (limit === false)
        return false;
      if (!exports3.isInteger(min2) || !exports3.isInteger(max))
        return false;
      return (Number(max) - Number(min2)) / Number(step) >= limit;
    };
    exports3.escapeNode = (block, n3 = 0, type) => {
      let node3 = block.nodes[n3];
      if (!node3)
        return;
      if (type && node3.type === type || node3.type === "open" || node3.type === "close") {
        if (node3.escaped !== true) {
          node3.value = "\\" + node3.value;
          node3.escaped = true;
        }
      }
    };
    exports3.encloseBrace = (node3) => {
      if (node3.type !== "brace")
        return false;
      if (node3.commas >> 0 + node3.ranges >> 0 === 0) {
        node3.invalid = true;
        return true;
      }
      return false;
    };
    exports3.isInvalidBrace = (block) => {
      if (block.type !== "brace")
        return false;
      if (block.invalid === true || block.dollar)
        return true;
      if (block.commas >> 0 + block.ranges >> 0 === 0) {
        block.invalid = true;
        return true;
      }
      if (block.open !== true || block.close !== true) {
        block.invalid = true;
        return true;
      }
      return false;
    };
    exports3.isOpenOrClose = (node3) => {
      if (node3.type === "open" || node3.type === "close") {
        return true;
      }
      return node3.open === true || node3.close === true;
    };
    exports3.reduce = (nodes) => nodes.reduce((acc, node3) => {
      if (node3.type === "text")
        acc.push(node3.value);
      if (node3.type === "range")
        node3.type = "text";
      return acc;
    }, []);
    exports3.flatten = (...args) => {
      const result = [];
      const flat = (arr) => {
        for (let i2 = 0; i2 < arr.length; i2++) {
          let ele = arr[i2];
          Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
        }
        return result;
      };
      flat(args);
      return result;
    };
  }
});

// node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/stringify.js"(exports3, module2) {
    "use strict";
    var utils2 = require_utils3();
    module2.exports = (ast, options3 = {}) => {
      let stringify5 = (node3, parent = {}) => {
        let invalidBlock = options3.escapeInvalid && utils2.isInvalidBrace(parent);
        let invalidNode = node3.invalid === true && options3.escapeInvalid === true;
        let output = "";
        if (node3.value) {
          if ((invalidBlock || invalidNode) && utils2.isOpenOrClose(node3)) {
            return "\\" + node3.value;
          }
          return node3.value;
        }
        if (node3.value) {
          return node3.value;
        }
        if (node3.nodes) {
          for (let child of node3.nodes) {
            output += stringify5(child);
          }
        }
        return output;
      };
      return stringify5(ast);
    };
  }
});

// node_modules/.pnpm/is-number@7.0.0/node_modules/is-number/index.js
var require_is_number = __commonJS({
  "node_modules/.pnpm/is-number@7.0.0/node_modules/is-number/index.js"(exports3, module2) {
    "use strict";
    module2.exports = function(num) {
      if (typeof num === "number") {
        return num - num === 0;
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
      }
      return false;
    };
  }
});

// node_modules/.pnpm/to-regex-range@5.0.1/node_modules/to-regex-range/index.js
var require_to_regex_range = __commonJS({
  "node_modules/.pnpm/to-regex-range@5.0.1/node_modules/to-regex-range/index.js"(exports3, module2) {
    "use strict";
    var isNumber2 = require_is_number();
    var toRegexRange2 = (min2, max, options3) => {
      if (isNumber2(min2) === false) {
        throw new TypeError("toRegexRange: expected the first argument to be a number");
      }
      if (max === void 0 || min2 === max) {
        return String(min2);
      }
      if (isNumber2(max) === false) {
        throw new TypeError("toRegexRange: expected the second argument to be a number.");
      }
      let opts = { relaxZeros: true, ...options3 };
      if (typeof opts.strictZeros === "boolean") {
        opts.relaxZeros = opts.strictZeros === false;
      }
      let relax = String(opts.relaxZeros);
      let shorthand = String(opts.shorthand);
      let capture = String(opts.capture);
      let wrap3 = String(opts.wrap);
      let cacheKey = min2 + ":" + max + "=" + relax + shorthand + capture + wrap3;
      if (toRegexRange2.cache.hasOwnProperty(cacheKey)) {
        return toRegexRange2.cache[cacheKey].result;
      }
      let a2 = Math.min(min2, max);
      let b = Math.max(min2, max);
      if (Math.abs(a2 - b) === 1) {
        let result = min2 + "|" + max;
        if (opts.capture) {
          return `(${result})`;
        }
        if (opts.wrap === false) {
          return result;
        }
        return `(?:${result})`;
      }
      let isPadded2 = hasPadding2(min2) || hasPadding2(max);
      let state = { min: min2, max, a: a2, b };
      let positives = [];
      let negatives = [];
      if (isPadded2) {
        state.isPadded = isPadded2;
        state.maxLen = String(state.max).length;
      }
      if (a2 < 0) {
        let newMin = b < 0 ? Math.abs(b) : 1;
        negatives = splitToPatterns2(newMin, Math.abs(a2), state, opts);
        a2 = state.a = 0;
      }
      if (b >= 0) {
        positives = splitToPatterns2(a2, b, state, opts);
      }
      state.negatives = negatives;
      state.positives = positives;
      state.result = collatePatterns2(negatives, positives, opts);
      if (opts.capture === true) {
        state.result = `(${state.result})`;
      } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
        state.result = `(?:${state.result})`;
      }
      toRegexRange2.cache[cacheKey] = state;
      return state.result;
    };
    function collatePatterns2(neg, pos, options3) {
      let onlyNegative = filterPatterns2(neg, pos, "-", false, options3) || [];
      let onlyPositive = filterPatterns2(pos, neg, "", false, options3) || [];
      let intersected = filterPatterns2(neg, pos, "-?", true, options3) || [];
      let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
      return subpatterns.join("|");
    }
    function splitToRanges2(min2, max) {
      let nines = 1;
      let zeros2 = 1;
      let stop = countNines2(min2, nines);
      let stops = /* @__PURE__ */ new Set([max]);
      while (min2 <= stop && stop <= max) {
        stops.add(stop);
        nines += 1;
        stop = countNines2(min2, nines);
      }
      stop = countZeros2(max + 1, zeros2) - 1;
      while (min2 < stop && stop <= max) {
        stops.add(stop);
        zeros2 += 1;
        stop = countZeros2(max + 1, zeros2) - 1;
      }
      stops = [...stops];
      stops.sort(compare2);
      return stops;
    }
    function rangeToPattern2(start, stop, options3) {
      if (start === stop) {
        return { pattern: start, count: [], digits: 0 };
      }
      let zipped = zip2(start, stop);
      let digits = zipped.length;
      let pattern2 = "";
      let count = 0;
      for (let i2 = 0; i2 < digits; i2++) {
        let [startDigit, stopDigit] = zipped[i2];
        if (startDigit === stopDigit) {
          pattern2 += startDigit;
        } else if (startDigit !== "0" || stopDigit !== "9") {
          pattern2 += toCharacterClass2(startDigit, stopDigit, options3);
        } else {
          count++;
        }
      }
      if (count) {
        pattern2 += options3.shorthand === true ? "\\d" : "[0-9]";
      }
      return { pattern: pattern2, count: [count], digits };
    }
    function splitToPatterns2(min2, max, tok, options3) {
      let ranges = splitToRanges2(min2, max);
      let tokens = [];
      let start = min2;
      let prev;
      for (let i2 = 0; i2 < ranges.length; i2++) {
        let max2 = ranges[i2];
        let obj = rangeToPattern2(String(start), String(max2), options3);
        let zeros2 = "";
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
          if (prev.count.length > 1) {
            prev.count.pop();
          }
          prev.count.push(obj.count[0]);
          prev.string = prev.pattern + toQuantifier2(prev.count);
          start = max2 + 1;
          continue;
        }
        if (tok.isPadded) {
          zeros2 = padZeros2(max2, tok, options3);
        }
        obj.string = zeros2 + obj.pattern + toQuantifier2(obj.count);
        tokens.push(obj);
        start = max2 + 1;
        prev = obj;
      }
      return tokens;
    }
    function filterPatterns2(arr, comparison, prefix, intersection, options3) {
      let result = [];
      for (let ele of arr) {
        let { string: string3 } = ele;
        if (!intersection && !contains2(comparison, "string", string3)) {
          result.push(prefix + string3);
        }
        if (intersection && contains2(comparison, "string", string3)) {
          result.push(prefix + string3);
        }
      }
      return result;
    }
    function zip2(a2, b) {
      let arr = [];
      for (let i2 = 0; i2 < a2.length; i2++)
        arr.push([a2[i2], b[i2]]);
      return arr;
    }
    function compare2(a2, b) {
      return a2 > b ? 1 : b > a2 ? -1 : 0;
    }
    function contains2(arr, key, val) {
      return arr.some((ele) => ele[key] === val);
    }
    function countNines2(min2, len) {
      return Number(String(min2).slice(0, -len) + "9".repeat(len));
    }
    function countZeros2(integer, zeros2) {
      return integer - integer % Math.pow(10, zeros2);
    }
    function toQuantifier2(digits) {
      let [start = 0, stop = ""] = digits;
      if (stop || start > 1) {
        return `{${start + (stop ? "," + stop : "")}}`;
      }
      return "";
    }
    function toCharacterClass2(a2, b, options3) {
      return `[${a2}${b - a2 === 1 ? "" : "-"}${b}]`;
    }
    function hasPadding2(str2) {
      return /^-?(0+)\d/.test(str2);
    }
    function padZeros2(value2, tok, options3) {
      if (!tok.isPadded) {
        return value2;
      }
      let diff = Math.abs(tok.maxLen - String(value2).length);
      let relax = options3.relaxZeros !== false;
      switch (diff) {
        case 0:
          return "";
        case 1:
          return relax ? "0?" : "0";
        case 2:
          return relax ? "0{0,2}" : "00";
        default: {
          return relax ? `0{0,${diff}}` : `0{${diff}}`;
        }
      }
    }
    toRegexRange2.cache = {};
    toRegexRange2.clearCache = () => toRegexRange2.cache = {};
    module2.exports = toRegexRange2;
  }
});

// node_modules/.pnpm/fill-range@7.0.1/node_modules/fill-range/index.js
var require_fill_range = __commonJS({
  "node_modules/.pnpm/fill-range@7.0.1/node_modules/fill-range/index.js"(exports3, module2) {
    "use strict";
    var util2 = require_util();
    var toRegexRange2 = require_to_regex_range();
    var isObject2 = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    var transform2 = (toNumber) => {
      return (value2) => toNumber === true ? Number(value2) : String(value2);
    };
    var isValidValue2 = (value2) => {
      return typeof value2 === "number" || typeof value2 === "string" && value2 !== "";
    };
    var isNumber2 = (num) => Number.isInteger(+num);
    var zeros2 = (input) => {
      let value2 = `${input}`;
      let index2 = -1;
      if (value2[0] === "-")
        value2 = value2.slice(1);
      if (value2 === "0")
        return false;
      while (value2[++index2] === "0")
        ;
      return index2 > 0;
    };
    var stringify5 = (start, end, options3) => {
      if (typeof start === "string" || typeof end === "string") {
        return true;
      }
      return options3.stringify === true;
    };
    var pad2 = (input, maxLength, toNumber) => {
      if (maxLength > 0) {
        let dash = input[0] === "-" ? "-" : "";
        if (dash)
          input = input.slice(1);
        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
      }
      if (toNumber === false) {
        return String(input);
      }
      return input;
    };
    var toMaxLen2 = (input, maxLength) => {
      let negative = input[0] === "-" ? "-" : "";
      if (negative) {
        input = input.slice(1);
        maxLength--;
      }
      while (input.length < maxLength)
        input = "0" + input;
      return negative ? "-" + input : input;
    };
    var toSequence2 = (parts, options3) => {
      parts.negatives.sort((a2, b) => a2 < b ? -1 : a2 > b ? 1 : 0);
      parts.positives.sort((a2, b) => a2 < b ? -1 : a2 > b ? 1 : 0);
      let prefix = options3.capture ? "" : "?:";
      let positives = "";
      let negatives = "";
      let result;
      if (parts.positives.length) {
        positives = parts.positives.join("|");
      }
      if (parts.negatives.length) {
        negatives = `-(${prefix}${parts.negatives.join("|")})`;
      }
      if (positives && negatives) {
        result = `${positives}|${negatives}`;
      } else {
        result = positives || negatives;
      }
      if (options3.wrap) {
        return `(${prefix}${result})`;
      }
      return result;
    };
    var toRange2 = (a2, b, isNumbers, options3) => {
      if (isNumbers) {
        return toRegexRange2(a2, b, { wrap: false, ...options3 });
      }
      let start = String.fromCharCode(a2);
      if (a2 === b)
        return start;
      let stop = String.fromCharCode(b);
      return `[${start}-${stop}]`;
    };
    var toRegex2 = (start, end, options3) => {
      if (Array.isArray(start)) {
        let wrap3 = options3.wrap === true;
        let prefix = options3.capture ? "" : "?:";
        return wrap3 ? `(${prefix}${start.join("|")})` : start.join("|");
      }
      return toRegexRange2(start, end, options3);
    };
    var rangeError2 = (...args) => {
      return new RangeError("Invalid range arguments: " + util2.inspect(...args));
    };
    var invalidRange2 = (start, end, options3) => {
      if (options3.strictRanges === true)
        throw rangeError2([start, end]);
      return [];
    };
    var invalidStep2 = (step, options3) => {
      if (options3.strictRanges === true) {
        throw new TypeError(`Expected step "${step}" to be a number`);
      }
      return [];
    };
    var fillNumbers2 = (start, end, step = 1, options3 = {}) => {
      let a2 = Number(start);
      let b = Number(end);
      if (!Number.isInteger(a2) || !Number.isInteger(b)) {
        if (options3.strictRanges === true)
          throw rangeError2([start, end]);
        return [];
      }
      if (a2 === 0)
        a2 = 0;
      if (b === 0)
        b = 0;
      let descending = a2 > b;
      let startString = String(start);
      let endString = String(end);
      let stepString = String(step);
      step = Math.max(Math.abs(step), 1);
      let padded = zeros2(startString) || zeros2(endString) || zeros2(stepString);
      let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
      let toNumber = padded === false && stringify5(start, end, options3) === false;
      let format2 = options3.transform || transform2(toNumber);
      if (options3.toRegex && step === 1) {
        return toRange2(toMaxLen2(start, maxLen), toMaxLen2(end, maxLen), true, options3);
      }
      let parts = { negatives: [], positives: [] };
      let push2 = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
      let range2 = [];
      let index2 = 0;
      while (descending ? a2 >= b : a2 <= b) {
        if (options3.toRegex === true && step > 1) {
          push2(a2);
        } else {
          range2.push(pad2(format2(a2, index2), maxLen, toNumber));
        }
        a2 = descending ? a2 - step : a2 + step;
        index2++;
      }
      if (options3.toRegex === true) {
        return step > 1 ? toSequence2(parts, options3) : toRegex2(range2, null, { wrap: false, ...options3 });
      }
      return range2;
    };
    var fillLetters2 = (start, end, step = 1, options3 = {}) => {
      if (!isNumber2(start) && start.length > 1 || !isNumber2(end) && end.length > 1) {
        return invalidRange2(start, end, options3);
      }
      let format2 = options3.transform || ((val) => String.fromCharCode(val));
      let a2 = `${start}`.charCodeAt(0);
      let b = `${end}`.charCodeAt(0);
      let descending = a2 > b;
      let min2 = Math.min(a2, b);
      let max = Math.max(a2, b);
      if (options3.toRegex && step === 1) {
        return toRange2(min2, max, false, options3);
      }
      let range2 = [];
      let index2 = 0;
      while (descending ? a2 >= b : a2 <= b) {
        range2.push(format2(a2, index2));
        a2 = descending ? a2 - step : a2 + step;
        index2++;
      }
      if (options3.toRegex === true) {
        return toRegex2(range2, null, { wrap: false, options: options3 });
      }
      return range2;
    };
    var fill2 = (start, end, step, options3 = {}) => {
      if (end == null && isValidValue2(start)) {
        return [start];
      }
      if (!isValidValue2(start) || !isValidValue2(end)) {
        return invalidRange2(start, end, options3);
      }
      if (typeof step === "function") {
        return fill2(start, end, 1, { transform: step });
      }
      if (isObject2(step)) {
        return fill2(start, end, 0, step);
      }
      let opts = { ...options3 };
      if (opts.capture === true)
        opts.wrap = true;
      step = step || opts.step || 1;
      if (!isNumber2(step)) {
        if (step != null && !isObject2(step))
          return invalidStep2(step, opts);
        return fill2(start, end, 1, step);
      }
      if (isNumber2(start) && isNumber2(end)) {
        return fillNumbers2(start, end, step, opts);
      }
      return fillLetters2(start, end, Math.max(Math.abs(step), 1), opts);
    };
    module2.exports = fill2;
  }
});

// node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/compile.js
var require_compile = __commonJS({
  "node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/compile.js"(exports3, module2) {
    "use strict";
    var fill2 = require_fill_range();
    var utils2 = require_utils3();
    var compile3 = (ast, options3 = {}) => {
      let walk2 = (node3, parent = {}) => {
        let invalidBlock = utils2.isInvalidBrace(parent);
        let invalidNode = node3.invalid === true && options3.escapeInvalid === true;
        let invalid = invalidBlock === true || invalidNode === true;
        let prefix = options3.escapeInvalid === true ? "\\" : "";
        let output = "";
        if (node3.isOpen === true) {
          return prefix + node3.value;
        }
        if (node3.isClose === true) {
          return prefix + node3.value;
        }
        if (node3.type === "open") {
          return invalid ? prefix + node3.value : "(";
        }
        if (node3.type === "close") {
          return invalid ? prefix + node3.value : ")";
        }
        if (node3.type === "comma") {
          return node3.prev.type === "comma" ? "" : invalid ? node3.value : "|";
        }
        if (node3.value) {
          return node3.value;
        }
        if (node3.nodes && node3.ranges > 0) {
          let args = utils2.reduce(node3.nodes);
          let range2 = fill2(...args, { ...options3, wrap: false, toRegex: true });
          if (range2.length !== 0) {
            return args.length > 1 && range2.length > 1 ? `(${range2})` : range2;
          }
        }
        if (node3.nodes) {
          for (let child of node3.nodes) {
            output += walk2(child, node3);
          }
        }
        return output;
      };
      return walk2(ast);
    };
    module2.exports = compile3;
  }
});

// node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/expand.js
var require_expand = __commonJS({
  "node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/expand.js"(exports3, module2) {
    "use strict";
    var fill2 = require_fill_range();
    var stringify5 = require_stringify();
    var utils2 = require_utils3();
    var append2 = (queue2 = "", stash = "", enclose = false) => {
      let result = [];
      queue2 = [].concat(queue2);
      stash = [].concat(stash);
      if (!stash.length)
        return queue2;
      if (!queue2.length) {
        return enclose ? utils2.flatten(stash).map((ele) => `{${ele}}`) : stash;
      }
      for (let item of queue2) {
        if (Array.isArray(item)) {
          for (let value2 of item) {
            result.push(append2(value2, stash, enclose));
          }
        } else {
          for (let ele of stash) {
            if (enclose === true && typeof ele === "string")
              ele = `{${ele}}`;
            result.push(Array.isArray(ele) ? append2(item, ele, enclose) : item + ele);
          }
        }
      }
      return utils2.flatten(result);
    };
    var expand2 = (ast, options3 = {}) => {
      let rangeLimit = options3.rangeLimit === void 0 ? 1e3 : options3.rangeLimit;
      let walk2 = (node3, parent = {}) => {
        node3.queue = [];
        let p2 = parent;
        let q = parent.queue;
        while (p2.type !== "brace" && p2.type !== "root" && p2.parent) {
          p2 = p2.parent;
          q = p2.queue;
        }
        if (node3.invalid || node3.dollar) {
          q.push(append2(q.pop(), stringify5(node3, options3)));
          return;
        }
        if (node3.type === "brace" && node3.invalid !== true && node3.nodes.length === 2) {
          q.push(append2(q.pop(), ["{}"]));
          return;
        }
        if (node3.nodes && node3.ranges > 0) {
          let args = utils2.reduce(node3.nodes);
          if (utils2.exceedsLimit(...args, options3.step, rangeLimit)) {
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          }
          let range2 = fill2(...args, options3);
          if (range2.length === 0) {
            range2 = stringify5(node3, options3);
          }
          q.push(append2(q.pop(), range2));
          node3.nodes = [];
          return;
        }
        let enclose = utils2.encloseBrace(node3);
        let queue2 = node3.queue;
        let block = node3;
        while (block.type !== "brace" && block.type !== "root" && block.parent) {
          block = block.parent;
          queue2 = block.queue;
        }
        for (let i2 = 0; i2 < node3.nodes.length; i2++) {
          let child = node3.nodes[i2];
          if (child.type === "comma" && node3.type === "brace") {
            if (i2 === 1)
              queue2.push("");
            queue2.push("");
            continue;
          }
          if (child.type === "close") {
            q.push(append2(q.pop(), queue2, enclose));
            continue;
          }
          if (child.value && child.type !== "open") {
            queue2.push(append2(queue2.pop(), child.value));
            continue;
          }
          if (child.nodes) {
            walk2(child, node3);
          }
        }
        return queue2;
      };
      return utils2.flatten(walk2(ast));
    };
    module2.exports = expand2;
  }
});

// node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/constants.js"(exports3, module2) {
    "use strict";
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      // Digits
      CHAR_0: "0",
      /* 0 */
      CHAR_9: "9",
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: "A",
      /* A */
      CHAR_LOWERCASE_A: "a",
      /* a */
      CHAR_UPPERCASE_Z: "Z",
      /* Z */
      CHAR_LOWERCASE_Z: "z",
      /* z */
      CHAR_LEFT_PARENTHESES: "(",
      /* ( */
      CHAR_RIGHT_PARENTHESES: ")",
      /* ) */
      CHAR_ASTERISK: "*",
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: "&",
      /* & */
      CHAR_AT: "@",
      /* @ */
      CHAR_BACKSLASH: "\\",
      /* \ */
      CHAR_BACKTICK: "`",
      /* ` */
      CHAR_CARRIAGE_RETURN: "\r",
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: "^",
      /* ^ */
      CHAR_COLON: ":",
      /* : */
      CHAR_COMMA: ",",
      /* , */
      CHAR_DOLLAR: "$",
      /* . */
      CHAR_DOT: ".",
      /* . */
      CHAR_DOUBLE_QUOTE: '"',
      /* " */
      CHAR_EQUAL: "=",
      /* = */
      CHAR_EXCLAMATION_MARK: "!",
      /* ! */
      CHAR_FORM_FEED: "\f",
      /* \f */
      CHAR_FORWARD_SLASH: "/",
      /* / */
      CHAR_HASH: "#",
      /* # */
      CHAR_HYPHEN_MINUS: "-",
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: "<",
      /* < */
      CHAR_LEFT_CURLY_BRACE: "{",
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: "[",
      /* [ */
      CHAR_LINE_FEED: "\n",
      /* \n */
      CHAR_NO_BREAK_SPACE: " ",
      /* \u00A0 */
      CHAR_PERCENT: "%",
      /* % */
      CHAR_PLUS: "+",
      /* + */
      CHAR_QUESTION_MARK: "?",
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: ">",
      /* > */
      CHAR_RIGHT_CURLY_BRACE: "}",
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: "]",
      /* ] */
      CHAR_SEMICOLON: ";",
      /* ; */
      CHAR_SINGLE_QUOTE: "'",
      /* ' */
      CHAR_SPACE: " ",
      /*   */
      CHAR_TAB: "	",
      /* \t */
      CHAR_UNDERSCORE: "_",
      /* _ */
      CHAR_VERTICAL_LINE: "|",
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
      /* \uFEFF */
    };
  }
});

// node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/parse.js
var require_parse = __commonJS({
  "node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/parse.js"(exports3, module2) {
    "use strict";
    var stringify5 = require_stringify();
    var {
      MAX_LENGTH: MAX_LENGTH2,
      CHAR_BACKSLASH: CHAR_BACKSLASH2,
      /* \ */
      CHAR_BACKTICK: CHAR_BACKTICK2,
      /* ` */
      CHAR_COMMA: CHAR_COMMA2,
      /* , */
      CHAR_DOT: CHAR_DOT2,
      /* . */
      CHAR_LEFT_PARENTHESES: CHAR_LEFT_PARENTHESES2,
      /* ( */
      CHAR_RIGHT_PARENTHESES: CHAR_RIGHT_PARENTHESES2,
      /* ) */
      CHAR_LEFT_CURLY_BRACE: CHAR_LEFT_CURLY_BRACE2,
      /* { */
      CHAR_RIGHT_CURLY_BRACE: CHAR_RIGHT_CURLY_BRACE2,
      /* } */
      CHAR_LEFT_SQUARE_BRACKET: CHAR_LEFT_SQUARE_BRACKET2,
      /* [ */
      CHAR_RIGHT_SQUARE_BRACKET: CHAR_RIGHT_SQUARE_BRACKET2,
      /* ] */
      CHAR_DOUBLE_QUOTE: CHAR_DOUBLE_QUOTE2,
      /* " */
      CHAR_SINGLE_QUOTE: CHAR_SINGLE_QUOTE2,
      /* ' */
      CHAR_NO_BREAK_SPACE: CHAR_NO_BREAK_SPACE2,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: CHAR_ZERO_WIDTH_NOBREAK_SPACE2
    } = require_constants2();
    var parse7 = (input, options3 = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      let opts = options3 || {};
      let max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH2, opts.maxLength) : MAX_LENGTH2;
      if (input.length > max) {
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
      }
      let ast = { type: "root", input, nodes: [] };
      let stack = [ast];
      let block = ast;
      let prev = ast;
      let brackets = 0;
      let length = input.length;
      let index2 = 0;
      let depth2 = 0;
      let value2;
      let memo = {};
      const advance2 = () => input[index2++];
      const push2 = (node3) => {
        if (node3.type === "text" && prev.type === "dot") {
          prev.type = "text";
        }
        if (prev && prev.type === "text" && node3.type === "text") {
          prev.value += node3.value;
          return;
        }
        block.nodes.push(node3);
        node3.parent = block;
        node3.prev = prev;
        prev = node3;
        return node3;
      };
      push2({ type: "bos" });
      while (index2 < length) {
        block = stack[stack.length - 1];
        value2 = advance2();
        if (value2 === CHAR_ZERO_WIDTH_NOBREAK_SPACE2 || value2 === CHAR_NO_BREAK_SPACE2) {
          continue;
        }
        if (value2 === CHAR_BACKSLASH2) {
          push2({ type: "text", value: (options3.keepEscaping ? value2 : "") + advance2() });
          continue;
        }
        if (value2 === CHAR_RIGHT_SQUARE_BRACKET2) {
          push2({ type: "text", value: "\\" + value2 });
          continue;
        }
        if (value2 === CHAR_LEFT_SQUARE_BRACKET2) {
          brackets++;
          let closed = true;
          let next;
          while (index2 < length && (next = advance2())) {
            value2 += next;
            if (next === CHAR_LEFT_SQUARE_BRACKET2) {
              brackets++;
              continue;
            }
            if (next === CHAR_BACKSLASH2) {
              value2 += advance2();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET2) {
              brackets--;
              if (brackets === 0) {
                break;
              }
            }
          }
          push2({ type: "text", value: value2 });
          continue;
        }
        if (value2 === CHAR_LEFT_PARENTHESES2) {
          block = push2({ type: "paren", nodes: [] });
          stack.push(block);
          push2({ type: "text", value: value2 });
          continue;
        }
        if (value2 === CHAR_RIGHT_PARENTHESES2) {
          if (block.type !== "paren") {
            push2({ type: "text", value: value2 });
            continue;
          }
          block = stack.pop();
          push2({ type: "text", value: value2 });
          block = stack[stack.length - 1];
          continue;
        }
        if (value2 === CHAR_DOUBLE_QUOTE2 || value2 === CHAR_SINGLE_QUOTE2 || value2 === CHAR_BACKTICK2) {
          let open2 = value2;
          let next;
          if (options3.keepQuotes !== true) {
            value2 = "";
          }
          while (index2 < length && (next = advance2())) {
            if (next === CHAR_BACKSLASH2) {
              value2 += next + advance2();
              continue;
            }
            if (next === open2) {
              if (options3.keepQuotes === true)
                value2 += next;
              break;
            }
            value2 += next;
          }
          push2({ type: "text", value: value2 });
          continue;
        }
        if (value2 === CHAR_LEFT_CURLY_BRACE2) {
          depth2++;
          let dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
          let brace = {
            type: "brace",
            open: true,
            close: false,
            dollar,
            depth: depth2,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          block = push2(brace);
          stack.push(block);
          push2({ type: "open", value: value2 });
          continue;
        }
        if (value2 === CHAR_RIGHT_CURLY_BRACE2) {
          if (block.type !== "brace") {
            push2({ type: "text", value: value2 });
            continue;
          }
          let type = "close";
          block = stack.pop();
          block.close = true;
          push2({ type, value: value2 });
          depth2--;
          block = stack[stack.length - 1];
          continue;
        }
        if (value2 === CHAR_COMMA2 && depth2 > 0) {
          if (block.ranges > 0) {
            block.ranges = 0;
            let open2 = block.nodes.shift();
            block.nodes = [open2, { type: "text", value: stringify5(block) }];
          }
          push2({ type: "comma", value: value2 });
          block.commas++;
          continue;
        }
        if (value2 === CHAR_DOT2 && depth2 > 0 && block.commas === 0) {
          let siblings = block.nodes;
          if (depth2 === 0 || siblings.length === 0) {
            push2({ type: "text", value: value2 });
            continue;
          }
          if (prev.type === "dot") {
            block.range = [];
            prev.value += value2;
            prev.type = "range";
            if (block.nodes.length !== 3 && block.nodes.length !== 5) {
              block.invalid = true;
              block.ranges = 0;
              prev.type = "text";
              continue;
            }
            block.ranges++;
            block.args = [];
            continue;
          }
          if (prev.type === "range") {
            siblings.pop();
            let before = siblings[siblings.length - 1];
            before.value += prev.value + value2;
            prev = before;
            block.ranges--;
            continue;
          }
          push2({ type: "dot", value: value2 });
          continue;
        }
        push2({ type: "text", value: value2 });
      }
      do {
        block = stack.pop();
        if (block.type !== "root") {
          block.nodes.forEach((node3) => {
            if (!node3.nodes) {
              if (node3.type === "open")
                node3.isOpen = true;
              if (node3.type === "close")
                node3.isClose = true;
              if (!node3.nodes)
                node3.type = "text";
              node3.invalid = true;
            }
          });
          let parent = stack[stack.length - 1];
          let index3 = parent.nodes.indexOf(block);
          parent.nodes.splice(index3, 1, ...block.nodes);
        }
      } while (stack.length > 0);
      push2({ type: "eos" });
      return ast;
    };
    module2.exports = parse7;
  }
});

// node_modules/.pnpm/braces@3.0.2/node_modules/braces/index.js
var require_braces = __commonJS({
  "node_modules/.pnpm/braces@3.0.2/node_modules/braces/index.js"(exports3, module2) {
    "use strict";
    var stringify5 = require_stringify();
    var compile3 = require_compile();
    var expand2 = require_expand();
    var parse7 = require_parse();
    var braces2 = (input, options3 = {}) => {
      let output = [];
      if (Array.isArray(input)) {
        for (let pattern2 of input) {
          let result = braces2.create(pattern2, options3);
          if (Array.isArray(result)) {
            output.push(...result);
          } else {
            output.push(result);
          }
        }
      } else {
        output = [].concat(braces2.create(input, options3));
      }
      if (options3 && options3.expand === true && options3.nodupes === true) {
        output = [...new Set(output)];
      }
      return output;
    };
    braces2.parse = (input, options3 = {}) => parse7(input, options3);
    braces2.stringify = (input, options3 = {}) => {
      if (typeof input === "string") {
        return stringify5(braces2.parse(input, options3), options3);
      }
      return stringify5(input, options3);
    };
    braces2.compile = (input, options3 = {}) => {
      if (typeof input === "string") {
        input = braces2.parse(input, options3);
      }
      return compile3(input, options3);
    };
    braces2.expand = (input, options3 = {}) => {
      if (typeof input === "string") {
        input = braces2.parse(input, options3);
      }
      let result = expand2(input, options3);
      if (options3.noempty === true) {
        result = result.filter(Boolean);
      }
      if (options3.nodupes === true) {
        result = [...new Set(result)];
      }
      return result;
    };
    braces2.create = (input, options3 = {}) => {
      if (input === "" || input.length < 3) {
        return [input];
      }
      return options3.expand !== true ? braces2.compile(input, options3) : braces2.expand(input, options3);
    };
    module2.exports = braces2;
  }
});

// node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/constants.js
var require_constants3 = __commonJS({
  "node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/constants.js"(exports3, module2) {
    "use strict";
    var path8 = require_path();
    var WIN_SLASH2 = "\\\\/";
    var WIN_NO_SLASH2 = `[^${WIN_SLASH2}]`;
    var DOT_LITERAL2 = "\\.";
    var PLUS_LITERAL2 = "\\+";
    var QMARK_LITERAL2 = "\\?";
    var SLASH_LITERAL2 = "\\/";
    var ONE_CHAR2 = "(?=.)";
    var QMARK2 = "[^/]";
    var END_ANCHOR2 = `(?:${SLASH_LITERAL2}|$)`;
    var START_ANCHOR2 = `(?:^|${SLASH_LITERAL2})`;
    var DOTS_SLASH2 = `${DOT_LITERAL2}{1,2}${END_ANCHOR2}`;
    var NO_DOT2 = `(?!${DOT_LITERAL2})`;
    var NO_DOTS2 = `(?!${START_ANCHOR2}${DOTS_SLASH2})`;
    var NO_DOT_SLASH2 = `(?!${DOT_LITERAL2}{0,1}${END_ANCHOR2})`;
    var NO_DOTS_SLASH2 = `(?!${DOTS_SLASH2})`;
    var QMARK_NO_DOT2 = `[^.${SLASH_LITERAL2}]`;
    var STAR2 = `${QMARK2}*?`;
    var POSIX_CHARS2 = {
      DOT_LITERAL: DOT_LITERAL2,
      PLUS_LITERAL: PLUS_LITERAL2,
      QMARK_LITERAL: QMARK_LITERAL2,
      SLASH_LITERAL: SLASH_LITERAL2,
      ONE_CHAR: ONE_CHAR2,
      QMARK: QMARK2,
      END_ANCHOR: END_ANCHOR2,
      DOTS_SLASH: DOTS_SLASH2,
      NO_DOT: NO_DOT2,
      NO_DOTS: NO_DOTS2,
      NO_DOT_SLASH: NO_DOT_SLASH2,
      NO_DOTS_SLASH: NO_DOTS_SLASH2,
      QMARK_NO_DOT: QMARK_NO_DOT2,
      STAR: STAR2,
      START_ANCHOR: START_ANCHOR2
    };
    var WINDOWS_CHARS2 = {
      ...POSIX_CHARS2,
      SLASH_LITERAL: `[${WIN_SLASH2}]`,
      QMARK: WIN_NO_SLASH2,
      STAR: `${WIN_NO_SLASH2}*?`,
      DOTS_SLASH: `${DOT_LITERAL2}{1,2}(?:[${WIN_SLASH2}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL2})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH2}])${DOT_LITERAL2}{1,2}(?:[${WIN_SLASH2}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL2}{0,1}(?:[${WIN_SLASH2}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL2}{1,2}(?:[${WIN_SLASH2}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH2}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH2}])`,
      END_ANCHOR: `(?:[${WIN_SLASH2}]|$)`
    };
    var POSIX_REGEX_SOURCE2 = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE: POSIX_REGEX_SOURCE2,
      // regular expressions
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      // Replace globs with equivalent patterns to reduce parsing time.
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      // Digits
      CHAR_0: 48,
      /* 0 */
      CHAR_9: 57,
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: 65,
      /* A */
      CHAR_LOWERCASE_A: 97,
      /* a */
      CHAR_UPPERCASE_Z: 90,
      /* Z */
      CHAR_LOWERCASE_Z: 122,
      /* z */
      CHAR_LEFT_PARENTHESES: 40,
      /* ( */
      CHAR_RIGHT_PARENTHESES: 41,
      /* ) */
      CHAR_ASTERISK: 42,
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: 38,
      /* & */
      CHAR_AT: 64,
      /* @ */
      CHAR_BACKWARD_SLASH: 92,
      /* \ */
      CHAR_CARRIAGE_RETURN: 13,
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: 94,
      /* ^ */
      CHAR_COLON: 58,
      /* : */
      CHAR_COMMA: 44,
      /* , */
      CHAR_DOT: 46,
      /* . */
      CHAR_DOUBLE_QUOTE: 34,
      /* " */
      CHAR_EQUAL: 61,
      /* = */
      CHAR_EXCLAMATION_MARK: 33,
      /* ! */
      CHAR_FORM_FEED: 12,
      /* \f */
      CHAR_FORWARD_SLASH: 47,
      /* / */
      CHAR_GRAVE_ACCENT: 96,
      /* ` */
      CHAR_HASH: 35,
      /* # */
      CHAR_HYPHEN_MINUS: 45,
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: 60,
      /* < */
      CHAR_LEFT_CURLY_BRACE: 123,
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: 91,
      /* [ */
      CHAR_LINE_FEED: 10,
      /* \n */
      CHAR_NO_BREAK_SPACE: 160,
      /* \u00A0 */
      CHAR_PERCENT: 37,
      /* % */
      CHAR_PLUS: 43,
      /* + */
      CHAR_QUESTION_MARK: 63,
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      /* > */
      CHAR_RIGHT_CURLY_BRACE: 125,
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      /* ] */
      CHAR_SEMICOLON: 59,
      /* ; */
      CHAR_SINGLE_QUOTE: 39,
      /* ' */
      CHAR_SPACE: 32,
      /*   */
      CHAR_TAB: 9,
      /* \t */
      CHAR_UNDERSCORE: 95,
      /* _ */
      CHAR_VERTICAL_LINE: 124,
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      /* \uFEFF */
      SEP: path8.sep,
      /**
       * Create EXTGLOB_CHARS
       */
      extglobChars(chars3) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars3.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      /**
       * Create GLOB_CHARS
       */
      globChars(win322) {
        return win322 === true ? WINDOWS_CHARS2 : POSIX_CHARS2;
      }
    };
  }
});

// node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/utils.js
var require_utils4 = __commonJS({
  "node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/utils.js"(exports3) {
    "use strict";
    var path8 = require_path();
    var win322 = process.platform === "win32";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants3();
    exports3.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports3.hasRegexChars = (str2) => REGEX_SPECIAL_CHARS.test(str2);
    exports3.isRegexChar = (str2) => str2.length === 1 && exports3.hasRegexChars(str2);
    exports3.escapeRegex = (str2) => str2.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports3.toPosixSlashes = (str2) => str2.replace(REGEX_BACKSLASH, "/");
    exports3.removeBackslashes = (str2) => {
      return str2.replace(REGEX_REMOVE_BACKSLASH, (match) => {
        return match === "\\" ? "" : match;
      });
    };
    exports3.supportsLookbehinds = () => {
      const segs = process.version.slice(1).split(".").map(Number);
      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
      }
      return false;
    };
    exports3.isWindows = (options3) => {
      if (options3 && typeof options3.windows === "boolean") {
        return options3.windows;
      }
      return win322 === true || path8.sep === "\\";
    };
    exports3.escapeLast = (input, char, lastIdx) => {
      const idx = input.lastIndexOf(char, lastIdx);
      if (idx === -1)
        return input;
      if (input[idx - 1] === "\\")
        return exports3.escapeLast(input, char, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports3.removePrefix = (input, state = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports3.wrapOutput = (input, state = {}, options3 = {}) => {
      const prepend = options3.contains ? "" : "^";
      const append2 = options3.contains ? "" : "$";
      let output = `${prepend}(?:${input})${append2}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
  }
});

// node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/scan.js
var require_scan = __commonJS({
  "node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/scan.js"(exports3, module2) {
    "use strict";
    var utils2 = require_utils4();
    var {
      CHAR_ASTERISK: CHAR_ASTERISK2,
      /* * */
      CHAR_AT: CHAR_AT2,
      /* @ */
      CHAR_BACKWARD_SLASH: CHAR_BACKWARD_SLASH2,
      /* \ */
      CHAR_COMMA: CHAR_COMMA2,
      /* , */
      CHAR_DOT: CHAR_DOT2,
      /* . */
      CHAR_EXCLAMATION_MARK: CHAR_EXCLAMATION_MARK2,
      /* ! */
      CHAR_FORWARD_SLASH: CHAR_FORWARD_SLASH2,
      /* / */
      CHAR_LEFT_CURLY_BRACE: CHAR_LEFT_CURLY_BRACE2,
      /* { */
      CHAR_LEFT_PARENTHESES: CHAR_LEFT_PARENTHESES2,
      /* ( */
      CHAR_LEFT_SQUARE_BRACKET: CHAR_LEFT_SQUARE_BRACKET2,
      /* [ */
      CHAR_PLUS: CHAR_PLUS2,
      /* + */
      CHAR_QUESTION_MARK: CHAR_QUESTION_MARK2,
      /* ? */
      CHAR_RIGHT_CURLY_BRACE: CHAR_RIGHT_CURLY_BRACE2,
      /* } */
      CHAR_RIGHT_PARENTHESES: CHAR_RIGHT_PARENTHESES2,
      /* ) */
      CHAR_RIGHT_SQUARE_BRACKET: CHAR_RIGHT_SQUARE_BRACKET2
      /* ] */
    } = require_constants3();
    var isPathSeparator2 = (code) => {
      return code === CHAR_FORWARD_SLASH2 || code === CHAR_BACKWARD_SLASH2;
    };
    var depth2 = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan2 = (input, options3) => {
      const opts = options3 || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str2 = input;
      let index2 = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob3 = false;
      let isExtglob3 = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces2 = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index2 >= length;
      const peek = () => str2.charCodeAt(index2 + 1);
      const advance2 = () => {
        prev = code;
        return str2.charCodeAt(++index2);
      };
      while (index2 < length) {
        code = advance2();
        let next;
        if (code === CHAR_BACKWARD_SLASH2) {
          backslashes = token.backslashes = true;
          code = advance2();
          if (code === CHAR_LEFT_CURLY_BRACE2) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE2) {
          braces2++;
          while (eos() !== true && (code = advance2())) {
            if (code === CHAR_BACKWARD_SLASH2) {
              backslashes = token.backslashes = true;
              advance2();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE2) {
              braces2++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT2 && (code = advance2()) === CHAR_DOT2) {
              isBrace = token.isBrace = true;
              isGlob3 = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA2) {
              isBrace = token.isBrace = true;
              isGlob3 = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE2) {
              braces2--;
              if (braces2 === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH2) {
          slashes.push(index2);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true)
            continue;
          if (prev === CHAR_DOT2 && index2 === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index2 + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS2 || code === CHAR_AT2 || code === CHAR_ASTERISK2 || code === CHAR_QUESTION_MARK2 || code === CHAR_EXCLAMATION_MARK2;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES2) {
            isGlob3 = token.isGlob = true;
            isExtglob3 = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK2 && index2 === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance2())) {
                if (code === CHAR_BACKWARD_SLASH2) {
                  backslashes = token.backslashes = true;
                  code = advance2();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES2) {
                  isGlob3 = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK2) {
          if (prev === CHAR_ASTERISK2)
            isGlobstar = token.isGlobstar = true;
          isGlob3 = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK2) {
          isGlob3 = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET2) {
          while (eos() !== true && (next = advance2())) {
            if (next === CHAR_BACKWARD_SLASH2) {
              backslashes = token.backslashes = true;
              advance2();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET2) {
              isBracket = token.isBracket = true;
              isGlob3 = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK2 && index2 === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES2) {
          isGlob3 = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance2())) {
              if (code === CHAR_LEFT_PARENTHESES2) {
                backslashes = token.backslashes = true;
                code = advance2();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES2) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob3 === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob3 = false;
        isGlob3 = false;
      }
      let base2 = str2;
      let prefix = "";
      let glob2 = "";
      if (start > 0) {
        prefix = str2.slice(0, start);
        str2 = str2.slice(start);
        lastIndex -= start;
      }
      if (base2 && isGlob3 === true && lastIndex > 0) {
        base2 = str2.slice(0, lastIndex);
        glob2 = str2.slice(lastIndex);
      } else if (isGlob3 === true) {
        base2 = "";
        glob2 = str2;
      } else {
        base2 = str2;
      }
      if (base2 && base2 !== "" && base2 !== "/" && base2 !== str2) {
        if (isPathSeparator2(base2.charCodeAt(base2.length - 1))) {
          base2 = base2.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob2)
          glob2 = utils2.removeBackslashes(glob2);
        if (base2 && backslashes === true) {
          base2 = utils2.removeBackslashes(base2);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base: base2,
        glob: glob2,
        isBrace,
        isBracket,
        isGlob: isGlob3,
        isExtglob: isExtglob3,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator2(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n3 = prevIndex ? prevIndex + 1 : start;
          const i2 = slashes[idx];
          const value2 = input.slice(n3, i2);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value2;
            }
            depth2(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value2 !== "") {
            parts.push(value2);
          }
          prevIndex = i2;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value2 = input.slice(prevIndex + 1);
          parts.push(value2);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value2;
            depth2(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    module2.exports = scan2;
  }
});

// node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/parse.js"(exports3, module2) {
    "use strict";
    var constants2 = require_constants3();
    var utils2 = require_utils4();
    var {
      MAX_LENGTH: MAX_LENGTH2,
      POSIX_REGEX_SOURCE: POSIX_REGEX_SOURCE2,
      REGEX_NON_SPECIAL_CHARS: REGEX_NON_SPECIAL_CHARS2,
      REGEX_SPECIAL_CHARS_BACKREF: REGEX_SPECIAL_CHARS_BACKREF2,
      REPLACEMENTS: REPLACEMENTS2
    } = constants2;
    var expandRange2 = (args, options3) => {
      if (typeof options3.expandRange === "function") {
        return options3.expandRange(...args, options3);
      }
      args.sort();
      const value2 = `[${args.join("-")}]`;
      try {
        new RegExp(value2);
      } catch (ex) {
        return args.map((v) => utils2.escapeRegex(v)).join("..");
      }
      return value2;
    };
    var syntaxError2 = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse7 = (input, options3) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS2[input] || input;
      const opts = { ...options3 };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH2, opts.maxLength) : MAX_LENGTH2;
      let len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win322 = utils2.isWindows(options3);
      const PLATFORM_CHARS = constants2.globChars(win322);
      const EXTGLOB_CHARS = constants2.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL: DOT_LITERAL2,
        PLUS_LITERAL: PLUS_LITERAL2,
        SLASH_LITERAL: SLASH_LITERAL2,
        ONE_CHAR: ONE_CHAR2,
        DOTS_SLASH: DOTS_SLASH2,
        NO_DOT: NO_DOT2,
        NO_DOT_SLASH: NO_DOT_SLASH2,
        NO_DOTS_SLASH: NO_DOTS_SLASH2,
        QMARK: QMARK2,
        QMARK_NO_DOT: QMARK_NO_DOT2,
        STAR: STAR2,
        START_ANCHOR: START_ANCHOR2
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR2}${opts2.dot ? DOTS_SLASH2 : DOT_LITERAL2}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT2;
      const qmarkNoDot = opts.dot ? QMARK2 : QMARK_NO_DOT2;
      let star2 = opts.bash === true ? globstar(opts) : STAR2;
      if (opts.capture) {
        star2 = `(${star2})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils2.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces2 = [];
      const stack = [];
      let prev = bos;
      let value2;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n3 = 1) => input[state.index + n3];
      const advance2 = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value3 = "", num = 0) => {
        state.consumed += value3;
        state.index += num;
      };
      const append2 = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance2();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push2 = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob3 = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob3) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star2;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output)
          append2(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value3) => {
        const token = { ...EXTGLOB_CHARS[value3], conditions: 1, inner: "" };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push2({ type, value: value3, output: state.output ? "" : ONE_CHAR2 });
        push2({ type: "paren", extglob: true, value: advance2(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star2;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star2 || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            const expression = parse7(rest, { ...options3, fastpaths: false }).output;
            output = token.close = `)${expression})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push2({ type: "paren", extglob: true, value: value2, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF2, (m, esc, chars3, first2, rest, index2) => {
          if (first2 === "\\") {
            backslashes = true;
            return m;
          }
          if (first2 === "?") {
            if (esc) {
              return esc + first2 + (rest ? QMARK2.repeat(rest.length) : "");
            }
            if (index2 === 0) {
              return qmarkNoDot + (rest ? QMARK2.repeat(rest.length) : "");
            }
            return QMARK2.repeat(chars3.length);
          }
          if (first2 === ".") {
            return DOT_LITERAL2.repeat(chars3.length);
          }
          if (first2 === "*") {
            if (esc) {
              return esc + first2 + (rest ? star2 : "");
            }
            return star2;
          }
          return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m) => {
              return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils2.wrapOutput(output, state, options3);
        return state;
      }
      while (!eos()) {
        value2 = advance2();
        if (value2 === "\0") {
          continue;
        }
        if (value2 === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value2 += "\\";
            push2({ type: "text", value: value2 });
            continue;
          }
          const match = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match && match[0].length > 2) {
            slashes = match[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value2 += "\\";
            }
          }
          if (opts.unescape === true) {
            value2 = advance2();
          } else {
            value2 += advance2();
          }
          if (state.brackets === 0) {
            push2({ type: "text", value: value2 });
            continue;
          }
        }
        if (state.brackets > 0 && (value2 !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value2 === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix2 = POSIX_REGEX_SOURCE2[rest2];
                if (posix2) {
                  prev.value = pre + posix2;
                  state.backtrack = true;
                  advance2();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR2;
                  }
                  continue;
                }
              }
            }
          }
          if (value2 === "[" && peek() !== ":" || value2 === "-" && peek() === "]") {
            value2 = `\\${value2}`;
          }
          if (value2 === "]" && (prev.value === "[" || prev.value === "[^")) {
            value2 = `\\${value2}`;
          }
          if (opts.posix === true && value2 === "!" && prev.value === "[") {
            value2 = "^";
          }
          prev.value += value2;
          append2({ value: value2 });
          continue;
        }
        if (state.quotes === 1 && value2 !== '"') {
          value2 = utils2.escapeRegex(value2);
          prev.value += value2;
          append2({ value: value2 });
          continue;
        }
        if (value2 === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push2({ type: "text", value: value2 });
          }
          continue;
        }
        if (value2 === "(") {
          increment("parens");
          push2({ type: "paren", value: value2 });
          continue;
        }
        if (value2 === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError2("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push2({ type: "paren", value: value2, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value2 === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError2("closing", "]"));
            }
            value2 = `\\${value2}`;
          } else {
            increment("brackets");
          }
          push2({ type: "bracket", value: value2 });
          continue;
        }
        if (value2 === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push2({ type: "text", value: value2, output: `\\${value2}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError2("opening", "["));
            }
            push2({ type: "text", value: value2, output: `\\${value2}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value2 = `/${value2}`;
          }
          prev.value += value2;
          append2({ value: value2 });
          if (opts.literalBrackets === false || utils2.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped2 = utils2.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped2;
            prev.value = escaped2;
            continue;
          }
          prev.value = `(${capture}${escaped2}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value2 === "{" && opts.nobrace !== true) {
          increment("braces");
          const open2 = {
            type: "brace",
            value: value2,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces2.push(open2);
          push2(open2);
          continue;
        }
        if (value2 === "}") {
          const brace = braces2[braces2.length - 1];
          if (opts.nobrace === true || !brace) {
            push2({ type: "text", value: value2, output: value2 });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range2 = [];
            for (let i2 = arr.length - 1; i2 >= 0; i2--) {
              tokens.pop();
              if (arr[i2].type === "brace") {
                break;
              }
              if (arr[i2].type !== "dots") {
                range2.unshift(arr[i2].value);
              }
            }
            output = expandRange2(range2, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out2 = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value2 = output = "\\}";
            state.output = out2;
            for (const t3 of toks) {
              state.output += t3.output || t3.value;
            }
          }
          push2({ type: "brace", value: value2, output });
          decrement("braces");
          braces2.pop();
          continue;
        }
        if (value2 === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push2({ type: "text", value: value2 });
          continue;
        }
        if (value2 === ",") {
          let output = value2;
          const brace = braces2[braces2.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push2({ type: "comma", value: value2, output });
          continue;
        }
        if (value2 === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push2({ type: "slash", value: value2, output: SLASH_LITERAL2 });
          continue;
        }
        if (value2 === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".")
              prev.output = DOT_LITERAL2;
            const brace = braces2[braces2.length - 1];
            prev.type = "dots";
            prev.output += value2;
            prev.value += value2;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push2({ type: "text", value: value2, output: DOT_LITERAL2 });
            continue;
          }
          push2({ type: "dot", value: value2, output: DOT_LITERAL2 });
          continue;
        }
        if (value2 === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value2);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value2;
            if (next === "<" && !utils2.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value2}`;
            }
            push2({ type: "text", value: value2, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push2({ type: "qmark", value: value2, output: QMARK_NO_DOT2 });
            continue;
          }
          push2({ type: "qmark", value: value2, output: QMARK2 });
          continue;
        }
        if (value2 === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value2);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value2 === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value2);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push2({ type: "plus", value: value2, output: PLUS_LITERAL2 });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push2({ type: "plus", value: value2 });
            continue;
          }
          push2({ type: "plus", value: PLUS_LITERAL2 });
          continue;
        }
        if (value2 === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push2({ type: "at", extglob: true, value: value2, output: "" });
            continue;
          }
          push2({ type: "text", value: value2 });
          continue;
        }
        if (value2 !== "*") {
          if (value2 === "$" || value2 === "^") {
            value2 = `\\${value2}`;
          }
          const match = REGEX_NON_SPECIAL_CHARS2.exec(remaining());
          if (match) {
            value2 += match[0];
            state.index += match[0].length;
          }
          push2({ type: "text", value: value2 });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value2;
          prev.output = star2;
          state.backtrack = true;
          state.globstar = true;
          consume(value2);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value2);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value2);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push2({ type: "star", value: value2, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob3 = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob3) {
            push2({ type: "star", value: value2, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value2;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value2);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value2;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value2);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL2}|${SLASH_LITERAL2}${end})`;
            prev.value += value2;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value2 + advance2());
            push2({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value2;
            prev.output = `(?:^|${SLASH_LITERAL2}|${globstar(opts)}${SLASH_LITERAL2})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value2 + advance2());
            push2({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value2;
          state.output += prev.output;
          state.globstar = true;
          consume(value2);
          continue;
        }
        const token = { type: "star", value: value2, output: star2 };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push2(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value2;
          push2(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH2;
            prev.output += NO_DOT_SLASH2;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH2;
            prev.output += NO_DOTS_SLASH2;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR2;
            prev.output += ONE_CHAR2;
          }
        }
        push2(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError2("closing", "]"));
        state.output = utils2.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError2("closing", ")"));
        state.output = utils2.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError2("closing", "}"));
        state.output = utils2.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push2({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL2}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse7.fastpaths = (input, options3) => {
      const opts = { ...options3 };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH2, opts.maxLength) : MAX_LENGTH2;
      const len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      input = REPLACEMENTS2[input] || input;
      const win322 = utils2.isWindows(options3);
      const {
        DOT_LITERAL: DOT_LITERAL2,
        SLASH_LITERAL: SLASH_LITERAL2,
        ONE_CHAR: ONE_CHAR2,
        DOTS_SLASH: DOTS_SLASH2,
        NO_DOT: NO_DOT2,
        NO_DOTS: NO_DOTS2,
        NO_DOTS_SLASH: NO_DOTS_SLASH2,
        STAR: STAR2,
        START_ANCHOR: START_ANCHOR2
      } = constants2.globChars(win322);
      const nodot = opts.dot ? NO_DOTS2 : NO_DOT2;
      const slashDot = opts.dot ? NO_DOTS_SLASH2 : NO_DOT2;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star2 = opts.bash === true ? ".*?" : STAR2;
      if (opts.capture) {
        star2 = `(${star2})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true)
          return star2;
        return `(${capture}(?:(?!${START_ANCHOR2}${opts2.dot ? DOTS_SLASH2 : DOT_LITERAL2}).)*?)`;
      };
      const create = (str2) => {
        switch (str2) {
          case "*":
            return `${nodot}${ONE_CHAR2}${star2}`;
          case ".*":
            return `${DOT_LITERAL2}${ONE_CHAR2}${star2}`;
          case "*.*":
            return `${nodot}${star2}${DOT_LITERAL2}${ONE_CHAR2}${star2}`;
          case "*/*":
            return `${nodot}${star2}${SLASH_LITERAL2}${ONE_CHAR2}${slashDot}${star2}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL2})?${slashDot}${ONE_CHAR2}${star2}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL2})?${slashDot}${star2}${DOT_LITERAL2}${ONE_CHAR2}${star2}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL2})?${DOT_LITERAL2}${ONE_CHAR2}${star2}`;
          default: {
            const match = /^(.*?)\.(\w+)$/.exec(str2);
            if (!match)
              return;
            const source2 = create(match[1]);
            if (!source2)
              return;
            return source2 + DOT_LITERAL2 + match[2];
          }
        }
      };
      const output = utils2.removePrefix(input, state);
      let source = create(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL2}?`;
      }
      return source;
    };
    module2.exports = parse7;
  }
});

// node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS({
  "node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/picomatch.js"(exports3, module2) {
    "use strict";
    var path8 = require_path();
    var scan2 = require_scan();
    var parse7 = require_parse2();
    var utils2 = require_utils4();
    var constants2 = require_constants3();
    var isObject2 = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch2 = (glob2, options3, returnState = false) => {
      if (Array.isArray(glob2)) {
        const fns = glob2.map((input) => picomatch2(input, options3, returnState));
        const arrayMatcher = (str2) => {
          for (const isMatch2 of fns) {
            const state2 = isMatch2(str2);
            if (state2)
              return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject2(glob2) && glob2.tokens && glob2.input;
      if (glob2 === "" || typeof glob2 !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options3 || {};
      const posix2 = utils2.isWindows(options3);
      const regex = isState ? picomatch2.compileRe(glob2, options3) : picomatch2.makeRe(glob2, options3, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored2 = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options3, ignore: null, onMatch: null, onResult: null };
        isIgnored2 = picomatch2(opts.ignore, ignoreOpts, returnState);
      }
      const matcher2 = (input, returnObject = false) => {
        const { isMatch: isMatch2, match, output } = picomatch2.test(input, regex, options3, { glob: glob2, posix: posix2 });
        const result = { glob: glob2, state, regex, posix: posix2, input, output, match, isMatch: isMatch2 };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch2 === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored2(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher2.state = state;
      }
      return matcher2;
    };
    picomatch2.test = (input, regex, options3, { glob: glob2, posix: posix2 } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options3 || {};
      const format2 = opts.format || (posix2 ? utils2.toPosixSlashes : null);
      let match = input === glob2;
      let output = match && format2 ? format2(input) : input;
      if (match === false) {
        output = format2 ? format2(input) : input;
        match = output === glob2;
      }
      if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match = picomatch2.matchBase(input, regex, options3, posix2);
        } else {
          match = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match), match, output };
    };
    picomatch2.matchBase = (input, glob2, options3, posix2 = utils2.isWindows(options3)) => {
      const regex = glob2 instanceof RegExp ? glob2 : picomatch2.makeRe(glob2, options3);
      return regex.test(path8.basename(input));
    };
    picomatch2.isMatch = (str2, patterns2, options3) => picomatch2(patterns2, options3)(str2);
    picomatch2.parse = (pattern2, options3) => {
      if (Array.isArray(pattern2))
        return pattern2.map((p2) => picomatch2.parse(p2, options3));
      return parse7(pattern2, { ...options3, fastpaths: false });
    };
    picomatch2.scan = (input, options3) => scan2(input, options3);
    picomatch2.compileRe = (state, options3, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options3 || {};
      const prepend = opts.contains ? "" : "^";
      const append2 = opts.contains ? "" : "$";
      let source = `${prepend}(?:${state.output})${append2}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch2.toRegex(source, options3);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch2.makeRe = (input, options3 = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options3.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse7.fastpaths(input, options3);
      }
      if (!parsed.output) {
        parsed = parse7(input, options3);
      }
      return picomatch2.compileRe(parsed, options3, returnOutput, returnState);
    };
    picomatch2.toRegex = (source, options3) => {
      try {
        const opts = options3 || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err2) {
        if (options3 && options3.debug === true)
          throw err2;
        return /$^/;
      }
    };
    picomatch2.constants = constants2;
    module2.exports = picomatch2;
  }
});

// node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/index.js
var require_picomatch2 = __commonJS({
  "node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/index.js"(exports3, module2) {
    "use strict";
    module2.exports = require_picomatch();
  }
});

// node_modules/.pnpm/micromatch@4.0.5/node_modules/micromatch/index.js
var require_micromatch = __commonJS({
  "node_modules/.pnpm/micromatch@4.0.5/node_modules/micromatch/index.js"(exports3, module2) {
    "use strict";
    var util2 = require_util();
    var braces2 = require_braces();
    var picomatch2 = require_picomatch2();
    var utils2 = require_utils4();
    var isEmptyString2 = (val) => val === "" || val === "./";
    var micromatch2 = (list, patterns2, options3) => {
      patterns2 = [].concat(patterns2);
      list = [].concat(list);
      let omit2 = /* @__PURE__ */ new Set();
      let keep = /* @__PURE__ */ new Set();
      let items = /* @__PURE__ */ new Set();
      let negatives = 0;
      let onResult = (state) => {
        items.add(state.output);
        if (options3 && options3.onResult) {
          options3.onResult(state);
        }
      };
      for (let i2 = 0; i2 < patterns2.length; i2++) {
        let isMatch2 = picomatch2(String(patterns2[i2]), { ...options3, onResult }, true);
        let negated = isMatch2.state.negated || isMatch2.state.negatedExtglob;
        if (negated)
          negatives++;
        for (let item of list) {
          let matched = isMatch2(item, true);
          let match = negated ? !matched.isMatch : matched.isMatch;
          if (!match)
            continue;
          if (negated) {
            omit2.add(matched.output);
          } else {
            omit2.delete(matched.output);
            keep.add(matched.output);
          }
        }
      }
      let result = negatives === patterns2.length ? [...items] : [...keep];
      let matches2 = result.filter((item) => !omit2.has(item));
      if (options3 && matches2.length === 0) {
        if (options3.failglob === true) {
          throw new Error(`No matches found for "${patterns2.join(", ")}"`);
        }
        if (options3.nonull === true || options3.nullglob === true) {
          return options3.unescape ? patterns2.map((p2) => p2.replace(/\\/g, "")) : patterns2;
        }
      }
      return matches2;
    };
    micromatch2.match = micromatch2;
    micromatch2.matcher = (pattern2, options3) => picomatch2(pattern2, options3);
    micromatch2.isMatch = (str2, patterns2, options3) => picomatch2(patterns2, options3)(str2);
    micromatch2.any = micromatch2.isMatch;
    micromatch2.not = (list, patterns2, options3 = {}) => {
      patterns2 = [].concat(patterns2).map(String);
      let result = /* @__PURE__ */ new Set();
      let items = [];
      let onResult = (state) => {
        if (options3.onResult)
          options3.onResult(state);
        items.push(state.output);
      };
      let matches2 = new Set(micromatch2(list, patterns2, { ...options3, onResult }));
      for (let item of items) {
        if (!matches2.has(item)) {
          result.add(item);
        }
      }
      return [...result];
    };
    micromatch2.contains = (str2, pattern2, options3) => {
      if (typeof str2 !== "string") {
        throw new TypeError(`Expected a string: "${util2.inspect(str2)}"`);
      }
      if (Array.isArray(pattern2)) {
        return pattern2.some((p2) => micromatch2.contains(str2, p2, options3));
      }
      if (typeof pattern2 === "string") {
        if (isEmptyString2(str2) || isEmptyString2(pattern2)) {
          return false;
        }
        if (str2.includes(pattern2) || str2.startsWith("./") && str2.slice(2).includes(pattern2)) {
          return true;
        }
      }
      return micromatch2.isMatch(str2, pattern2, { ...options3, contains: true });
    };
    micromatch2.matchKeys = (obj, patterns2, options3) => {
      if (!utils2.isObject(obj)) {
        throw new TypeError("Expected the first argument to be an object");
      }
      let keys = micromatch2(Object.keys(obj), patterns2, options3);
      let res = {};
      for (let key of keys)
        res[key] = obj[key];
      return res;
    };
    micromatch2.some = (list, patterns2, options3) => {
      let items = [].concat(list);
      for (let pattern2 of [].concat(patterns2)) {
        let isMatch2 = picomatch2(String(pattern2), options3);
        if (items.some((item) => isMatch2(item))) {
          return true;
        }
      }
      return false;
    };
    micromatch2.every = (list, patterns2, options3) => {
      let items = [].concat(list);
      for (let pattern2 of [].concat(patterns2)) {
        let isMatch2 = picomatch2(String(pattern2), options3);
        if (!items.every((item) => isMatch2(item))) {
          return false;
        }
      }
      return true;
    };
    micromatch2.all = (str2, patterns2, options3) => {
      if (typeof str2 !== "string") {
        throw new TypeError(`Expected a string: "${util2.inspect(str2)}"`);
      }
      return [].concat(patterns2).every((p2) => picomatch2(p2, options3)(str2));
    };
    micromatch2.capture = (glob2, input, options3) => {
      let posix2 = utils2.isWindows(options3);
      let regex = picomatch2.makeRe(String(glob2), { ...options3, capture: true });
      let match = regex.exec(posix2 ? utils2.toPosixSlashes(input) : input);
      if (match) {
        return match.slice(1).map((v) => v === void 0 ? "" : v);
      }
    };
    micromatch2.makeRe = (...args) => picomatch2.makeRe(...args);
    micromatch2.scan = (...args) => picomatch2.scan(...args);
    micromatch2.parse = (patterns2, options3) => {
      let res = [];
      for (let pattern2 of [].concat(patterns2 || [])) {
        for (let str2 of braces2(String(pattern2), options3)) {
          res.push(picomatch2.parse(str2, options3));
        }
      }
      return res;
    };
    micromatch2.braces = (pattern2, options3) => {
      if (typeof pattern2 !== "string")
        throw new TypeError("Expected a string");
      if (options3 && options3.nobrace === true || !/\{.*\}/.test(pattern2)) {
        return [pattern2];
      }
      return braces2(pattern2, options3);
    };
    micromatch2.braceExpand = (pattern2, options3) => {
      if (typeof pattern2 !== "string")
        throw new TypeError("Expected a string");
      return micromatch2.braces(pattern2, { ...options3, expand: true });
    };
    module2.exports = micromatch2;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/pattern.js
var require_pattern = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/pattern.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    exports3.matchAny = exports3.convertPatternsToRe = exports3.makeRe = exports3.getPatternParts = exports3.expandBraceExpansion = exports3.expandPatternsWithBraceExpansion = exports3.isAffectDepthOfReadingPattern = exports3.endsWithSlashGlobStar = exports3.hasGlobStar = exports3.getBaseDirectory = exports3.isPatternRelatedToParentDirectory = exports3.getPatternsOutsideCurrentDirectory = exports3.getPatternsInsideCurrentDirectory = exports3.getPositivePatterns = exports3.getNegativePatterns = exports3.isPositivePattern = exports3.isNegativePattern = exports3.convertToNegativePattern = exports3.convertToPositivePattern = exports3.isDynamicPattern = exports3.isStaticPattern = void 0;
    var path8 = require_path();
    var globParent3 = require_glob_parent();
    var micromatch2 = require_micromatch();
    var GLOBSTAR2 = "**";
    var ESCAPE_SYMBOL2 = "\\";
    var COMMON_GLOB_SYMBOLS_RE2 = /[*?]|^!/;
    var REGEX_CHARACTER_CLASS_SYMBOLS_RE2 = /\[[^[]*]/;
    var REGEX_GROUP_SYMBOLS_RE2 = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/;
    var GLOB_EXTENSION_SYMBOLS_RE2 = /[!*+?@]\([^(]*\)/;
    var BRACE_EXPANSION_SEPARATORS_RE2 = /,|\.\./;
    function isStaticPattern2(pattern2, options3 = {}) {
      return !isDynamicPattern3(pattern2, options3);
    }
    exports3.isStaticPattern = isStaticPattern2;
    function isDynamicPattern3(pattern2, options3 = {}) {
      if (pattern2 === "") {
        return false;
      }
      if (options3.caseSensitiveMatch === false || pattern2.includes(ESCAPE_SYMBOL2)) {
        return true;
      }
      if (COMMON_GLOB_SYMBOLS_RE2.test(pattern2) || REGEX_CHARACTER_CLASS_SYMBOLS_RE2.test(pattern2) || REGEX_GROUP_SYMBOLS_RE2.test(pattern2)) {
        return true;
      }
      if (options3.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE2.test(pattern2)) {
        return true;
      }
      if (options3.braceExpansion !== false && hasBraceExpansion2(pattern2)) {
        return true;
      }
      return false;
    }
    exports3.isDynamicPattern = isDynamicPattern3;
    function hasBraceExpansion2(pattern2) {
      const openingBraceIndex = pattern2.indexOf("{");
      if (openingBraceIndex === -1) {
        return false;
      }
      const closingBraceIndex = pattern2.indexOf("}", openingBraceIndex + 1);
      if (closingBraceIndex === -1) {
        return false;
      }
      const braceContent = pattern2.slice(openingBraceIndex, closingBraceIndex);
      return BRACE_EXPANSION_SEPARATORS_RE2.test(braceContent);
    }
    function convertToPositivePattern2(pattern2) {
      return isNegativePattern3(pattern2) ? pattern2.slice(1) : pattern2;
    }
    exports3.convertToPositivePattern = convertToPositivePattern2;
    function convertToNegativePattern2(pattern2) {
      return "!" + pattern2;
    }
    exports3.convertToNegativePattern = convertToNegativePattern2;
    function isNegativePattern3(pattern2) {
      return pattern2.startsWith("!") && pattern2[1] !== "(";
    }
    exports3.isNegativePattern = isNegativePattern3;
    function isPositivePattern2(pattern2) {
      return !isNegativePattern3(pattern2);
    }
    exports3.isPositivePattern = isPositivePattern2;
    function getNegativePatterns2(patterns2) {
      return patterns2.filter(isNegativePattern3);
    }
    exports3.getNegativePatterns = getNegativePatterns2;
    function getPositivePatterns2(patterns2) {
      return patterns2.filter(isPositivePattern2);
    }
    exports3.getPositivePatterns = getPositivePatterns2;
    function getPatternsInsideCurrentDirectory2(patterns2) {
      return patterns2.filter((pattern2) => !isPatternRelatedToParentDirectory2(pattern2));
    }
    exports3.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory2;
    function getPatternsOutsideCurrentDirectory2(patterns2) {
      return patterns2.filter(isPatternRelatedToParentDirectory2);
    }
    exports3.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory2;
    function isPatternRelatedToParentDirectory2(pattern2) {
      return pattern2.startsWith("..") || pattern2.startsWith("./..");
    }
    exports3.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory2;
    function getBaseDirectory2(pattern2) {
      return globParent3(pattern2, { flipBackslashes: false });
    }
    exports3.getBaseDirectory = getBaseDirectory2;
    function hasGlobStar2(pattern2) {
      return pattern2.includes(GLOBSTAR2);
    }
    exports3.hasGlobStar = hasGlobStar2;
    function endsWithSlashGlobStar2(pattern2) {
      return pattern2.endsWith("/" + GLOBSTAR2);
    }
    exports3.endsWithSlashGlobStar = endsWithSlashGlobStar2;
    function isAffectDepthOfReadingPattern2(pattern2) {
      const basename2 = path8.basename(pattern2);
      return endsWithSlashGlobStar2(pattern2) || isStaticPattern2(basename2);
    }
    exports3.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern2;
    function expandPatternsWithBraceExpansion2(patterns2) {
      return patterns2.reduce((collection, pattern2) => {
        return collection.concat(expandBraceExpansion2(pattern2));
      }, []);
    }
    exports3.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion2;
    function expandBraceExpansion2(pattern2) {
      return micromatch2.braces(pattern2, {
        expand: true,
        nodupes: true
      });
    }
    exports3.expandBraceExpansion = expandBraceExpansion2;
    function getPatternParts2(pattern2, options3) {
      let { parts } = micromatch2.scan(pattern2, Object.assign(Object.assign({}, options3), { parts: true }));
      if (parts.length === 0) {
        parts = [pattern2];
      }
      if (parts[0].startsWith("/")) {
        parts[0] = parts[0].slice(1);
        parts.unshift("");
      }
      return parts;
    }
    exports3.getPatternParts = getPatternParts2;
    function makeRe2(pattern2, options3) {
      return micromatch2.makeRe(pattern2, options3);
    }
    exports3.makeRe = makeRe2;
    function convertPatternsToRe2(patterns2, options3) {
      return patterns2.map((pattern2) => makeRe2(pattern2, options3));
    }
    exports3.convertPatternsToRe = convertPatternsToRe2;
    function matchAny2(entry2, patternsRe) {
      return patternsRe.some((patternRe) => patternRe.test(entry2));
    }
    exports3.matchAny = matchAny2;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/stream.js
var require_stream2 = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/stream.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    exports3.merge = void 0;
    var merge23 = require_merge2();
    function merge3(streams) {
      const mergedStream = merge23(streams);
      streams.forEach((stream4) => {
        stream4.once("error", (error3) => mergedStream.emit("error", error3));
      });
      mergedStream.once("close", () => propagateCloseEventToSources2(streams));
      mergedStream.once("end", () => propagateCloseEventToSources2(streams));
      return mergedStream;
    }
    exports3.merge = merge3;
    function propagateCloseEventToSources2(streams) {
      streams.forEach((stream4) => stream4.emit("close"));
    }
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/string.js
var require_string = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/string.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    exports3.isEmpty = exports3.isString = void 0;
    function isString3(input) {
      return typeof input === "string";
    }
    exports3.isString = isString3;
    function isEmpty3(input) {
      return input === "";
    }
    exports3.isEmpty = isEmpty3;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/index.js
var require_utils5 = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/utils/index.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    exports3.string = exports3.stream = exports3.pattern = exports3.path = exports3.fs = exports3.errno = exports3.array = void 0;
    var array2 = require_array();
    exports3.array = array2;
    var errno2 = require_errno();
    exports3.errno = errno2;
    var fs6 = require_fs3();
    exports3.fs = fs6;
    var path8 = require_path2();
    exports3.path = path8;
    var pattern2 = require_pattern();
    exports3.pattern = pattern2;
    var stream4 = require_stream2();
    exports3.stream = stream4;
    var string3 = require_string();
    exports3.string = string3;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/managers/tasks.js
var require_tasks = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/managers/tasks.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    exports3.convertPatternGroupToTask = exports3.convertPatternGroupsToTasks = exports3.groupPatternsByBaseDirectory = exports3.getNegativePatternsAsPositive = exports3.getPositivePatterns = exports3.convertPatternsToTasks = exports3.generate = void 0;
    var utils2 = require_utils5();
    function generate2(patterns2, settings2) {
      const positivePatterns = getPositivePatterns2(patterns2);
      const negativePatterns = getNegativePatternsAsPositive2(patterns2, settings2.ignore);
      const staticPatterns = positivePatterns.filter((pattern2) => utils2.pattern.isStaticPattern(pattern2, settings2));
      const dynamicPatterns = positivePatterns.filter((pattern2) => utils2.pattern.isDynamicPattern(pattern2, settings2));
      const staticTasks = convertPatternsToTasks2(
        staticPatterns,
        negativePatterns,
        /* dynamic */
        false
      );
      const dynamicTasks = convertPatternsToTasks2(
        dynamicPatterns,
        negativePatterns,
        /* dynamic */
        true
      );
      return staticTasks.concat(dynamicTasks);
    }
    exports3.generate = generate2;
    function convertPatternsToTasks2(positive, negative, dynamic) {
      const tasks2 = [];
      const patternsOutsideCurrentDirectory = utils2.pattern.getPatternsOutsideCurrentDirectory(positive);
      const patternsInsideCurrentDirectory = utils2.pattern.getPatternsInsideCurrentDirectory(positive);
      const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory2(patternsOutsideCurrentDirectory);
      const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory2(patternsInsideCurrentDirectory);
      tasks2.push(...convertPatternGroupsToTasks2(outsideCurrentDirectoryGroup, negative, dynamic));
      if ("." in insideCurrentDirectoryGroup) {
        tasks2.push(convertPatternGroupToTask2(".", patternsInsideCurrentDirectory, negative, dynamic));
      } else {
        tasks2.push(...convertPatternGroupsToTasks2(insideCurrentDirectoryGroup, negative, dynamic));
      }
      return tasks2;
    }
    exports3.convertPatternsToTasks = convertPatternsToTasks2;
    function getPositivePatterns2(patterns2) {
      return utils2.pattern.getPositivePatterns(patterns2);
    }
    exports3.getPositivePatterns = getPositivePatterns2;
    function getNegativePatternsAsPositive2(patterns2, ignore2) {
      const negative = utils2.pattern.getNegativePatterns(patterns2).concat(ignore2);
      const positive = negative.map(utils2.pattern.convertToPositivePattern);
      return positive;
    }
    exports3.getNegativePatternsAsPositive = getNegativePatternsAsPositive2;
    function groupPatternsByBaseDirectory2(patterns2) {
      const group = {};
      return patterns2.reduce((collection, pattern2) => {
        const base2 = utils2.pattern.getBaseDirectory(pattern2);
        if (base2 in collection) {
          collection[base2].push(pattern2);
        } else {
          collection[base2] = [pattern2];
        }
        return collection;
      }, group);
    }
    exports3.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory2;
    function convertPatternGroupsToTasks2(positive, negative, dynamic) {
      return Object.keys(positive).map((base2) => {
        return convertPatternGroupToTask2(base2, positive[base2], negative, dynamic);
      });
    }
    exports3.convertPatternGroupsToTasks = convertPatternGroupsToTasks2;
    function convertPatternGroupToTask2(base2, positive, negative, dynamic) {
      return {
        dynamic,
        positive,
        negative,
        base: base2,
        patterns: [].concat(positive, negative.map(utils2.pattern.convertToNegativePattern))
      };
    }
    exports3.convertPatternGroupToTask = convertPatternGroupToTask2;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/managers/patterns.js
var require_patterns = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/managers/patterns.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    exports3.removeDuplicateSlashes = exports3.transform = void 0;
    var DOUBLE_SLASH_RE2 = /(?!^)\/{2,}/g;
    function transform2(patterns2) {
      return patterns2.map((pattern2) => removeDuplicateSlashes2(pattern2));
    }
    exports3.transform = transform2;
    function removeDuplicateSlashes2(pattern2) {
      return pattern2.replace(DOUBLE_SLASH_RE2, "/");
    }
    exports3.removeDuplicateSlashes = removeDuplicateSlashes2;
  }
});

// node_modules/.pnpm/@nodelib+fs.stat@2.0.5/node_modules/@nodelib/fs.stat/out/providers/async.js
var require_async = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.stat@2.0.5/node_modules/@nodelib/fs.stat/out/providers/async.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    exports3.read = void 0;
    function read2(path8, settings2, callback) {
      settings2.fs.lstat(path8, (lstatError, lstat2) => {
        if (lstatError !== null) {
          callFailureCallback2(callback, lstatError);
          return;
        }
        if (!lstat2.isSymbolicLink() || !settings2.followSymbolicLink) {
          callSuccessCallback2(callback, lstat2);
          return;
        }
        settings2.fs.stat(path8, (statError, stat2) => {
          if (statError !== null) {
            if (settings2.throwErrorOnBrokenSymbolicLink) {
              callFailureCallback2(callback, statError);
              return;
            }
            callSuccessCallback2(callback, lstat2);
            return;
          }
          if (settings2.markSymbolicLink) {
            stat2.isSymbolicLink = () => true;
          }
          callSuccessCallback2(callback, stat2);
        });
      });
    }
    exports3.read = read2;
    function callFailureCallback2(callback, error3) {
      callback(error3);
    }
    function callSuccessCallback2(callback, result) {
      callback(null, result);
    }
  }
});

// node_modules/.pnpm/@nodelib+fs.stat@2.0.5/node_modules/@nodelib/fs.stat/out/providers/sync.js
var require_sync = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.stat@2.0.5/node_modules/@nodelib/fs.stat/out/providers/sync.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    exports3.read = void 0;
    function read2(path8, settings2) {
      const lstat2 = settings2.fs.lstatSync(path8);
      if (!lstat2.isSymbolicLink() || !settings2.followSymbolicLink) {
        return lstat2;
      }
      try {
        const stat2 = settings2.fs.statSync(path8);
        if (settings2.markSymbolicLink) {
          stat2.isSymbolicLink = () => true;
        }
        return stat2;
      } catch (error3) {
        if (!settings2.throwErrorOnBrokenSymbolicLink) {
          return lstat2;
        }
        throw error3;
      }
    }
    exports3.read = read2;
  }
});

// node_modules/.pnpm/@nodelib+fs.stat@2.0.5/node_modules/@nodelib/fs.stat/out/adapters/fs.js
var require_fs4 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.stat@2.0.5/node_modules/@nodelib/fs.stat/out/adapters/fs.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    exports3.createFileSystemAdapter = exports3.FILE_SYSTEM_ADAPTER = void 0;
    var fs6 = require_fs();
    exports3.FILE_SYSTEM_ADAPTER = {
      lstat: fs6.lstat,
      stat: fs6.stat,
      lstatSync: fs6.lstatSync,
      statSync: fs6.statSync
    };
    function createFileSystemAdapter(fsMethods) {
      if (fsMethods === void 0) {
        return exports3.FILE_SYSTEM_ADAPTER;
      }
      return Object.assign(Object.assign({}, exports3.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports3.createFileSystemAdapter = createFileSystemAdapter;
  }
});

// node_modules/.pnpm/@nodelib+fs.stat@2.0.5/node_modules/@nodelib/fs.stat/out/settings.js
var require_settings = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.stat@2.0.5/node_modules/@nodelib/fs.stat/out/settings.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    var fs6 = require_fs4();
    var Settings4 = class {
      constructor(_options2 = {}) {
        this._options = _options2;
        this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
        this.fs = fs6.createFileSystemAdapter(this._options.fs);
        this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
      }
      _getValue(option, value2) {
        return option !== null && option !== void 0 ? option : value2;
      }
    };
    exports3.default = Settings4;
  }
});

// node_modules/.pnpm/@nodelib+fs.stat@2.0.5/node_modules/@nodelib/fs.stat/out/index.js
var require_out = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.stat@2.0.5/node_modules/@nodelib/fs.stat/out/index.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    exports3.statSync = exports3.stat = exports3.Settings = void 0;
    var async2 = require_async();
    var sync2 = require_sync();
    var settings_12 = require_settings();
    exports3.Settings = settings_12.default;
    function stat2(path8, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        async2.read(path8, getSettings2(), optionsOrSettingsOrCallback);
        return;
      }
      async2.read(path8, getSettings2(optionsOrSettingsOrCallback), callback);
    }
    exports3.stat = stat2;
    function statSync3(path8, optionsOrSettings) {
      const settings2 = getSettings2(optionsOrSettings);
      return sync2.read(path8, settings2);
    }
    exports3.statSync = statSync3;
    function getSettings2(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_12.default) {
        return settingsOrOptions;
      }
      return new settings_12.default(settingsOrOptions);
    }
  }
});

// node_modules/.pnpm/queue-microtask@1.2.3/node_modules/queue-microtask/index.js
var require_queue_microtask = __commonJS({
  "node_modules/.pnpm/queue-microtask@1.2.3/node_modules/queue-microtask/index.js"(exports3, module2) {
    var promise2;
    module2.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : global) : (cb) => (promise2 || (promise2 = Promise.resolve())).then(cb).catch((err2) => setTimeout(() => {
      throw err2;
    }, 0));
  }
});

// node_modules/.pnpm/run-parallel@1.2.0/node_modules/run-parallel/index.js
var require_run_parallel = __commonJS({
  "node_modules/.pnpm/run-parallel@1.2.0/node_modules/run-parallel/index.js"(exports3, module2) {
    module2.exports = runParallel2;
    var queueMicrotask2 = require_queue_microtask();
    function runParallel2(tasks2, cb) {
      let results, pending, keys;
      let isSync = true;
      if (Array.isArray(tasks2)) {
        results = [];
        pending = tasks2.length;
      } else {
        keys = Object.keys(tasks2);
        results = {};
        pending = keys.length;
      }
      function done(err2) {
        function end() {
          if (cb)
            cb(err2, results);
          cb = null;
        }
        if (isSync)
          queueMicrotask2(end);
        else
          end();
      }
      function each(i2, err2, result) {
        results[i2] = result;
        if (--pending === 0 || err2) {
          done(err2);
        }
      }
      if (!pending) {
        done(null);
      } else if (keys) {
        keys.forEach(function(key) {
          tasks2[key](function(err2, result) {
            each(key, err2, result);
          });
        });
      } else {
        tasks2.forEach(function(task, i2) {
          task(function(err2, result) {
            each(i2, err2, result);
          });
        });
      }
      isSync = false;
    }
  }
});

// node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/constants.js
var require_constants4 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/constants.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    exports3.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
    var NODE_PROCESS_VERSION_PARTS2 = process.versions.node.split(".");
    if (NODE_PROCESS_VERSION_PARTS2[0] === void 0 || NODE_PROCESS_VERSION_PARTS2[1] === void 0) {
      throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
    }
    var MAJOR_VERSION2 = Number.parseInt(NODE_PROCESS_VERSION_PARTS2[0], 10);
    var MINOR_VERSION2 = Number.parseInt(NODE_PROCESS_VERSION_PARTS2[1], 10);
    var SUPPORTED_MAJOR_VERSION2 = 10;
    var SUPPORTED_MINOR_VERSION2 = 10;
    var IS_MATCHED_BY_MAJOR2 = MAJOR_VERSION2 > SUPPORTED_MAJOR_VERSION2;
    var IS_MATCHED_BY_MAJOR_AND_MINOR2 = MAJOR_VERSION2 === SUPPORTED_MAJOR_VERSION2 && MINOR_VERSION2 >= SUPPORTED_MINOR_VERSION2;
    exports3.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR2 || IS_MATCHED_BY_MAJOR_AND_MINOR2;
  }
});

// node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/utils/fs.js
var require_fs5 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/utils/fs.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    exports3.createDirentFromStats = void 0;
    var DirentFromStats3 = class {
      constructor(name2, stats) {
        this.name = name2;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats2(name2, stats) {
      return new DirentFromStats3(name2, stats);
    }
    exports3.createDirentFromStats = createDirentFromStats2;
  }
});

// node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/utils/index.js
var require_utils6 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/utils/index.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    exports3.fs = void 0;
    var fs6 = require_fs5();
    exports3.fs = fs6;
  }
});

// node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/providers/common.js
var require_common2 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/providers/common.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    exports3.joinPathSegments = void 0;
    function joinPathSegments2(a2, b, separator) {
      if (a2.endsWith(separator)) {
        return a2 + b;
      }
      return a2 + separator + b;
    }
    exports3.joinPathSegments = joinPathSegments2;
  }
});

// node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/providers/async.js
var require_async2 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/providers/async.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    exports3.readdir = exports3.readdirWithFileTypes = exports3.read = void 0;
    var fsStat2 = require_out();
    var rpl2 = require_run_parallel();
    var constants_12 = require_constants4();
    var utils2 = require_utils6();
    var common3 = require_common2();
    function read2(directory, settings2, callback) {
      if (!settings2.stats && constants_12.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        readdirWithFileTypes2(directory, settings2, callback);
        return;
      }
      readdir2(directory, settings2, callback);
    }
    exports3.read = read2;
    function readdirWithFileTypes2(directory, settings2, callback) {
      settings2.fs.readdir(directory, { withFileTypes: true }, (readdirError, dirents) => {
        if (readdirError !== null) {
          callFailureCallback2(callback, readdirError);
          return;
        }
        const entries = dirents.map((dirent) => ({
          dirent,
          name: dirent.name,
          path: common3.joinPathSegments(directory, dirent.name, settings2.pathSegmentSeparator)
        }));
        if (!settings2.followSymbolicLinks) {
          callSuccessCallback2(callback, entries);
          return;
        }
        const tasks2 = entries.map((entry2) => makeRplTaskEntry2(entry2, settings2));
        rpl2(tasks2, (rplError, rplEntries) => {
          if (rplError !== null) {
            callFailureCallback2(callback, rplError);
            return;
          }
          callSuccessCallback2(callback, rplEntries);
        });
      });
    }
    exports3.readdirWithFileTypes = readdirWithFileTypes2;
    function makeRplTaskEntry2(entry2, settings2) {
      return (done) => {
        if (!entry2.dirent.isSymbolicLink()) {
          done(null, entry2);
          return;
        }
        settings2.fs.stat(entry2.path, (statError, stats) => {
          if (statError !== null) {
            if (settings2.throwErrorOnBrokenSymbolicLink) {
              done(statError);
              return;
            }
            done(null, entry2);
            return;
          }
          entry2.dirent = utils2.fs.createDirentFromStats(entry2.name, stats);
          done(null, entry2);
        });
      };
    }
    function readdir2(directory, settings2, callback) {
      settings2.fs.readdir(directory, (readdirError, names) => {
        if (readdirError !== null) {
          callFailureCallback2(callback, readdirError);
          return;
        }
        const tasks2 = names.map((name2) => {
          const path8 = common3.joinPathSegments(directory, name2, settings2.pathSegmentSeparator);
          return (done) => {
            fsStat2.stat(path8, settings2.fsStatSettings, (error3, stats) => {
              if (error3 !== null) {
                done(error3);
                return;
              }
              const entry2 = {
                name: name2,
                path: path8,
                dirent: utils2.fs.createDirentFromStats(name2, stats)
              };
              if (settings2.stats) {
                entry2.stats = stats;
              }
              done(null, entry2);
            });
          };
        });
        rpl2(tasks2, (rplError, entries) => {
          if (rplError !== null) {
            callFailureCallback2(callback, rplError);
            return;
          }
          callSuccessCallback2(callback, entries);
        });
      });
    }
    exports3.readdir = readdir2;
    function callFailureCallback2(callback, error3) {
      callback(error3);
    }
    function callSuccessCallback2(callback, result) {
      callback(null, result);
    }
  }
});

// node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/providers/sync.js
var require_sync2 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/providers/sync.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    exports3.readdir = exports3.readdirWithFileTypes = exports3.read = void 0;
    var fsStat2 = require_out();
    var constants_12 = require_constants4();
    var utils2 = require_utils6();
    var common3 = require_common2();
    function read2(directory, settings2) {
      if (!settings2.stats && constants_12.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        return readdirWithFileTypes2(directory, settings2);
      }
      return readdir2(directory, settings2);
    }
    exports3.read = read2;
    function readdirWithFileTypes2(directory, settings2) {
      const dirents = settings2.fs.readdirSync(directory, { withFileTypes: true });
      return dirents.map((dirent) => {
        const entry2 = {
          dirent,
          name: dirent.name,
          path: common3.joinPathSegments(directory, dirent.name, settings2.pathSegmentSeparator)
        };
        if (entry2.dirent.isSymbolicLink() && settings2.followSymbolicLinks) {
          try {
            const stats = settings2.fs.statSync(entry2.path);
            entry2.dirent = utils2.fs.createDirentFromStats(entry2.name, stats);
          } catch (error3) {
            if (settings2.throwErrorOnBrokenSymbolicLink) {
              throw error3;
            }
          }
        }
        return entry2;
      });
    }
    exports3.readdirWithFileTypes = readdirWithFileTypes2;
    function readdir2(directory, settings2) {
      const names = settings2.fs.readdirSync(directory);
      return names.map((name2) => {
        const entryPath = common3.joinPathSegments(directory, name2, settings2.pathSegmentSeparator);
        const stats = fsStat2.statSync(entryPath, settings2.fsStatSettings);
        const entry2 = {
          name: name2,
          path: entryPath,
          dirent: utils2.fs.createDirentFromStats(name2, stats)
        };
        if (settings2.stats) {
          entry2.stats = stats;
        }
        return entry2;
      });
    }
    exports3.readdir = readdir2;
  }
});

// node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/adapters/fs.js
var require_fs6 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/adapters/fs.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    exports3.createFileSystemAdapter = exports3.FILE_SYSTEM_ADAPTER = void 0;
    var fs6 = require_fs();
    exports3.FILE_SYSTEM_ADAPTER = {
      lstat: fs6.lstat,
      stat: fs6.stat,
      lstatSync: fs6.lstatSync,
      statSync: fs6.statSync,
      readdir: fs6.readdir,
      readdirSync: fs6.readdirSync
    };
    function createFileSystemAdapter(fsMethods) {
      if (fsMethods === void 0) {
        return exports3.FILE_SYSTEM_ADAPTER;
      }
      return Object.assign(Object.assign({}, exports3.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports3.createFileSystemAdapter = createFileSystemAdapter;
  }
});

// node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/settings.js
var require_settings2 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/settings.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    var path8 = require_path();
    var fsStat2 = require_out();
    var fs6 = require_fs6();
    var Settings4 = class {
      constructor(_options2 = {}) {
        this._options = _options2;
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
        this.fs = fs6.createFileSystemAdapter(this._options.fs);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path8.sep);
        this.stats = this._getValue(this._options.stats, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
        this.fsStatSettings = new fsStat2.Settings({
          followSymbolicLink: this.followSymbolicLinks,
          fs: this.fs,
          throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value2) {
        return option !== null && option !== void 0 ? option : value2;
      }
    };
    exports3.default = Settings4;
  }
});

// node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/index.js
var require_out2 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.scandir@2.1.5/node_modules/@nodelib/fs.scandir/out/index.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    exports3.Settings = exports3.scandirSync = exports3.scandir = void 0;
    var async2 = require_async2();
    var sync2 = require_sync2();
    var settings_12 = require_settings2();
    exports3.Settings = settings_12.default;
    function scandir2(path8, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        async2.read(path8, getSettings2(), optionsOrSettingsOrCallback);
        return;
      }
      async2.read(path8, getSettings2(optionsOrSettingsOrCallback), callback);
    }
    exports3.scandir = scandir2;
    function scandirSync2(path8, optionsOrSettings) {
      const settings2 = getSettings2(optionsOrSettings);
      return sync2.read(path8, settings2);
    }
    exports3.scandirSync = scandirSync2;
    function getSettings2(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_12.default) {
        return settingsOrOptions;
      }
      return new settings_12.default(settingsOrOptions);
    }
  }
});

// node_modules/.pnpm/reusify@1.0.4/node_modules/reusify/reusify.js
var require_reusify = __commonJS({
  "node_modules/.pnpm/reusify@1.0.4/node_modules/reusify/reusify.js"(exports3, module2) {
    "use strict";
    function reusify2(Constructor) {
      var head = new Constructor();
      var tail = head;
      function get3() {
        var current2 = head;
        if (current2.next) {
          head = current2.next;
        } else {
          head = new Constructor();
          tail = head;
        }
        current2.next = null;
        return current2;
      }
      function release(obj) {
        tail.next = obj;
        tail = obj;
      }
      return {
        get: get3,
        release
      };
    }
    module2.exports = reusify2;
  }
});

// node_modules/.pnpm/fastq@1.15.0/node_modules/fastq/queue.js
var require_queue = __commonJS({
  "node_modules/.pnpm/fastq@1.15.0/node_modules/fastq/queue.js"(exports3, module2) {
    "use strict";
    var reusify2 = require_reusify();
    function fastqueue2(context, worker, concurrency) {
      if (typeof context === "function") {
        concurrency = worker;
        worker = context;
        context = null;
      }
      if (concurrency < 1) {
        throw new Error("fastqueue concurrency must be greater than 1");
      }
      var cache2 = reusify2(Task2);
      var queueHead = null;
      var queueTail = null;
      var _running = 0;
      var errorHandler = null;
      var self2 = {
        push: push2,
        drain: noop2,
        saturated: noop2,
        pause,
        paused: false,
        concurrency,
        running,
        resume: resume2,
        idle,
        length,
        getQueue,
        unshift,
        empty: noop2,
        kill,
        killAndDrain,
        error: error3
      };
      return self2;
      function running() {
        return _running;
      }
      function pause() {
        self2.paused = true;
      }
      function length() {
        var current2 = queueHead;
        var counter = 0;
        while (current2) {
          current2 = current2.next;
          counter++;
        }
        return counter;
      }
      function getQueue() {
        var current2 = queueHead;
        var tasks2 = [];
        while (current2) {
          tasks2.push(current2.value);
          current2 = current2.next;
        }
        return tasks2;
      }
      function resume2() {
        if (!self2.paused)
          return;
        self2.paused = false;
        for (var i2 = 0; i2 < self2.concurrency; i2++) {
          _running++;
          release();
        }
      }
      function idle() {
        return _running === 0 && self2.length() === 0;
      }
      function push2(value2, done) {
        var current2 = cache2.get();
        current2.context = context;
        current2.release = release;
        current2.value = value2;
        current2.callback = done || noop2;
        current2.errorHandler = errorHandler;
        if (_running === self2.concurrency || self2.paused) {
          if (queueTail) {
            queueTail.next = current2;
            queueTail = current2;
          } else {
            queueHead = current2;
            queueTail = current2;
            self2.saturated();
          }
        } else {
          _running++;
          worker.call(context, current2.value, current2.worked);
        }
      }
      function unshift(value2, done) {
        var current2 = cache2.get();
        current2.context = context;
        current2.release = release;
        current2.value = value2;
        current2.callback = done || noop2;
        if (_running === self2.concurrency || self2.paused) {
          if (queueHead) {
            current2.next = queueHead;
            queueHead = current2;
          } else {
            queueHead = current2;
            queueTail = current2;
            self2.saturated();
          }
        } else {
          _running++;
          worker.call(context, current2.value, current2.worked);
        }
      }
      function release(holder) {
        if (holder) {
          cache2.release(holder);
        }
        var next = queueHead;
        if (next) {
          if (!self2.paused) {
            if (queueTail === queueHead) {
              queueTail = null;
            }
            queueHead = next.next;
            next.next = null;
            worker.call(context, next.value, next.worked);
            if (queueTail === null) {
              self2.empty();
            }
          } else {
            _running--;
          }
        } else if (--_running === 0) {
          self2.drain();
        }
      }
      function kill() {
        queueHead = null;
        queueTail = null;
        self2.drain = noop2;
      }
      function killAndDrain() {
        queueHead = null;
        queueTail = null;
        self2.drain();
        self2.drain = noop2;
      }
      function error3(handler) {
        errorHandler = handler;
      }
    }
    function noop2() {
    }
    function Task2() {
      this.value = null;
      this.callback = noop2;
      this.next = null;
      this.release = noop2;
      this.context = null;
      this.errorHandler = null;
      var self2 = this;
      this.worked = function worked(err2, result) {
        var callback = self2.callback;
        var errorHandler = self2.errorHandler;
        var val = self2.value;
        self2.value = null;
        self2.callback = noop2;
        if (self2.errorHandler) {
          errorHandler(err2, val);
        }
        callback.call(self2.context, err2, result);
        self2.release(self2);
      };
    }
    function queueAsPromised2(context, worker, concurrency) {
      if (typeof context === "function") {
        concurrency = worker;
        worker = context;
        context = null;
      }
      function asyncWrapper(arg, cb) {
        worker.call(this, arg).then(function(res) {
          cb(null, res);
        }, cb);
      }
      var queue2 = fastqueue2(context, asyncWrapper, concurrency);
      var pushCb = queue2.push;
      var unshiftCb = queue2.unshift;
      queue2.push = push2;
      queue2.unshift = unshift;
      queue2.drained = drained;
      return queue2;
      function push2(value2) {
        var p2 = new Promise(function(resolve4, reject) {
          pushCb(value2, function(err2, result) {
            if (err2) {
              reject(err2);
              return;
            }
            resolve4(result);
          });
        });
        p2.catch(noop2);
        return p2;
      }
      function unshift(value2) {
        var p2 = new Promise(function(resolve4, reject) {
          unshiftCb(value2, function(err2, result) {
            if (err2) {
              reject(err2);
              return;
            }
            resolve4(result);
          });
        });
        p2.catch(noop2);
        return p2;
      }
      function drained() {
        if (queue2.idle()) {
          return new Promise(function(resolve4) {
            resolve4();
          });
        }
        var previousDrain = queue2.drain;
        var p2 = new Promise(function(resolve4) {
          queue2.drain = function() {
            previousDrain();
            resolve4();
          };
        });
        return p2;
      }
    }
    module2.exports = fastqueue2;
    module2.exports.promise = queueAsPromised2;
  }
});

// node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/readers/common.js
var require_common3 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/readers/common.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    exports3.joinPathSegments = exports3.replacePathSegmentSeparator = exports3.isAppliedFilter = exports3.isFatalError = void 0;
    function isFatalError2(settings2, error3) {
      if (settings2.errorFilter === null) {
        return true;
      }
      return !settings2.errorFilter(error3);
    }
    exports3.isFatalError = isFatalError2;
    function isAppliedFilter2(filter2, value2) {
      return filter2 === null || filter2(value2);
    }
    exports3.isAppliedFilter = isAppliedFilter2;
    function replacePathSegmentSeparator2(filepath, separator) {
      return filepath.split(/[/\\]/).join(separator);
    }
    exports3.replacePathSegmentSeparator = replacePathSegmentSeparator2;
    function joinPathSegments2(a2, b, separator) {
      if (a2 === "") {
        return b;
      }
      if (a2.endsWith(separator)) {
        return a2 + b;
      }
      return a2 + separator + b;
    }
    exports3.joinPathSegments = joinPathSegments2;
  }
});

// node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/readers/reader.js
var require_reader = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/readers/reader.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    var common3 = require_common3();
    var Reader3 = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._root = common3.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
      }
    };
    exports3.default = Reader3;
  }
});

// node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/readers/async.js
var require_async3 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/readers/async.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    var events_12 = require_events();
    var fsScandir2 = require_out2();
    var fastq2 = require_queue();
    var common3 = require_common3();
    var reader_12 = require_reader();
    var AsyncReader2 = class extends reader_12.default {
      constructor(_root, _settings) {
        super(_root, _settings);
        this._settings = _settings;
        this._scandir = fsScandir2.scandir;
        this._emitter = new events_12.EventEmitter();
        this._queue = fastq2(this._worker.bind(this), this._settings.concurrency);
        this._isFatalError = false;
        this._isDestroyed = false;
        this._queue.drain = () => {
          if (!this._isFatalError) {
            this._emitter.emit("end");
          }
        };
      }
      read() {
        this._isFatalError = false;
        this._isDestroyed = false;
        setImmediate(() => {
          this._pushToQueue(this._root, this._settings.basePath);
        });
        return this._emitter;
      }
      get isDestroyed() {
        return this._isDestroyed;
      }
      destroy() {
        if (this._isDestroyed) {
          throw new Error("The reader is already destroyed");
        }
        this._isDestroyed = true;
        this._queue.killAndDrain();
      }
      onEntry(callback) {
        this._emitter.on("entry", callback);
      }
      onError(callback) {
        this._emitter.once("error", callback);
      }
      onEnd(callback) {
        this._emitter.once("end", callback);
      }
      _pushToQueue(directory, base2) {
        const queueItem = { directory, base: base2 };
        this._queue.push(queueItem, (error3) => {
          if (error3 !== null) {
            this._handleError(error3);
          }
        });
      }
      _worker(item, done) {
        this._scandir(item.directory, this._settings.fsScandirSettings, (error3, entries) => {
          if (error3 !== null) {
            done(error3, void 0);
            return;
          }
          for (const entry2 of entries) {
            this._handleEntry(entry2, item.base);
          }
          done(null, void 0);
        });
      }
      _handleError(error3) {
        if (this._isDestroyed || !common3.isFatalError(this._settings, error3)) {
          return;
        }
        this._isFatalError = true;
        this._isDestroyed = true;
        this._emitter.emit("error", error3);
      }
      _handleEntry(entry2, base2) {
        if (this._isDestroyed || this._isFatalError) {
          return;
        }
        const fullpath = entry2.path;
        if (base2 !== void 0) {
          entry2.path = common3.joinPathSegments(base2, entry2.name, this._settings.pathSegmentSeparator);
        }
        if (common3.isAppliedFilter(this._settings.entryFilter, entry2)) {
          this._emitEntry(entry2);
        }
        if (entry2.dirent.isDirectory() && common3.isAppliedFilter(this._settings.deepFilter, entry2)) {
          this._pushToQueue(fullpath, base2 === void 0 ? void 0 : entry2.path);
        }
      }
      _emitEntry(entry2) {
        this._emitter.emit("entry", entry2);
      }
    };
    exports3.default = AsyncReader2;
  }
});

// node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/providers/async.js
var require_async4 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/providers/async.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    var async_12 = require_async3();
    var AsyncProvider2 = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_12.default(this._root, this._settings);
        this._storage = [];
      }
      read(callback) {
        this._reader.onError((error3) => {
          callFailureCallback2(callback, error3);
        });
        this._reader.onEntry((entry2) => {
          this._storage.push(entry2);
        });
        this._reader.onEnd(() => {
          callSuccessCallback2(callback, this._storage);
        });
        this._reader.read();
      }
    };
    exports3.default = AsyncProvider2;
    function callFailureCallback2(callback, error3) {
      callback(error3);
    }
    function callSuccessCallback2(callback, entries) {
      callback(null, entries);
    }
  }
});

// node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/providers/stream.js
var require_stream3 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/providers/stream.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    var stream_12 = require_stream();
    var async_12 = require_async3();
    var StreamProvider2 = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_12.default(this._root, this._settings);
        this._stream = new stream_12.Readable({
          objectMode: true,
          read: () => {
          },
          destroy: () => {
            if (!this._reader.isDestroyed) {
              this._reader.destroy();
            }
          }
        });
      }
      read() {
        this._reader.onError((error3) => {
          this._stream.emit("error", error3);
        });
        this._reader.onEntry((entry2) => {
          this._stream.push(entry2);
        });
        this._reader.onEnd(() => {
          this._stream.push(null);
        });
        this._reader.read();
        return this._stream;
      }
    };
    exports3.default = StreamProvider2;
  }
});

// node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/readers/sync.js
var require_sync3 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/readers/sync.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    var fsScandir2 = require_out2();
    var common3 = require_common3();
    var reader_12 = require_reader();
    var SyncReader2 = class extends reader_12.default {
      constructor() {
        super(...arguments);
        this._scandir = fsScandir2.scandirSync;
        this._storage = [];
        this._queue = /* @__PURE__ */ new Set();
      }
      read() {
        this._pushToQueue(this._root, this._settings.basePath);
        this._handleQueue();
        return this._storage;
      }
      _pushToQueue(directory, base2) {
        this._queue.add({ directory, base: base2 });
      }
      _handleQueue() {
        for (const item of this._queue.values()) {
          this._handleDirectory(item.directory, item.base);
        }
      }
      _handleDirectory(directory, base2) {
        try {
          const entries = this._scandir(directory, this._settings.fsScandirSettings);
          for (const entry2 of entries) {
            this._handleEntry(entry2, base2);
          }
        } catch (error3) {
          this._handleError(error3);
        }
      }
      _handleError(error3) {
        if (!common3.isFatalError(this._settings, error3)) {
          return;
        }
        throw error3;
      }
      _handleEntry(entry2, base2) {
        const fullpath = entry2.path;
        if (base2 !== void 0) {
          entry2.path = common3.joinPathSegments(base2, entry2.name, this._settings.pathSegmentSeparator);
        }
        if (common3.isAppliedFilter(this._settings.entryFilter, entry2)) {
          this._pushToStorage(entry2);
        }
        if (entry2.dirent.isDirectory() && common3.isAppliedFilter(this._settings.deepFilter, entry2)) {
          this._pushToQueue(fullpath, base2 === void 0 ? void 0 : entry2.path);
        }
      }
      _pushToStorage(entry2) {
        this._storage.push(entry2);
      }
    };
    exports3.default = SyncReader2;
  }
});

// node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/providers/sync.js
var require_sync4 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/providers/sync.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    var sync_12 = require_sync3();
    var SyncProvider2 = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new sync_12.default(this._root, this._settings);
      }
      read() {
        return this._reader.read();
      }
    };
    exports3.default = SyncProvider2;
  }
});

// node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/settings.js
var require_settings3 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/settings.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    var path8 = require_path();
    var fsScandir2 = require_out2();
    var Settings4 = class {
      constructor(_options2 = {}) {
        this._options = _options2;
        this.basePath = this._getValue(this._options.basePath, void 0);
        this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY);
        this.deepFilter = this._getValue(this._options.deepFilter, null);
        this.entryFilter = this._getValue(this._options.entryFilter, null);
        this.errorFilter = this._getValue(this._options.errorFilter, null);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path8.sep);
        this.fsScandirSettings = new fsScandir2.Settings({
          followSymbolicLinks: this._options.followSymbolicLinks,
          fs: this._options.fs,
          pathSegmentSeparator: this._options.pathSegmentSeparator,
          stats: this._options.stats,
          throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value2) {
        return option !== null && option !== void 0 ? option : value2;
      }
    };
    exports3.default = Settings4;
  }
});

// node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/index.js
var require_out3 = __commonJS({
  "node_modules/.pnpm/@nodelib+fs.walk@1.2.8/node_modules/@nodelib/fs.walk/out/index.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    exports3.Settings = exports3.walkStream = exports3.walkSync = exports3.walk = void 0;
    var async_12 = require_async4();
    var stream_12 = require_stream3();
    var sync_12 = require_sync4();
    var settings_12 = require_settings3();
    exports3.Settings = settings_12.default;
    function walk2(directory, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        new async_12.default(directory, getSettings2()).read(optionsOrSettingsOrCallback);
        return;
      }
      new async_12.default(directory, getSettings2(optionsOrSettingsOrCallback)).read(callback);
    }
    exports3.walk = walk2;
    function walkSync2(directory, optionsOrSettings) {
      const settings2 = getSettings2(optionsOrSettings);
      const provider2 = new sync_12.default(directory, settings2);
      return provider2.read();
    }
    exports3.walkSync = walkSync2;
    function walkStream2(directory, optionsOrSettings) {
      const settings2 = getSettings2(optionsOrSettings);
      const provider2 = new stream_12.default(directory, settings2);
      return provider2.read();
    }
    exports3.walkStream = walkStream2;
    function getSettings2(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_12.default) {
        return settingsOrOptions;
      }
      return new settings_12.default(settingsOrOptions);
    }
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/readers/reader.js
var require_reader2 = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/readers/reader.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    var path8 = require_path();
    var fsStat2 = require_out();
    var utils2 = require_utils5();
    var Reader3 = class {
      constructor(_settings) {
        this._settings = _settings;
        this._fsStatSettings = new fsStat2.Settings({
          followSymbolicLink: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
        });
      }
      _getFullEntryPath(filepath) {
        return path8.resolve(this._settings.cwd, filepath);
      }
      _makeEntry(stats, pattern2) {
        const entry2 = {
          name: pattern2,
          path: pattern2,
          dirent: utils2.fs.createDirentFromStats(pattern2, stats)
        };
        if (this._settings.stats) {
          entry2.stats = stats;
        }
        return entry2;
      }
      _isFatalError(error3) {
        return !utils2.errno.isEnoentCodeError(error3) && !this._settings.suppressErrors;
      }
    };
    exports3.default = Reader3;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/readers/stream.js
var require_stream4 = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/readers/stream.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    var stream_12 = require_stream();
    var fsStat2 = require_out();
    var fsWalk2 = require_out3();
    var reader_12 = require_reader2();
    var ReaderStream2 = class extends reader_12.default {
      constructor() {
        super(...arguments);
        this._walkStream = fsWalk2.walkStream;
        this._stat = fsStat2.stat;
      }
      dynamic(root, options3) {
        return this._walkStream(root, options3);
      }
      static(patterns2, options3) {
        const filepaths = patterns2.map(this._getFullEntryPath, this);
        const stream4 = new stream_12.PassThrough({ objectMode: true });
        stream4._write = (index2, _enc, done) => {
          return this._getEntry(filepaths[index2], patterns2[index2], options3).then((entry2) => {
            if (entry2 !== null && options3.entryFilter(entry2)) {
              stream4.push(entry2);
            }
            if (index2 === filepaths.length - 1) {
              stream4.end();
            }
            done();
          }).catch(done);
        };
        for (let i2 = 0; i2 < filepaths.length; i2++) {
          stream4.write(i2);
        }
        return stream4;
      }
      _getEntry(filepath, pattern2, options3) {
        return this._getStat(filepath).then((stats) => this._makeEntry(stats, pattern2)).catch((error3) => {
          if (options3.errorFilter(error3)) {
            return null;
          }
          throw error3;
        });
      }
      _getStat(filepath) {
        return new Promise((resolve4, reject) => {
          this._stat(filepath, this._fsStatSettings, (error3, stats) => {
            return error3 === null ? resolve4(stats) : reject(error3);
          });
        });
      }
    };
    exports3.default = ReaderStream2;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/readers/async.js
var require_async5 = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/readers/async.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    var fsWalk2 = require_out3();
    var reader_12 = require_reader2();
    var stream_12 = require_stream4();
    var ReaderAsync2 = class extends reader_12.default {
      constructor() {
        super(...arguments);
        this._walkAsync = fsWalk2.walk;
        this._readerStream = new stream_12.default(this._settings);
      }
      dynamic(root, options3) {
        return new Promise((resolve4, reject) => {
          this._walkAsync(root, options3, (error3, entries) => {
            if (error3 === null) {
              resolve4(entries);
            } else {
              reject(error3);
            }
          });
        });
      }
      async static(patterns2, options3) {
        const entries = [];
        const stream4 = this._readerStream.static(patterns2, options3);
        return new Promise((resolve4, reject) => {
          stream4.once("error", reject);
          stream4.on("data", (entry2) => entries.push(entry2));
          stream4.once("end", () => resolve4(entries));
        });
      }
    };
    exports3.default = ReaderAsync2;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/matchers/matcher.js
var require_matcher = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/matchers/matcher.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    var utils2 = require_utils5();
    var Matcher2 = class {
      constructor(_patterns, _settings, _micromatchOptions) {
        this._patterns = _patterns;
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this._storage = [];
        this._fillStorage();
      }
      _fillStorage() {
        const patterns2 = utils2.pattern.expandPatternsWithBraceExpansion(this._patterns);
        for (const pattern2 of patterns2) {
          const segments = this._getPatternSegments(pattern2);
          const sections = this._splitSegmentsIntoSections(segments);
          this._storage.push({
            complete: sections.length <= 1,
            pattern: pattern2,
            segments,
            sections
          });
        }
      }
      _getPatternSegments(pattern2) {
        const parts = utils2.pattern.getPatternParts(pattern2, this._micromatchOptions);
        return parts.map((part) => {
          const dynamic = utils2.pattern.isDynamicPattern(part, this._settings);
          if (!dynamic) {
            return {
              dynamic: false,
              pattern: part
            };
          }
          return {
            dynamic: true,
            pattern: part,
            patternRe: utils2.pattern.makeRe(part, this._micromatchOptions)
          };
        });
      }
      _splitSegmentsIntoSections(segments) {
        return utils2.array.splitWhen(segments, (segment) => segment.dynamic && utils2.pattern.hasGlobStar(segment.pattern));
      }
    };
    exports3.default = Matcher2;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/matchers/partial.js
var require_partial = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/matchers/partial.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    var matcher_12 = require_matcher();
    var PartialMatcher2 = class extends matcher_12.default {
      match(filepath) {
        const parts = filepath.split("/");
        const levels = parts.length;
        const patterns2 = this._storage.filter((info3) => !info3.complete || info3.segments.length > levels);
        for (const pattern2 of patterns2) {
          const section = pattern2.sections[0];
          if (!pattern2.complete && levels > section.length) {
            return true;
          }
          const match = parts.every((part, index2) => {
            const segment = pattern2.segments[index2];
            if (segment.dynamic && segment.patternRe.test(part)) {
              return true;
            }
            if (!segment.dynamic && segment.pattern === part) {
              return true;
            }
            return false;
          });
          if (match) {
            return true;
          }
        }
        return false;
      }
    };
    exports3.default = PartialMatcher2;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/filters/deep.js
var require_deep = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/filters/deep.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    var utils2 = require_utils5();
    var partial_12 = require_partial();
    var DeepFilter2 = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
      }
      getFilter(basePath, positive, negative) {
        const matcher2 = this._getMatcher(positive);
        const negativeRe = this._getNegativePatternsRe(negative);
        return (entry2) => this._filter(basePath, entry2, matcher2, negativeRe);
      }
      _getMatcher(patterns2) {
        return new partial_12.default(patterns2, this._settings, this._micromatchOptions);
      }
      _getNegativePatternsRe(patterns2) {
        const affectDepthOfReadingPatterns = patterns2.filter(utils2.pattern.isAffectDepthOfReadingPattern);
        return utils2.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
      }
      _filter(basePath, entry2, matcher2, negativeRe) {
        if (this._isSkippedByDeep(basePath, entry2.path)) {
          return false;
        }
        if (this._isSkippedSymbolicLink(entry2)) {
          return false;
        }
        const filepath = utils2.path.removeLeadingDotSegment(entry2.path);
        if (this._isSkippedByPositivePatterns(filepath, matcher2)) {
          return false;
        }
        return this._isSkippedByNegativePatterns(filepath, negativeRe);
      }
      _isSkippedByDeep(basePath, entryPath) {
        if (this._settings.deep === Infinity) {
          return false;
        }
        return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
      }
      _getEntryLevel(basePath, entryPath) {
        const entryPathDepth = entryPath.split("/").length;
        if (basePath === "") {
          return entryPathDepth;
        }
        const basePathDepth = basePath.split("/").length;
        return entryPathDepth - basePathDepth;
      }
      _isSkippedSymbolicLink(entry2) {
        return !this._settings.followSymbolicLinks && entry2.dirent.isSymbolicLink();
      }
      _isSkippedByPositivePatterns(entryPath, matcher2) {
        return !this._settings.baseNameMatch && !matcher2.match(entryPath);
      }
      _isSkippedByNegativePatterns(entryPath, patternsRe) {
        return !utils2.pattern.matchAny(entryPath, patternsRe);
      }
    };
    exports3.default = DeepFilter2;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/filters/entry.js
var require_entry = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/filters/entry.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    var utils2 = require_utils5();
    var EntryFilter2 = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this.index = /* @__PURE__ */ new Map();
      }
      getFilter(positive, negative) {
        const positiveRe = utils2.pattern.convertPatternsToRe(positive, this._micromatchOptions);
        const negativeRe = utils2.pattern.convertPatternsToRe(negative, this._micromatchOptions);
        return (entry2) => this._filter(entry2, positiveRe, negativeRe);
      }
      _filter(entry2, positiveRe, negativeRe) {
        if (this._settings.unique && this._isDuplicateEntry(entry2)) {
          return false;
        }
        if (this._onlyFileFilter(entry2) || this._onlyDirectoryFilter(entry2)) {
          return false;
        }
        if (this._isSkippedByAbsoluteNegativePatterns(entry2.path, negativeRe)) {
          return false;
        }
        const filepath = this._settings.baseNameMatch ? entry2.name : entry2.path;
        const isDirectory2 = entry2.dirent.isDirectory();
        const isMatched = this._isMatchToPatterns(filepath, positiveRe, isDirectory2) && !this._isMatchToPatterns(entry2.path, negativeRe, isDirectory2);
        if (this._settings.unique && isMatched) {
          this._createIndexRecord(entry2);
        }
        return isMatched;
      }
      _isDuplicateEntry(entry2) {
        return this.index.has(entry2.path);
      }
      _createIndexRecord(entry2) {
        this.index.set(entry2.path, void 0);
      }
      _onlyFileFilter(entry2) {
        return this._settings.onlyFiles && !entry2.dirent.isFile();
      }
      _onlyDirectoryFilter(entry2) {
        return this._settings.onlyDirectories && !entry2.dirent.isDirectory();
      }
      _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
        if (!this._settings.absolute) {
          return false;
        }
        const fullpath = utils2.path.makeAbsolute(this._settings.cwd, entryPath);
        return utils2.pattern.matchAny(fullpath, patternsRe);
      }
      _isMatchToPatterns(entryPath, patternsRe, isDirectory2) {
        const filepath = utils2.path.removeLeadingDotSegment(entryPath);
        const isMatched = utils2.pattern.matchAny(filepath, patternsRe);
        if (!isMatched && isDirectory2) {
          return utils2.pattern.matchAny(filepath + "/", patternsRe);
        }
        return isMatched;
      }
    };
    exports3.default = EntryFilter2;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/filters/error.js
var require_error = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/filters/error.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    var utils2 = require_utils5();
    var ErrorFilter2 = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getFilter() {
        return (error3) => this._isNonFatalError(error3);
      }
      _isNonFatalError(error3) {
        return utils2.errno.isEnoentCodeError(error3) || this._settings.suppressErrors;
      }
    };
    exports3.default = ErrorFilter2;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/transformers/entry.js
var require_entry2 = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/transformers/entry.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    var utils2 = require_utils5();
    var EntryTransformer2 = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getTransformer() {
        return (entry2) => this._transform(entry2);
      }
      _transform(entry2) {
        let filepath = entry2.path;
        if (this._settings.absolute) {
          filepath = utils2.path.makeAbsolute(this._settings.cwd, filepath);
          filepath = utils2.path.unixify(filepath);
        }
        if (this._settings.markDirectories && entry2.dirent.isDirectory()) {
          filepath += "/";
        }
        if (!this._settings.objectMode) {
          return filepath;
        }
        return Object.assign(Object.assign({}, entry2), { path: filepath });
      }
    };
    exports3.default = EntryTransformer2;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/provider.js
var require_provider = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/provider.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    var path8 = require_path();
    var deep_12 = require_deep();
    var entry_12 = require_entry();
    var error_12 = require_error();
    var entry_22 = require_entry2();
    var Provider2 = class {
      constructor(_settings) {
        this._settings = _settings;
        this.errorFilter = new error_12.default(this._settings);
        this.entryFilter = new entry_12.default(this._settings, this._getMicromatchOptions());
        this.deepFilter = new deep_12.default(this._settings, this._getMicromatchOptions());
        this.entryTransformer = new entry_22.default(this._settings);
      }
      _getRootDirectory(task) {
        return path8.resolve(this._settings.cwd, task.base);
      }
      _getReaderOptions(task) {
        const basePath = task.base === "." ? "" : task.base;
        return {
          basePath,
          pathSegmentSeparator: "/",
          concurrency: this._settings.concurrency,
          deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
          entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
          errorFilter: this.errorFilter.getFilter(),
          followSymbolicLinks: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          stats: this._settings.stats,
          throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
          transform: this.entryTransformer.getTransformer()
        };
      }
      _getMicromatchOptions() {
        return {
          dot: this._settings.dot,
          matchBase: this._settings.baseNameMatch,
          nobrace: !this._settings.braceExpansion,
          nocase: !this._settings.caseSensitiveMatch,
          noext: !this._settings.extglob,
          noglobstar: !this._settings.globstar,
          posix: true,
          strictSlashes: false
        };
      }
    };
    exports3.default = Provider2;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/async.js
var require_async6 = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/async.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    var async_12 = require_async5();
    var provider_12 = require_provider();
    var ProviderAsync2 = class extends provider_12.default {
      constructor() {
        super(...arguments);
        this._reader = new async_12.default(this._settings);
      }
      async read(task) {
        const root = this._getRootDirectory(task);
        const options3 = this._getReaderOptions(task);
        const entries = await this.api(root, task, options3);
        return entries.map((entry2) => options3.transform(entry2));
      }
      api(root, task, options3) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options3);
        }
        return this._reader.static(task.patterns, options3);
      }
    };
    exports3.default = ProviderAsync2;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/stream.js
var require_stream5 = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/stream.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    var stream_12 = require_stream();
    var stream_22 = require_stream4();
    var provider_12 = require_provider();
    var ProviderStream2 = class extends provider_12.default {
      constructor() {
        super(...arguments);
        this._reader = new stream_22.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options3 = this._getReaderOptions(task);
        const source = this.api(root, task, options3);
        const destination = new stream_12.Readable({ objectMode: true, read: () => {
        } });
        source.once("error", (error3) => destination.emit("error", error3)).on("data", (entry2) => destination.emit("data", options3.transform(entry2))).once("end", () => destination.emit("end"));
        destination.once("close", () => source.destroy());
        return destination;
      }
      api(root, task, options3) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options3);
        }
        return this._reader.static(task.patterns, options3);
      }
    };
    exports3.default = ProviderStream2;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/readers/sync.js
var require_sync5 = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/readers/sync.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    var fsStat2 = require_out();
    var fsWalk2 = require_out3();
    var reader_12 = require_reader2();
    var ReaderSync2 = class extends reader_12.default {
      constructor() {
        super(...arguments);
        this._walkSync = fsWalk2.walkSync;
        this._statSync = fsStat2.statSync;
      }
      dynamic(root, options3) {
        return this._walkSync(root, options3);
      }
      static(patterns2, options3) {
        const entries = [];
        for (const pattern2 of patterns2) {
          const filepath = this._getFullEntryPath(pattern2);
          const entry2 = this._getEntry(filepath, pattern2, options3);
          if (entry2 === null || !options3.entryFilter(entry2)) {
            continue;
          }
          entries.push(entry2);
        }
        return entries;
      }
      _getEntry(filepath, pattern2, options3) {
        try {
          const stats = this._getStat(filepath);
          return this._makeEntry(stats, pattern2);
        } catch (error3) {
          if (options3.errorFilter(error3)) {
            return null;
          }
          throw error3;
        }
      }
      _getStat(filepath) {
        return this._statSync(filepath, this._fsStatSettings);
      }
    };
    exports3.default = ReaderSync2;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/sync.js
var require_sync6 = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/providers/sync.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    var sync_12 = require_sync5();
    var provider_12 = require_provider();
    var ProviderSync2 = class extends provider_12.default {
      constructor() {
        super(...arguments);
        this._reader = new sync_12.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options3 = this._getReaderOptions(task);
        const entries = this.api(root, task, options3);
        return entries.map(options3.transform);
      }
      api(root, task, options3) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options3);
        }
        return this._reader.static(task.patterns, options3);
      }
    };
    exports3.default = ProviderSync2;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/settings.js
var require_settings4 = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/settings.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    exports3.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
    var fs6 = require_fs();
    var os2 = require_os();
    var CPU_COUNT = Math.max(os2.cpus().length, 1);
    exports3.DEFAULT_FILE_SYSTEM_ADAPTER = {
      lstat: fs6.lstat,
      lstatSync: fs6.lstatSync,
      stat: fs6.stat,
      statSync: fs6.statSync,
      readdir: fs6.readdir,
      readdirSync: fs6.readdirSync
    };
    var Settings4 = class {
      constructor(_options2 = {}) {
        this._options = _options2;
        this.absolute = this._getValue(this._options.absolute, false);
        this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
        this.braceExpansion = this._getValue(this._options.braceExpansion, true);
        this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
        this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
        this.cwd = this._getValue(this._options.cwd, process.cwd());
        this.deep = this._getValue(this._options.deep, Infinity);
        this.dot = this._getValue(this._options.dot, false);
        this.extglob = this._getValue(this._options.extglob, true);
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
        this.fs = this._getFileSystemMethods(this._options.fs);
        this.globstar = this._getValue(this._options.globstar, true);
        this.ignore = this._getValue(this._options.ignore, []);
        this.markDirectories = this._getValue(this._options.markDirectories, false);
        this.objectMode = this._getValue(this._options.objectMode, false);
        this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
        this.onlyFiles = this._getValue(this._options.onlyFiles, true);
        this.stats = this._getValue(this._options.stats, false);
        this.suppressErrors = this._getValue(this._options.suppressErrors, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
        this.unique = this._getValue(this._options.unique, true);
        if (this.onlyDirectories) {
          this.onlyFiles = false;
        }
        if (this.stats) {
          this.objectMode = true;
        }
      }
      _getValue(option, value2) {
        return option === void 0 ? value2 : option;
      }
      _getFileSystemMethods(methods = {}) {
        return Object.assign(Object.assign({}, exports3.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
      }
    };
    exports3.default = Settings4;
  }
});

// node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/index.js
var require_out4 = __commonJS({
  "node_modules/.pnpm/fast-glob@3.2.12/node_modules/fast-glob/out/index.js"(exports3, module2) {
    "use strict";
    var taskManager2 = require_tasks();
    var patternManager2 = require_patterns();
    var async_12 = require_async6();
    var stream_12 = require_stream5();
    var sync_12 = require_sync6();
    var settings_12 = require_settings4();
    var utils2 = require_utils5();
    async function FastGlob2(source, options3) {
      assertPatternsInput3(source);
      const works = getWorks2(source, async_12.default, options3);
      const result = await Promise.all(works);
      return utils2.array.flatten(result);
    }
    (function(FastGlob3) {
      function sync2(source, options3) {
        assertPatternsInput3(source);
        const works = getWorks2(source, sync_12.default, options3);
        return utils2.array.flatten(works);
      }
      FastGlob3.sync = sync2;
      function stream4(source, options3) {
        assertPatternsInput3(source);
        const works = getWorks2(source, stream_12.default, options3);
        return utils2.stream.merge(works);
      }
      FastGlob3.stream = stream4;
      function generateTasks2(source, options3) {
        assertPatternsInput3(source);
        const patterns2 = patternManager2.transform([].concat(source));
        const settings2 = new settings_12.default(options3);
        return taskManager2.generate(patterns2, settings2);
      }
      FastGlob3.generateTasks = generateTasks2;
      function isDynamicPattern3(source, options3) {
        assertPatternsInput3(source);
        const settings2 = new settings_12.default(options3);
        return utils2.pattern.isDynamicPattern(source, settings2);
      }
      FastGlob3.isDynamicPattern = isDynamicPattern3;
      function escapePath(source) {
        assertPatternsInput3(source);
        return utils2.path.escape(source);
      }
      FastGlob3.escapePath = escapePath;
    })(FastGlob2 || (FastGlob2 = {}));
    function getWorks2(source, _Provider, options3) {
      const patterns2 = patternManager2.transform([].concat(source));
      const settings2 = new settings_12.default(options3);
      const tasks2 = taskManager2.generate(patterns2, settings2);
      const provider2 = new _Provider(settings2);
      return tasks2.map(provider2.read, provider2);
    }
    function assertPatternsInput3(input) {
      const source = [].concat(input);
      const isValidSource = source.every((item) => utils2.string.isString(item) && !utils2.string.isEmpty(item));
      if (!isValidSource) {
        throw new TypeError("Patterns must be a string (non empty) or an array of strings");
      }
    }
    module2.exports = FastGlob2;
  }
});

// node_modules/.pnpm/path-type@4.0.0/node_modules/path-type/index.js
var require_path_type = __commonJS({
  "node_modules/.pnpm/path-type@4.0.0/node_modules/path-type/index.js"(exports3) {
    "use strict";
    var { promisify: promisify2 } = require_util();
    var fs6 = require_fs();
    async function isType(fsStatType, statsMethodName, filePath) {
      if (typeof filePath !== "string") {
        throw new TypeError(`Expected a string, got ${typeof filePath}`);
      }
      try {
        const stats = await promisify2(fs6[fsStatType])(filePath);
        return stats[statsMethodName]();
      } catch (error3) {
        if (error3.code === "ENOENT") {
          return false;
        }
        throw error3;
      }
    }
    function isTypeSync(fsStatType, statsMethodName, filePath) {
      if (typeof filePath !== "string") {
        throw new TypeError(`Expected a string, got ${typeof filePath}`);
      }
      try {
        return fs6[fsStatType](filePath)[statsMethodName]();
      } catch (error3) {
        if (error3.code === "ENOENT") {
          return false;
        }
        throw error3;
      }
    }
    exports3.isFile = isType.bind(null, "stat", "isFile");
    exports3.isDirectory = isType.bind(null, "stat", "isDirectory");
    exports3.isSymlink = isType.bind(null, "lstat", "isSymbolicLink");
    exports3.isFileSync = isTypeSync.bind(null, "statSync", "isFile");
    exports3.isDirectorySync = isTypeSync.bind(null, "statSync", "isDirectory");
    exports3.isSymlinkSync = isTypeSync.bind(null, "lstatSync", "isSymbolicLink");
  }
});

// node_modules/.pnpm/dir-glob@3.0.1/node_modules/dir-glob/index.js
var require_dir_glob = __commonJS({
  "node_modules/.pnpm/dir-glob@3.0.1/node_modules/dir-glob/index.js"(exports3, module2) {
    "use strict";
    var path8 = require_path();
    var pathType = require_path_type();
    var getExtensions = (extensions2) => extensions2.length > 1 ? `{${extensions2.join(",")}}` : extensions2[0];
    var getPath = (filepath, cwd) => {
      const pth = filepath[0] === "!" ? filepath.slice(1) : filepath;
      return path8.isAbsolute(pth) ? pth : path8.join(cwd, pth);
    };
    var addExtensions = (file, extensions2) => {
      if (path8.extname(file)) {
        return `**/${file}`;
      }
      return `**/${file}.${getExtensions(extensions2)}`;
    };
    var getGlob = (directory, options3) => {
      if (options3.files && !Array.isArray(options3.files)) {
        throw new TypeError(`Expected \`files\` to be of type \`Array\` but received type \`${typeof options3.files}\``);
      }
      if (options3.extensions && !Array.isArray(options3.extensions)) {
        throw new TypeError(`Expected \`extensions\` to be of type \`Array\` but received type \`${typeof options3.extensions}\``);
      }
      if (options3.files && options3.extensions) {
        return options3.files.map((x) => path8.posix.join(directory, addExtensions(x, options3.extensions)));
      }
      if (options3.files) {
        return options3.files.map((x) => path8.posix.join(directory, `**/${x}`));
      }
      if (options3.extensions) {
        return [path8.posix.join(directory, `**/*.${getExtensions(options3.extensions)}`)];
      }
      return [path8.posix.join(directory, "**")];
    };
    module2.exports = async (input, options3) => {
      options3 = {
        cwd: process.cwd(),
        ...options3
      };
      if (typeof options3.cwd !== "string") {
        throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options3.cwd}\``);
      }
      const globs = await Promise.all([].concat(input).map(async (x) => {
        const isDirectory2 = await pathType.isDirectory(getPath(x, options3.cwd));
        return isDirectory2 ? getGlob(x, options3) : x;
      }));
      return [].concat.apply([], globs);
    };
    module2.exports.sync = (input, options3) => {
      options3 = {
        cwd: process.cwd(),
        ...options3
      };
      if (typeof options3.cwd !== "string") {
        throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options3.cwd}\``);
      }
      const globs = [].concat(input).map((x) => pathType.isDirectorySync(getPath(x, options3.cwd)) ? getGlob(x, options3) : x);
      return [].concat.apply([], globs);
    };
  }
});

// node_modules/.pnpm/ignore@5.2.4/node_modules/ignore/index.js
var require_ignore = __commonJS({
  "node_modules/.pnpm/ignore@5.2.4/node_modules/ignore/index.js"(exports3, module2) {
    function makeArray(subject) {
      return Array.isArray(subject) ? subject : [subject];
    }
    var EMPTY = "";
    var SPACE = " ";
    var ESCAPE = "\\";
    var REGEX_TEST_BLANK_LINE = /^\s+$/;
    var REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/;
    var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
    var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
    var REGEX_SPLITALL_CRLF = /\r?\n/g;
    var REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
    var SLASH2 = "/";
    var TMP_KEY_IGNORE = "node-ignore";
    if (typeof Symbol !== "undefined") {
      TMP_KEY_IGNORE = Symbol.for("node-ignore");
    }
    var KEY_IGNORE = TMP_KEY_IGNORE;
    var define2 = (object, key, value2) => Object.defineProperty(object, key, { value: value2 });
    var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
    var RETURN_FALSE = () => false;
    var sanitizeRange = (range2) => range2.replace(
      REGEX_REGEXP_RANGE,
      (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY
    );
    var cleanRangeBackSlash = (slashes) => {
      const { length } = slashes;
      return slashes.slice(0, length - length % 2);
    };
    var REPLACERS = [
      // > Trailing spaces are ignored unless they are quoted with backslash ("\")
      [
        // (a\ ) -> (a )
        // (a  ) -> (a)
        // (a \ ) -> (a  )
        /\\?\s+$/,
        (match) => match.indexOf("\\") === 0 ? SPACE : EMPTY
      ],
      // replace (\ ) with ' '
      [
        /\\\s/g,
        () => SPACE
      ],
      // Escape metacharacters
      // which is written down by users but means special for regular expressions.
      // > There are 12 characters with special meanings:
      // > - the backslash \,
      // > - the caret ^,
      // > - the dollar sign $,
      // > - the period or dot .,
      // > - the vertical bar or pipe symbol |,
      // > - the question mark ?,
      // > - the asterisk or star *,
      // > - the plus sign +,
      // > - the opening parenthesis (,
      // > - the closing parenthesis ),
      // > - and the opening square bracket [,
      // > - the opening curly brace {,
      // > These special characters are often called "metacharacters".
      [
        /[\\$.|*+(){^]/g,
        (match) => `\\${match}`
      ],
      [
        // > a question mark (?) matches a single character
        /(?!\\)\?/g,
        () => "[^/]"
      ],
      // leading slash
      [
        // > A leading slash matches the beginning of the pathname.
        // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
        // A leading slash matches the beginning of the pathname
        /^\//,
        () => "^"
      ],
      // replace special metacharacter slash after the leading slash
      [
        /\//g,
        () => "\\/"
      ],
      [
        // > A leading "**" followed by a slash means match in all directories.
        // > For example, "**/foo" matches file or directory "foo" anywhere,
        // > the same as pattern "foo".
        // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
        // >   under directory "foo".
        // Notice that the '*'s have been replaced as '\\*'
        /^\^*\\\*\\\*\\\//,
        // '**/foo' <-> 'foo'
        () => "^(?:.*\\/)?"
      ],
      // starting
      [
        // there will be no leading '/'
        //   (which has been replaced by section "leading slash")
        // If starts with '**', adding a '^' to the regular expression also works
        /^(?=[^^])/,
        function startingReplacer() {
          return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
        }
      ],
      // two globstars
      [
        // Use lookahead assertions so that we could match more than one `'/**'`
        /\\\/\\\*\\\*(?=\\\/|$)/g,
        // Zero, one or several directories
        // should not use '*', or it will be replaced by the next replacer
        // Check if it is not the last `'/**'`
        (_, index2, str2) => index2 + 6 < str2.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
      ],
      // normal intermediate wildcards
      [
        // Never replace escaped '*'
        // ignore rule '\*' will match the path '*'
        // 'abc.*/' -> go
        // 'abc.*'  -> skip this rule,
        //    coz trailing single wildcard will be handed by [trailing wildcard]
        /(^|[^\\]+)(\\\*)+(?=.+)/g,
        // '*.js' matches '.js'
        // '*.js' doesn't match 'abc'
        (_, p1, p2) => {
          const unescaped = p2.replace(/\\\*/g, "[^\\/]*");
          return p1 + unescaped;
        }
      ],
      [
        // unescape, revert step 3 except for back slash
        // For example, if a user escape a '\\*',
        // after step 3, the result will be '\\\\\\*'
        /\\\\\\(?=[$.|*+(){^])/g,
        () => ESCAPE
      ],
      [
        // '\\\\' -> '\\'
        /\\\\/g,
        () => ESCAPE
      ],
      [
        // > The range notation, e.g. [a-zA-Z],
        // > can be used to match one of the characters in a range.
        // `\` is escaped by step 3
        /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
        (match, leadEscape, range2, endEscape, close2) => leadEscape === ESCAPE ? `\\[${range2}${cleanRangeBackSlash(endEscape)}${close2}` : close2 === "]" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range2)}${endEscape}]` : "[]" : "[]"
      ],
      // ending
      [
        // 'js' will not match 'js.'
        // 'ab' will not match 'abc'
        /(?:[^*])$/,
        // WTF!
        // https://git-scm.com/docs/gitignore
        // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
        // which re-fixes #24, #38
        // > If there is a separator at the end of the pattern then the pattern
        // > will only match directories, otherwise the pattern can match both
        // > files and directories.
        // 'js*' will not match 'a.js'
        // 'js/' will not match 'a.js'
        // 'js' will match 'a.js' and 'a.js/'
        (match) => /\/$/.test(match) ? `${match}$` : `${match}(?=$|\\/$)`
      ],
      // trailing wildcard
      [
        /(\^|\\\/)?\\\*$/,
        (_, p1) => {
          const prefix = p1 ? `${p1}[^/]+` : "[^/]*";
          return `${prefix}(?=$|\\/$)`;
        }
      ]
    ];
    var regexCache = /* @__PURE__ */ Object.create(null);
    var makeRegex = (pattern2, ignoreCase) => {
      let source = regexCache[pattern2];
      if (!source) {
        source = REPLACERS.reduce(
          (prev, current2) => prev.replace(current2[0], current2[1].bind(pattern2)),
          pattern2
        );
        regexCache[pattern2] = source;
      }
      return ignoreCase ? new RegExp(source, "i") : new RegExp(source);
    };
    var isString3 = (subject) => typeof subject === "string";
    var checkPattern = (pattern2) => pattern2 && isString3(pattern2) && !REGEX_TEST_BLANK_LINE.test(pattern2) && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern2) && pattern2.indexOf("#") !== 0;
    var splitPattern = (pattern2) => pattern2.split(REGEX_SPLITALL_CRLF);
    var IgnoreRule = class {
      constructor(origin, pattern2, negative, regex) {
        this.origin = origin;
        this.pattern = pattern2;
        this.negative = negative;
        this.regex = regex;
      }
    };
    var createRule = (pattern2, ignoreCase) => {
      const origin = pattern2;
      let negative = false;
      if (pattern2.indexOf("!") === 0) {
        negative = true;
        pattern2 = pattern2.substr(1);
      }
      pattern2 = pattern2.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
      const regex = makeRegex(pattern2, ignoreCase);
      return new IgnoreRule(
        origin,
        pattern2,
        negative,
        regex
      );
    };
    var throwError = (message, Ctor) => {
      throw new Ctor(message);
    };
    var checkPath = (path8, originalPath, doThrow) => {
      if (!isString3(path8)) {
        return doThrow(
          `path must be a string, but got \`${originalPath}\``,
          TypeError
        );
      }
      if (!path8) {
        return doThrow(`path must not be empty`, TypeError);
      }
      if (checkPath.isNotRelative(path8)) {
        const r3 = "`path.relative()`d";
        return doThrow(
          `path should be a ${r3} string, but got "${originalPath}"`,
          RangeError
        );
      }
      return true;
    };
    var isNotRelative = (path8) => REGEX_TEST_INVALID_PATH.test(path8);
    checkPath.isNotRelative = isNotRelative;
    checkPath.convert = (p2) => p2;
    var Ignore = class {
      constructor({
        ignorecase = true,
        ignoreCase = ignorecase,
        allowRelativePaths = false
      } = {}) {
        define2(this, KEY_IGNORE, true);
        this._rules = [];
        this._ignoreCase = ignoreCase;
        this._allowRelativePaths = allowRelativePaths;
        this._initCache();
      }
      _initCache() {
        this._ignoreCache = /* @__PURE__ */ Object.create(null);
        this._testCache = /* @__PURE__ */ Object.create(null);
      }
      _addPattern(pattern2) {
        if (pattern2 && pattern2[KEY_IGNORE]) {
          this._rules = this._rules.concat(pattern2._rules);
          this._added = true;
          return;
        }
        if (checkPattern(pattern2)) {
          const rule = createRule(pattern2, this._ignoreCase);
          this._added = true;
          this._rules.push(rule);
        }
      }
      // @param {Array<string> | string | Ignore} pattern
      add(pattern2) {
        this._added = false;
        makeArray(
          isString3(pattern2) ? splitPattern(pattern2) : pattern2
        ).forEach(this._addPattern, this);
        if (this._added) {
          this._initCache();
        }
        return this;
      }
      // legacy
      addPattern(pattern2) {
        return this.add(pattern2);
      }
      //          |           ignored : unignored
      // negative |   0:0   |   0:1   |   1:0   |   1:1
      // -------- | ------- | ------- | ------- | --------
      //     0    |  TEST   |  TEST   |  SKIP   |    X
      //     1    |  TESTIF |  SKIP   |  TEST   |    X
      // - SKIP: always skip
      // - TEST: always test
      // - TESTIF: only test if checkUnignored
      // - X: that never happen
      // @param {boolean} whether should check if the path is unignored,
      //   setting `checkUnignored` to `false` could reduce additional
      //   path matching.
      // @returns {TestResult} true if a file is ignored
      _testOne(path8, checkUnignored) {
        let ignored = false;
        let unignored = false;
        this._rules.forEach((rule) => {
          const { negative } = rule;
          if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
            return;
          }
          const matched = rule.regex.test(path8);
          if (matched) {
            ignored = !negative;
            unignored = negative;
          }
        });
        return {
          ignored,
          unignored
        };
      }
      // @returns {TestResult}
      _test(originalPath, cache2, checkUnignored, slices) {
        const path8 = originalPath && checkPath.convert(originalPath);
        checkPath(
          path8,
          originalPath,
          this._allowRelativePaths ? RETURN_FALSE : throwError
        );
        return this._t(path8, cache2, checkUnignored, slices);
      }
      _t(path8, cache2, checkUnignored, slices) {
        if (path8 in cache2) {
          return cache2[path8];
        }
        if (!slices) {
          slices = path8.split(SLASH2);
        }
        slices.pop();
        if (!slices.length) {
          return cache2[path8] = this._testOne(path8, checkUnignored);
        }
        const parent = this._t(
          slices.join(SLASH2) + SLASH2,
          cache2,
          checkUnignored,
          slices
        );
        return cache2[path8] = parent.ignored ? parent : this._testOne(path8, checkUnignored);
      }
      ignores(path8) {
        return this._test(path8, this._ignoreCache, false).ignored;
      }
      createFilter() {
        return (path8) => !this.ignores(path8);
      }
      filter(paths) {
        return makeArray(paths).filter(this.createFilter());
      }
      // @returns {TestResult}
      test(path8) {
        return this._test(path8, this._testCache, true);
      }
    };
    var factory = (options3) => new Ignore(options3);
    var isPathValid = (path8) => checkPath(path8 && checkPath.convert(path8), path8, RETURN_FALSE);
    factory.isPathValid = isPathValid;
    factory.default = factory;
    module2.exports = factory;
    if (
      // Detect `process` so that it can run in browsers.
      typeof process !== "undefined" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")
    ) {
      const makePosix = (str2) => /^\\\\\?\\/.test(str2) || /["<>|\u0000-\u001F]+/u.test(str2) ? str2 : str2.replace(/\\/g, "/");
      checkPath.convert = makePosix;
      const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
      checkPath.isNotRelative = (path8) => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path8) || isNotRelative(path8);
    }
  }
});

// browser-external:node:stream
var require_node_stream = __commonJS({
  "browser-external:node:stream"(exports3, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:stream" has been externalized for browser compatibility. Cannot access "node:stream.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/.pnpm/hash-sum@2.0.0/node_modules/hash-sum/hash-sum.js
var require_hash_sum = __commonJS({
  "node_modules/.pnpm/hash-sum@2.0.0/node_modules/hash-sum/hash-sum.js"(exports3, module2) {
    "use strict";
    function pad2(hash2, len) {
      while (hash2.length < len) {
        hash2 = "0" + hash2;
      }
      return hash2;
    }
    function fold(hash2, text) {
      var i2;
      var chr;
      var len;
      if (text.length === 0) {
        return hash2;
      }
      for (i2 = 0, len = text.length; i2 < len; i2++) {
        chr = text.charCodeAt(i2);
        hash2 = (hash2 << 5) - hash2 + chr;
        hash2 |= 0;
      }
      return hash2 < 0 ? hash2 * -2 : hash2;
    }
    function foldObject(hash2, o3, seen2) {
      return Object.keys(o3).sort().reduce(foldKey, hash2);
      function foldKey(hash3, key) {
        return foldValue(hash3, o3[key], key, seen2);
      }
    }
    function foldValue(input, value2, key, seen2) {
      var hash2 = fold(fold(fold(input, key), toString2(value2)), typeof value2);
      if (value2 === null) {
        return fold(hash2, "null");
      }
      if (value2 === void 0) {
        return fold(hash2, "undefined");
      }
      if (typeof value2 === "object" || typeof value2 === "function") {
        if (seen2.indexOf(value2) !== -1) {
          return fold(hash2, "[Circular]" + key);
        }
        seen2.push(value2);
        var objHash = foldObject(hash2, value2, seen2);
        if (!("valueOf" in value2) || typeof value2.valueOf !== "function") {
          return objHash;
        }
        try {
          return fold(objHash, String(value2.valueOf()));
        } catch (err2) {
          return fold(objHash, "[valueOf exception]" + (err2.stack || err2.message));
        }
      }
      return fold(hash2, value2.toString());
    }
    function toString2(o3) {
      return Object.prototype.toString.call(o3);
    }
    function sum(o3) {
      return pad2(foldValue(0, o3, "", []).toString(16), 8);
    }
    module2.exports = sum;
  }
});

// node_modules/.pnpm/mimic-fn@2.1.0/node_modules/mimic-fn/index.js
var require_mimic_fn = __commonJS({
  "node_modules/.pnpm/mimic-fn@2.1.0/node_modules/mimic-fn/index.js"(exports3, module2) {
    "use strict";
    var mimicFn = (to, from) => {
      for (const prop of Reflect.ownKeys(from)) {
        Object.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));
      }
      return to;
    };
    module2.exports = mimicFn;
    module2.exports.default = mimicFn;
  }
});

// node_modules/.pnpm/onetime@5.1.2/node_modules/onetime/index.js
var require_onetime = __commonJS({
  "node_modules/.pnpm/onetime@5.1.2/node_modules/onetime/index.js"(exports3, module2) {
    "use strict";
    var mimicFn = require_mimic_fn();
    var calledFunctions = /* @__PURE__ */ new WeakMap();
    var onetime2 = (function_, options3 = {}) => {
      if (typeof function_ !== "function") {
        throw new TypeError("Expected a function");
      }
      let returnValue;
      let callCount = 0;
      const functionName = function_.displayName || function_.name || "<anonymous>";
      const onetime3 = function(...arguments_) {
        calledFunctions.set(onetime3, ++callCount);
        if (callCount === 1) {
          returnValue = function_.apply(this, arguments_);
          function_ = null;
        } else if (options3.throw === true) {
          throw new Error(`Function \`${functionName}\` can only be called once`);
        }
        return returnValue;
      };
      mimicFn(onetime3, function_);
      calledFunctions.set(onetime3, callCount);
      return onetime3;
    };
    module2.exports = onetime2;
    module2.exports.default = onetime2;
    module2.exports.callCount = (function_) => {
      if (!calledFunctions.has(function_)) {
        throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
      }
      return calledFunctions.get(function_);
    };
  }
});

// node_modules/.pnpm/signal-exit@3.0.7/node_modules/signal-exit/signals.js
var require_signals = __commonJS({
  "node_modules/.pnpm/signal-exit@3.0.7/node_modules/signal-exit/signals.js"(exports3, module2) {
    module2.exports = [
      "SIGABRT",
      "SIGALRM",
      "SIGHUP",
      "SIGINT",
      "SIGTERM"
    ];
    if (process.platform !== "win32") {
      module2.exports.push(
        "SIGVTALRM",
        "SIGXCPU",
        "SIGXFSZ",
        "SIGUSR2",
        "SIGTRAP",
        "SIGSYS",
        "SIGQUIT",
        "SIGIOT"
        // should detect profiler and enable/disable accordingly.
        // see #21
        // 'SIGPROF'
      );
    }
    if (process.platform === "linux") {
      module2.exports.push(
        "SIGIO",
        "SIGPOLL",
        "SIGPWR",
        "SIGSTKFLT",
        "SIGUNUSED"
      );
    }
  }
});

// node_modules/.pnpm/signal-exit@3.0.7/node_modules/signal-exit/index.js
var require_signal_exit = __commonJS({
  "node_modules/.pnpm/signal-exit@3.0.7/node_modules/signal-exit/index.js"(exports3, module2) {
    var process10 = global.process;
    var processOk = function(process11) {
      return process11 && typeof process11 === "object" && typeof process11.removeListener === "function" && typeof process11.emit === "function" && typeof process11.reallyExit === "function" && typeof process11.listeners === "function" && typeof process11.kill === "function" && typeof process11.pid === "number" && typeof process11.on === "function";
    };
    if (!processOk(process10)) {
      module2.exports = function() {
        return function() {
        };
      };
    } else {
      assert2 = require_assert();
      signals = require_signals();
      isWin2 = /^win/i.test(process10.platform);
      EE = require_events();
      if (typeof EE !== "function") {
        EE = EE.EventEmitter;
      }
      if (process10.__signal_exit_emitter__) {
        emitter = process10.__signal_exit_emitter__;
      } else {
        emitter = process10.__signal_exit_emitter__ = new EE();
        emitter.count = 0;
        emitter.emitted = {};
      }
      if (!emitter.infinite) {
        emitter.setMaxListeners(Infinity);
        emitter.infinite = true;
      }
      module2.exports = function(cb, opts) {
        if (!processOk(global.process)) {
          return function() {
          };
        }
        assert2.equal(typeof cb, "function", "a callback must be provided for exit handler");
        if (loaded === false) {
          load2();
        }
        var ev = "exit";
        if (opts && opts.alwaysLast) {
          ev = "afterexit";
        }
        var remove = function() {
          emitter.removeListener(ev, cb);
          if (emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0) {
            unload();
          }
        };
        emitter.on(ev, cb);
        return remove;
      };
      unload = function unload2() {
        if (!loaded || !processOk(global.process)) {
          return;
        }
        loaded = false;
        signals.forEach(function(sig) {
          try {
            process10.removeListener(sig, sigListeners[sig]);
          } catch (er) {
          }
        });
        process10.emit = originalProcessEmit;
        process10.reallyExit = originalProcessReallyExit;
        emitter.count -= 1;
      };
      module2.exports.unload = unload;
      emit = function emit2(event, code, signal) {
        if (emitter.emitted[event]) {
          return;
        }
        emitter.emitted[event] = true;
        emitter.emit(event, code, signal);
      };
      sigListeners = {};
      signals.forEach(function(sig) {
        sigListeners[sig] = function listener2() {
          if (!processOk(global.process)) {
            return;
          }
          var listeners = process10.listeners(sig);
          if (listeners.length === emitter.count) {
            unload();
            emit("exit", null, sig);
            emit("afterexit", null, sig);
            if (isWin2 && sig === "SIGHUP") {
              sig = "SIGINT";
            }
            process10.kill(process10.pid, sig);
          }
        };
      });
      module2.exports.signals = function() {
        return signals;
      };
      loaded = false;
      load2 = function load3() {
        if (loaded || !processOk(global.process)) {
          return;
        }
        loaded = true;
        emitter.count += 1;
        signals = signals.filter(function(sig) {
          try {
            process10.on(sig, sigListeners[sig]);
            return true;
          } catch (er) {
            return false;
          }
        });
        process10.emit = processEmit;
        process10.reallyExit = processReallyExit;
      };
      module2.exports.load = load2;
      originalProcessReallyExit = process10.reallyExit;
      processReallyExit = function processReallyExit2(code) {
        if (!processOk(global.process)) {
          return;
        }
        process10.exitCode = code || /* istanbul ignore next */
        0;
        emit("exit", process10.exitCode, null);
        emit("afterexit", process10.exitCode, null);
        originalProcessReallyExit.call(process10, process10.exitCode);
      };
      originalProcessEmit = process10.emit;
      processEmit = function processEmit2(ev, arg) {
        if (ev === "exit" && processOk(global.process)) {
          if (arg !== void 0) {
            process10.exitCode = arg;
          }
          var ret = originalProcessEmit.apply(this, arguments);
          emit("exit", process10.exitCode, null);
          emit("afterexit", process10.exitCode, null);
          return ret;
        } else {
          return originalProcessEmit.apply(this, arguments);
        }
      };
    }
    var assert2;
    var signals;
    var isWin2;
    var EE;
    var emitter;
    var unload;
    var emit;
    var sigListeners;
    var loaded;
    var load2;
    var originalProcessReallyExit;
    var processReallyExit;
    var originalProcessEmit;
    var processEmit;
  }
});

// node_modules/.pnpm/cli-spinners@2.9.0/node_modules/cli-spinners/spinners.json
var require_spinners = __commonJS({
  "node_modules/.pnpm/cli-spinners@2.9.0/node_modules/cli-spinners/spinners.json"(exports3, module2) {
    module2.exports = {
      dots: {
        interval: 80,
        frames: [
          "⠋",
          "⠙",
          "⠹",
          "⠸",
          "⠼",
          "⠴",
          "⠦",
          "⠧",
          "⠇",
          "⠏"
        ]
      },
      dots2: {
        interval: 80,
        frames: [
          "⣾",
          "⣽",
          "⣻",
          "⢿",
          "⡿",
          "⣟",
          "⣯",
          "⣷"
        ]
      },
      dots3: {
        interval: 80,
        frames: [
          "⠋",
          "⠙",
          "⠚",
          "⠞",
          "⠖",
          "⠦",
          "⠴",
          "⠲",
          "⠳",
          "⠓"
        ]
      },
      dots4: {
        interval: 80,
        frames: [
          "⠄",
          "⠆",
          "⠇",
          "⠋",
          "⠙",
          "⠸",
          "⠰",
          "⠠",
          "⠰",
          "⠸",
          "⠙",
          "⠋",
          "⠇",
          "⠆"
        ]
      },
      dots5: {
        interval: 80,
        frames: [
          "⠋",
          "⠙",
          "⠚",
          "⠒",
          "⠂",
          "⠂",
          "⠒",
          "⠲",
          "⠴",
          "⠦",
          "⠖",
          "⠒",
          "⠐",
          "⠐",
          "⠒",
          "⠓",
          "⠋"
        ]
      },
      dots6: {
        interval: 80,
        frames: [
          "⠁",
          "⠉",
          "⠙",
          "⠚",
          "⠒",
          "⠂",
          "⠂",
          "⠒",
          "⠲",
          "⠴",
          "⠤",
          "⠄",
          "⠄",
          "⠤",
          "⠴",
          "⠲",
          "⠒",
          "⠂",
          "⠂",
          "⠒",
          "⠚",
          "⠙",
          "⠉",
          "⠁"
        ]
      },
      dots7: {
        interval: 80,
        frames: [
          "⠈",
          "⠉",
          "⠋",
          "⠓",
          "⠒",
          "⠐",
          "⠐",
          "⠒",
          "⠖",
          "⠦",
          "⠤",
          "⠠",
          "⠠",
          "⠤",
          "⠦",
          "⠖",
          "⠒",
          "⠐",
          "⠐",
          "⠒",
          "⠓",
          "⠋",
          "⠉",
          "⠈"
        ]
      },
      dots8: {
        interval: 80,
        frames: [
          "⠁",
          "⠁",
          "⠉",
          "⠙",
          "⠚",
          "⠒",
          "⠂",
          "⠂",
          "⠒",
          "⠲",
          "⠴",
          "⠤",
          "⠄",
          "⠄",
          "⠤",
          "⠠",
          "⠠",
          "⠤",
          "⠦",
          "⠖",
          "⠒",
          "⠐",
          "⠐",
          "⠒",
          "⠓",
          "⠋",
          "⠉",
          "⠈",
          "⠈"
        ]
      },
      dots9: {
        interval: 80,
        frames: [
          "⢹",
          "⢺",
          "⢼",
          "⣸",
          "⣇",
          "⡧",
          "⡗",
          "⡏"
        ]
      },
      dots10: {
        interval: 80,
        frames: [
          "⢄",
          "⢂",
          "⢁",
          "⡁",
          "⡈",
          "⡐",
          "⡠"
        ]
      },
      dots11: {
        interval: 100,
        frames: [
          "⠁",
          "⠂",
          "⠄",
          "⡀",
          "⢀",
          "⠠",
          "⠐",
          "⠈"
        ]
      },
      dots12: {
        interval: 80,
        frames: [
          "⢀⠀",
          "⡀⠀",
          "⠄⠀",
          "⢂⠀",
          "⡂⠀",
          "⠅⠀",
          "⢃⠀",
          "⡃⠀",
          "⠍⠀",
          "⢋⠀",
          "⡋⠀",
          "⠍⠁",
          "⢋⠁",
          "⡋⠁",
          "⠍⠉",
          "⠋⠉",
          "⠋⠉",
          "⠉⠙",
          "⠉⠙",
          "⠉⠩",
          "⠈⢙",
          "⠈⡙",
          "⢈⠩",
          "⡀⢙",
          "⠄⡙",
          "⢂⠩",
          "⡂⢘",
          "⠅⡘",
          "⢃⠨",
          "⡃⢐",
          "⠍⡐",
          "⢋⠠",
          "⡋⢀",
          "⠍⡁",
          "⢋⠁",
          "⡋⠁",
          "⠍⠉",
          "⠋⠉",
          "⠋⠉",
          "⠉⠙",
          "⠉⠙",
          "⠉⠩",
          "⠈⢙",
          "⠈⡙",
          "⠈⠩",
          "⠀⢙",
          "⠀⡙",
          "⠀⠩",
          "⠀⢘",
          "⠀⡘",
          "⠀⠨",
          "⠀⢐",
          "⠀⡐",
          "⠀⠠",
          "⠀⢀",
          "⠀⡀"
        ]
      },
      dots13: {
        interval: 80,
        frames: [
          "⣼",
          "⣹",
          "⢻",
          "⠿",
          "⡟",
          "⣏",
          "⣧",
          "⣶"
        ]
      },
      dots8Bit: {
        interval: 80,
        frames: [
          "⠀",
          "⠁",
          "⠂",
          "⠃",
          "⠄",
          "⠅",
          "⠆",
          "⠇",
          "⡀",
          "⡁",
          "⡂",
          "⡃",
          "⡄",
          "⡅",
          "⡆",
          "⡇",
          "⠈",
          "⠉",
          "⠊",
          "⠋",
          "⠌",
          "⠍",
          "⠎",
          "⠏",
          "⡈",
          "⡉",
          "⡊",
          "⡋",
          "⡌",
          "⡍",
          "⡎",
          "⡏",
          "⠐",
          "⠑",
          "⠒",
          "⠓",
          "⠔",
          "⠕",
          "⠖",
          "⠗",
          "⡐",
          "⡑",
          "⡒",
          "⡓",
          "⡔",
          "⡕",
          "⡖",
          "⡗",
          "⠘",
          "⠙",
          "⠚",
          "⠛",
          "⠜",
          "⠝",
          "⠞",
          "⠟",
          "⡘",
          "⡙",
          "⡚",
          "⡛",
          "⡜",
          "⡝",
          "⡞",
          "⡟",
          "⠠",
          "⠡",
          "⠢",
          "⠣",
          "⠤",
          "⠥",
          "⠦",
          "⠧",
          "⡠",
          "⡡",
          "⡢",
          "⡣",
          "⡤",
          "⡥",
          "⡦",
          "⡧",
          "⠨",
          "⠩",
          "⠪",
          "⠫",
          "⠬",
          "⠭",
          "⠮",
          "⠯",
          "⡨",
          "⡩",
          "⡪",
          "⡫",
          "⡬",
          "⡭",
          "⡮",
          "⡯",
          "⠰",
          "⠱",
          "⠲",
          "⠳",
          "⠴",
          "⠵",
          "⠶",
          "⠷",
          "⡰",
          "⡱",
          "⡲",
          "⡳",
          "⡴",
          "⡵",
          "⡶",
          "⡷",
          "⠸",
          "⠹",
          "⠺",
          "⠻",
          "⠼",
          "⠽",
          "⠾",
          "⠿",
          "⡸",
          "⡹",
          "⡺",
          "⡻",
          "⡼",
          "⡽",
          "⡾",
          "⡿",
          "⢀",
          "⢁",
          "⢂",
          "⢃",
          "⢄",
          "⢅",
          "⢆",
          "⢇",
          "⣀",
          "⣁",
          "⣂",
          "⣃",
          "⣄",
          "⣅",
          "⣆",
          "⣇",
          "⢈",
          "⢉",
          "⢊",
          "⢋",
          "⢌",
          "⢍",
          "⢎",
          "⢏",
          "⣈",
          "⣉",
          "⣊",
          "⣋",
          "⣌",
          "⣍",
          "⣎",
          "⣏",
          "⢐",
          "⢑",
          "⢒",
          "⢓",
          "⢔",
          "⢕",
          "⢖",
          "⢗",
          "⣐",
          "⣑",
          "⣒",
          "⣓",
          "⣔",
          "⣕",
          "⣖",
          "⣗",
          "⢘",
          "⢙",
          "⢚",
          "⢛",
          "⢜",
          "⢝",
          "⢞",
          "⢟",
          "⣘",
          "⣙",
          "⣚",
          "⣛",
          "⣜",
          "⣝",
          "⣞",
          "⣟",
          "⢠",
          "⢡",
          "⢢",
          "⢣",
          "⢤",
          "⢥",
          "⢦",
          "⢧",
          "⣠",
          "⣡",
          "⣢",
          "⣣",
          "⣤",
          "⣥",
          "⣦",
          "⣧",
          "⢨",
          "⢩",
          "⢪",
          "⢫",
          "⢬",
          "⢭",
          "⢮",
          "⢯",
          "⣨",
          "⣩",
          "⣪",
          "⣫",
          "⣬",
          "⣭",
          "⣮",
          "⣯",
          "⢰",
          "⢱",
          "⢲",
          "⢳",
          "⢴",
          "⢵",
          "⢶",
          "⢷",
          "⣰",
          "⣱",
          "⣲",
          "⣳",
          "⣴",
          "⣵",
          "⣶",
          "⣷",
          "⢸",
          "⢹",
          "⢺",
          "⢻",
          "⢼",
          "⢽",
          "⢾",
          "⢿",
          "⣸",
          "⣹",
          "⣺",
          "⣻",
          "⣼",
          "⣽",
          "⣾",
          "⣿"
        ]
      },
      sand: {
        interval: 80,
        frames: [
          "⠁",
          "⠂",
          "⠄",
          "⡀",
          "⡈",
          "⡐",
          "⡠",
          "⣀",
          "⣁",
          "⣂",
          "⣄",
          "⣌",
          "⣔",
          "⣤",
          "⣥",
          "⣦",
          "⣮",
          "⣶",
          "⣷",
          "⣿",
          "⡿",
          "⠿",
          "⢟",
          "⠟",
          "⡛",
          "⠛",
          "⠫",
          "⢋",
          "⠋",
          "⠍",
          "⡉",
          "⠉",
          "⠑",
          "⠡",
          "⢁"
        ]
      },
      line: {
        interval: 130,
        frames: [
          "-",
          "\\",
          "|",
          "/"
        ]
      },
      line2: {
        interval: 100,
        frames: [
          "⠂",
          "-",
          "–",
          "—",
          "–",
          "-"
        ]
      },
      pipe: {
        interval: 100,
        frames: [
          "┤",
          "┘",
          "┴",
          "└",
          "├",
          "┌",
          "┬",
          "┐"
        ]
      },
      simpleDots: {
        interval: 400,
        frames: [
          ".  ",
          ".. ",
          "...",
          "   "
        ]
      },
      simpleDotsScrolling: {
        interval: 200,
        frames: [
          ".  ",
          ".. ",
          "...",
          " ..",
          "  .",
          "   "
        ]
      },
      star: {
        interval: 70,
        frames: [
          "✶",
          "✸",
          "✹",
          "✺",
          "✹",
          "✷"
        ]
      },
      star2: {
        interval: 80,
        frames: [
          "+",
          "x",
          "*"
        ]
      },
      flip: {
        interval: 70,
        frames: [
          "_",
          "_",
          "_",
          "-",
          "`",
          "`",
          "'",
          "´",
          "-",
          "_",
          "_",
          "_"
        ]
      },
      hamburger: {
        interval: 100,
        frames: [
          "☱",
          "☲",
          "☴"
        ]
      },
      growVertical: {
        interval: 120,
        frames: [
          "▁",
          "▃",
          "▄",
          "▅",
          "▆",
          "▇",
          "▆",
          "▅",
          "▄",
          "▃"
        ]
      },
      growHorizontal: {
        interval: 120,
        frames: [
          "▏",
          "▎",
          "▍",
          "▌",
          "▋",
          "▊",
          "▉",
          "▊",
          "▋",
          "▌",
          "▍",
          "▎"
        ]
      },
      balloon: {
        interval: 140,
        frames: [
          " ",
          ".",
          "o",
          "O",
          "@",
          "*",
          " "
        ]
      },
      balloon2: {
        interval: 120,
        frames: [
          ".",
          "o",
          "O",
          "°",
          "O",
          "o",
          "."
        ]
      },
      noise: {
        interval: 100,
        frames: [
          "▓",
          "▒",
          "░"
        ]
      },
      bounce: {
        interval: 120,
        frames: [
          "⠁",
          "⠂",
          "⠄",
          "⠂"
        ]
      },
      boxBounce: {
        interval: 120,
        frames: [
          "▖",
          "▘",
          "▝",
          "▗"
        ]
      },
      boxBounce2: {
        interval: 100,
        frames: [
          "▌",
          "▀",
          "▐",
          "▄"
        ]
      },
      triangle: {
        interval: 50,
        frames: [
          "◢",
          "◣",
          "◤",
          "◥"
        ]
      },
      binary: {
        interval: 80,
        frames: [
          "010010",
          "001100",
          "100101",
          "111010",
          "111101",
          "010111",
          "101011",
          "111000",
          "110011",
          "110101"
        ]
      },
      arc: {
        interval: 100,
        frames: [
          "◜",
          "◠",
          "◝",
          "◞",
          "◡",
          "◟"
        ]
      },
      circle: {
        interval: 120,
        frames: [
          "◡",
          "⊙",
          "◠"
        ]
      },
      squareCorners: {
        interval: 180,
        frames: [
          "◰",
          "◳",
          "◲",
          "◱"
        ]
      },
      circleQuarters: {
        interval: 120,
        frames: [
          "◴",
          "◷",
          "◶",
          "◵"
        ]
      },
      circleHalves: {
        interval: 50,
        frames: [
          "◐",
          "◓",
          "◑",
          "◒"
        ]
      },
      squish: {
        interval: 100,
        frames: [
          "╫",
          "╪"
        ]
      },
      toggle: {
        interval: 250,
        frames: [
          "⊶",
          "⊷"
        ]
      },
      toggle2: {
        interval: 80,
        frames: [
          "▫",
          "▪"
        ]
      },
      toggle3: {
        interval: 120,
        frames: [
          "□",
          "■"
        ]
      },
      toggle4: {
        interval: 100,
        frames: [
          "■",
          "□",
          "▪",
          "▫"
        ]
      },
      toggle5: {
        interval: 100,
        frames: [
          "▮",
          "▯"
        ]
      },
      toggle6: {
        interval: 300,
        frames: [
          "ဝ",
          "၀"
        ]
      },
      toggle7: {
        interval: 80,
        frames: [
          "⦾",
          "⦿"
        ]
      },
      toggle8: {
        interval: 100,
        frames: [
          "◍",
          "◌"
        ]
      },
      toggle9: {
        interval: 100,
        frames: [
          "◉",
          "◎"
        ]
      },
      toggle10: {
        interval: 100,
        frames: [
          "㊂",
          "㊀",
          "㊁"
        ]
      },
      toggle11: {
        interval: 50,
        frames: [
          "⧇",
          "⧆"
        ]
      },
      toggle12: {
        interval: 120,
        frames: [
          "☗",
          "☖"
        ]
      },
      toggle13: {
        interval: 80,
        frames: [
          "=",
          "*",
          "-"
        ]
      },
      arrow: {
        interval: 100,
        frames: [
          "←",
          "↖",
          "↑",
          "↗",
          "→",
          "↘",
          "↓",
          "↙"
        ]
      },
      arrow2: {
        interval: 80,
        frames: [
          "⬆️ ",
          "↗️ ",
          "➡️ ",
          "↘️ ",
          "⬇️ ",
          "↙️ ",
          "⬅️ ",
          "↖️ "
        ]
      },
      arrow3: {
        interval: 120,
        frames: [
          "▹▹▹▹▹",
          "▸▹▹▹▹",
          "▹▸▹▹▹",
          "▹▹▸▹▹",
          "▹▹▹▸▹",
          "▹▹▹▹▸"
        ]
      },
      bouncingBar: {
        interval: 80,
        frames: [
          "[    ]",
          "[=   ]",
          "[==  ]",
          "[=== ]",
          "[ ===]",
          "[  ==]",
          "[   =]",
          "[    ]",
          "[   =]",
          "[  ==]",
          "[ ===]",
          "[====]",
          "[=== ]",
          "[==  ]",
          "[=   ]"
        ]
      },
      bouncingBall: {
        interval: 80,
        frames: [
          "( ●    )",
          "(  ●   )",
          "(   ●  )",
          "(    ● )",
          "(     ●)",
          "(    ● )",
          "(   ●  )",
          "(  ●   )",
          "( ●    )",
          "(●     )"
        ]
      },
      smiley: {
        interval: 200,
        frames: [
          "😄 ",
          "😝 "
        ]
      },
      monkey: {
        interval: 300,
        frames: [
          "🙈 ",
          "🙈 ",
          "🙉 ",
          "🙊 "
        ]
      },
      hearts: {
        interval: 100,
        frames: [
          "💛 ",
          "💙 ",
          "💜 ",
          "💚 ",
          "❤️ "
        ]
      },
      clock: {
        interval: 100,
        frames: [
          "🕛 ",
          "🕐 ",
          "🕑 ",
          "🕒 ",
          "🕓 ",
          "🕔 ",
          "🕕 ",
          "🕖 ",
          "🕗 ",
          "🕘 ",
          "🕙 ",
          "🕚 "
        ]
      },
      earth: {
        interval: 180,
        frames: [
          "🌍 ",
          "🌎 ",
          "🌏 "
        ]
      },
      material: {
        interval: 17,
        frames: [
          "█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁",
          "██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁",
          "███▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁",
          "████▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁",
          "██████▁▁▁▁▁▁▁▁▁▁▁▁▁▁",
          "██████▁▁▁▁▁▁▁▁▁▁▁▁▁▁",
          "███████▁▁▁▁▁▁▁▁▁▁▁▁▁",
          "████████▁▁▁▁▁▁▁▁▁▁▁▁",
          "█████████▁▁▁▁▁▁▁▁▁▁▁",
          "█████████▁▁▁▁▁▁▁▁▁▁▁",
          "██████████▁▁▁▁▁▁▁▁▁▁",
          "███████████▁▁▁▁▁▁▁▁▁",
          "█████████████▁▁▁▁▁▁▁",
          "██████████████▁▁▁▁▁▁",
          "██████████████▁▁▁▁▁▁",
          "▁██████████████▁▁▁▁▁",
          "▁██████████████▁▁▁▁▁",
          "▁██████████████▁▁▁▁▁",
          "▁▁██████████████▁▁▁▁",
          "▁▁▁██████████████▁▁▁",
          "▁▁▁▁█████████████▁▁▁",
          "▁▁▁▁██████████████▁▁",
          "▁▁▁▁██████████████▁▁",
          "▁▁▁▁▁██████████████▁",
          "▁▁▁▁▁██████████████▁",
          "▁▁▁▁▁██████████████▁",
          "▁▁▁▁▁▁██████████████",
          "▁▁▁▁▁▁██████████████",
          "▁▁▁▁▁▁▁█████████████",
          "▁▁▁▁▁▁▁█████████████",
          "▁▁▁▁▁▁▁▁████████████",
          "▁▁▁▁▁▁▁▁████████████",
          "▁▁▁▁▁▁▁▁▁███████████",
          "▁▁▁▁▁▁▁▁▁███████████",
          "▁▁▁▁▁▁▁▁▁▁██████████",
          "▁▁▁▁▁▁▁▁▁▁██████████",
          "▁▁▁▁▁▁▁▁▁▁▁▁████████",
          "▁▁▁▁▁▁▁▁▁▁▁▁▁███████",
          "▁▁▁▁▁▁▁▁▁▁▁▁▁▁██████",
          "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█████",
          "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█████",
          "█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁████",
          "██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁███",
          "██▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁███",
          "███▁▁▁▁▁▁▁▁▁▁▁▁▁▁███",
          "████▁▁▁▁▁▁▁▁▁▁▁▁▁▁██",
          "█████▁▁▁▁▁▁▁▁▁▁▁▁▁▁█",
          "█████▁▁▁▁▁▁▁▁▁▁▁▁▁▁█",
          "██████▁▁▁▁▁▁▁▁▁▁▁▁▁█",
          "████████▁▁▁▁▁▁▁▁▁▁▁▁",
          "█████████▁▁▁▁▁▁▁▁▁▁▁",
          "█████████▁▁▁▁▁▁▁▁▁▁▁",
          "█████████▁▁▁▁▁▁▁▁▁▁▁",
          "█████████▁▁▁▁▁▁▁▁▁▁▁",
          "███████████▁▁▁▁▁▁▁▁▁",
          "████████████▁▁▁▁▁▁▁▁",
          "████████████▁▁▁▁▁▁▁▁",
          "██████████████▁▁▁▁▁▁",
          "██████████████▁▁▁▁▁▁",
          "▁██████████████▁▁▁▁▁",
          "▁██████████████▁▁▁▁▁",
          "▁▁▁█████████████▁▁▁▁",
          "▁▁▁▁▁████████████▁▁▁",
          "▁▁▁▁▁████████████▁▁▁",
          "▁▁▁▁▁▁███████████▁▁▁",
          "▁▁▁▁▁▁▁▁█████████▁▁▁",
          "▁▁▁▁▁▁▁▁█████████▁▁▁",
          "▁▁▁▁▁▁▁▁▁█████████▁▁",
          "▁▁▁▁▁▁▁▁▁█████████▁▁",
          "▁▁▁▁▁▁▁▁▁▁█████████▁",
          "▁▁▁▁▁▁▁▁▁▁▁████████▁",
          "▁▁▁▁▁▁▁▁▁▁▁████████▁",
          "▁▁▁▁▁▁▁▁▁▁▁▁███████▁",
          "▁▁▁▁▁▁▁▁▁▁▁▁███████▁",
          "▁▁▁▁▁▁▁▁▁▁▁▁▁███████",
          "▁▁▁▁▁▁▁▁▁▁▁▁▁███████",
          "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█████",
          "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁████",
          "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁████",
          "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁████",
          "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁███",
          "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁███",
          "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁██",
          "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁██",
          "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁██",
          "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█",
          "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█",
          "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█",
          "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁",
          "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁",
          "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁",
          "▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁"
        ]
      },
      moon: {
        interval: 80,
        frames: [
          "🌑 ",
          "🌒 ",
          "🌓 ",
          "🌔 ",
          "🌕 ",
          "🌖 ",
          "🌗 ",
          "🌘 "
        ]
      },
      runner: {
        interval: 140,
        frames: [
          "🚶 ",
          "🏃 "
        ]
      },
      pong: {
        interval: 80,
        frames: [
          "▐⠂       ▌",
          "▐⠈       ▌",
          "▐ ⠂      ▌",
          "▐ ⠠      ▌",
          "▐  ⡀     ▌",
          "▐  ⠠     ▌",
          "▐   ⠂    ▌",
          "▐   ⠈    ▌",
          "▐    ⠂   ▌",
          "▐    ⠠   ▌",
          "▐     ⡀  ▌",
          "▐     ⠠  ▌",
          "▐      ⠂ ▌",
          "▐      ⠈ ▌",
          "▐       ⠂▌",
          "▐       ⠠▌",
          "▐       ⡀▌",
          "▐      ⠠ ▌",
          "▐      ⠂ ▌",
          "▐     ⠈  ▌",
          "▐     ⠂  ▌",
          "▐    ⠠   ▌",
          "▐    ⡀   ▌",
          "▐   ⠠    ▌",
          "▐   ⠂    ▌",
          "▐  ⠈     ▌",
          "▐  ⠂     ▌",
          "▐ ⠠      ▌",
          "▐ ⡀      ▌",
          "▐⠠       ▌"
        ]
      },
      shark: {
        interval: 120,
        frames: [
          "▐|\\____________▌",
          "▐_|\\___________▌",
          "▐__|\\__________▌",
          "▐___|\\_________▌",
          "▐____|\\________▌",
          "▐_____|\\_______▌",
          "▐______|\\______▌",
          "▐_______|\\_____▌",
          "▐________|\\____▌",
          "▐_________|\\___▌",
          "▐__________|\\__▌",
          "▐___________|\\_▌",
          "▐____________|\\▌",
          "▐____________/|▌",
          "▐___________/|_▌",
          "▐__________/|__▌",
          "▐_________/|___▌",
          "▐________/|____▌",
          "▐_______/|_____▌",
          "▐______/|______▌",
          "▐_____/|_______▌",
          "▐____/|________▌",
          "▐___/|_________▌",
          "▐__/|__________▌",
          "▐_/|___________▌",
          "▐/|____________▌"
        ]
      },
      dqpb: {
        interval: 100,
        frames: [
          "d",
          "q",
          "p",
          "b"
        ]
      },
      weather: {
        interval: 100,
        frames: [
          "☀️ ",
          "☀️ ",
          "☀️ ",
          "🌤 ",
          "⛅️ ",
          "🌥 ",
          "☁️ ",
          "🌧 ",
          "🌨 ",
          "🌧 ",
          "🌨 ",
          "🌧 ",
          "🌨 ",
          "⛈ ",
          "🌨 ",
          "🌧 ",
          "🌨 ",
          "☁️ ",
          "🌥 ",
          "⛅️ ",
          "🌤 ",
          "☀️ ",
          "☀️ "
        ]
      },
      christmas: {
        interval: 400,
        frames: [
          "🌲",
          "🎄"
        ]
      },
      grenade: {
        interval: 80,
        frames: [
          "،  ",
          "′  ",
          " ´ ",
          " ‾ ",
          "  ⸌",
          "  ⸊",
          "  |",
          "  ⁎",
          "  ⁕",
          " ෴ ",
          "  ⁓",
          "   ",
          "   ",
          "   "
        ]
      },
      point: {
        interval: 125,
        frames: [
          "∙∙∙",
          "●∙∙",
          "∙●∙",
          "∙∙●",
          "∙∙∙"
        ]
      },
      layer: {
        interval: 150,
        frames: [
          "-",
          "=",
          "≡"
        ]
      },
      betaWave: {
        interval: 80,
        frames: [
          "ρββββββ",
          "βρβββββ",
          "ββρββββ",
          "βββρβββ",
          "ββββρββ",
          "βββββρβ",
          "ββββββρ"
        ]
      },
      fingerDance: {
        interval: 160,
        frames: [
          "🤘 ",
          "🤟 ",
          "🖖 ",
          "✋ ",
          "🤚 ",
          "👆 "
        ]
      },
      fistBump: {
        interval: 80,
        frames: [
          "🤜　　　　🤛 ",
          "🤜　　　　🤛 ",
          "🤜　　　　🤛 ",
          "　🤜　　🤛　 ",
          "　　🤜🤛　　 ",
          "　🤜✨🤛　　 ",
          "🤜　✨　🤛　 "
        ]
      },
      soccerHeader: {
        interval: 80,
        frames: [
          " 🧑⚽️       🧑 ",
          "🧑  ⚽️      🧑 ",
          "🧑   ⚽️     🧑 ",
          "🧑    ⚽️    🧑 ",
          "🧑     ⚽️   🧑 ",
          "🧑      ⚽️  🧑 ",
          "🧑       ⚽️🧑  ",
          "🧑      ⚽️  🧑 ",
          "🧑     ⚽️   🧑 ",
          "🧑    ⚽️    🧑 ",
          "🧑   ⚽️     🧑 ",
          "🧑  ⚽️      🧑 "
        ]
      },
      mindblown: {
        interval: 160,
        frames: [
          "😐 ",
          "😐 ",
          "😮 ",
          "😮 ",
          "😦 ",
          "😦 ",
          "😧 ",
          "😧 ",
          "🤯 ",
          "💥 ",
          "✨ ",
          "　 ",
          "　 ",
          "　 "
        ]
      },
      speaker: {
        interval: 160,
        frames: [
          "🔈 ",
          "🔉 ",
          "🔊 ",
          "🔉 "
        ]
      },
      orangePulse: {
        interval: 100,
        frames: [
          "🔸 ",
          "🔶 ",
          "🟠 ",
          "🟠 ",
          "🔶 "
        ]
      },
      bluePulse: {
        interval: 100,
        frames: [
          "🔹 ",
          "🔷 ",
          "🔵 ",
          "🔵 ",
          "🔷 "
        ]
      },
      orangeBluePulse: {
        interval: 100,
        frames: [
          "🔸 ",
          "🔶 ",
          "🟠 ",
          "🟠 ",
          "🔶 ",
          "🔹 ",
          "🔷 ",
          "🔵 ",
          "🔵 ",
          "🔷 "
        ]
      },
      timeTravel: {
        interval: 100,
        frames: [
          "🕛 ",
          "🕚 ",
          "🕙 ",
          "🕘 ",
          "🕗 ",
          "🕖 ",
          "🕕 ",
          "🕔 ",
          "🕓 ",
          "🕒 ",
          "🕑 ",
          "🕐 "
        ]
      },
      aesthetic: {
        interval: 80,
        frames: [
          "▰▱▱▱▱▱▱",
          "▰▰▱▱▱▱▱",
          "▰▰▰▱▱▱▱",
          "▰▰▰▰▱▱▱",
          "▰▰▰▰▰▱▱",
          "▰▰▰▰▰▰▱",
          "▰▰▰▰▰▰▰",
          "▰▱▱▱▱▱▱"
        ]
      },
      dwarfFortress: {
        interval: 80,
        frames: [
          " ██████£££  ",
          "☺██████£££  ",
          "☺██████£££  ",
          "☺▓█████£££  ",
          "☺▓█████£££  ",
          "☺▒█████£££  ",
          "☺▒█████£££  ",
          "☺░█████£££  ",
          "☺░█████£££  ",
          "☺ █████£££  ",
          " ☺█████£££  ",
          " ☺█████£££  ",
          " ☺▓████£££  ",
          " ☺▓████£££  ",
          " ☺▒████£££  ",
          " ☺▒████£££  ",
          " ☺░████£££  ",
          " ☺░████£££  ",
          " ☺ ████£££  ",
          "  ☺████£££  ",
          "  ☺████£££  ",
          "  ☺▓███£££  ",
          "  ☺▓███£££  ",
          "  ☺▒███£££  ",
          "  ☺▒███£££  ",
          "  ☺░███£££  ",
          "  ☺░███£££  ",
          "  ☺ ███£££  ",
          "   ☺███£££  ",
          "   ☺███£££  ",
          "   ☺▓██£££  ",
          "   ☺▓██£££  ",
          "   ☺▒██£££  ",
          "   ☺▒██£££  ",
          "   ☺░██£££  ",
          "   ☺░██£££  ",
          "   ☺ ██£££  ",
          "    ☺██£££  ",
          "    ☺██£££  ",
          "    ☺▓█£££  ",
          "    ☺▓█£££  ",
          "    ☺▒█£££  ",
          "    ☺▒█£££  ",
          "    ☺░█£££  ",
          "    ☺░█£££  ",
          "    ☺ █£££  ",
          "     ☺█£££  ",
          "     ☺█£££  ",
          "     ☺▓£££  ",
          "     ☺▓£££  ",
          "     ☺▒£££  ",
          "     ☺▒£££  ",
          "     ☺░£££  ",
          "     ☺░£££  ",
          "     ☺ £££  ",
          "      ☺£££  ",
          "      ☺£££  ",
          "      ☺▓££  ",
          "      ☺▓££  ",
          "      ☺▒££  ",
          "      ☺▒££  ",
          "      ☺░££  ",
          "      ☺░££  ",
          "      ☺ ££  ",
          "       ☺££  ",
          "       ☺££  ",
          "       ☺▓£  ",
          "       ☺▓£  ",
          "       ☺▒£  ",
          "       ☺▒£  ",
          "       ☺░£  ",
          "       ☺░£  ",
          "       ☺ £  ",
          "        ☺£  ",
          "        ☺£  ",
          "        ☺▓  ",
          "        ☺▓  ",
          "        ☺▒  ",
          "        ☺▒  ",
          "        ☺░  ",
          "        ☺░  ",
          "        ☺   ",
          "        ☺  &",
          "        ☺ ☼&",
          "       ☺ ☼ &",
          "       ☺☼  &",
          "      ☺☼  & ",
          "      ‼   & ",
          "     ☺   &  ",
          "    ‼    &  ",
          "   ☺    &   ",
          "  ‼     &   ",
          " ☺     &    ",
          "‼      &    ",
          "      &     ",
          "      &     ",
          "     &   ░  ",
          "     &   ▒  ",
          "    &    ▓  ",
          "    &    £  ",
          "   &    ░£  ",
          "   &    ▒£  ",
          "  &     ▓£  ",
          "  &     ££  ",
          " &     ░££  ",
          " &     ▒££  ",
          "&      ▓££  ",
          "&      £££  ",
          "      ░£££  ",
          "      ▒£££  ",
          "      ▓£££  ",
          "      █£££  ",
          "     ░█£££  ",
          "     ▒█£££  ",
          "     ▓█£££  ",
          "     ██£££  ",
          "    ░██£££  ",
          "    ▒██£££  ",
          "    ▓██£££  ",
          "    ███£££  ",
          "   ░███£££  ",
          "   ▒███£££  ",
          "   ▓███£££  ",
          "   ████£££  ",
          "  ░████£££  ",
          "  ▒████£££  ",
          "  ▓████£££  ",
          "  █████£££  ",
          " ░█████£££  ",
          " ▒█████£££  ",
          " ▓█████£££  ",
          " ██████£££  ",
          " ██████£££  "
        ]
      }
    };
  }
});

// node_modules/.pnpm/cli-spinners@2.9.0/node_modules/cli-spinners/index.js
var require_cli_spinners = __commonJS({
  "node_modules/.pnpm/cli-spinners@2.9.0/node_modules/cli-spinners/index.js"(exports3, module2) {
    "use strict";
    var spinners = Object.assign({}, require_spinners());
    var spinnersList = Object.keys(spinners);
    Object.defineProperty(spinners, "random", {
      get() {
        const randomIndex = Math.floor(Math.random() * spinnersList.length);
        const spinnerName = spinnersList[randomIndex];
        return spinners[spinnerName];
      }
    });
    module2.exports = spinners;
  }
});

// node_modules/.pnpm/clone@1.0.4/node_modules/clone/clone.js
var require_clone2 = __commonJS({
  "node_modules/.pnpm/clone@1.0.4/node_modules/clone/clone.js"(exports3, module2) {
    var clone = function() {
      "use strict";
      function clone2(parent, circular, depth2, prototype) {
        var filter2;
        if (typeof circular === "object") {
          depth2 = circular.depth;
          prototype = circular.prototype;
          filter2 = circular.filter;
          circular = circular.circular;
        }
        var allParents = [];
        var allChildren = [];
        var useBuffer = typeof Buffer != "undefined";
        if (typeof circular == "undefined")
          circular = true;
        if (typeof depth2 == "undefined")
          depth2 = Infinity;
        function _clone(parent2, depth3) {
          if (parent2 === null)
            return null;
          if (depth3 == 0)
            return parent2;
          var child;
          var proto3;
          if (typeof parent2 != "object") {
            return parent2;
          }
          if (clone2.__isArray(parent2)) {
            child = [];
          } else if (clone2.__isRegExp(parent2)) {
            child = new RegExp(parent2.source, __getRegExpFlags(parent2));
            if (parent2.lastIndex)
              child.lastIndex = parent2.lastIndex;
          } else if (clone2.__isDate(parent2)) {
            child = new Date(parent2.getTime());
          } else if (useBuffer && Buffer.isBuffer(parent2)) {
            if (Buffer.allocUnsafe) {
              child = Buffer.allocUnsafe(parent2.length);
            } else {
              child = new Buffer(parent2.length);
            }
            parent2.copy(child);
            return child;
          } else {
            if (typeof prototype == "undefined") {
              proto3 = Object.getPrototypeOf(parent2);
              child = Object.create(proto3);
            } else {
              child = Object.create(prototype);
              proto3 = prototype;
            }
          }
          if (circular) {
            var index2 = allParents.indexOf(parent2);
            if (index2 != -1) {
              return allChildren[index2];
            }
            allParents.push(parent2);
            allChildren.push(child);
          }
          for (var i2 in parent2) {
            var attrs;
            if (proto3) {
              attrs = Object.getOwnPropertyDescriptor(proto3, i2);
            }
            if (attrs && attrs.set == null) {
              continue;
            }
            child[i2] = _clone(parent2[i2], depth3 - 1);
          }
          return child;
        }
        return _clone(parent, depth2);
      }
      clone2.clonePrototype = function clonePrototype(parent) {
        if (parent === null)
          return null;
        var c2 = function() {
        };
        c2.prototype = parent;
        return new c2();
      };
      function __objToStr(o3) {
        return Object.prototype.toString.call(o3);
      }
      ;
      clone2.__objToStr = __objToStr;
      function __isDate(o3) {
        return typeof o3 === "object" && __objToStr(o3) === "[object Date]";
      }
      ;
      clone2.__isDate = __isDate;
      function __isArray(o3) {
        return typeof o3 === "object" && __objToStr(o3) === "[object Array]";
      }
      ;
      clone2.__isArray = __isArray;
      function __isRegExp(o3) {
        return typeof o3 === "object" && __objToStr(o3) === "[object RegExp]";
      }
      ;
      clone2.__isRegExp = __isRegExp;
      function __getRegExpFlags(re) {
        var flags = "";
        if (re.global)
          flags += "g";
        if (re.ignoreCase)
          flags += "i";
        if (re.multiline)
          flags += "m";
        return flags;
      }
      ;
      clone2.__getRegExpFlags = __getRegExpFlags;
      return clone2;
    }();
    if (typeof module2 === "object" && module2.exports) {
      module2.exports = clone;
    }
  }
});

// node_modules/.pnpm/defaults@1.0.4/node_modules/defaults/index.js
var require_defaults = __commonJS({
  "node_modules/.pnpm/defaults@1.0.4/node_modules/defaults/index.js"(exports3, module2) {
    var clone = require_clone2();
    module2.exports = function(options3, defaults) {
      options3 = options3 || {};
      Object.keys(defaults).forEach(function(key) {
        if (typeof options3[key] === "undefined") {
          options3[key] = clone(defaults[key]);
        }
      });
      return options3;
    };
  }
});

// node_modules/.pnpm/wcwidth@1.0.1/node_modules/wcwidth/combining.js
var require_combining = __commonJS({
  "node_modules/.pnpm/wcwidth@1.0.1/node_modules/wcwidth/combining.js"(exports3, module2) {
    module2.exports = [
      [768, 879],
      [1155, 1158],
      [1160, 1161],
      [1425, 1469],
      [1471, 1471],
      [1473, 1474],
      [1476, 1477],
      [1479, 1479],
      [1536, 1539],
      [1552, 1557],
      [1611, 1630],
      [1648, 1648],
      [1750, 1764],
      [1767, 1768],
      [1770, 1773],
      [1807, 1807],
      [1809, 1809],
      [1840, 1866],
      [1958, 1968],
      [2027, 2035],
      [2305, 2306],
      [2364, 2364],
      [2369, 2376],
      [2381, 2381],
      [2385, 2388],
      [2402, 2403],
      [2433, 2433],
      [2492, 2492],
      [2497, 2500],
      [2509, 2509],
      [2530, 2531],
      [2561, 2562],
      [2620, 2620],
      [2625, 2626],
      [2631, 2632],
      [2635, 2637],
      [2672, 2673],
      [2689, 2690],
      [2748, 2748],
      [2753, 2757],
      [2759, 2760],
      [2765, 2765],
      [2786, 2787],
      [2817, 2817],
      [2876, 2876],
      [2879, 2879],
      [2881, 2883],
      [2893, 2893],
      [2902, 2902],
      [2946, 2946],
      [3008, 3008],
      [3021, 3021],
      [3134, 3136],
      [3142, 3144],
      [3146, 3149],
      [3157, 3158],
      [3260, 3260],
      [3263, 3263],
      [3270, 3270],
      [3276, 3277],
      [3298, 3299],
      [3393, 3395],
      [3405, 3405],
      [3530, 3530],
      [3538, 3540],
      [3542, 3542],
      [3633, 3633],
      [3636, 3642],
      [3655, 3662],
      [3761, 3761],
      [3764, 3769],
      [3771, 3772],
      [3784, 3789],
      [3864, 3865],
      [3893, 3893],
      [3895, 3895],
      [3897, 3897],
      [3953, 3966],
      [3968, 3972],
      [3974, 3975],
      [3984, 3991],
      [3993, 4028],
      [4038, 4038],
      [4141, 4144],
      [4146, 4146],
      [4150, 4151],
      [4153, 4153],
      [4184, 4185],
      [4448, 4607],
      [4959, 4959],
      [5906, 5908],
      [5938, 5940],
      [5970, 5971],
      [6002, 6003],
      [6068, 6069],
      [6071, 6077],
      [6086, 6086],
      [6089, 6099],
      [6109, 6109],
      [6155, 6157],
      [6313, 6313],
      [6432, 6434],
      [6439, 6440],
      [6450, 6450],
      [6457, 6459],
      [6679, 6680],
      [6912, 6915],
      [6964, 6964],
      [6966, 6970],
      [6972, 6972],
      [6978, 6978],
      [7019, 7027],
      [7616, 7626],
      [7678, 7679],
      [8203, 8207],
      [8234, 8238],
      [8288, 8291],
      [8298, 8303],
      [8400, 8431],
      [12330, 12335],
      [12441, 12442],
      [43014, 43014],
      [43019, 43019],
      [43045, 43046],
      [64286, 64286],
      [65024, 65039],
      [65056, 65059],
      [65279, 65279],
      [65529, 65531],
      [68097, 68099],
      [68101, 68102],
      [68108, 68111],
      [68152, 68154],
      [68159, 68159],
      [119143, 119145],
      [119155, 119170],
      [119173, 119179],
      [119210, 119213],
      [119362, 119364],
      [917505, 917505],
      [917536, 917631],
      [917760, 917999]
    ];
  }
});

// node_modules/.pnpm/wcwidth@1.0.1/node_modules/wcwidth/index.js
var require_wcwidth = __commonJS({
  "node_modules/.pnpm/wcwidth@1.0.1/node_modules/wcwidth/index.js"(exports3, module2) {
    "use strict";
    var defaults = require_defaults();
    var combining = require_combining();
    var DEFAULTS = {
      nul: 0,
      control: 0
    };
    module2.exports = function wcwidth3(str2) {
      return wcswidth(str2, DEFAULTS);
    };
    module2.exports.config = function(opts) {
      opts = defaults(opts || {}, DEFAULTS);
      return function wcwidth3(str2) {
        return wcswidth(str2, opts);
      };
    };
    function wcswidth(str2, opts) {
      if (typeof str2 !== "string")
        return wcwidth2(str2, opts);
      var s2 = 0;
      for (var i2 = 0; i2 < str2.length; i2++) {
        var n3 = wcwidth2(str2.charCodeAt(i2), opts);
        if (n3 < 0)
          return -1;
        s2 += n3;
      }
      return s2;
    }
    function wcwidth2(ucs, opts) {
      if (ucs === 0)
        return opts.nul;
      if (ucs < 32 || ucs >= 127 && ucs < 160)
        return opts.control;
      if (bisearch(ucs))
        return 0;
      return 1 + (ucs >= 4352 && (ucs <= 4447 || // Hangul Jamo init. consonants
      ucs == 9001 || ucs == 9002 || ucs >= 11904 && ucs <= 42191 && ucs != 12351 || // CJK ... Yi
      ucs >= 44032 && ucs <= 55203 || // Hangul Syllables
      ucs >= 63744 && ucs <= 64255 || // CJK Compatibility Ideographs
      ucs >= 65040 && ucs <= 65049 || // Vertical forms
      ucs >= 65072 && ucs <= 65135 || // CJK Compatibility Forms
      ucs >= 65280 && ucs <= 65376 || // Fullwidth Forms
      ucs >= 65504 && ucs <= 65510 || ucs >= 131072 && ucs <= 196605 || ucs >= 196608 && ucs <= 262141));
    }
    function bisearch(ucs) {
      var min2 = 0;
      var max = combining.length - 1;
      var mid;
      if (ucs < combining[0][0] || ucs > combining[max][1])
        return false;
      while (max >= min2) {
        mid = Math.floor((min2 + max) / 2);
        if (ucs > combining[mid][1])
          min2 = mid + 1;
        else if (ucs < combining[mid][0])
          max = mid - 1;
        else
          return true;
      }
      return false;
    }
  }
});

// browser-external:node:readline
var require_node_readline = __commonJS({
  "browser-external:node:readline"(exports3, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:readline" has been externalized for browser compatibility. Cannot access "node:readline.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/stream-browser.js
var require_stream_browser = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports3, module2) {
    module2.exports = require_events().EventEmitter;
  }
});

// node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js"(exports3) {
    "use strict";
    exports3.byteLength = byteLength;
    exports3.toByteArray = toByteArray;
    exports3.fromByteArray = fromByteArray;
    var lookup2 = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i2 = 0, len = code.length; i2 < len; ++i2) {
      lookup2[i2] = code[i2];
      revLookup[code.charCodeAt(i2)] = i2;
    }
    var i2;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i3;
      for (i3 = 0; i3 < len2; i3 += 4) {
        tmp = revLookup[b64.charCodeAt(i3)] << 18 | revLookup[b64.charCodeAt(i3 + 1)] << 12 | revLookup[b64.charCodeAt(i3 + 2)] << 6 | revLookup[b64.charCodeAt(i3 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i3)] << 2 | revLookup[b64.charCodeAt(i3 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i3)] << 10 | revLookup[b64.charCodeAt(i3 + 1)] << 4 | revLookup[b64.charCodeAt(i3 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup2[num >> 18 & 63] + lookup2[num >> 12 & 63] + lookup2[num >> 6 & 63] + lookup2[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i3 = start; i3 < end; i3 += 3) {
        tmp = (uint8[i3] << 16 & 16711680) + (uint8[i3 + 1] << 8 & 65280) + (uint8[i3 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i3 = 0, len22 = len2 - extraBytes; i3 < len22; i3 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i3, i3 + maxChunkLength > len22 ? len22 : i3 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup2[tmp >> 2] + lookup2[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup2[tmp >> 10] + lookup2[tmp >> 4 & 63] + lookup2[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js"(exports3) {
    exports3.read = function(buffer, offset3, isLE, mLen, nBytes) {
      var e3, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i2 = isLE ? nBytes - 1 : 0;
      var d2 = isLE ? -1 : 1;
      var s2 = buffer[offset3 + i2];
      i2 += d2;
      e3 = s2 & (1 << -nBits) - 1;
      s2 >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e3 = e3 * 256 + buffer[offset3 + i2], i2 += d2, nBits -= 8) {
      }
      m = e3 & (1 << -nBits) - 1;
      e3 >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset3 + i2], i2 += d2, nBits -= 8) {
      }
      if (e3 === 0) {
        e3 = 1 - eBias;
      } else if (e3 === eMax) {
        return m ? NaN : (s2 ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e3 = e3 - eBias;
      }
      return (s2 ? -1 : 1) * m * Math.pow(2, e3 - mLen);
    };
    exports3.write = function(buffer, value2, offset3, isLE, mLen, nBytes) {
      var e3, m, c2;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i2 = isLE ? 0 : nBytes - 1;
      var d2 = isLE ? 1 : -1;
      var s2 = value2 < 0 || value2 === 0 && 1 / value2 < 0 ? 1 : 0;
      value2 = Math.abs(value2);
      if (isNaN(value2) || value2 === Infinity) {
        m = isNaN(value2) ? 1 : 0;
        e3 = eMax;
      } else {
        e3 = Math.floor(Math.log(value2) / Math.LN2);
        if (value2 * (c2 = Math.pow(2, -e3)) < 1) {
          e3--;
          c2 *= 2;
        }
        if (e3 + eBias >= 1) {
          value2 += rt / c2;
        } else {
          value2 += rt * Math.pow(2, 1 - eBias);
        }
        if (value2 * c2 >= 2) {
          e3++;
          c2 /= 2;
        }
        if (e3 + eBias >= eMax) {
          m = 0;
          e3 = eMax;
        } else if (e3 + eBias >= 1) {
          m = (value2 * c2 - 1) * Math.pow(2, mLen);
          e3 = e3 + eBias;
        } else {
          m = value2 * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e3 = 0;
        }
      }
      for (; mLen >= 8; buffer[offset3 + i2] = m & 255, i2 += d2, m /= 256, mLen -= 8) {
      }
      e3 = e3 << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset3 + i2] = e3 & 255, i2 += d2, e3 /= 256, eLen -= 8) {
      }
      buffer[offset3 + i2 - d2] |= s2 * 128;
    };
  }
});

// node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js"(exports3) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports3.Buffer = Buffer2;
    exports3.SlowBuffer = SlowBuffer;
    exports3.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports3.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto3 = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto3, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto3);
        return arr.foo() === 42;
      } catch (e3) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer2.poolSize = 8192;
    function from(value2, encodingOrOffset, length) {
      if (typeof value2 === "string") {
        return fromString(value2, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value2)) {
        return fromArrayView(value2);
      }
      if (value2 == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2
        );
      }
      if (isInstance(value2, ArrayBuffer) || value2 && isInstance(value2.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value2, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value2, SharedArrayBuffer) || value2 && isInstance(value2.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value2, encodingOrOffset, length);
      }
      if (typeof value2 === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value2.valueOf && value2.valueOf();
      if (valueOf != null && valueOf !== value2) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      const b = fromObject(value2);
      if (b)
        return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value2[Symbol.toPrimitive] === "function") {
        return Buffer2.from(value2[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2
      );
    }
    Buffer2.from = function(value2, encodingOrOffset, length) {
      return from(value2, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill2, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill2 !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill2, encoding) : createBuffer(size).fill(fill2);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill2, encoding) {
      return alloc(size, fill2, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string3, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string3, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string3, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array2) {
      const length = array2.length < 0 ? 0 : checked(array2.length) | 0;
      const buf = createBuffer(length);
      for (let i2 = 0; i2 < length; i2 += 1) {
        buf[i2] = array2[i2] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array2, byteOffset, length) {
      if (byteOffset < 0 || array2.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array2.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array2);
      } else if (length === void 0) {
        buf = new Uint8Array(array2, byteOffset);
      } else {
        buf = new Uint8Array(array2, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    Buffer2.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer2.prototype;
    };
    Buffer2.compare = function compare2(a2, b) {
      if (isInstance(a2, Uint8Array))
        a2 = Buffer2.from(a2, a2.offset, a2.byteLength);
      if (isInstance(b, Uint8Array))
        b = Buffer2.from(b, b.offset, b.byteLength);
      if (!Buffer2.isBuffer(a2) || !Buffer2.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a2 === b)
        return 0;
      let x = a2.length;
      let y = b.length;
      for (let i2 = 0, len = Math.min(x, y); i2 < len; ++i2) {
        if (a2[i2] !== b[i2]) {
          x = a2[i2];
          y = b[i2];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat2(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      let i2;
      if (length === void 0) {
        length = 0;
        for (i2 = 0; i2 < list.length; ++i2) {
          length += list[i2].length;
        }
      }
      const buffer = Buffer2.allocUnsafe(length);
      let pos = 0;
      for (i2 = 0; i2 < list.length; ++i2) {
        let buf = list[i2];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer2.isBuffer(buf))
              buf = Buffer2.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string3, encoding) {
      if (Buffer2.isBuffer(string3)) {
        return string3.length;
      }
      if (ArrayBuffer.isView(string3) || isInstance(string3, ArrayBuffer)) {
        return string3.byteLength;
      }
      if (typeof string3 !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string3
        );
      }
      const len = string3.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string3).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string3).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string3).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b, n3, m) {
      const i2 = b[n3];
      b[n3] = b[m];
      b[m] = i2;
    }
    Buffer2.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i2 = 0; i2 < len; i2 += 2) {
        swap(this, i2, i2 + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i2 = 0; i2 < len; i2 += 4) {
        swap(this, i2, i2 + 3);
        swap(this, i2 + 1, i2 + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i2 = 0; i2 < len; i2 += 8) {
        swap(this, i2, i2 + 7);
        swap(this, i2 + 1, i2 + 6);
        swap(this, i2 + 2, i2 + 5);
        swap(this, i2 + 3, i2 + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString2() {
      const length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals2(b) {
      if (!Buffer2.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect2() {
      let str2 = "";
      const max = exports3.INSPECT_MAX_BYTES;
      str2 = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str2 += " ... ";
      return "<Buffer " + str2 + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i2 = 0; i2 < len; ++i2) {
        if (thisCopy[i2] !== targetCopy[i2]) {
          x = thisCopy[i2];
          y = targetCopy[i2];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read2(buf, i3) {
        if (indexSize === 1) {
          return buf[i3];
        } else {
          return buf.readUInt16BE(i3 * indexSize);
        }
      }
      let i2;
      if (dir) {
        let foundIndex = -1;
        for (i2 = byteOffset; i2 < arrLength; i2++) {
          if (read2(arr, i2) === read2(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i2;
            if (i2 - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i2 -= i2 - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i2 = byteOffset; i2 >= 0; i2--) {
          let found2 = true;
          for (let j = 0; j < valLength; j++) {
            if (read2(arr, i2 + j) !== read2(val, j)) {
              found2 = false;
              break;
            }
          }
          if (found2)
            return i2;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf3(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string3, offset3, length) {
      offset3 = Number(offset3) || 0;
      const remaining = buf.length - offset3;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string3.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i2;
      for (i2 = 0; i2 < length; ++i2) {
        const parsed = parseInt(string3.substr(i2 * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i2;
        buf[offset3 + i2] = parsed;
      }
      return i2;
    }
    function utf8Write(buf, string3, offset3, length) {
      return blitBuffer(utf8ToBytes(string3, buf.length - offset3), buf, offset3, length);
    }
    function asciiWrite(buf, string3, offset3, length) {
      return blitBuffer(asciiToBytes(string3), buf, offset3, length);
    }
    function base64Write(buf, string3, offset3, length) {
      return blitBuffer(base64ToBytes(string3), buf, offset3, length);
    }
    function ucs2Write(buf, string3, offset3, length) {
      return blitBuffer(utf16leToBytes(string3, buf.length - offset3), buf, offset3, length);
    }
    Buffer2.prototype.write = function write(string3, offset3, length, encoding) {
      if (offset3 === void 0) {
        encoding = "utf8";
        length = this.length;
        offset3 = 0;
      } else if (length === void 0 && typeof offset3 === "string") {
        encoding = offset3;
        length = this.length;
        offset3 = 0;
      } else if (isFinite(offset3)) {
        offset3 = offset3 >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset3;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string3.length > 0 && (length < 0 || offset3 < 0) || offset3 > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string3, offset3, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string3, offset3, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string3, offset3, length);
          case "base64":
            return base64Write(this, string3, offset3, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string3, offset3, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i2 = start;
      while (i2 < end) {
        const firstByte = buf[i2];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i2 + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i2 + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i2 + 1];
              thirdByte = buf[i2 + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i2 + 1];
              thirdByte = buf[i2 + 2];
              fourthByte = buf[i2 + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i2 += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i2 = 0;
      while (i2 < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i2 = start; i2 < end; ++i2) {
        ret += String.fromCharCode(buf[i2] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i2 = start; i2 < end; ++i2) {
        ret += String.fromCharCode(buf[i2]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out2 = "";
      for (let i2 = start; i2 < end; ++i2) {
        out2 += hexSliceLookupTable[buf[i2]];
      }
      return out2;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i2 = 0; i2 < bytes.length - 1; i2 += 2) {
        res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice2(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset3, ext2, length) {
      if (offset3 % 1 !== 0 || offset3 < 0)
        throw new RangeError("offset is not uint");
      if (offset3 + ext2 > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset3, byteLength2, noAssert) {
      offset3 = offset3 >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset3, byteLength2, this.length);
      let val = this[offset3];
      let mul = 1;
      let i2 = 0;
      while (++i2 < byteLength2 && (mul *= 256)) {
        val += this[offset3 + i2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset3, byteLength2, noAssert) {
      offset3 = offset3 >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset3, byteLength2, this.length);
      }
      let val = this[offset3 + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset3 + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset3, noAssert) {
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkOffset(offset3, 1, this.length);
      return this[offset3];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset3, noAssert) {
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkOffset(offset3, 2, this.length);
      return this[offset3] | this[offset3 + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset3, noAssert) {
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkOffset(offset3, 2, this.length);
      return this[offset3] << 8 | this[offset3 + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset3, noAssert) {
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkOffset(offset3, 4, this.length);
      return (this[offset3] | this[offset3 + 1] << 8 | this[offset3 + 2] << 16) + this[offset3 + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset3, noAssert) {
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkOffset(offset3, 4, this.length);
      return this[offset3] * 16777216 + (this[offset3 + 1] << 16 | this[offset3 + 2] << 8 | this[offset3 + 3]);
    };
    Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset3) {
      offset3 = offset3 >>> 0;
      validateNumber(offset3, "offset");
      const first2 = this[offset3];
      const last = this[offset3 + 7];
      if (first2 === void 0 || last === void 0) {
        boundsError(offset3, this.length - 8);
      }
      const lo = first2 + this[++offset3] * 2 ** 8 + this[++offset3] * 2 ** 16 + this[++offset3] * 2 ** 24;
      const hi = this[++offset3] + this[++offset3] * 2 ** 8 + this[++offset3] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset3) {
      offset3 = offset3 >>> 0;
      validateNumber(offset3, "offset");
      const first2 = this[offset3];
      const last = this[offset3 + 7];
      if (first2 === void 0 || last === void 0) {
        boundsError(offset3, this.length - 8);
      }
      const hi = first2 * 2 ** 24 + this[++offset3] * 2 ** 16 + this[++offset3] * 2 ** 8 + this[++offset3];
      const lo = this[++offset3] * 2 ** 24 + this[++offset3] * 2 ** 16 + this[++offset3] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer2.prototype.readIntLE = function readIntLE(offset3, byteLength2, noAssert) {
      offset3 = offset3 >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset3, byteLength2, this.length);
      let val = this[offset3];
      let mul = 1;
      let i2 = 0;
      while (++i2 < byteLength2 && (mul *= 256)) {
        val += this[offset3 + i2] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset3, byteLength2, noAssert) {
      offset3 = offset3 >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset3, byteLength2, this.length);
      let i2 = byteLength2;
      let mul = 1;
      let val = this[offset3 + --i2];
      while (i2 > 0 && (mul *= 256)) {
        val += this[offset3 + --i2] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset3, noAssert) {
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkOffset(offset3, 1, this.length);
      if (!(this[offset3] & 128))
        return this[offset3];
      return (255 - this[offset3] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset3, noAssert) {
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkOffset(offset3, 2, this.length);
      const val = this[offset3] | this[offset3 + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset3, noAssert) {
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkOffset(offset3, 2, this.length);
      const val = this[offset3 + 1] | this[offset3] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset3, noAssert) {
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkOffset(offset3, 4, this.length);
      return this[offset3] | this[offset3 + 1] << 8 | this[offset3 + 2] << 16 | this[offset3 + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset3, noAssert) {
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkOffset(offset3, 4, this.length);
      return this[offset3] << 24 | this[offset3 + 1] << 16 | this[offset3 + 2] << 8 | this[offset3 + 3];
    };
    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset3) {
      offset3 = offset3 >>> 0;
      validateNumber(offset3, "offset");
      const first2 = this[offset3];
      const last = this[offset3 + 7];
      if (first2 === void 0 || last === void 0) {
        boundsError(offset3, this.length - 8);
      }
      const val = this[offset3 + 4] + this[offset3 + 5] * 2 ** 8 + this[offset3 + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first2 + this[++offset3] * 2 ** 8 + this[++offset3] * 2 ** 16 + this[++offset3] * 2 ** 24);
    });
    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset3) {
      offset3 = offset3 >>> 0;
      validateNumber(offset3, "offset");
      const first2 = this[offset3];
      const last = this[offset3 + 7];
      if (first2 === void 0 || last === void 0) {
        boundsError(offset3, this.length - 8);
      }
      const val = (first2 << 24) + // Overflow
      this[++offset3] * 2 ** 16 + this[++offset3] * 2 ** 8 + this[++offset3];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset3] * 2 ** 24 + this[++offset3] * 2 ** 16 + this[++offset3] * 2 ** 8 + last);
    });
    Buffer2.prototype.readFloatLE = function readFloatLE(offset3, noAssert) {
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkOffset(offset3, 4, this.length);
      return ieee754.read(this, offset3, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset3, noAssert) {
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkOffset(offset3, 4, this.length);
      return ieee754.read(this, offset3, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset3, noAssert) {
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkOffset(offset3, 8, this.length);
      return ieee754.read(this, offset3, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset3, noAssert) {
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkOffset(offset3, 8, this.length);
      return ieee754.read(this, offset3, false, 52, 8);
    };
    function checkInt(buf, value2, offset3, ext2, max, min2) {
      if (!Buffer2.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value2 > max || value2 < min2)
        throw new RangeError('"value" argument is out of bounds');
      if (offset3 + ext2 > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value2, offset3, byteLength2, noAssert) {
      value2 = +value2;
      offset3 = offset3 >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value2, offset3, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i2 = 0;
      this[offset3] = value2 & 255;
      while (++i2 < byteLength2 && (mul *= 256)) {
        this[offset3 + i2] = value2 / mul & 255;
      }
      return offset3 + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value2, offset3, byteLength2, noAssert) {
      value2 = +value2;
      offset3 = offset3 >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value2, offset3, byteLength2, maxBytes, 0);
      }
      let i2 = byteLength2 - 1;
      let mul = 1;
      this[offset3 + i2] = value2 & 255;
      while (--i2 >= 0 && (mul *= 256)) {
        this[offset3 + i2] = value2 / mul & 255;
      }
      return offset3 + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value2, offset3, noAssert) {
      value2 = +value2;
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset3, 1, 255, 0);
      this[offset3] = value2 & 255;
      return offset3 + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value2, offset3, noAssert) {
      value2 = +value2;
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset3, 2, 65535, 0);
      this[offset3] = value2 & 255;
      this[offset3 + 1] = value2 >>> 8;
      return offset3 + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value2, offset3, noAssert) {
      value2 = +value2;
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset3, 2, 65535, 0);
      this[offset3] = value2 >>> 8;
      this[offset3 + 1] = value2 & 255;
      return offset3 + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value2, offset3, noAssert) {
      value2 = +value2;
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset3, 4, 4294967295, 0);
      this[offset3 + 3] = value2 >>> 24;
      this[offset3 + 2] = value2 >>> 16;
      this[offset3 + 1] = value2 >>> 8;
      this[offset3] = value2 & 255;
      return offset3 + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value2, offset3, noAssert) {
      value2 = +value2;
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset3, 4, 4294967295, 0);
      this[offset3] = value2 >>> 24;
      this[offset3 + 1] = value2 >>> 16;
      this[offset3 + 2] = value2 >>> 8;
      this[offset3 + 3] = value2 & 255;
      return offset3 + 4;
    };
    function wrtBigUInt64LE(buf, value2, offset3, min2, max) {
      checkIntBI(value2, min2, max, buf, offset3, 7);
      let lo = Number(value2 & BigInt(4294967295));
      buf[offset3++] = lo;
      lo = lo >> 8;
      buf[offset3++] = lo;
      lo = lo >> 8;
      buf[offset3++] = lo;
      lo = lo >> 8;
      buf[offset3++] = lo;
      let hi = Number(value2 >> BigInt(32) & BigInt(4294967295));
      buf[offset3++] = hi;
      hi = hi >> 8;
      buf[offset3++] = hi;
      hi = hi >> 8;
      buf[offset3++] = hi;
      hi = hi >> 8;
      buf[offset3++] = hi;
      return offset3;
    }
    function wrtBigUInt64BE(buf, value2, offset3, min2, max) {
      checkIntBI(value2, min2, max, buf, offset3, 7);
      let lo = Number(value2 & BigInt(4294967295));
      buf[offset3 + 7] = lo;
      lo = lo >> 8;
      buf[offset3 + 6] = lo;
      lo = lo >> 8;
      buf[offset3 + 5] = lo;
      lo = lo >> 8;
      buf[offset3 + 4] = lo;
      let hi = Number(value2 >> BigInt(32) & BigInt(4294967295));
      buf[offset3 + 3] = hi;
      hi = hi >> 8;
      buf[offset3 + 2] = hi;
      hi = hi >> 8;
      buf[offset3 + 1] = hi;
      hi = hi >> 8;
      buf[offset3] = hi;
      return offset3 + 8;
    }
    Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value2, offset3 = 0) {
      return wrtBigUInt64LE(this, value2, offset3, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value2, offset3 = 0) {
      return wrtBigUInt64BE(this, value2, offset3, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeIntLE = function writeIntLE(value2, offset3, byteLength2, noAssert) {
      value2 = +value2;
      offset3 = offset3 >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value2, offset3, byteLength2, limit - 1, -limit);
      }
      let i2 = 0;
      let mul = 1;
      let sub = 0;
      this[offset3] = value2 & 255;
      while (++i2 < byteLength2 && (mul *= 256)) {
        if (value2 < 0 && sub === 0 && this[offset3 + i2 - 1] !== 0) {
          sub = 1;
        }
        this[offset3 + i2] = (value2 / mul >> 0) - sub & 255;
      }
      return offset3 + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value2, offset3, byteLength2, noAssert) {
      value2 = +value2;
      offset3 = offset3 >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value2, offset3, byteLength2, limit - 1, -limit);
      }
      let i2 = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset3 + i2] = value2 & 255;
      while (--i2 >= 0 && (mul *= 256)) {
        if (value2 < 0 && sub === 0 && this[offset3 + i2 + 1] !== 0) {
          sub = 1;
        }
        this[offset3 + i2] = (value2 / mul >> 0) - sub & 255;
      }
      return offset3 + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value2, offset3, noAssert) {
      value2 = +value2;
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset3, 1, 127, -128);
      if (value2 < 0)
        value2 = 255 + value2 + 1;
      this[offset3] = value2 & 255;
      return offset3 + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value2, offset3, noAssert) {
      value2 = +value2;
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset3, 2, 32767, -32768);
      this[offset3] = value2 & 255;
      this[offset3 + 1] = value2 >>> 8;
      return offset3 + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value2, offset3, noAssert) {
      value2 = +value2;
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset3, 2, 32767, -32768);
      this[offset3] = value2 >>> 8;
      this[offset3 + 1] = value2 & 255;
      return offset3 + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value2, offset3, noAssert) {
      value2 = +value2;
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset3, 4, 2147483647, -2147483648);
      this[offset3] = value2 & 255;
      this[offset3 + 1] = value2 >>> 8;
      this[offset3 + 2] = value2 >>> 16;
      this[offset3 + 3] = value2 >>> 24;
      return offset3 + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value2, offset3, noAssert) {
      value2 = +value2;
      offset3 = offset3 >>> 0;
      if (!noAssert)
        checkInt(this, value2, offset3, 4, 2147483647, -2147483648);
      if (value2 < 0)
        value2 = 4294967295 + value2 + 1;
      this[offset3] = value2 >>> 24;
      this[offset3 + 1] = value2 >>> 16;
      this[offset3 + 2] = value2 >>> 8;
      this[offset3 + 3] = value2 & 255;
      return offset3 + 4;
    };
    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value2, offset3 = 0) {
      return wrtBigUInt64LE(this, value2, offset3, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value2, offset3 = 0) {
      return wrtBigUInt64BE(this, value2, offset3, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value2, offset3, ext2, max, min2) {
      if (offset3 + ext2 > buf.length)
        throw new RangeError("Index out of range");
      if (offset3 < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value2, offset3, littleEndian, noAssert) {
      value2 = +value2;
      offset3 = offset3 >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value2, offset3, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value2, offset3, littleEndian, 23, 4);
      return offset3 + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value2, offset3, noAssert) {
      return writeFloat(this, value2, offset3, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value2, offset3, noAssert) {
      return writeFloat(this, value2, offset3, false, noAssert);
    };
    function writeDouble(buf, value2, offset3, littleEndian, noAssert) {
      value2 = +value2;
      offset3 = offset3 >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value2, offset3, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value2, offset3, littleEndian, 52, 8);
      return offset3 + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value2, offset3, noAssert) {
      return writeDouble(this, value2, offset3, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value2, offset3, noAssert) {
      return writeDouble(this, value2, offset3, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill2(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i2;
      if (typeof val === "number") {
        for (i2 = start; i2 < end; ++i2) {
          this[i2] = val;
        }
      } else {
        const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i2 = 0; i2 < end - start; ++i2) {
          this[i2 + start] = bytes[i2 % len];
        }
      }
      return this;
    };
    var errors = {};
    function E2(sym, getMessage2, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage2.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value2) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value: value2,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E2(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name2) {
        if (name2) {
          return `${name2} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E2(
      "ERR_INVALID_ARG_TYPE",
      function(name2, actual) {
        return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E2(
      "ERR_OUT_OF_RANGE",
      function(str2, range2, input) {
        let msg = `The value of "${str2}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range2}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i2 = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i2 >= start + 4; i2 -= 3) {
        res = `_${val.slice(i2 - 3, i2)}${res}`;
      }
      return `${val.slice(0, i2)}${res}`;
    }
    function checkBounds(buf, offset3, byteLength2) {
      validateNumber(offset3, "offset");
      if (buf[offset3] === void 0 || buf[offset3 + byteLength2] === void 0) {
        boundsError(offset3, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value2, min2, max, buf, offset3, byteLength2) {
      if (value2 > max || value2 < min2) {
        const n3 = typeof min2 === "bigint" ? "n" : "";
        let range2;
        if (byteLength2 > 3) {
          if (min2 === 0 || min2 === BigInt(0)) {
            range2 = `>= 0${n3} and < 2${n3} ** ${(byteLength2 + 1) * 8}${n3}`;
          } else {
            range2 = `>= -(2${n3} ** ${(byteLength2 + 1) * 8 - 1}${n3}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n3}`;
          }
        } else {
          range2 = `>= ${min2}${n3} and <= ${max}${n3}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range2, value2);
      }
      checkBounds(buf, offset3, byteLength2);
    }
    function validateNumber(value2, name2) {
      if (typeof value2 !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name2, "number", value2);
      }
    }
    function boundsError(value2, length, type) {
      if (Math.floor(value2) !== value2) {
        validateNumber(value2, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value2);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length}`,
        value2
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str2) {
      str2 = str2.split("=")[0];
      str2 = str2.trim().replace(INVALID_BASE64_RE, "");
      if (str2.length < 2)
        return "";
      while (str2.length % 4 !== 0) {
        str2 = str2 + "=";
      }
      return str2;
    }
    function utf8ToBytes(string3, units) {
      units = units || Infinity;
      let codePoint;
      const length = string3.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i2 = 0; i2 < length; ++i2) {
        codePoint = string3.charCodeAt(i2);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i2 + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str2) {
      const byteArray = [];
      for (let i2 = 0; i2 < str2.length; ++i2) {
        byteArray.push(str2.charCodeAt(i2) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str2, units) {
      let c2, hi, lo;
      const byteArray = [];
      for (let i2 = 0; i2 < str2.length; ++i2) {
        if ((units -= 2) < 0)
          break;
        c2 = str2.charCodeAt(i2);
        hi = c2 >> 8;
        lo = c2 % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str2) {
      return base64.toByteArray(base64clean(str2));
    }
    function blitBuffer(src3, dst, offset3, length) {
      let i2;
      for (i2 = 0; i2 < length; ++i2) {
        if (i2 + offset3 >= dst.length || i2 >= src3.length)
          break;
        dst[i2 + offset3] = src3[i2];
      }
      return i2;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i2 = 0; i2 < 16; ++i2) {
        const i16 = i2 * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i2] + alphabet[j];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports3, module2) {
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = null != arguments[i2] ? arguments[i2] : {};
        i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _defineProperty(obj, key, value2) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value: value2, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value2;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i2 = 0; i2 < props.length; i2++) {
        var descriptor = props[i2];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var _require3 = require_buffer();
    var Buffer2 = _require3.Buffer;
    var _require22 = require_util();
    var inspect2 = _require22.inspect;
    var custom = inspect2 && inspect2.custom || "inspect";
    function copyBuffer(src3, target, offset3) {
      Buffer2.prototype.copy.call(src3, target, offset3);
    }
    module2.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push2(v) {
          var entry2 = {
            data: v,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry2;
          else
            this.head = entry2;
          this.tail = entry2;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry2 = {
            data: v,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry2;
          this.head = entry2;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join2(s2) {
          if (this.length === 0)
            return "";
          var p2 = this.head;
          var ret = "" + p2.data;
          while (p2 = p2.next)
            ret += s2 + p2.data;
          return ret;
        }
      }, {
        key: "concat",
        value: function concat2(n3) {
          if (this.length === 0)
            return Buffer2.alloc(0);
          var ret = Buffer2.allocUnsafe(n3 >>> 0);
          var p2 = this.head;
          var i2 = 0;
          while (p2) {
            copyBuffer(p2.data, ret, i2);
            i2 += p2.data.length;
            p2 = p2.next;
          }
          return ret;
        }
        // Consumes a specified amount of bytes or characters from the buffered data.
      }, {
        key: "consume",
        value: function consume(n3, hasStrings) {
          var ret;
          if (n3 < this.head.data.length) {
            ret = this.head.data.slice(0, n3);
            this.head.data = this.head.data.slice(n3);
          } else if (n3 === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n3) : this._getBuffer(n3);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first2() {
          return this.head.data;
        }
        // Consumes a specified amount of characters from the buffered data.
      }, {
        key: "_getString",
        value: function _getString(n3) {
          var p2 = this.head;
          var c2 = 1;
          var ret = p2.data;
          n3 -= ret.length;
          while (p2 = p2.next) {
            var str2 = p2.data;
            var nb = n3 > str2.length ? str2.length : n3;
            if (nb === str2.length)
              ret += str2;
            else
              ret += str2.slice(0, n3);
            n3 -= nb;
            if (n3 === 0) {
              if (nb === str2.length) {
                ++c2;
                if (p2.next)
                  this.head = p2.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p2;
                p2.data = str2.slice(nb);
              }
              break;
            }
            ++c2;
          }
          this.length -= c2;
          return ret;
        }
        // Consumes a specified amount of bytes from the buffered data.
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n3) {
          var ret = Buffer2.allocUnsafe(n3);
          var p2 = this.head;
          var c2 = 1;
          p2.data.copy(ret);
          n3 -= p2.data.length;
          while (p2 = p2.next) {
            var buf = p2.data;
            var nb = n3 > buf.length ? buf.length : n3;
            buf.copy(ret, ret.length - n3, 0, nb);
            n3 -= nb;
            if (n3 === 0) {
              if (nb === buf.length) {
                ++c2;
                if (p2.next)
                  this.head = p2.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p2;
                p2.data = buf.slice(nb);
              }
              break;
            }
            ++c2;
          }
          this.length -= c2;
          return ret;
        }
        // Make sure the linked list only shows the minimal necessary information.
      }, {
        key: custom,
        value: function value2(_, options3) {
          return inspect2(this, _objectSpread(_objectSpread({}, options3), {}, {
            // Only inspect one level.
            depth: 0,
            // It should not recurse.
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports3, module2) {
    "use strict";
    function destroy(err2, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err2);
        } else if (err2) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err2);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err2);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err2 || null, function(err3) {
        if (!cb && err3) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err3);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err3);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err3);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err2) {
      emitErrorNT(self2, err2);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err2) {
      self2.emit("error", err2);
    }
    function errorOrDestroy(stream4, err2) {
      var rState = stream4._readableState;
      var wState = stream4._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream4.destroy(err2);
      else
        stream4.emit("error", err2);
    }
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors-browser.js
var require_errors_browser = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/errors-browser.js"(exports3, module2) {
    "use strict";
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var codes2 = {};
    function createErrorType2(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage2(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      var NodeError = function(_Base) {
        _inheritsLoose(NodeError2, _Base);
        function NodeError2(arg1, arg2, arg3) {
          return _Base.call(this, getMessage2(arg1, arg2, arg3)) || this;
        }
        return NodeError2;
      }(Base);
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes2[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i2) {
          return String(i2);
        });
        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    }
    function startsWith(str2, search, pos) {
      return str2.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str2, search, this_len) {
      if (this_len === void 0 || this_len > str2.length) {
        this_len = str2.length;
      }
      return str2.substring(this_len - search.length, this_len) === search;
    }
    function includes(str2, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str2.length) {
        return false;
      } else {
        return str2.indexOf(search, start) !== -1;
      }
    }
    createErrorType2("ERR_INVALID_OPT_VALUE", function(name2, value2) {
      return 'The value "' + value2 + '" is invalid for option "' + name2 + '"';
    }, TypeError);
    createErrorType2("ERR_INVALID_ARG_TYPE", function(name2, expected, actual) {
      var determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      var msg;
      if (endsWith(name2, " argument")) {
        msg = "The ".concat(name2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else {
        var type = includes(name2, ".") ? "property" : "argument";
        msg = 'The "'.concat(name2, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      }
      msg += ". Received type ".concat(typeof actual);
      return msg;
    }, TypeError);
    createErrorType2("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType2("ERR_METHOD_NOT_IMPLEMENTED", function(name2) {
      return "The " + name2 + " method is not implemented";
    });
    createErrorType2("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType2("ERR_STREAM_DESTROYED", function(name2) {
      return "Cannot call " + name2 + " after a stream was destroyed";
    });
    createErrorType2("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType2("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType2("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType2("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType2("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType2("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes2;
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/state.js"(exports3, module2) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors_browser().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options3, isDuplex, duplexKey) {
      return options3.highWaterMark != null ? options3.highWaterMark : isDuplex ? options3[duplexKey] : null;
    }
    function getHighWaterMark(state, options3, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options3, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name2 = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name2, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module2.exports = {
      getHighWaterMark
    };
  }
});

// node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js"(exports3, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits2(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits2(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/.pnpm/util-deprecate@1.0.2/node_modules/util-deprecate/browser.js
var require_browser2 = __commonJS({
  "node_modules/.pnpm/util-deprecate@1.0.2/node_modules/util-deprecate/browser.js"(exports3, module2) {
    module2.exports = deprecate;
    function deprecate(fn, msg) {
      if (config2("noDeprecation")) {
        return fn;
      }
      var warned2 = false;
      function deprecated() {
        if (!warned2) {
          if (config2("throwDeprecation")) {
            throw new Error(msg);
          } else if (config2("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned2 = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    }
    function config2(name2) {
      try {
        if (!global.localStorage)
          return false;
      } catch (_) {
        return false;
      }
      var val = global.localStorage[name2];
      if (null == val)
        return false;
      return String(val).toLowerCase() === "true";
    }
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_writable.js"(exports3, module2) {
    "use strict";
    module2.exports = Writable2;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable2.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_browser2()
    };
    var Stream2 = require_stream_browser();
    var Buffer2 = require_buffer().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    var _require3 = require_state();
    var getHighWaterMark = _require3.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits_browser()(Writable2, Stream2);
    function nop() {
    }
    function WritableState(options3, stream4, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options3 = options3 || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream4 instanceof Duplex;
      this.objectMode = !!options3.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options3.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options3, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options3.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options3.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream4, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options3.emitClose !== false;
      this.autoDestroy = !!options3.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current2 = this.bufferedRequest;
      var out2 = [];
      while (current2) {
        out2.push(current2);
        current2 = current2.next;
      }
      return out2;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable2, Symbol.hasInstance, {
        value: function value2(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable2)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable2(options3) {
      Duplex = Duplex || require_stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable2, this))
        return new Writable2(options3);
      this._writableState = new WritableState(options3, this, isDuplex);
      this.writable = true;
      if (options3) {
        if (typeof options3.write === "function")
          this._write = options3.write;
        if (typeof options3.writev === "function")
          this._writev = options3.writev;
        if (typeof options3.destroy === "function")
          this._destroy = options3.destroy;
        if (typeof options3.final === "function")
          this._final = options3.final;
      }
      Stream2.call(this);
    }
    Writable2.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream4, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream4, er);
      process.nextTick(cb, er);
    }
    function validChunk(stream4, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream4, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable2.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable2.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable2.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable2.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable2.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get3() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get3() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream4, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream4, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream4, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream4._writev(chunk, state.onwrite);
      else
        stream4._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream4, state, sync2, er, cb) {
      --state.pendingcb;
      if (sync2) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream4, state);
        stream4._writableState.errorEmitted = true;
        errorOrDestroy(stream4, er);
      } else {
        cb(er);
        stream4._writableState.errorEmitted = true;
        errorOrDestroy(stream4, er);
        finishMaybe(stream4, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream4, er) {
      var state = stream4._writableState;
      var sync2 = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream4, state, sync2, er, cb);
      else {
        var finished = needFinish(state) || stream4.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream4, state);
        }
        if (sync2) {
          process.nextTick(afterWrite, stream4, state, finished, cb);
        } else {
          afterWrite(stream4, state, finished, cb);
        }
      }
    }
    function afterWrite(stream4, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream4, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream4, state);
    }
    function onwriteDrain(stream4, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream4.emit("drain");
      }
    }
    function clearBuffer(stream4, state) {
      state.bufferProcessing = true;
      var entry2 = state.bufferedRequest;
      if (stream4._writev && entry2 && entry2.next) {
        var l2 = state.bufferedRequestCount;
        var buffer = new Array(l2);
        var holder = state.corkedRequestsFree;
        holder.entry = entry2;
        var count = 0;
        var allBuffers = true;
        while (entry2) {
          buffer[count] = entry2;
          if (!entry2.isBuf)
            allBuffers = false;
          entry2 = entry2.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream4, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry2) {
          var chunk = entry2.chunk;
          var encoding = entry2.encoding;
          var cb = entry2.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream4, state, false, len, chunk, encoding, cb);
          entry2 = entry2.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry2 === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry2;
      state.bufferProcessing = false;
    }
    Writable2.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable2.prototype._writev = null;
    Writable2.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable2.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get3() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream4, state) {
      stream4._final(function(err2) {
        state.pendingcb--;
        if (err2) {
          errorOrDestroy(stream4, err2);
        }
        state.prefinished = true;
        stream4.emit("prefinish");
        finishMaybe(stream4, state);
      });
    }
    function prefinish(stream4, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream4._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream4, state);
        } else {
          state.prefinished = true;
          stream4.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream4, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream4, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream4.emit("finish");
          if (state.autoDestroy) {
            var rState = stream4._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream4.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream4, state, cb) {
      state.ending = true;
      finishMaybe(stream4, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream4.once("finish", cb);
      }
      state.ended = true;
      stream4.writable = false;
    }
    function onCorkedFinish(corkReq, state, err2) {
      var entry2 = corkReq.entry;
      corkReq.entry = null;
      while (entry2) {
        var cb = entry2.callback;
        state.pendingcb--;
        cb(err2);
        entry2 = entry2.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable2.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get3() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set3(value2) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value2;
      }
    });
    Writable2.prototype.destroy = destroyImpl.destroy;
    Writable2.prototype._undestroy = destroyImpl.undestroy;
    Writable2.prototype._destroy = function(err2, cb) {
      cb(err2);
    };
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_duplex.js"(exports3, module2) {
    "use strict";
    var objectKeys2 = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj)
        keys2.push(key);
      return keys2;
    };
    module2.exports = Duplex;
    var Readable2 = require_stream_readable();
    var Writable2 = require_stream_writable();
    require_inherits_browser()(Duplex, Readable2);
    {
      keys = objectKeys2(Writable2.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable2.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options3) {
      if (!(this instanceof Duplex))
        return new Duplex(options3);
      Readable2.call(this, options3);
      Writable2.call(this, options3);
      this.allowHalfOpen = true;
      if (options3) {
        if (options3.readable === false)
          this.readable = false;
        if (options3.writable === false)
          this.writable = false;
        if (options3.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get3() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get3() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get3() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get3() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set3(value2) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value2;
        this._writableState.destroyed = value2;
      }
    });
  }
});

// node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js"(exports3, module2) {
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    function copyProps(src3, dst) {
      for (var key in src3) {
        dst[key] = src3[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports3);
      exports3.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill2, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill2 !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill2, encoding);
        } else {
          buf.fill(fill2);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/.pnpm/string_decoder@1.3.0/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/.pnpm/string_decoder@1.3.0/node_modules/string_decoder/lib/string_decoder.js"(exports3) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports3.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r3;
      var i2;
      if (this.lastNeed) {
        r3 = this.fillLast(buf);
        if (r3 === void 0)
          return "";
        i2 = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i2 = 0;
      }
      if (i2 < buf.length)
        return r3 ? r3 + this.text(buf, i2) : this.text(buf, i2);
      return r3 || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i2) {
      var j = buf.length - 1;
      if (j < i2)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i2 || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i2 || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p2) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "�";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "�";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "�";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p2 = this.lastTotal - this.lastNeed;
      var r3 = utf8CheckExtraBytes(this, buf, p2);
      if (r3 !== void 0)
        return r3;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p2, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p2, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i2) {
      var total = utf8CheckIncomplete(this, buf, i2);
      if (!this.lastNeed)
        return buf.toString("utf8", i2);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i2, end);
    }
    function utf8End(buf) {
      var r3 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r3 + "�";
      return r3;
    }
    function utf16Text(buf, i2) {
      if ((buf.length - i2) % 2 === 0) {
        var r3 = buf.toString("utf16le", i2);
        if (r3) {
          var c2 = r3.charCodeAt(r3.length - 1);
          if (c2 >= 55296 && c2 <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r3.slice(0, -1);
          }
        }
        return r3;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i2, buf.length - 1);
    }
    function utf16End(buf) {
      var r3 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r3 + this.lastChar.toString("utf16le", 0, end);
      }
      return r3;
    }
    function base64Text(buf, i2) {
      var n3 = (buf.length - i2) % 3;
      if (n3 === 0)
        return buf.toString("base64", i2);
      this.lastNeed = 3 - n3;
      this.lastTotal = 3;
      if (n3 === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i2, buf.length - n3);
    }
    function base64End(buf) {
      var r3 = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r3 + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r3;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports3, module2) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once2(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop2() {
    }
    function isRequest(stream4) {
      return stream4.setHeader && typeof stream4.abort === "function";
    }
    function eos(stream4, opts, callback) {
      if (typeof opts === "function")
        return eos(stream4, null, opts);
      if (!opts)
        opts = {};
      callback = once2(callback || noop2);
      var readable = opts.readable || opts.readable !== false && stream4.readable;
      var writable = opts.writable || opts.writable !== false && stream4.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream4.writable)
          onfinish();
      };
      var writableEnded = stream4._writableState && stream4._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream4);
      };
      var readableEnded = stream4._readableState && stream4._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream4);
      };
      var onerror = function onerror2(err2) {
        callback.call(stream4, err2);
      };
      var onclose = function onclose2() {
        var err2;
        if (readable && !readableEnded) {
          if (!stream4._readableState || !stream4._readableState.ended)
            err2 = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream4, err2);
        }
        if (writable && !writableEnded) {
          if (!stream4._writableState || !stream4._writableState.ended)
            err2 = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream4, err2);
        }
      };
      var onrequest = function onrequest2() {
        stream4.req.on("finish", onfinish);
      };
      if (isRequest(stream4)) {
        stream4.on("complete", onfinish);
        stream4.on("abort", onclose);
        if (stream4.req)
          onrequest();
        else
          stream4.on("request", onrequest);
      } else if (writable && !stream4._writableState) {
        stream4.on("end", onlegacyfinish);
        stream4.on("close", onlegacyfinish);
      }
      stream4.on("end", onend);
      stream4.on("finish", onfinish);
      if (opts.error !== false)
        stream4.on("error", onerror);
      stream4.on("close", onclose);
      return function() {
        stream4.removeListener("complete", onfinish);
        stream4.removeListener("abort", onclose);
        stream4.removeListener("request", onrequest);
        if (stream4.req)
          stream4.req.removeListener("finish", onfinish);
        stream4.removeListener("end", onlegacyfinish);
        stream4.removeListener("close", onlegacyfinish);
        stream4.removeListener("finish", onfinish);
        stream4.removeListener("end", onend);
        stream4.removeListener("error", onerror);
        stream4.removeListener("close", onclose);
      };
    }
    module2.exports = eos;
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports3, module2) {
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value2) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value: value2, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value2;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError2 = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value2, done) {
      return {
        value: value2,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve4 = iter[kLastResolve];
      if (resolve4 !== null) {
        var data2 = iter[kStream].read();
        if (data2 !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve4(createIterResult(data2, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve4, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve4(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve4, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error3 = this[kError2];
        if (error3 !== null) {
          return Promise.reject(error3);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve4, reject) {
            process.nextTick(function() {
              if (_this[kError2]) {
                reject(_this[kError2]);
              } else {
                resolve4(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise2;
        if (lastPromise) {
          promise2 = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data2 = this[kStream].read();
          if (data2 !== null) {
            return Promise.resolve(createIterResult(data2, false));
          }
          promise2 = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise2;
        return promise2;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve4, reject) {
        _this2[kStream].destroy(null, function(err2) {
          if (err2) {
            reject(err2);
            return;
          }
          resolve4(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream4) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream4,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError2, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream4._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value2(resolve4, reject) {
          var data2 = iterator[kStream].read();
          if (data2) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve4(createIterResult(data2, false));
          } else {
            iterator[kLastResolve] = resolve4;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream4, function(err2) {
        if (err2 && err2.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err2);
          }
          iterator[kError2] = err2;
          return;
        }
        var resolve4 = iterator[kLastResolve];
        if (resolve4 !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve4(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream4.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module2.exports = createReadableStreamAsyncIterator;
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/from-browser.js
var require_from_browser = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports3, module2) {
    module2.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_readable.js"(exports3, module2) {
    "use strict";
    module2.exports = Readable2;
    var Duplex;
    Readable2.ReadableState = ReadableState;
    var EE = require_events().EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream2 = require_stream_browser();
    var Buffer2 = require_buffer().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require_util();
    var debug4;
    if (debugUtil && debugUtil.debuglog) {
      debug4 = debugUtil.debuglog("stream");
    } else {
      debug4 = function debug5() {
      };
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require3 = require_state();
    var getHighWaterMark = _require3.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits_browser()(Readable2, Stream2);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options3, stream4, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options3 = options3 || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream4 instanceof Duplex;
      this.objectMode = !!options3.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options3.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options3, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options3.emitClose !== false;
      this.autoDestroy = !!options3.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options3.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options3.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options3.encoding);
        this.encoding = options3.encoding;
      }
    }
    function Readable2(options3) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable2))
        return new Readable2(options3);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options3, this, isDuplex);
      this.readable = true;
      if (options3) {
        if (typeof options3.read === "function")
          this._read = options3.read;
        if (typeof options3.destroy === "function")
          this._destroy = options3.destroy;
      }
      Stream2.call(this);
    }
    Object.defineProperty(Readable2.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get3() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set3(value2) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value2;
      }
    });
    Readable2.prototype.destroy = destroyImpl.destroy;
    Readable2.prototype._undestroy = destroyImpl.undestroy;
    Readable2.prototype._destroy = function(err2, cb) {
      cb(err2);
    };
    Readable2.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable2.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream4, chunk, encoding, addToFront, skipChunkCheck) {
      debug4("readableAddChunk", chunk);
      var state = stream4._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream4, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream4, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream4, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream4, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream4, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream4, state, chunk, false);
              else
                maybeReadMore(stream4, state);
            } else {
              addChunk(stream4, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream4, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream4, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream4.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream4);
      }
      maybeReadMore(stream4, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable2.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable2.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p2 = this._readableState.buffer.head;
      var content = "";
      while (p2 !== null) {
        content += decoder.write(p2.data);
        p2 = p2.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n3) {
      if (n3 >= MAX_HWM) {
        n3 = MAX_HWM;
      } else {
        n3--;
        n3 |= n3 >>> 1;
        n3 |= n3 >>> 2;
        n3 |= n3 >>> 4;
        n3 |= n3 >>> 8;
        n3 |= n3 >>> 16;
        n3++;
      }
      return n3;
    }
    function howMuchToRead(n3, state) {
      if (n3 <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n3 !== n3) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n3 > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n3);
      if (n3 <= state.length)
        return n3;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable2.prototype.read = function(n3) {
      debug4("read", n3);
      n3 = parseInt(n3, 10);
      var state = this._readableState;
      var nOrig = n3;
      if (n3 !== 0)
        state.emittedReadable = false;
      if (n3 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug4("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n3 = howMuchToRead(n3, state);
      if (n3 === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug4("need readable", doRead);
      if (state.length === 0 || state.length - n3 < state.highWaterMark) {
        doRead = true;
        debug4("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug4("reading or ended", doRead);
      } else if (doRead) {
        debug4("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n3 = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n3 > 0)
        ret = fromList(n3, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n3 = 0;
      } else {
        state.length -= n3;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n3 && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream4, state) {
      debug4("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream4);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream4);
        }
      }
    }
    function emitReadable(stream4) {
      var state = stream4._readableState;
      debug4("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug4("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream4);
      }
    }
    function emitReadable_(stream4) {
      var state = stream4._readableState;
      debug4("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream4.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream4);
    }
    function maybeReadMore(stream4, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream4, state);
      }
    }
    function maybeReadMore_(stream4, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug4("maybeReadMore read 0");
        stream4.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable2.prototype._read = function(n3) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable2.prototype.pipe = function(dest, pipeOpts) {
      var src3 = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug4("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe2;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src3.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug4("onunpipe");
        if (readable === src3) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug4("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src3);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug4("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src3.removeListener("end", onend);
        src3.removeListener("end", unpipe2);
        src3.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src3.on("data", ondata);
      function ondata(chunk) {
        debug4("ondata");
        var ret = dest.write(chunk);
        debug4("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf3(state.pipes, dest) !== -1) && !cleanedUp) {
            debug4("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src3.pause();
        }
      }
      function onerror(er) {
        debug4("onerror", er);
        unpipe2();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe2();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug4("onfinish");
        dest.removeListener("close", onclose);
        unpipe2();
      }
      dest.once("finish", onfinish);
      function unpipe2() {
        debug4("unpipe");
        src3.unpipe(dest);
      }
      dest.emit("pipe", src3);
      if (!state.flowing) {
        debug4("pipe resume");
        src3.resume();
      }
      return dest;
    };
    function pipeOnDrain(src3) {
      return function pipeOnDrainFunctionResult() {
        var state = src3._readableState;
        debug4("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src3, "data")) {
          state.flowing = true;
          flow(src3);
        }
      };
    }
    Readable2.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i2 = 0; i2 < len; i2++)
          dests[i2].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      var index2 = indexOf3(state.pipes, dest);
      if (index2 === -1)
        return this;
      state.pipes.splice(index2, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable2.prototype.on = function(ev, fn) {
      var res = Stream2.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug4("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable2.prototype.addListener = Readable2.prototype.on;
    Readable2.prototype.removeListener = function(ev, fn) {
      var res = Stream2.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable2.prototype.removeAllListeners = function(ev) {
      var res = Stream2.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug4("readable nexttick read 0");
      self2.read(0);
    }
    Readable2.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug4("resume");
        state.flowing = !state.readableListening;
        resume2(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume2(stream4, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream4, state);
      }
    }
    function resume_(stream4, state) {
      debug4("resume", state.reading);
      if (!state.reading) {
        stream4.read(0);
      }
      state.resumeScheduled = false;
      stream4.emit("resume");
      flow(stream4);
      if (state.flowing && !state.reading)
        stream4.read(0);
    }
    Readable2.prototype.pause = function() {
      debug4("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug4("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream4) {
      var state = stream4._readableState;
      debug4("flow", state.flowing);
      while (state.flowing && stream4.read() !== null)
        ;
    }
    Readable2.prototype.wrap = function(stream4) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream4.on("end", function() {
        debug4("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream4.on("data", function(chunk) {
        debug4("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream4.pause();
        }
      });
      for (var i2 in stream4) {
        if (this[i2] === void 0 && typeof stream4[i2] === "function") {
          this[i2] = function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream4[method].apply(stream4, arguments);
            };
          }(i2);
        }
      }
      for (var n3 = 0; n3 < kProxyEvents.length; n3++) {
        stream4.on(kProxyEvents[n3], this.emit.bind(this, kProxyEvents[n3]));
      }
      this._read = function(n4) {
        debug4("wrapped _read", n4);
        if (paused) {
          paused = false;
          stream4.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable2.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get3() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable2.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get3() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable2.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get3() {
        return this._readableState.flowing;
      },
      set: function set3(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable2._fromList = fromList;
    Object.defineProperty(Readable2.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function get3() {
        return this._readableState.length;
      }
    });
    function fromList(n3, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n3 || n3 >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n3, state.decoder);
      }
      return ret;
    }
    function endReadable(stream4) {
      var state = stream4._readableState;
      debug4("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream4);
      }
    }
    function endReadableNT(state, stream4) {
      debug4("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream4.readable = false;
        stream4.emit("end");
        if (state.autoDestroy) {
          var wState = stream4._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream4.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable2.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from_browser();
        }
        return from(Readable2, iterable, opts);
      };
    }
    function indexOf3(xs, x) {
      for (var i2 = 0, l2 = xs.length; i2 < l2; i2++) {
        if (xs[i2] === x)
          return i2;
      }
      return -1;
    }
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_transform.js"(exports3, module2) {
    "use strict";
    module2.exports = Transform2;
    var _require$codes = require_errors_browser().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    require_inherits_browser()(Transform2, Duplex);
    function afterTransform(er, data2) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data2 != null)
        this.push(data2);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform2(options3) {
      if (!(this instanceof Transform2))
        return new Transform2(options3);
      Duplex.call(this, options3);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options3) {
        if (typeof options3.transform === "function")
          this._transform = options3.transform;
        if (typeof options3.flush === "function")
          this._flush = options3.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data2) {
          done(_this, er, data2);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform2.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform2.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform2.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform2.prototype._read = function(n3) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform2.prototype._destroy = function(err2, cb) {
      Duplex.prototype._destroy.call(this, err2, function(err22) {
        cb(err22);
      });
    };
    function done(stream4, er, data2) {
      if (er)
        return stream4.emit("error", er);
      if (data2 != null)
        stream4.push(data2);
      if (stream4._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream4._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream4.push(null);
    }
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/_stream_passthrough.js"(exports3, module2) {
    "use strict";
    module2.exports = PassThrough2;
    var Transform2 = require_stream_transform();
    require_inherits_browser()(PassThrough2, Transform2);
    function PassThrough2(options3) {
      if (!(this instanceof PassThrough2))
        return new PassThrough2(options3);
      Transform2.call(this, options3);
    }
    PassThrough2.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports3, module2) {
    "use strict";
    var eos;
    function once2(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors_browser().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop2(err2) {
      if (err2)
        throw err2;
    }
    function isRequest(stream4) {
      return stream4.setHeader && typeof stream4.abort === "function";
    }
    function destroyer(stream4, reading, writing, callback) {
      callback = once2(callback);
      var closed = false;
      stream4.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream();
      eos(stream4, {
        readable: reading,
        writable: writing
      }, function(err2) {
        if (err2)
          return callback(err2);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err2) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream4))
          return stream4.abort();
        if (typeof stream4.destroy === "function")
          return stream4.destroy();
        callback(err2 || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call2(fn) {
      fn();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop2;
      if (typeof streams[streams.length - 1] !== "function")
        return noop2;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error3;
      var destroys = streams.map(function(stream4, i2) {
        var reading = i2 < streams.length - 1;
        var writing = i2 > 0;
        return destroyer(stream4, reading, writing, function(err2) {
          if (!error3)
            error3 = err2;
          if (err2)
            destroys.forEach(call2);
          if (reading)
            return;
          destroys.forEach(call2);
          callback(error3);
        });
      });
      return streams.reduce(pipe);
    }
    module2.exports = pipeline;
  }
});

// node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/readable-browser.js
var require_readable_browser = __commonJS({
  "node_modules/.pnpm/readable-stream@3.6.2/node_modules/readable-stream/readable-browser.js"(exports3, module2) {
    exports3 = module2.exports = require_stream_readable();
    exports3.Stream = exports3;
    exports3.Readable = exports3;
    exports3.Writable = require_stream_writable();
    exports3.Duplex = require_stream_duplex();
    exports3.Transform = require_stream_transform();
    exports3.PassThrough = require_stream_passthrough();
    exports3.finished = require_end_of_stream();
    exports3.pipeline = require_pipeline();
  }
});

// node_modules/.pnpm/bl@5.1.0/node_modules/bl/BufferList.js
var require_BufferList = __commonJS({
  "node_modules/.pnpm/bl@5.1.0/node_modules/bl/BufferList.js"(exports3, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require_buffer();
    var symbol = Symbol.for("BufferList");
    function BufferList(buf) {
      if (!(this instanceof BufferList)) {
        return new BufferList(buf);
      }
      BufferList._init.call(this, buf);
    }
    BufferList._init = function _init(buf) {
      Object.defineProperty(this, symbol, { value: true });
      this._bufs = [];
      this.length = 0;
      if (buf) {
        this.append(buf);
      }
    };
    BufferList.prototype._new = function _new(buf) {
      return new BufferList(buf);
    };
    BufferList.prototype._offset = function _offset(offset3) {
      if (offset3 === 0) {
        return [0, 0];
      }
      let tot = 0;
      for (let i2 = 0; i2 < this._bufs.length; i2++) {
        const _t = tot + this._bufs[i2].length;
        if (offset3 < _t || i2 === this._bufs.length - 1) {
          return [i2, offset3 - tot];
        }
        tot = _t;
      }
    };
    BufferList.prototype._reverseOffset = function(blOffset) {
      const bufferId = blOffset[0];
      let offset3 = blOffset[1];
      for (let i2 = 0; i2 < bufferId; i2++) {
        offset3 += this._bufs[i2].length;
      }
      return offset3;
    };
    BufferList.prototype.get = function get3(index2) {
      if (index2 > this.length || index2 < 0) {
        return void 0;
      }
      const offset3 = this._offset(index2);
      return this._bufs[offset3[0]][offset3[1]];
    };
    BufferList.prototype.slice = function slice2(start, end) {
      if (typeof start === "number" && start < 0) {
        start += this.length;
      }
      if (typeof end === "number" && end < 0) {
        end += this.length;
      }
      return this.copy(null, 0, start, end);
    };
    BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
      if (typeof srcStart !== "number" || srcStart < 0) {
        srcStart = 0;
      }
      if (typeof srcEnd !== "number" || srcEnd > this.length) {
        srcEnd = this.length;
      }
      if (srcStart >= this.length) {
        return dst || Buffer2.alloc(0);
      }
      if (srcEnd <= 0) {
        return dst || Buffer2.alloc(0);
      }
      const copy2 = !!dst;
      const off = this._offset(srcStart);
      const len = srcEnd - srcStart;
      let bytes = len;
      let bufoff = copy2 && dstStart || 0;
      let start = off[1];
      if (srcStart === 0 && srcEnd === this.length) {
        if (!copy2) {
          return this._bufs.length === 1 ? this._bufs[0] : Buffer2.concat(this._bufs, this.length);
        }
        for (let i2 = 0; i2 < this._bufs.length; i2++) {
          this._bufs[i2].copy(dst, bufoff);
          bufoff += this._bufs[i2].length;
        }
        return dst;
      }
      if (bytes <= this._bufs[off[0]].length - start) {
        return copy2 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
      }
      if (!copy2) {
        dst = Buffer2.allocUnsafe(len);
      }
      for (let i2 = off[0]; i2 < this._bufs.length; i2++) {
        const l2 = this._bufs[i2].length - start;
        if (bytes > l2) {
          this._bufs[i2].copy(dst, bufoff, start);
          bufoff += l2;
        } else {
          this._bufs[i2].copy(dst, bufoff, start, start + bytes);
          bufoff += l2;
          break;
        }
        bytes -= l2;
        if (start) {
          start = 0;
        }
      }
      if (dst.length > bufoff)
        return dst.slice(0, bufoff);
      return dst;
    };
    BufferList.prototype.shallowSlice = function shallowSlice(start, end) {
      start = start || 0;
      end = typeof end !== "number" ? this.length : end;
      if (start < 0) {
        start += this.length;
      }
      if (end < 0) {
        end += this.length;
      }
      if (start === end) {
        return this._new();
      }
      const startOffset = this._offset(start);
      const endOffset = this._offset(end);
      const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
      if (endOffset[1] === 0) {
        buffers.pop();
      } else {
        buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
      }
      if (startOffset[1] !== 0) {
        buffers[0] = buffers[0].slice(startOffset[1]);
      }
      return this._new(buffers);
    };
    BufferList.prototype.toString = function toString2(encoding, start, end) {
      return this.slice(start, end).toString(encoding);
    };
    BufferList.prototype.consume = function consume(bytes) {
      bytes = Math.trunc(bytes);
      if (Number.isNaN(bytes) || bytes <= 0)
        return this;
      while (this._bufs.length) {
        if (bytes >= this._bufs[0].length) {
          bytes -= this._bufs[0].length;
          this.length -= this._bufs[0].length;
          this._bufs.shift();
        } else {
          this._bufs[0] = this._bufs[0].slice(bytes);
          this.length -= bytes;
          break;
        }
      }
      return this;
    };
    BufferList.prototype.duplicate = function duplicate() {
      const copy = this._new();
      for (let i2 = 0; i2 < this._bufs.length; i2++) {
        copy.append(this._bufs[i2]);
      }
      return copy;
    };
    BufferList.prototype.append = function append2(buf) {
      if (buf == null) {
        return this;
      }
      if (buf.buffer) {
        this._appendBuffer(Buffer2.from(buf.buffer, buf.byteOffset, buf.byteLength));
      } else if (Array.isArray(buf)) {
        for (let i2 = 0; i2 < buf.length; i2++) {
          this.append(buf[i2]);
        }
      } else if (this._isBufferList(buf)) {
        for (let i2 = 0; i2 < buf._bufs.length; i2++) {
          this.append(buf._bufs[i2]);
        }
      } else {
        if (typeof buf === "number") {
          buf = buf.toString();
        }
        this._appendBuffer(Buffer2.from(buf));
      }
      return this;
    };
    BufferList.prototype._appendBuffer = function appendBuffer(buf) {
      this._bufs.push(buf);
      this.length += buf.length;
    };
    BufferList.prototype.indexOf = function(search, offset3, encoding) {
      if (encoding === void 0 && typeof offset3 === "string") {
        encoding = offset3;
        offset3 = void 0;
      }
      if (typeof search === "function" || Array.isArray(search)) {
        throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
      } else if (typeof search === "number") {
        search = Buffer2.from([search]);
      } else if (typeof search === "string") {
        search = Buffer2.from(search, encoding);
      } else if (this._isBufferList(search)) {
        search = search.slice();
      } else if (Array.isArray(search.buffer)) {
        search = Buffer2.from(search.buffer, search.byteOffset, search.byteLength);
      } else if (!Buffer2.isBuffer(search)) {
        search = Buffer2.from(search);
      }
      offset3 = Number(offset3 || 0);
      if (isNaN(offset3)) {
        offset3 = 0;
      }
      if (offset3 < 0) {
        offset3 = this.length + offset3;
      }
      if (offset3 < 0) {
        offset3 = 0;
      }
      if (search.length === 0) {
        return offset3 > this.length ? this.length : offset3;
      }
      const blOffset = this._offset(offset3);
      let blIndex = blOffset[0];
      let buffOffset = blOffset[1];
      for (; blIndex < this._bufs.length; blIndex++) {
        const buff = this._bufs[blIndex];
        while (buffOffset < buff.length) {
          const availableWindow = buff.length - buffOffset;
          if (availableWindow >= search.length) {
            const nativeSearchResult = buff.indexOf(search, buffOffset);
            if (nativeSearchResult !== -1) {
              return this._reverseOffset([blIndex, nativeSearchResult]);
            }
            buffOffset = buff.length - search.length + 1;
          } else {
            const revOffset = this._reverseOffset([blIndex, buffOffset]);
            if (this._match(revOffset, search)) {
              return revOffset;
            }
            buffOffset++;
          }
        }
        buffOffset = 0;
      }
      return -1;
    };
    BufferList.prototype._match = function(offset3, search) {
      if (this.length - offset3 < search.length) {
        return false;
      }
      for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
        if (this.get(offset3 + searchOffset) !== search[searchOffset]) {
          return false;
        }
      }
      return true;
    };
    (function() {
      const methods = {
        readDoubleBE: 8,
        readDoubleLE: 8,
        readFloatBE: 4,
        readFloatLE: 4,
        readInt32BE: 4,
        readInt32LE: 4,
        readUInt32BE: 4,
        readUInt32LE: 4,
        readInt16BE: 2,
        readInt16LE: 2,
        readUInt16BE: 2,
        readUInt16LE: 2,
        readInt8: 1,
        readUInt8: 1,
        readIntBE: null,
        readIntLE: null,
        readUIntBE: null,
        readUIntLE: null
      };
      for (const m in methods) {
        (function(m2) {
          if (methods[m2] === null) {
            BufferList.prototype[m2] = function(offset3, byteLength) {
              return this.slice(offset3, offset3 + byteLength)[m2](0, byteLength);
            };
          } else {
            BufferList.prototype[m2] = function(offset3 = 0) {
              return this.slice(offset3, offset3 + methods[m2])[m2](0);
            };
          }
        })(m);
      }
    })();
    BufferList.prototype._isBufferList = function _isBufferList(b) {
      return b instanceof BufferList || BufferList.isBufferList(b);
    };
    BufferList.isBufferList = function isBufferList(b) {
      return b != null && b[symbol];
    };
    module2.exports = BufferList;
  }
});

// node_modules/.pnpm/bl@5.1.0/node_modules/bl/bl.js
var require_bl = __commonJS({
  "node_modules/.pnpm/bl@5.1.0/node_modules/bl/bl.js"(exports3, module2) {
    "use strict";
    var DuplexStream = require_readable_browser().Duplex;
    var inherits2 = require_inherits_browser();
    var BufferList = require_BufferList();
    function BufferListStream2(callback) {
      if (!(this instanceof BufferListStream2)) {
        return new BufferListStream2(callback);
      }
      if (typeof callback === "function") {
        this._callback = callback;
        const piper = function piper2(err2) {
          if (this._callback) {
            this._callback(err2);
            this._callback = null;
          }
        }.bind(this);
        this.on("pipe", function onPipe(src3) {
          src3.on("error", piper);
        });
        this.on("unpipe", function onUnpipe(src3) {
          src3.removeListener("error", piper);
        });
        callback = null;
      }
      BufferList._init.call(this, callback);
      DuplexStream.call(this);
    }
    inherits2(BufferListStream2, DuplexStream);
    Object.assign(BufferListStream2.prototype, BufferList.prototype);
    BufferListStream2.prototype._new = function _new(callback) {
      return new BufferListStream2(callback);
    };
    BufferListStream2.prototype._write = function _write(buf, encoding, callback) {
      this._appendBuffer(buf);
      if (typeof callback === "function") {
        callback();
      }
    };
    BufferListStream2.prototype._read = function _read(size) {
      if (!this.length) {
        return this.push(null);
      }
      size = Math.min(size, this.length);
      this.push(this.slice(0, size));
      this.consume(size);
    };
    BufferListStream2.prototype.end = function end(chunk) {
      DuplexStream.prototype.end.call(this, chunk);
      if (this._callback) {
        this._callback(null, this.slice());
        this._callback = null;
      }
    };
    BufferListStream2.prototype._destroy = function _destroy(err2, cb) {
      this._bufs.length = 0;
      this.length = 0;
      cb(err2);
    };
    BufferListStream2.prototype._isBufferList = function _isBufferList(b) {
      return b instanceof BufferListStream2 || b instanceof BufferList || BufferListStream2.isBufferList(b);
    };
    BufferListStream2.isBufferList = BufferList.isBufferList;
    module2.exports = BufferListStream2;
    module2.exports.BufferListStream = BufferListStream2;
    module2.exports.BufferList = BufferList;
  }
});

// node_modules/.pnpm/upath@2.0.1/node_modules/upath/build/code/upath.js
var require_upath = __commonJS({
  "node_modules/.pnpm/upath@2.0.1/node_modules/upath/build/code/upath.js"(exports3) {
    var VERSION2 = "2.0.1";
    var extraFn;
    var extraFunctions;
    var isFunction3;
    var isString3;
    var isValidExt;
    var name2;
    var path8;
    var propName;
    var propValue;
    var toUnix2;
    var upath;
    var slice2 = [].slice;
    var indexOf3 = [].indexOf || function(item) {
      for (var i2 = 0, l2 = this.length; i2 < l2; i2++) {
        if (i2 in this && this[i2] === item)
          return i2;
      }
      return -1;
    };
    var hasProp = {}.hasOwnProperty;
    path8 = require_path();
    isFunction3 = function(val) {
      return typeof val === "function";
    };
    isString3 = function(val) {
      return typeof val === "string" || !!val && typeof val === "object" && Object.prototype.toString.call(val) === "[object String]";
    };
    upath = exports3;
    upath.VERSION = typeof VERSION2 !== "undefined" && VERSION2 !== null ? VERSION2 : "NO-VERSION";
    toUnix2 = function(p2) {
      p2 = p2.replace(/\\/g, "/");
      p2 = p2.replace(new RegExp("(?<!^)\\/+", "g"), "/");
      return p2;
    };
    for (propName in path8) {
      propValue = path8[propName];
      if (isFunction3(propValue)) {
        upath[propName] = function(propName2) {
          return function() {
            var args, result;
            args = 1 <= arguments.length ? slice2.call(arguments, 0) : [];
            args = args.map(function(p2) {
              if (isString3(p2)) {
                return toUnix2(p2);
              } else {
                return p2;
              }
            });
            result = path8[propName2].apply(path8, args);
            if (isString3(result)) {
              return toUnix2(result);
            } else {
              return result;
            }
          };
        }(propName);
      } else {
        upath[propName] = propValue;
      }
    }
    upath.sep = "/";
    extraFunctions = {
      toUnix: toUnix2,
      normalizeSafe: function(p2) {
        var result;
        p2 = toUnix2(p2);
        result = upath.normalize(p2);
        if (p2.startsWith("./") && !result.startsWith("./") && !result.startsWith("..")) {
          result = "./" + result;
        } else if (p2.startsWith("//") && !result.startsWith("//")) {
          if (p2.startsWith("//./")) {
            result = "//." + result;
          } else {
            result = "/" + result;
          }
        }
        return result;
      },
      normalizeTrim: function(p2) {
        p2 = upath.normalizeSafe(p2);
        if (p2.endsWith("/")) {
          return p2.slice(0, +(p2.length - 2) + 1 || 9e9);
        } else {
          return p2;
        }
      },
      joinSafe: function() {
        var p2, p0, result;
        p2 = 1 <= arguments.length ? slice2.call(arguments, 0) : [];
        result = upath.join.apply(null, p2);
        if (p2.length > 0) {
          p0 = toUnix2(p2[0]);
          if (p0.startsWith("./") && !result.startsWith("./") && !result.startsWith("..")) {
            result = "./" + result;
          } else if (p0.startsWith("//") && !result.startsWith("//")) {
            if (p0.startsWith("//./")) {
              result = "//." + result;
            } else {
              result = "/" + result;
            }
          }
        }
        return result;
      },
      addExt: function(file, ext2) {
        if (!ext2) {
          return file;
        } else {
          if (ext2[0] !== ".") {
            ext2 = "." + ext2;
          }
          return file + (file.endsWith(ext2) ? "" : ext2);
        }
      },
      trimExt: function(filename, ignoreExts, maxSize) {
        var oldExt;
        if (maxSize == null) {
          maxSize = 7;
        }
        oldExt = upath.extname(filename);
        if (isValidExt(oldExt, ignoreExts, maxSize)) {
          return filename.slice(0, +(filename.length - oldExt.length - 1) + 1 || 9e9);
        } else {
          return filename;
        }
      },
      removeExt: function(filename, ext2) {
        if (!ext2) {
          return filename;
        } else {
          ext2 = ext2[0] === "." ? ext2 : "." + ext2;
          if (upath.extname(filename) === ext2) {
            return upath.trimExt(filename, [], ext2.length);
          } else {
            return filename;
          }
        }
      },
      changeExt: function(filename, ext2, ignoreExts, maxSize) {
        if (maxSize == null) {
          maxSize = 7;
        }
        return upath.trimExt(filename, ignoreExts, maxSize) + (!ext2 ? "" : ext2[0] === "." ? ext2 : "." + ext2);
      },
      defaultExt: function(filename, ext2, ignoreExts, maxSize) {
        var oldExt;
        if (maxSize == null) {
          maxSize = 7;
        }
        oldExt = upath.extname(filename);
        if (isValidExt(oldExt, ignoreExts, maxSize)) {
          return filename;
        } else {
          return upath.addExt(filename, ext2);
        }
      }
    };
    isValidExt = function(ext2, ignoreExts, maxSize) {
      if (ignoreExts == null) {
        ignoreExts = [];
      }
      return ext2 && ext2.length <= maxSize && indexOf3.call(ignoreExts.map(function(e3) {
        return (e3 && e3[0] !== "." ? "." : "") + e3;
      }), ext2) < 0;
    };
    for (name2 in extraFunctions) {
      if (!hasProp.call(extraFunctions, name2))
        continue;
      extraFn = extraFunctions[name2];
      if (upath[name2] !== void 0) {
        throw new Error("path." + name2 + " already exists.");
      } else {
        upath[name2] = extraFn;
      }
    }
  }
});

// browser-external:process
var require_process = __commonJS({
  "browser-external:process"(exports3, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "process" has been externalized for browser compatibility. Cannot access "process.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:child_process
var require_child_process = __commonJS({
  "browser-external:child_process"(exports3, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "child_process" has been externalized for browser compatibility. Cannot access "child_process.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:worker_threads
var require_worker_threads = __commonJS({
  "browser-external:worker_threads"(exports3, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "worker_threads" has been externalized for browser compatibility. Cannot access "worker_threads.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/.pnpm/esbuild@0.16.17/node_modules/esbuild/lib/main.js
var require_main = __commonJS({
  "node_modules/.pnpm/esbuild@0.16.17/node_modules/esbuild/lib/main.js"(exports3, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export3 = (target, all) => {
      for (var name2 in all)
        __defProp2(target, name2, { get: all[name2], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
    var node_exports = {};
    __export3(node_exports, {
      analyzeMetafile: () => analyzeMetafile,
      analyzeMetafileSync: () => analyzeMetafileSync,
      build: () => build4,
      buildSync: () => buildSync,
      default: () => node_default,
      formatMessages: () => formatMessages2,
      formatMessagesSync: () => formatMessagesSync,
      initialize: () => initialize,
      serve: () => serve,
      transform: () => transform2,
      transformSync: () => transformSync,
      version: () => version4
    });
    module2.exports = __toCommonJS2(node_exports);
    function encodePacket(packet) {
      let visit4 = (value2) => {
        if (value2 === null) {
          bb.write8(0);
        } else if (typeof value2 === "boolean") {
          bb.write8(1);
          bb.write8(+value2);
        } else if (typeof value2 === "number") {
          bb.write8(2);
          bb.write32(value2 | 0);
        } else if (typeof value2 === "string") {
          bb.write8(3);
          bb.write(encodeUTF8(value2));
        } else if (value2 instanceof Uint8Array) {
          bb.write8(4);
          bb.write(value2);
        } else if (value2 instanceof Array) {
          bb.write8(5);
          bb.write32(value2.length);
          for (let item of value2) {
            visit4(item);
          }
        } else {
          let keys = Object.keys(value2);
          bb.write8(6);
          bb.write32(keys.length);
          for (let key of keys) {
            bb.write(encodeUTF8(key));
            visit4(value2[key]);
          }
        }
      };
      let bb = new ByteBuffer();
      bb.write32(0);
      bb.write32(packet.id << 1 | +!packet.isRequest);
      visit4(packet.value);
      writeUInt32LE(bb.buf, bb.len - 4, 0);
      return bb.buf.subarray(0, bb.len);
    }
    function decodePacket(bytes) {
      let visit4 = () => {
        switch (bb.read8()) {
          case 0:
            return null;
          case 1:
            return !!bb.read8();
          case 2:
            return bb.read32();
          case 3:
            return decodeUTF8(bb.read());
          case 4:
            return bb.read();
          case 5: {
            let count = bb.read32();
            let value22 = [];
            for (let i2 = 0; i2 < count; i2++) {
              value22.push(visit4());
            }
            return value22;
          }
          case 6: {
            let count = bb.read32();
            let value22 = {};
            for (let i2 = 0; i2 < count; i2++) {
              value22[decodeUTF8(bb.read())] = visit4();
            }
            return value22;
          }
          default:
            throw new Error("Invalid packet");
        }
      };
      let bb = new ByteBuffer(bytes);
      let id = bb.read32();
      let isRequest = (id & 1) === 0;
      id >>>= 1;
      let value2 = visit4();
      if (bb.ptr !== bytes.length) {
        throw new Error("Invalid packet");
      }
      return { id, isRequest, value: value2 };
    }
    var ByteBuffer = class {
      constructor(buf = new Uint8Array(1024)) {
        this.buf = buf;
        this.len = 0;
        this.ptr = 0;
      }
      _write(delta) {
        if (this.len + delta > this.buf.length) {
          let clone = new Uint8Array((this.len + delta) * 2);
          clone.set(this.buf);
          this.buf = clone;
        }
        this.len += delta;
        return this.len - delta;
      }
      write8(value2) {
        let offset3 = this._write(1);
        this.buf[offset3] = value2;
      }
      write32(value2) {
        let offset3 = this._write(4);
        writeUInt32LE(this.buf, value2, offset3);
      }
      write(bytes) {
        let offset3 = this._write(4 + bytes.length);
        writeUInt32LE(this.buf, bytes.length, offset3);
        this.buf.set(bytes, offset3 + 4);
      }
      _read(delta) {
        if (this.ptr + delta > this.buf.length) {
          throw new Error("Invalid packet");
        }
        this.ptr += delta;
        return this.ptr - delta;
      }
      read8() {
        return this.buf[this._read(1)];
      }
      read32() {
        return readUInt32LE(this.buf, this._read(4));
      }
      read() {
        let length = this.read32();
        let bytes = new Uint8Array(length);
        let ptr = this._read(bytes.length);
        bytes.set(this.buf.subarray(ptr, ptr + length));
        return bytes;
      }
    };
    var encodeUTF8;
    var decodeUTF8;
    var encodeInvariant;
    if (typeof TextEncoder !== "undefined" && typeof TextDecoder !== "undefined") {
      let encoder = new TextEncoder();
      let decoder = new TextDecoder();
      encodeUTF8 = (text) => encoder.encode(text);
      decodeUTF8 = (bytes) => decoder.decode(bytes);
      encodeInvariant = 'new TextEncoder().encode("")';
    } else if (typeof Buffer !== "undefined") {
      encodeUTF8 = (text) => Buffer.from(text);
      decodeUTF8 = (bytes) => {
        let { buffer, byteOffset, byteLength } = bytes;
        return Buffer.from(buffer, byteOffset, byteLength).toString();
      };
      encodeInvariant = 'Buffer.from("")';
    } else {
      throw new Error("No UTF-8 codec found");
    }
    if (!(encodeUTF8("") instanceof Uint8Array))
      throw new Error(`Invariant violation: "${encodeInvariant} instanceof Uint8Array" is incorrectly false

This indicates that your JavaScript environment is broken. You cannot use
esbuild in this environment because esbuild relies on this invariant. This
is not a problem with esbuild. You need to fix your environment instead.
`);
    function readUInt32LE(buffer, offset3) {
      return buffer[offset3++] | buffer[offset3++] << 8 | buffer[offset3++] << 16 | buffer[offset3++] << 24;
    }
    function writeUInt32LE(buffer, value2, offset3) {
      buffer[offset3++] = value2;
      buffer[offset3++] = value2 >> 8;
      buffer[offset3++] = value2 >> 16;
      buffer[offset3++] = value2 >> 24;
    }
    var quote = JSON.stringify;
    var buildLogLevelDefault = "warning";
    var transformLogLevelDefault = "silent";
    function validateTarget(target) {
      validateStringValue(target, "target");
      if (target.indexOf(",") >= 0)
        throw new Error(`Invalid target: ${target}`);
      return target;
    }
    var canBeAnything = () => null;
    var mustBeBoolean = (value2) => typeof value2 === "boolean" ? null : "a boolean";
    var mustBeBooleanOrObject = (value2) => typeof value2 === "boolean" || typeof value2 === "object" && !Array.isArray(value2) ? null : "a boolean or an object";
    var mustBeString = (value2) => typeof value2 === "string" ? null : "a string";
    var mustBeRegExp = (value2) => value2 instanceof RegExp ? null : "a RegExp object";
    var mustBeInteger = (value2) => typeof value2 === "number" && value2 === (value2 | 0) ? null : "an integer";
    var mustBeFunction = (value2) => typeof value2 === "function" ? null : "a function";
    var mustBeArray = (value2) => Array.isArray(value2) ? null : "an array";
    var mustBeObject = (value2) => typeof value2 === "object" && value2 !== null && !Array.isArray(value2) ? null : "an object";
    var mustBeWebAssemblyModule = (value2) => value2 instanceof WebAssembly.Module ? null : "a WebAssembly.Module";
    var mustBeArrayOrRecord = (value2) => typeof value2 === "object" && value2 !== null ? null : "an array or an object";
    var mustBeObjectOrNull = (value2) => typeof value2 === "object" && !Array.isArray(value2) ? null : "an object or null";
    var mustBeStringOrBoolean = (value2) => typeof value2 === "string" || typeof value2 === "boolean" ? null : "a string or a boolean";
    var mustBeStringOrObject = (value2) => typeof value2 === "string" || typeof value2 === "object" && value2 !== null && !Array.isArray(value2) ? null : "a string or an object";
    var mustBeStringOrArray = (value2) => typeof value2 === "string" || Array.isArray(value2) ? null : "a string or an array";
    var mustBeStringOrUint8Array = (value2) => typeof value2 === "string" || value2 instanceof Uint8Array ? null : "a string or a Uint8Array";
    var mustBeStringOrURL = (value2) => typeof value2 === "string" || value2 instanceof URL ? null : "a string or a URL";
    function getFlag(object, keys, key, mustBeFn) {
      let value2 = object[key];
      keys[key + ""] = true;
      if (value2 === void 0)
        return void 0;
      let mustBe = mustBeFn(value2);
      if (mustBe !== null)
        throw new Error(`${quote(key)} must be ${mustBe}`);
      return value2;
    }
    function checkForInvalidFlags(object, keys, where) {
      for (let key in object) {
        if (!(key in keys)) {
          throw new Error(`Invalid option ${where}: ${quote(key)}`);
        }
      }
    }
    function validateInitializeOptions(options3) {
      let keys = /* @__PURE__ */ Object.create(null);
      let wasmURL = getFlag(options3, keys, "wasmURL", mustBeStringOrURL);
      let wasmModule = getFlag(options3, keys, "wasmModule", mustBeWebAssemblyModule);
      let worker = getFlag(options3, keys, "worker", mustBeBoolean);
      checkForInvalidFlags(options3, keys, "in initialize() call");
      return {
        wasmURL,
        wasmModule,
        worker
      };
    }
    function validateMangleCache(mangleCache) {
      let validated;
      if (mangleCache !== void 0) {
        validated = /* @__PURE__ */ Object.create(null);
        for (let key in mangleCache) {
          let value2 = mangleCache[key];
          if (typeof value2 === "string" || value2 === false) {
            validated[key] = value2;
          } else {
            throw new Error(`Expected ${quote(key)} in mangle cache to map to either a string or false`);
          }
        }
      }
      return validated;
    }
    function pushLogFlags(flags, options3, keys, isTTY2, logLevelDefault) {
      let color = getFlag(options3, keys, "color", mustBeBoolean);
      let logLevel = getFlag(options3, keys, "logLevel", mustBeString);
      let logLimit = getFlag(options3, keys, "logLimit", mustBeInteger);
      if (color !== void 0)
        flags.push(`--color=${color}`);
      else if (isTTY2)
        flags.push(`--color=true`);
      flags.push(`--log-level=${logLevel || logLevelDefault}`);
      flags.push(`--log-limit=${logLimit || 0}`);
    }
    function validateStringValue(value2, what, key) {
      if (typeof value2 !== "string") {
        throw new Error(`Expected value for ${what}${key !== void 0 ? " " + quote(key) : ""} to be a string, got ${typeof value2} instead`);
      }
      return value2;
    }
    function pushCommonFlags(flags, options3, keys) {
      let legalComments = getFlag(options3, keys, "legalComments", mustBeString);
      let sourceRoot = getFlag(options3, keys, "sourceRoot", mustBeString);
      let sourcesContent = getFlag(options3, keys, "sourcesContent", mustBeBoolean);
      let target = getFlag(options3, keys, "target", mustBeStringOrArray);
      let format2 = getFlag(options3, keys, "format", mustBeString);
      let globalName = getFlag(options3, keys, "globalName", mustBeString);
      let mangleProps = getFlag(options3, keys, "mangleProps", mustBeRegExp);
      let reserveProps = getFlag(options3, keys, "reserveProps", mustBeRegExp);
      let mangleQuoted = getFlag(options3, keys, "mangleQuoted", mustBeBoolean);
      let minify = getFlag(options3, keys, "minify", mustBeBoolean);
      let minifySyntax = getFlag(options3, keys, "minifySyntax", mustBeBoolean);
      let minifyWhitespace = getFlag(options3, keys, "minifyWhitespace", mustBeBoolean);
      let minifyIdentifiers = getFlag(options3, keys, "minifyIdentifiers", mustBeBoolean);
      let drop = getFlag(options3, keys, "drop", mustBeArray);
      let charset = getFlag(options3, keys, "charset", mustBeString);
      let treeShaking = getFlag(options3, keys, "treeShaking", mustBeBoolean);
      let ignoreAnnotations = getFlag(options3, keys, "ignoreAnnotations", mustBeBoolean);
      let jsx = getFlag(options3, keys, "jsx", mustBeString);
      let jsxFactory = getFlag(options3, keys, "jsxFactory", mustBeString);
      let jsxFragment = getFlag(options3, keys, "jsxFragment", mustBeString);
      let jsxImportSource = getFlag(options3, keys, "jsxImportSource", mustBeString);
      let jsxDev = getFlag(options3, keys, "jsxDev", mustBeBoolean);
      let jsxSideEffects = getFlag(options3, keys, "jsxSideEffects", mustBeBoolean);
      let define2 = getFlag(options3, keys, "define", mustBeObject);
      let logOverride = getFlag(options3, keys, "logOverride", mustBeObject);
      let supported = getFlag(options3, keys, "supported", mustBeObject);
      let pure = getFlag(options3, keys, "pure", mustBeArray);
      let keepNames = getFlag(options3, keys, "keepNames", mustBeBoolean);
      let platform2 = getFlag(options3, keys, "platform", mustBeString);
      if (legalComments)
        flags.push(`--legal-comments=${legalComments}`);
      if (sourceRoot !== void 0)
        flags.push(`--source-root=${sourceRoot}`);
      if (sourcesContent !== void 0)
        flags.push(`--sources-content=${sourcesContent}`);
      if (target) {
        if (Array.isArray(target))
          flags.push(`--target=${Array.from(target).map(validateTarget).join(",")}`);
        else
          flags.push(`--target=${validateTarget(target)}`);
      }
      if (format2)
        flags.push(`--format=${format2}`);
      if (globalName)
        flags.push(`--global-name=${globalName}`);
      if (platform2)
        flags.push(`--platform=${platform2}`);
      if (minify)
        flags.push("--minify");
      if (minifySyntax)
        flags.push("--minify-syntax");
      if (minifyWhitespace)
        flags.push("--minify-whitespace");
      if (minifyIdentifiers)
        flags.push("--minify-identifiers");
      if (charset)
        flags.push(`--charset=${charset}`);
      if (treeShaking !== void 0)
        flags.push(`--tree-shaking=${treeShaking}`);
      if (ignoreAnnotations)
        flags.push(`--ignore-annotations`);
      if (drop)
        for (let what of drop)
          flags.push(`--drop:${validateStringValue(what, "drop")}`);
      if (mangleProps)
        flags.push(`--mangle-props=${mangleProps.source}`);
      if (reserveProps)
        flags.push(`--reserve-props=${reserveProps.source}`);
      if (mangleQuoted !== void 0)
        flags.push(`--mangle-quoted=${mangleQuoted}`);
      if (jsx)
        flags.push(`--jsx=${jsx}`);
      if (jsxFactory)
        flags.push(`--jsx-factory=${jsxFactory}`);
      if (jsxFragment)
        flags.push(`--jsx-fragment=${jsxFragment}`);
      if (jsxImportSource)
        flags.push(`--jsx-import-source=${jsxImportSource}`);
      if (jsxDev)
        flags.push(`--jsx-dev`);
      if (jsxSideEffects)
        flags.push(`--jsx-side-effects`);
      if (define2) {
        for (let key in define2) {
          if (key.indexOf("=") >= 0)
            throw new Error(`Invalid define: ${key}`);
          flags.push(`--define:${key}=${validateStringValue(define2[key], "define", key)}`);
        }
      }
      if (logOverride) {
        for (let key in logOverride) {
          if (key.indexOf("=") >= 0)
            throw new Error(`Invalid log override: ${key}`);
          flags.push(`--log-override:${key}=${validateStringValue(logOverride[key], "log override", key)}`);
        }
      }
      if (supported) {
        for (let key in supported) {
          if (key.indexOf("=") >= 0)
            throw new Error(`Invalid supported: ${key}`);
          const value2 = supported[key];
          if (typeof value2 !== "boolean")
            throw new Error(`Expected value for supported ${quote(key)} to be a boolean, got ${typeof value2} instead`);
          flags.push(`--supported:${key}=${value2}`);
        }
      }
      if (pure)
        for (let fn of pure)
          flags.push(`--pure:${validateStringValue(fn, "pure")}`);
      if (keepNames)
        flags.push(`--keep-names`);
    }
    function flagsForBuildOptions(callName, options3, isTTY2, logLevelDefault, writeDefault) {
      var _a2;
      let flags = [];
      let entries = [];
      let keys = /* @__PURE__ */ Object.create(null);
      let stdinContents = null;
      let stdinResolveDir = null;
      let watchMode = null;
      pushLogFlags(flags, options3, keys, isTTY2, logLevelDefault);
      pushCommonFlags(flags, options3, keys);
      let sourcemap = getFlag(options3, keys, "sourcemap", mustBeStringOrBoolean);
      let bundle = getFlag(options3, keys, "bundle", mustBeBoolean);
      let watch2 = getFlag(options3, keys, "watch", mustBeBooleanOrObject);
      let splitting = getFlag(options3, keys, "splitting", mustBeBoolean);
      let preserveSymlinks = getFlag(options3, keys, "preserveSymlinks", mustBeBoolean);
      let metafile = getFlag(options3, keys, "metafile", mustBeBoolean);
      let outfile = getFlag(options3, keys, "outfile", mustBeString);
      let outdir = getFlag(options3, keys, "outdir", mustBeString);
      let outbase = getFlag(options3, keys, "outbase", mustBeString);
      let tsconfig = getFlag(options3, keys, "tsconfig", mustBeString);
      let resolveExtensions2 = getFlag(options3, keys, "resolveExtensions", mustBeArray);
      let nodePathsInput = getFlag(options3, keys, "nodePaths", mustBeArray);
      let mainFields = getFlag(options3, keys, "mainFields", mustBeArray);
      let conditions = getFlag(options3, keys, "conditions", mustBeArray);
      let external = getFlag(options3, keys, "external", mustBeArray);
      let packages = getFlag(options3, keys, "packages", mustBeString);
      let alias2 = getFlag(options3, keys, "alias", mustBeObject);
      let loader = getFlag(options3, keys, "loader", mustBeObject);
      let outExtension = getFlag(options3, keys, "outExtension", mustBeObject);
      let publicPath = getFlag(options3, keys, "publicPath", mustBeString);
      let entryNames = getFlag(options3, keys, "entryNames", mustBeString);
      let chunkNames = getFlag(options3, keys, "chunkNames", mustBeString);
      let assetNames = getFlag(options3, keys, "assetNames", mustBeString);
      let inject = getFlag(options3, keys, "inject", mustBeArray);
      let banner = getFlag(options3, keys, "banner", mustBeObject);
      let footer = getFlag(options3, keys, "footer", mustBeObject);
      let entryPoints = getFlag(options3, keys, "entryPoints", mustBeArrayOrRecord);
      let absWorkingDir = getFlag(options3, keys, "absWorkingDir", mustBeString);
      let stdin = getFlag(options3, keys, "stdin", mustBeObject);
      let write = (_a2 = getFlag(options3, keys, "write", mustBeBoolean)) != null ? _a2 : writeDefault;
      let allowOverwrite = getFlag(options3, keys, "allowOverwrite", mustBeBoolean);
      let incremental = getFlag(options3, keys, "incremental", mustBeBoolean) === true;
      let mangleCache = getFlag(options3, keys, "mangleCache", mustBeObject);
      keys.plugins = true;
      checkForInvalidFlags(options3, keys, `in ${callName}() call`);
      if (sourcemap)
        flags.push(`--sourcemap${sourcemap === true ? "" : `=${sourcemap}`}`);
      if (bundle)
        flags.push("--bundle");
      if (allowOverwrite)
        flags.push("--allow-overwrite");
      if (watch2) {
        flags.push("--watch");
        if (typeof watch2 === "boolean") {
          watchMode = {};
        } else {
          let watchKeys = /* @__PURE__ */ Object.create(null);
          let onRebuild = getFlag(watch2, watchKeys, "onRebuild", mustBeFunction);
          checkForInvalidFlags(watch2, watchKeys, `on "watch" in ${callName}() call`);
          watchMode = { onRebuild };
        }
      }
      if (splitting)
        flags.push("--splitting");
      if (preserveSymlinks)
        flags.push("--preserve-symlinks");
      if (metafile)
        flags.push(`--metafile`);
      if (outfile)
        flags.push(`--outfile=${outfile}`);
      if (outdir)
        flags.push(`--outdir=${outdir}`);
      if (outbase)
        flags.push(`--outbase=${outbase}`);
      if (tsconfig)
        flags.push(`--tsconfig=${tsconfig}`);
      if (packages)
        flags.push(`--packages=${packages}`);
      if (resolveExtensions2) {
        let values = [];
        for (let value2 of resolveExtensions2) {
          validateStringValue(value2, "resolve extension");
          if (value2.indexOf(",") >= 0)
            throw new Error(`Invalid resolve extension: ${value2}`);
          values.push(value2);
        }
        flags.push(`--resolve-extensions=${values.join(",")}`);
      }
      if (publicPath)
        flags.push(`--public-path=${publicPath}`);
      if (entryNames)
        flags.push(`--entry-names=${entryNames}`);
      if (chunkNames)
        flags.push(`--chunk-names=${chunkNames}`);
      if (assetNames)
        flags.push(`--asset-names=${assetNames}`);
      if (mainFields) {
        let values = [];
        for (let value2 of mainFields) {
          validateStringValue(value2, "main field");
          if (value2.indexOf(",") >= 0)
            throw new Error(`Invalid main field: ${value2}`);
          values.push(value2);
        }
        flags.push(`--main-fields=${values.join(",")}`);
      }
      if (conditions) {
        let values = [];
        for (let value2 of conditions) {
          validateStringValue(value2, "condition");
          if (value2.indexOf(",") >= 0)
            throw new Error(`Invalid condition: ${value2}`);
          values.push(value2);
        }
        flags.push(`--conditions=${values.join(",")}`);
      }
      if (external)
        for (let name2 of external)
          flags.push(`--external:${validateStringValue(name2, "external")}`);
      if (alias2) {
        for (let old2 in alias2) {
          if (old2.indexOf("=") >= 0)
            throw new Error(`Invalid package name in alias: ${old2}`);
          flags.push(`--alias:${old2}=${validateStringValue(alias2[old2], "alias", old2)}`);
        }
      }
      if (banner) {
        for (let type in banner) {
          if (type.indexOf("=") >= 0)
            throw new Error(`Invalid banner file type: ${type}`);
          flags.push(`--banner:${type}=${validateStringValue(banner[type], "banner", type)}`);
        }
      }
      if (footer) {
        for (let type in footer) {
          if (type.indexOf("=") >= 0)
            throw new Error(`Invalid footer file type: ${type}`);
          flags.push(`--footer:${type}=${validateStringValue(footer[type], "footer", type)}`);
        }
      }
      if (inject)
        for (let path32 of inject)
          flags.push(`--inject:${validateStringValue(path32, "inject")}`);
      if (loader) {
        for (let ext2 in loader) {
          if (ext2.indexOf("=") >= 0)
            throw new Error(`Invalid loader extension: ${ext2}`);
          flags.push(`--loader:${ext2}=${validateStringValue(loader[ext2], "loader", ext2)}`);
        }
      }
      if (outExtension) {
        for (let ext2 in outExtension) {
          if (ext2.indexOf("=") >= 0)
            throw new Error(`Invalid out extension: ${ext2}`);
          flags.push(`--out-extension:${ext2}=${validateStringValue(outExtension[ext2], "out extension", ext2)}`);
        }
      }
      if (entryPoints) {
        if (Array.isArray(entryPoints)) {
          for (let entryPoint of entryPoints) {
            entries.push(["", validateStringValue(entryPoint, "entry point")]);
          }
        } else {
          for (let key in entryPoints) {
            entries.push([key, validateStringValue(entryPoints[key], "entry point", key)]);
          }
        }
      }
      if (stdin) {
        let stdinKeys = /* @__PURE__ */ Object.create(null);
        let contents = getFlag(stdin, stdinKeys, "contents", mustBeStringOrUint8Array);
        let resolveDir = getFlag(stdin, stdinKeys, "resolveDir", mustBeString);
        let sourcefile = getFlag(stdin, stdinKeys, "sourcefile", mustBeString);
        let loader2 = getFlag(stdin, stdinKeys, "loader", mustBeString);
        checkForInvalidFlags(stdin, stdinKeys, 'in "stdin" object');
        if (sourcefile)
          flags.push(`--sourcefile=${sourcefile}`);
        if (loader2)
          flags.push(`--loader=${loader2}`);
        if (resolveDir)
          stdinResolveDir = resolveDir;
        if (typeof contents === "string")
          stdinContents = encodeUTF8(contents);
        else if (contents instanceof Uint8Array)
          stdinContents = contents;
      }
      let nodePaths = [];
      if (nodePathsInput) {
        for (let value2 of nodePathsInput) {
          value2 += "";
          nodePaths.push(value2);
        }
      }
      return {
        entries,
        flags,
        write,
        stdinContents,
        stdinResolveDir,
        absWorkingDir,
        incremental,
        nodePaths,
        watch: watchMode,
        mangleCache: validateMangleCache(mangleCache)
      };
    }
    function flagsForTransformOptions(callName, options3, isTTY2, logLevelDefault) {
      let flags = [];
      let keys = /* @__PURE__ */ Object.create(null);
      pushLogFlags(flags, options3, keys, isTTY2, logLevelDefault);
      pushCommonFlags(flags, options3, keys);
      let sourcemap = getFlag(options3, keys, "sourcemap", mustBeStringOrBoolean);
      let tsconfigRaw = getFlag(options3, keys, "tsconfigRaw", mustBeStringOrObject);
      let sourcefile = getFlag(options3, keys, "sourcefile", mustBeString);
      let loader = getFlag(options3, keys, "loader", mustBeString);
      let banner = getFlag(options3, keys, "banner", mustBeString);
      let footer = getFlag(options3, keys, "footer", mustBeString);
      let mangleCache = getFlag(options3, keys, "mangleCache", mustBeObject);
      checkForInvalidFlags(options3, keys, `in ${callName}() call`);
      if (sourcemap)
        flags.push(`--sourcemap=${sourcemap === true ? "external" : sourcemap}`);
      if (tsconfigRaw)
        flags.push(`--tsconfig-raw=${typeof tsconfigRaw === "string" ? tsconfigRaw : JSON.stringify(tsconfigRaw)}`);
      if (sourcefile)
        flags.push(`--sourcefile=${sourcefile}`);
      if (loader)
        flags.push(`--loader=${loader}`);
      if (banner)
        flags.push(`--banner=${banner}`);
      if (footer)
        flags.push(`--footer=${footer}`);
      return {
        flags,
        mangleCache: validateMangleCache(mangleCache)
      };
    }
    function createChannel(streamIn) {
      const requestCallbacksByKey = {};
      const closeData = { didClose: false, reason: "" };
      let responseCallbacks = {};
      let nextRequestID = 0;
      let nextBuildKey = 0;
      let stdout = new Uint8Array(16 * 1024);
      let stdoutUsed = 0;
      let readFromStdout = (chunk) => {
        let limit = stdoutUsed + chunk.length;
        if (limit > stdout.length) {
          let swap = new Uint8Array(limit * 2);
          swap.set(stdout);
          stdout = swap;
        }
        stdout.set(chunk, stdoutUsed);
        stdoutUsed += chunk.length;
        let offset3 = 0;
        while (offset3 + 4 <= stdoutUsed) {
          let length = readUInt32LE(stdout, offset3);
          if (offset3 + 4 + length > stdoutUsed) {
            break;
          }
          offset3 += 4;
          handleIncomingPacket(stdout.subarray(offset3, offset3 + length));
          offset3 += length;
        }
        if (offset3 > 0) {
          stdout.copyWithin(0, offset3, stdoutUsed);
          stdoutUsed -= offset3;
        }
      };
      let afterClose = (error3) => {
        closeData.didClose = true;
        if (error3)
          closeData.reason = ": " + (error3.message || error3);
        const text = "The service was stopped" + closeData.reason;
        for (let id in responseCallbacks) {
          responseCallbacks[id](text, null);
        }
        responseCallbacks = {};
      };
      let sendRequest = (refs, value2, callback) => {
        if (closeData.didClose)
          return callback("The service is no longer running" + closeData.reason, null);
        let id = nextRequestID++;
        responseCallbacks[id] = (error3, response) => {
          try {
            callback(error3, response);
          } finally {
            if (refs)
              refs.unref();
          }
        };
        if (refs)
          refs.ref();
        streamIn.writeToStdin(encodePacket({ id, isRequest: true, value: value2 }));
      };
      let sendResponse = (id, value2) => {
        if (closeData.didClose)
          throw new Error("The service is no longer running" + closeData.reason);
        streamIn.writeToStdin(encodePacket({ id, isRequest: false, value: value2 }));
      };
      let handleRequest = async (id, request) => {
        try {
          if (request.command === "ping") {
            sendResponse(id, {});
            return;
          }
          if (typeof request.key === "number") {
            const requestCallbacks = requestCallbacksByKey[request.key];
            if (requestCallbacks) {
              const callback = requestCallbacks[request.command];
              if (callback) {
                await callback(id, request);
                return;
              }
            }
          }
          throw new Error(`Invalid command: ` + request.command);
        } catch (e3) {
          sendResponse(id, { errors: [extractErrorMessageV8(e3, streamIn, null, void 0, "")] });
        }
      };
      let isFirstPacket = true;
      let handleIncomingPacket = (bytes) => {
        if (isFirstPacket) {
          isFirstPacket = false;
          let binaryVersion = String.fromCharCode(...bytes);
          if (binaryVersion !== "0.16.17") {
            throw new Error(`Cannot start service: Host version "${"0.16.17"}" does not match binary version ${quote(binaryVersion)}`);
          }
          return;
        }
        let packet = decodePacket(bytes);
        if (packet.isRequest) {
          handleRequest(packet.id, packet.value);
        } else {
          let callback = responseCallbacks[packet.id];
          delete responseCallbacks[packet.id];
          if (packet.value.error)
            callback(packet.value.error, {});
          else
            callback(null, packet.value);
        }
      };
      let buildOrServe = ({ callName, refs, serveOptions, options: options3, isTTY: isTTY2, defaultWD: defaultWD2, callback }) => {
        let refCount = 0;
        const buildKey = nextBuildKey++;
        const requestCallbacks = {};
        const buildRefs = {
          ref() {
            if (++refCount === 1) {
              if (refs)
                refs.ref();
            }
          },
          unref() {
            if (--refCount === 0) {
              delete requestCallbacksByKey[buildKey];
              if (refs)
                refs.unref();
            }
          }
        };
        requestCallbacksByKey[buildKey] = requestCallbacks;
        buildRefs.ref();
        buildOrServeImpl(
          callName,
          buildKey,
          sendRequest,
          sendResponse,
          buildRefs,
          streamIn,
          requestCallbacks,
          options3,
          serveOptions,
          isTTY2,
          defaultWD2,
          closeData,
          (err2, res) => {
            try {
              callback(err2, res);
            } finally {
              buildRefs.unref();
            }
          }
        );
      };
      let transform22 = ({ callName, refs, input, options: options3, isTTY: isTTY2, fs: fs32, callback }) => {
        const details = createObjectStash();
        let start = (inputPath) => {
          try {
            if (typeof input !== "string" && !(input instanceof Uint8Array))
              throw new Error('The input to "transform" must be a string or a Uint8Array');
            let {
              flags,
              mangleCache
            } = flagsForTransformOptions(callName, options3, isTTY2, transformLogLevelDefault);
            let request = {
              command: "transform",
              flags,
              inputFS: inputPath !== null,
              input: inputPath !== null ? encodeUTF8(inputPath) : typeof input === "string" ? encodeUTF8(input) : input
            };
            if (mangleCache)
              request.mangleCache = mangleCache;
            sendRequest(refs, request, (error3, response) => {
              if (error3)
                return callback(new Error(error3), null);
              let errors = replaceDetailsInMessages(response.errors, details);
              let warnings = replaceDetailsInMessages(response.warnings, details);
              let outstanding = 1;
              let next = () => {
                if (--outstanding === 0) {
                  let result = { warnings, code: response.code, map: response.map };
                  if ("legalComments" in response)
                    result.legalComments = response == null ? void 0 : response.legalComments;
                  if (response.mangleCache)
                    result.mangleCache = response == null ? void 0 : response.mangleCache;
                  callback(null, result);
                }
              };
              if (errors.length > 0)
                return callback(failureErrorWithLog("Transform failed", errors, warnings), null);
              if (response.codeFS) {
                outstanding++;
                fs32.readFile(response.code, (err2, contents) => {
                  if (err2 !== null) {
                    callback(err2, null);
                  } else {
                    response.code = contents;
                    next();
                  }
                });
              }
              if (response.mapFS) {
                outstanding++;
                fs32.readFile(response.map, (err2, contents) => {
                  if (err2 !== null) {
                    callback(err2, null);
                  } else {
                    response.map = contents;
                    next();
                  }
                });
              }
              next();
            });
          } catch (e3) {
            let flags = [];
            try {
              pushLogFlags(flags, options3, {}, isTTY2, transformLogLevelDefault);
            } catch {
            }
            const error3 = extractErrorMessageV8(e3, streamIn, details, void 0, "");
            sendRequest(refs, { command: "error", flags, error: error3 }, () => {
              error3.detail = details.load(error3.detail);
              callback(failureErrorWithLog("Transform failed", [error3], []), null);
            });
          }
        };
        if ((typeof input === "string" || input instanceof Uint8Array) && input.length > 1024 * 1024) {
          let next = start;
          start = () => fs32.writeFile(input, next);
        }
        start(null);
      };
      let formatMessages22 = ({ callName, refs, messages: messages2, options: options3, callback }) => {
        let result = sanitizeMessages(messages2, "messages", null, "");
        if (!options3)
          throw new Error(`Missing second argument in ${callName}() call`);
        let keys = {};
        let kind = getFlag(options3, keys, "kind", mustBeString);
        let color = getFlag(options3, keys, "color", mustBeBoolean);
        let terminalWidth = getFlag(options3, keys, "terminalWidth", mustBeInteger);
        checkForInvalidFlags(options3, keys, `in ${callName}() call`);
        if (kind === void 0)
          throw new Error(`Missing "kind" in ${callName}() call`);
        if (kind !== "error" && kind !== "warning")
          throw new Error(`Expected "kind" to be "error" or "warning" in ${callName}() call`);
        let request = {
          command: "format-msgs",
          messages: result,
          isWarning: kind === "warning"
        };
        if (color !== void 0)
          request.color = color;
        if (terminalWidth !== void 0)
          request.terminalWidth = terminalWidth;
        sendRequest(refs, request, (error3, response) => {
          if (error3)
            return callback(new Error(error3), null);
          callback(null, response.messages);
        });
      };
      let analyzeMetafile2 = ({ callName, refs, metafile, options: options3, callback }) => {
        if (options3 === void 0)
          options3 = {};
        let keys = {};
        let color = getFlag(options3, keys, "color", mustBeBoolean);
        let verbose = getFlag(options3, keys, "verbose", mustBeBoolean);
        checkForInvalidFlags(options3, keys, `in ${callName}() call`);
        let request = {
          command: "analyze-metafile",
          metafile
        };
        if (color !== void 0)
          request.color = color;
        if (verbose !== void 0)
          request.verbose = verbose;
        sendRequest(refs, request, (error3, response) => {
          if (error3)
            return callback(new Error(error3), null);
          callback(null, response.result);
        });
      };
      return {
        readFromStdout,
        afterClose,
        service: {
          buildOrServe,
          transform: transform22,
          formatMessages: formatMessages22,
          analyzeMetafile: analyzeMetafile2
        }
      };
    }
    function buildOrServeImpl(callName, buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, options3, serveOptions, isTTY2, defaultWD2, closeData, callback) {
      const details = createObjectStash();
      const logPluginError = (e3, pluginName, note, done) => {
        const flags = [];
        try {
          pushLogFlags(flags, options3, {}, isTTY2, buildLogLevelDefault);
        } catch {
        }
        const message = extractErrorMessageV8(e3, streamIn, details, note, pluginName);
        sendRequest(refs, { command: "error", flags, error: message }, () => {
          message.detail = details.load(message.detail);
          done(message);
        });
      };
      const handleError = (e3, pluginName) => {
        logPluginError(e3, pluginName, void 0, (error3) => {
          callback(failureErrorWithLog("Build failed", [error3], []), null);
        });
      };
      let plugins2;
      if (typeof options3 === "object") {
        const value2 = options3.plugins;
        if (value2 !== void 0) {
          if (!Array.isArray(value2))
            throw new Error(`"plugins" must be an array`);
          plugins2 = value2;
        }
      }
      if (plugins2 && plugins2.length > 0) {
        if (streamIn.isSync) {
          handleError(new Error("Cannot use plugins in synchronous API calls"), "");
          return;
        }
        handlePlugins(
          buildKey,
          sendRequest,
          sendResponse,
          refs,
          streamIn,
          requestCallbacks,
          options3,
          plugins2,
          details
        ).then(
          (result) => {
            if (!result.ok) {
              handleError(result.error, result.pluginName);
              return;
            }
            try {
              buildOrServeContinue(result.requestPlugins, result.runOnEndCallbacks);
            } catch (e3) {
              handleError(e3, "");
            }
          },
          (e3) => handleError(e3, "")
        );
        return;
      }
      try {
        buildOrServeContinue(null, (result, logPluginError2, done) => done());
      } catch (e3) {
        handleError(e3, "");
      }
      function buildOrServeContinue(requestPlugins, runOnEndCallbacks) {
        let writeDefault = !streamIn.isWriteUnavailable;
        let {
          entries,
          flags,
          write,
          stdinContents,
          stdinResolveDir,
          absWorkingDir,
          incremental,
          nodePaths,
          watch: watch2,
          mangleCache
        } = flagsForBuildOptions(callName, options3, isTTY2, buildLogLevelDefault, writeDefault);
        let request = {
          command: "build",
          key: buildKey,
          entries,
          flags,
          write,
          stdinContents,
          stdinResolveDir,
          absWorkingDir: absWorkingDir || defaultWD2,
          incremental,
          nodePaths
        };
        if (requestPlugins)
          request.plugins = requestPlugins;
        if (mangleCache)
          request.mangleCache = mangleCache;
        let serve2 = serveOptions && buildServeData(buildKey, sendRequest, sendResponse, refs, requestCallbacks, serveOptions, request);
        let rebuild;
        let stop;
        let copyResponseToResult = (response, result) => {
          if (response.outputFiles)
            result.outputFiles = response.outputFiles.map(convertOutputFiles);
          if (response.metafile)
            result.metafile = JSON.parse(response.metafile);
          if (response.mangleCache)
            result.mangleCache = response.mangleCache;
          if (response.writeToStdout !== void 0)
            console.log(decodeUTF8(response.writeToStdout).replace(/\n$/, ""));
        };
        let buildResponseToResult = (response, callback2) => {
          let result = {
            errors: replaceDetailsInMessages(response.errors, details),
            warnings: replaceDetailsInMessages(response.warnings, details)
          };
          copyResponseToResult(response, result);
          runOnEndCallbacks(result, logPluginError, () => {
            if (result.errors.length > 0) {
              return callback2(failureErrorWithLog("Build failed", result.errors, result.warnings), null);
            }
            if (response.rebuild) {
              if (!rebuild) {
                let isDisposed = false;
                rebuild = () => new Promise((resolve4, reject) => {
                  if (isDisposed || closeData.didClose)
                    throw new Error("Cannot rebuild");
                  sendRequest(
                    refs,
                    { command: "rebuild", key: buildKey },
                    (error22, response2) => {
                      if (error22) {
                        const message = { id: "", pluginName: "", text: error22, location: null, notes: [], detail: void 0 };
                        return callback2(failureErrorWithLog("Build failed", [message], []), null);
                      }
                      buildResponseToResult(response2, (error3, result3) => {
                        if (error3)
                          reject(error3);
                        else
                          resolve4(result3);
                      });
                    }
                  );
                });
                refs.ref();
                rebuild.dispose = () => {
                  if (isDisposed)
                    return;
                  isDisposed = true;
                  sendRequest(refs, { command: "rebuild-dispose", key: buildKey }, () => {
                  });
                  refs.unref();
                };
              }
              result.rebuild = rebuild;
            }
            if (response.watch) {
              if (!stop) {
                let isStopped = false;
                refs.ref();
                stop = () => {
                  if (isStopped)
                    return;
                  isStopped = true;
                  delete requestCallbacks["watch-rebuild"];
                  sendRequest(refs, { command: "watch-stop", key: buildKey }, () => {
                  });
                  refs.unref();
                };
                if (watch2) {
                  requestCallbacks["watch-rebuild"] = (id, request2) => {
                    try {
                      let watchResponse = request2.args;
                      let result2 = {
                        errors: replaceDetailsInMessages(watchResponse.errors, details),
                        warnings: replaceDetailsInMessages(watchResponse.warnings, details)
                      };
                      copyResponseToResult(watchResponse, result2);
                      runOnEndCallbacks(result2, logPluginError, () => {
                        if (result2.errors.length > 0) {
                          if (watch2.onRebuild)
                            watch2.onRebuild(failureErrorWithLog("Build failed", result2.errors, result2.warnings), null);
                          return;
                        }
                        result2.stop = stop;
                        if (watch2.onRebuild)
                          watch2.onRebuild(null, result2);
                      });
                    } catch (err2) {
                      console.error(err2);
                    }
                    sendResponse(id, {});
                  };
                }
              }
              result.stop = stop;
            }
            callback2(null, result);
          });
        };
        if (write && streamIn.isWriteUnavailable)
          throw new Error(`The "write" option is unavailable in this environment`);
        if (incremental && streamIn.isSync)
          throw new Error(`Cannot use "incremental" with a synchronous build`);
        if (watch2 && streamIn.isSync)
          throw new Error(`Cannot use "watch" with a synchronous build`);
        sendRequest(refs, request, (error3, response) => {
          if (error3)
            return callback(new Error(error3), null);
          if (serve2) {
            let serveResponse = response;
            let isStopped = false;
            refs.ref();
            let result = {
              port: serveResponse.port,
              host: serveResponse.host,
              wait: serve2.wait,
              stop() {
                if (isStopped)
                  return;
                isStopped = true;
                serve2.stop();
                refs.unref();
              }
            };
            refs.ref();
            serve2.wait.then(refs.unref, refs.unref);
            return callback(null, result);
          }
          return buildResponseToResult(response, callback);
        });
      }
    }
    var buildServeData = (buildKey, sendRequest, sendResponse, refs, requestCallbacks, options3, request) => {
      let keys = {};
      let port = getFlag(options3, keys, "port", mustBeInteger);
      let host = getFlag(options3, keys, "host", mustBeString);
      let servedir = getFlag(options3, keys, "servedir", mustBeString);
      let onRequest = getFlag(options3, keys, "onRequest", mustBeFunction);
      let wait = new Promise((resolve4, reject) => {
        requestCallbacks["serve-wait"] = (id, request2) => {
          if (request2.error !== null)
            reject(new Error(request2.error));
          else
            resolve4();
          sendResponse(id, {});
        };
      });
      request.serve = {};
      checkForInvalidFlags(options3, keys, `in serve() call`);
      if (port !== void 0)
        request.serve.port = port;
      if (host !== void 0)
        request.serve.host = host;
      if (servedir !== void 0)
        request.serve.servedir = servedir;
      requestCallbacks["serve-request"] = (id, request2) => {
        if (onRequest)
          onRequest(request2.args);
        sendResponse(id, {});
      };
      return {
        wait,
        stop() {
          sendRequest(refs, { command: "serve-stop", key: buildKey }, () => {
          });
        }
      };
    };
    var handlePlugins = async (buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, initialOptions, plugins2, details) => {
      let onStartCallbacks = [];
      let onEndCallbacks = [];
      let onResolveCallbacks = {};
      let onLoadCallbacks = {};
      let nextCallbackID = 0;
      let i2 = 0;
      let requestPlugins = [];
      let isSetupDone = false;
      plugins2 = [...plugins2];
      for (let item of plugins2) {
        let keys = {};
        if (typeof item !== "object")
          throw new Error(`Plugin at index ${i2} must be an object`);
        const name2 = getFlag(item, keys, "name", mustBeString);
        if (typeof name2 !== "string" || name2 === "")
          throw new Error(`Plugin at index ${i2} is missing a name`);
        try {
          let setup = getFlag(item, keys, "setup", mustBeFunction);
          if (typeof setup !== "function")
            throw new Error(`Plugin is missing a setup function`);
          checkForInvalidFlags(item, keys, `on plugin ${quote(name2)}`);
          let plugin = {
            name: name2,
            onStart: false,
            onEnd: false,
            onResolve: [],
            onLoad: []
          };
          i2++;
          let resolve4 = (path32, options3 = {}) => {
            if (!isSetupDone)
              throw new Error('Cannot call "resolve" before plugin setup has completed');
            if (typeof path32 !== "string")
              throw new Error(`The path to resolve must be a string`);
            let keys2 = /* @__PURE__ */ Object.create(null);
            let pluginName = getFlag(options3, keys2, "pluginName", mustBeString);
            let importer = getFlag(options3, keys2, "importer", mustBeString);
            let namespace = getFlag(options3, keys2, "namespace", mustBeString);
            let resolveDir = getFlag(options3, keys2, "resolveDir", mustBeString);
            let kind = getFlag(options3, keys2, "kind", mustBeString);
            let pluginData = getFlag(options3, keys2, "pluginData", canBeAnything);
            checkForInvalidFlags(options3, keys2, "in resolve() call");
            return new Promise((resolve22, reject) => {
              const request = {
                command: "resolve",
                path: path32,
                key: buildKey,
                pluginName: name2
              };
              if (pluginName != null)
                request.pluginName = pluginName;
              if (importer != null)
                request.importer = importer;
              if (namespace != null)
                request.namespace = namespace;
              if (resolveDir != null)
                request.resolveDir = resolveDir;
              if (kind != null)
                request.kind = kind;
              else
                throw new Error(`Must specify "kind" when calling "resolve"`);
              if (pluginData != null)
                request.pluginData = details.store(pluginData);
              sendRequest(refs, request, (error3, response) => {
                if (error3 !== null)
                  reject(new Error(error3));
                else
                  resolve22({
                    errors: replaceDetailsInMessages(response.errors, details),
                    warnings: replaceDetailsInMessages(response.warnings, details),
                    path: response.path,
                    external: response.external,
                    sideEffects: response.sideEffects,
                    namespace: response.namespace,
                    suffix: response.suffix,
                    pluginData: details.load(response.pluginData)
                  });
              });
            });
          };
          let promise2 = setup({
            initialOptions,
            resolve: resolve4,
            onStart(callback) {
              let registeredText = `This error came from the "onStart" callback registered here:`;
              let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onStart");
              onStartCallbacks.push({ name: name2, callback, note: registeredNote });
              plugin.onStart = true;
            },
            onEnd(callback) {
              let registeredText = `This error came from the "onEnd" callback registered here:`;
              let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onEnd");
              onEndCallbacks.push({ name: name2, callback, note: registeredNote });
              plugin.onEnd = true;
            },
            onResolve(options3, callback) {
              let registeredText = `This error came from the "onResolve" callback registered here:`;
              let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onResolve");
              let keys2 = {};
              let filter2 = getFlag(options3, keys2, "filter", mustBeRegExp);
              let namespace = getFlag(options3, keys2, "namespace", mustBeString);
              checkForInvalidFlags(options3, keys2, `in onResolve() call for plugin ${quote(name2)}`);
              if (filter2 == null)
                throw new Error(`onResolve() call is missing a filter`);
              let id = nextCallbackID++;
              onResolveCallbacks[id] = { name: name2, callback, note: registeredNote };
              plugin.onResolve.push({ id, filter: filter2.source, namespace: namespace || "" });
            },
            onLoad(options3, callback) {
              let registeredText = `This error came from the "onLoad" callback registered here:`;
              let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onLoad");
              let keys2 = {};
              let filter2 = getFlag(options3, keys2, "filter", mustBeRegExp);
              let namespace = getFlag(options3, keys2, "namespace", mustBeString);
              checkForInvalidFlags(options3, keys2, `in onLoad() call for plugin ${quote(name2)}`);
              if (filter2 == null)
                throw new Error(`onLoad() call is missing a filter`);
              let id = nextCallbackID++;
              onLoadCallbacks[id] = { name: name2, callback, note: registeredNote };
              plugin.onLoad.push({ id, filter: filter2.source, namespace: namespace || "" });
            },
            esbuild: streamIn.esbuild
          });
          if (promise2)
            await promise2;
          requestPlugins.push(plugin);
        } catch (e3) {
          return { ok: false, error: e3, pluginName: name2 };
        }
      }
      requestCallbacks["on-start"] = async (id, request) => {
        let response = { errors: [], warnings: [] };
        await Promise.all(onStartCallbacks.map(async ({ name: name2, callback, note }) => {
          try {
            let result = await callback();
            if (result != null) {
              if (typeof result !== "object")
                throw new Error(`Expected onStart() callback in plugin ${quote(name2)} to return an object`);
              let keys = {};
              let errors = getFlag(result, keys, "errors", mustBeArray);
              let warnings = getFlag(result, keys, "warnings", mustBeArray);
              checkForInvalidFlags(result, keys, `from onStart() callback in plugin ${quote(name2)}`);
              if (errors != null)
                response.errors.push(...sanitizeMessages(errors, "errors", details, name2));
              if (warnings != null)
                response.warnings.push(...sanitizeMessages(warnings, "warnings", details, name2));
            }
          } catch (e3) {
            response.errors.push(extractErrorMessageV8(e3, streamIn, details, note && note(), name2));
          }
        }));
        sendResponse(id, response);
      };
      requestCallbacks["on-resolve"] = async (id, request) => {
        let response = {}, name2 = "", callback, note;
        for (let id2 of request.ids) {
          try {
            ({ name: name2, callback, note } = onResolveCallbacks[id2]);
            let result = await callback({
              path: request.path,
              importer: request.importer,
              namespace: request.namespace,
              resolveDir: request.resolveDir,
              kind: request.kind,
              pluginData: details.load(request.pluginData)
            });
            if (result != null) {
              if (typeof result !== "object")
                throw new Error(`Expected onResolve() callback in plugin ${quote(name2)} to return an object`);
              let keys = {};
              let pluginName = getFlag(result, keys, "pluginName", mustBeString);
              let path32 = getFlag(result, keys, "path", mustBeString);
              let namespace = getFlag(result, keys, "namespace", mustBeString);
              let suffix = getFlag(result, keys, "suffix", mustBeString);
              let external = getFlag(result, keys, "external", mustBeBoolean);
              let sideEffects = getFlag(result, keys, "sideEffects", mustBeBoolean);
              let pluginData = getFlag(result, keys, "pluginData", canBeAnything);
              let errors = getFlag(result, keys, "errors", mustBeArray);
              let warnings = getFlag(result, keys, "warnings", mustBeArray);
              let watchFiles = getFlag(result, keys, "watchFiles", mustBeArray);
              let watchDirs = getFlag(result, keys, "watchDirs", mustBeArray);
              checkForInvalidFlags(result, keys, `from onResolve() callback in plugin ${quote(name2)}`);
              response.id = id2;
              if (pluginName != null)
                response.pluginName = pluginName;
              if (path32 != null)
                response.path = path32;
              if (namespace != null)
                response.namespace = namespace;
              if (suffix != null)
                response.suffix = suffix;
              if (external != null)
                response.external = external;
              if (sideEffects != null)
                response.sideEffects = sideEffects;
              if (pluginData != null)
                response.pluginData = details.store(pluginData);
              if (errors != null)
                response.errors = sanitizeMessages(errors, "errors", details, name2);
              if (warnings != null)
                response.warnings = sanitizeMessages(warnings, "warnings", details, name2);
              if (watchFiles != null)
                response.watchFiles = sanitizeStringArray(watchFiles, "watchFiles");
              if (watchDirs != null)
                response.watchDirs = sanitizeStringArray(watchDirs, "watchDirs");
              break;
            }
          } catch (e3) {
            response = { id: id2, errors: [extractErrorMessageV8(e3, streamIn, details, note && note(), name2)] };
            break;
          }
        }
        sendResponse(id, response);
      };
      requestCallbacks["on-load"] = async (id, request) => {
        let response = {}, name2 = "", callback, note;
        for (let id2 of request.ids) {
          try {
            ({ name: name2, callback, note } = onLoadCallbacks[id2]);
            let result = await callback({
              path: request.path,
              namespace: request.namespace,
              suffix: request.suffix,
              pluginData: details.load(request.pluginData)
            });
            if (result != null) {
              if (typeof result !== "object")
                throw new Error(`Expected onLoad() callback in plugin ${quote(name2)} to return an object`);
              let keys = {};
              let pluginName = getFlag(result, keys, "pluginName", mustBeString);
              let contents = getFlag(result, keys, "contents", mustBeStringOrUint8Array);
              let resolveDir = getFlag(result, keys, "resolveDir", mustBeString);
              let pluginData = getFlag(result, keys, "pluginData", canBeAnything);
              let loader = getFlag(result, keys, "loader", mustBeString);
              let errors = getFlag(result, keys, "errors", mustBeArray);
              let warnings = getFlag(result, keys, "warnings", mustBeArray);
              let watchFiles = getFlag(result, keys, "watchFiles", mustBeArray);
              let watchDirs = getFlag(result, keys, "watchDirs", mustBeArray);
              checkForInvalidFlags(result, keys, `from onLoad() callback in plugin ${quote(name2)}`);
              response.id = id2;
              if (pluginName != null)
                response.pluginName = pluginName;
              if (contents instanceof Uint8Array)
                response.contents = contents;
              else if (contents != null)
                response.contents = encodeUTF8(contents);
              if (resolveDir != null)
                response.resolveDir = resolveDir;
              if (pluginData != null)
                response.pluginData = details.store(pluginData);
              if (loader != null)
                response.loader = loader;
              if (errors != null)
                response.errors = sanitizeMessages(errors, "errors", details, name2);
              if (warnings != null)
                response.warnings = sanitizeMessages(warnings, "warnings", details, name2);
              if (watchFiles != null)
                response.watchFiles = sanitizeStringArray(watchFiles, "watchFiles");
              if (watchDirs != null)
                response.watchDirs = sanitizeStringArray(watchDirs, "watchDirs");
              break;
            }
          } catch (e3) {
            response = { id: id2, errors: [extractErrorMessageV8(e3, streamIn, details, note && note(), name2)] };
            break;
          }
        }
        sendResponse(id, response);
      };
      let runOnEndCallbacks = (result, logPluginError, done) => done();
      if (onEndCallbacks.length > 0) {
        runOnEndCallbacks = (result, logPluginError, done) => {
          (async () => {
            for (const { name: name2, callback, note } of onEndCallbacks) {
              try {
                await callback(result);
              } catch (e3) {
                result.errors.push(await new Promise((resolve4) => logPluginError(e3, name2, note && note(), resolve4)));
              }
            }
          })().then(done);
        };
      }
      isSetupDone = true;
      return {
        ok: true,
        requestPlugins,
        runOnEndCallbacks
      };
    };
    function createObjectStash() {
      const map3 = /* @__PURE__ */ new Map();
      let nextID = 0;
      return {
        load(id) {
          return map3.get(id);
        },
        store(value2) {
          if (value2 === void 0)
            return -1;
          const id = nextID++;
          map3.set(id, value2);
          return id;
        }
      };
    }
    function extractCallerV8(e3, streamIn, ident) {
      let note;
      let tried = false;
      return () => {
        if (tried)
          return note;
        tried = true;
        try {
          let lines = (e3.stack + "").split("\n");
          lines.splice(1, 1);
          let location2 = parseStackLinesV8(streamIn, lines, ident);
          if (location2) {
            note = { text: e3.message, location: location2 };
            return note;
          }
        } catch {
        }
      };
    }
    function extractErrorMessageV8(e3, streamIn, stash, note, pluginName) {
      let text = "Internal error";
      let location2 = null;
      try {
        text = (e3 && e3.message || e3) + "";
      } catch {
      }
      try {
        location2 = parseStackLinesV8(streamIn, (e3.stack + "").split("\n"), "");
      } catch {
      }
      return { id: "", pluginName, text, location: location2, notes: note ? [note] : [], detail: stash ? stash.store(e3) : -1 };
    }
    function parseStackLinesV8(streamIn, lines, ident) {
      let at2 = "    at ";
      if (streamIn.readFileSync && !lines[0].startsWith(at2) && lines[1].startsWith(at2)) {
        for (let i2 = 1; i2 < lines.length; i2++) {
          let line = lines[i2];
          if (!line.startsWith(at2))
            continue;
          line = line.slice(at2.length);
          while (true) {
            let match = /^(?:new |async )?\S+ \((.*)\)$/.exec(line);
            if (match) {
              line = match[1];
              continue;
            }
            match = /^eval at \S+ \((.*)\)(?:, \S+:\d+:\d+)?$/.exec(line);
            if (match) {
              line = match[1];
              continue;
            }
            match = /^(\S+):(\d+):(\d+)$/.exec(line);
            if (match) {
              let contents;
              try {
                contents = streamIn.readFileSync(match[1], "utf8");
              } catch {
                break;
              }
              let lineText = contents.split(/\r\n|\r|\n|\u2028|\u2029/)[+match[2] - 1] || "";
              let column = +match[3] - 1;
              let length = lineText.slice(column, column + ident.length) === ident ? ident.length : 0;
              return {
                file: match[1],
                namespace: "file",
                line: +match[2],
                column: encodeUTF8(lineText.slice(0, column)).length,
                length: encodeUTF8(lineText.slice(column, column + length)).length,
                lineText: lineText + "\n" + lines.slice(1).join("\n"),
                suggestion: ""
              };
            }
            break;
          }
        }
      }
      return null;
    }
    function failureErrorWithLog(text, errors, warnings) {
      let limit = 5;
      let summary = errors.length < 1 ? "" : ` with ${errors.length} error${errors.length < 2 ? "" : "s"}:` + errors.slice(0, limit + 1).map((e3, i2) => {
        if (i2 === limit)
          return "\n...";
        if (!e3.location)
          return `
error: ${e3.text}`;
        let { file, line, column } = e3.location;
        let pluginText = e3.pluginName ? `[plugin: ${e3.pluginName}] ` : "";
        return `
${file}:${line}:${column}: ERROR: ${pluginText}${e3.text}`;
      }).join("");
      let error3 = new Error(`${text}${summary}`);
      error3.errors = errors;
      error3.warnings = warnings;
      return error3;
    }
    function replaceDetailsInMessages(messages2, stash) {
      for (const message of messages2) {
        message.detail = stash.load(message.detail);
      }
      return messages2;
    }
    function sanitizeLocation(location2, where) {
      if (location2 == null)
        return null;
      let keys = {};
      let file = getFlag(location2, keys, "file", mustBeString);
      let namespace = getFlag(location2, keys, "namespace", mustBeString);
      let line = getFlag(location2, keys, "line", mustBeInteger);
      let column = getFlag(location2, keys, "column", mustBeInteger);
      let length = getFlag(location2, keys, "length", mustBeInteger);
      let lineText = getFlag(location2, keys, "lineText", mustBeString);
      let suggestion = getFlag(location2, keys, "suggestion", mustBeString);
      checkForInvalidFlags(location2, keys, where);
      return {
        file: file || "",
        namespace: namespace || "",
        line: line || 0,
        column: column || 0,
        length: length || 0,
        lineText: lineText || "",
        suggestion: suggestion || ""
      };
    }
    function sanitizeMessages(messages2, property, stash, fallbackPluginName) {
      let messagesClone = [];
      let index2 = 0;
      for (const message of messages2) {
        let keys = {};
        let id = getFlag(message, keys, "id", mustBeString);
        let pluginName = getFlag(message, keys, "pluginName", mustBeString);
        let text = getFlag(message, keys, "text", mustBeString);
        let location2 = getFlag(message, keys, "location", mustBeObjectOrNull);
        let notes = getFlag(message, keys, "notes", mustBeArray);
        let detail = getFlag(message, keys, "detail", canBeAnything);
        let where = `in element ${index2} of "${property}"`;
        checkForInvalidFlags(message, keys, where);
        let notesClone = [];
        if (notes) {
          for (const note of notes) {
            let noteKeys = {};
            let noteText = getFlag(note, noteKeys, "text", mustBeString);
            let noteLocation = getFlag(note, noteKeys, "location", mustBeObjectOrNull);
            checkForInvalidFlags(note, noteKeys, where);
            notesClone.push({
              text: noteText || "",
              location: sanitizeLocation(noteLocation, where)
            });
          }
        }
        messagesClone.push({
          id: id || "",
          pluginName: pluginName || fallbackPluginName,
          text: text || "",
          location: sanitizeLocation(location2, where),
          notes: notesClone,
          detail: stash ? stash.store(detail) : -1
        });
        index2++;
      }
      return messagesClone;
    }
    function sanitizeStringArray(values, property) {
      const result = [];
      for (const value2 of values) {
        if (typeof value2 !== "string")
          throw new Error(`${quote(property)} must be an array of strings`);
        result.push(value2);
      }
      return result;
    }
    function convertOutputFiles({ path: path32, contents }) {
      let text = null;
      return {
        path: path32,
        contents,
        get text() {
          const binary3 = this.contents;
          if (text === null || binary3 !== contents) {
            contents = binary3;
            text = decodeUTF8(binary3);
          }
          return text;
        }
      };
    }
    var fs6 = require_fs();
    var os2 = require_os();
    var path8 = require_path();
    var ESBUILD_BINARY_PATH = process.env.ESBUILD_BINARY_PATH || ESBUILD_BINARY_PATH;
    var packageDarwin_arm64 = "@esbuild/darwin-arm64";
    var packageDarwin_x64 = "@esbuild/darwin-x64";
    var knownWindowsPackages = {
      "win32 arm64 LE": "@esbuild/win32-arm64",
      "win32 ia32 LE": "@esbuild/win32-ia32",
      "win32 x64 LE": "@esbuild/win32-x64"
    };
    var knownUnixlikePackages = {
      "android arm64 LE": "@esbuild/android-arm64",
      "darwin arm64 LE": "@esbuild/darwin-arm64",
      "darwin x64 LE": "@esbuild/darwin-x64",
      "freebsd arm64 LE": "@esbuild/freebsd-arm64",
      "freebsd x64 LE": "@esbuild/freebsd-x64",
      "linux arm LE": "@esbuild/linux-arm",
      "linux arm64 LE": "@esbuild/linux-arm64",
      "linux ia32 LE": "@esbuild/linux-ia32",
      "linux mips64el LE": "@esbuild/linux-mips64el",
      "linux ppc64 LE": "@esbuild/linux-ppc64",
      "linux riscv64 LE": "@esbuild/linux-riscv64",
      "linux s390x BE": "@esbuild/linux-s390x",
      "linux x64 LE": "@esbuild/linux-x64",
      "linux loong64 LE": "@esbuild/linux-loong64",
      "netbsd x64 LE": "@esbuild/netbsd-x64",
      "openbsd x64 LE": "@esbuild/openbsd-x64",
      "sunos x64 LE": "@esbuild/sunos-x64"
    };
    var knownWebAssemblyFallbackPackages = {
      "android arm LE": "@esbuild/android-arm",
      "android x64 LE": "@esbuild/android-x64"
    };
    function pkgAndSubpathForCurrentPlatform() {
      let pkg;
      let subpath;
      let isWASM = false;
      let platformKey = `${process.platform} ${os2.arch()} ${os2.endianness()}`;
      if (platformKey in knownWindowsPackages) {
        pkg = knownWindowsPackages[platformKey];
        subpath = "esbuild.exe";
      } else if (platformKey in knownUnixlikePackages) {
        pkg = knownUnixlikePackages[platformKey];
        subpath = "bin/esbuild";
      } else if (platformKey in knownWebAssemblyFallbackPackages) {
        pkg = knownWebAssemblyFallbackPackages[platformKey];
        subpath = "bin/esbuild";
        isWASM = true;
      } else {
        throw new Error(`Unsupported platform: ${platformKey}`);
      }
      return { pkg, subpath, isWASM };
    }
    function pkgForSomeOtherPlatform() {
      const libMainJS = __require.resolve("esbuild");
      const nodeModulesDirectory = path8.dirname(path8.dirname(path8.dirname(libMainJS)));
      if (path8.basename(nodeModulesDirectory) === "node_modules") {
        for (const unixKey in knownUnixlikePackages) {
          try {
            const pkg = knownUnixlikePackages[unixKey];
            if (fs6.existsSync(path8.join(nodeModulesDirectory, pkg)))
              return pkg;
          } catch {
          }
        }
        for (const windowsKey in knownWindowsPackages) {
          try {
            const pkg = knownWindowsPackages[windowsKey];
            if (fs6.existsSync(path8.join(nodeModulesDirectory, pkg)))
              return pkg;
          } catch {
          }
        }
      }
      return null;
    }
    function downloadedBinPath(pkg, subpath) {
      const esbuildLibDir = path8.dirname(__require.resolve("esbuild"));
      return path8.join(esbuildLibDir, `downloaded-${pkg.replace("/", "-")}-${path8.basename(subpath)}`);
    }
    function generateBinPath() {
      if (ESBUILD_BINARY_PATH) {
        if (!fs6.existsSync(ESBUILD_BINARY_PATH)) {
          console.warn(`[esbuild] Ignoring bad configuration: ESBUILD_BINARY_PATH=${ESBUILD_BINARY_PATH}`);
        } else {
          return { binPath: ESBUILD_BINARY_PATH, isWASM: false };
        }
      }
      const { pkg, subpath, isWASM } = pkgAndSubpathForCurrentPlatform();
      let binPath;
      try {
        binPath = __require.resolve(`${pkg}/${subpath}`);
      } catch (e3) {
        binPath = downloadedBinPath(pkg, subpath);
        if (!fs6.existsSync(binPath)) {
          try {
            __require.resolve(pkg);
          } catch {
            const otherPkg = pkgForSomeOtherPlatform();
            if (otherPkg) {
              let suggestions = `
Specifically the "${otherPkg}" package is present but this platform
needs the "${pkg}" package instead. People often get into this
situation by installing esbuild on Windows or macOS and copying "node_modules"
into a Docker image that runs Linux, or by copying "node_modules" between
Windows and WSL environments.

If you are installing with npm, you can try not copying the "node_modules"
directory when you copy the files over, and running "npm ci" or "npm install"
on the destination platform after the copy. Or you could consider using yarn
instead of npm which has built-in support for installing a package on multiple
platforms simultaneously.

If you are installing with yarn, you can try listing both this platform and the
other platform in your ".yarnrc.yml" file using the "supportedArchitectures"
feature: https://yarnpkg.com/configuration/yarnrc/#supportedArchitectures
Keep in mind that this means multiple copies of esbuild will be present.
`;
              if (pkg === packageDarwin_x64 && otherPkg === packageDarwin_arm64 || pkg === packageDarwin_arm64 && otherPkg === packageDarwin_x64) {
                suggestions = `
Specifically the "${otherPkg}" package is present but this platform
needs the "${pkg}" package instead. People often get into this
situation by installing esbuild with npm running inside of Rosetta 2 and then
trying to use it with node running outside of Rosetta 2, or vice versa (Rosetta
2 is Apple's on-the-fly x86_64-to-arm64 translation service).

If you are installing with npm, you can try ensuring that both npm and node are
not running under Rosetta 2 and then reinstalling esbuild. This likely involves
changing how you installed npm and/or node. For example, installing node with
the universal installer here should work: https://nodejs.org/en/download/. Or
you could consider using yarn instead of npm which has built-in support for
installing a package on multiple platforms simultaneously.

If you are installing with yarn, you can try listing both "arm64" and "x64"
in your ".yarnrc.yml" file using the "supportedArchitectures" feature:
https://yarnpkg.com/configuration/yarnrc/#supportedArchitectures
Keep in mind that this means multiple copies of esbuild will be present.
`;
              }
              throw new Error(`
You installed esbuild for another platform than the one you're currently using.
This won't work because esbuild is written with native code and needs to
install a platform-specific binary executable.
${suggestions}
Another alternative is to use the "esbuild-wasm" package instead, which works
the same way on all platforms. But it comes with a heavy performance cost and
can sometimes be 10x slower than the "esbuild" package, so you may also not
want to do that.
`);
            }
            throw new Error(`The package "${pkg}" could not be found, and is needed by esbuild.

If you are installing esbuild with npm, make sure that you don't specify the
"--no-optional" or "--omit=optional" flags. The "optionalDependencies" feature
of "package.json" is used by esbuild to install the correct binary executable
for your current platform.`);
          }
          throw e3;
        }
      }
      if (/\.zip\//.test(binPath)) {
        let pnpapi;
        try {
          pnpapi = __require("pnpapi");
        } catch (e3) {
        }
        if (pnpapi) {
          const root = pnpapi.getPackageInformation(pnpapi.topLevel).packageLocation;
          const binTargetPath = path8.join(
            root,
            "node_modules",
            ".cache",
            "esbuild",
            `pnpapi-${pkg.replace("/", "-")}-${"0.16.17"}-${path8.basename(subpath)}`
          );
          if (!fs6.existsSync(binTargetPath)) {
            fs6.mkdirSync(path8.dirname(binTargetPath), { recursive: true });
            fs6.copyFileSync(binPath, binTargetPath);
            fs6.chmodSync(binTargetPath, 493);
          }
          return { binPath: binTargetPath, isWASM };
        }
      }
      return { binPath, isWASM };
    }
    var child_process = require_child_process();
    var crypto2 = require_crypto();
    var path23 = require_path();
    var fs22 = require_fs();
    var os22 = require_os();
    var tty2 = require_tty();
    var worker_threads;
    if (process.env.ESBUILD_WORKER_THREADS !== "0") {
      try {
        worker_threads = require_worker_threads();
      } catch {
      }
      let [major, minor] = process.versions.node.split(".");
      if (
        // <v12.17.0 does not work
        +major < 12 || +major === 12 && +minor < 17 || +major === 13 && +minor < 13
      ) {
        worker_threads = void 0;
      }
    }
    var _a;
    var isInternalWorkerThread = ((_a = worker_threads == null ? void 0 : worker_threads.workerData) == null ? void 0 : _a.esbuildVersion) === "0.16.17";
    var esbuildCommandAndArgs = () => {
      if ((!ESBUILD_BINARY_PATH || false) && (path23.basename(__filename) !== "main.js" || path23.basename(__dirname) !== "lib")) {
        throw new Error(
          `The esbuild JavaScript API cannot be bundled. Please mark the "esbuild" package as external so it's not included in the bundle.

More information: The file containing the code for esbuild's JavaScript API (${__filename}) does not appear to be inside the esbuild package on the file system, which usually means that the esbuild package was bundled into another file. This is problematic because the API needs to run a binary executable inside the esbuild package which is located using a relative path from the API code to the executable. If the esbuild package is bundled, the relative path will be incorrect and the executable won't be found.`
        );
      }
      if (false) {
        return ["node", [path23.join(__dirname, "..", "bin", "esbuild")]];
      } else {
        const { binPath, isWASM } = generateBinPath();
        if (isWASM) {
          return ["node", [binPath]];
        } else {
          return [binPath, []];
        }
      }
    };
    var isTTY = () => tty2.isatty(2);
    var fsSync = {
      readFile(tempFile, callback) {
        try {
          let contents = fs22.readFileSync(tempFile, "utf8");
          try {
            fs22.unlinkSync(tempFile);
          } catch {
          }
          callback(null, contents);
        } catch (err2) {
          callback(err2, null);
        }
      },
      writeFile(contents, callback) {
        try {
          let tempFile = randomFileName();
          fs22.writeFileSync(tempFile, contents);
          callback(tempFile);
        } catch {
          callback(null);
        }
      }
    };
    var fsAsync = {
      readFile(tempFile, callback) {
        try {
          fs22.readFile(tempFile, "utf8", (err2, contents) => {
            try {
              fs22.unlink(tempFile, () => callback(err2, contents));
            } catch {
              callback(err2, contents);
            }
          });
        } catch (err2) {
          callback(err2, null);
        }
      },
      writeFile(contents, callback) {
        try {
          let tempFile = randomFileName();
          fs22.writeFile(tempFile, contents, (err2) => err2 !== null ? callback(null) : callback(tempFile));
        } catch {
          callback(null);
        }
      }
    };
    var version4 = "0.16.17";
    var build4 = (options3) => ensureServiceIsRunning().build(options3);
    var serve = (serveOptions, buildOptions) => ensureServiceIsRunning().serve(serveOptions, buildOptions);
    var transform2 = (input, options3) => ensureServiceIsRunning().transform(input, options3);
    var formatMessages2 = (messages2, options3) => ensureServiceIsRunning().formatMessages(messages2, options3);
    var analyzeMetafile = (messages2, options3) => ensureServiceIsRunning().analyzeMetafile(messages2, options3);
    var buildSync = (options3) => {
      if (worker_threads && !isInternalWorkerThread) {
        if (!workerThreadService)
          workerThreadService = startWorkerThreadService(worker_threads);
        return workerThreadService.buildSync(options3);
      }
      let result;
      runServiceSync((service) => service.buildOrServe({
        callName: "buildSync",
        refs: null,
        serveOptions: null,
        options: options3,
        isTTY: isTTY(),
        defaultWD,
        callback: (err2, res) => {
          if (err2)
            throw err2;
          result = res;
        }
      }));
      return result;
    };
    var transformSync = (input, options3) => {
      if (worker_threads && !isInternalWorkerThread) {
        if (!workerThreadService)
          workerThreadService = startWorkerThreadService(worker_threads);
        return workerThreadService.transformSync(input, options3);
      }
      let result;
      runServiceSync((service) => service.transform({
        callName: "transformSync",
        refs: null,
        input,
        options: options3 || {},
        isTTY: isTTY(),
        fs: fsSync,
        callback: (err2, res) => {
          if (err2)
            throw err2;
          result = res;
        }
      }));
      return result;
    };
    var formatMessagesSync = (messages2, options3) => {
      if (worker_threads && !isInternalWorkerThread) {
        if (!workerThreadService)
          workerThreadService = startWorkerThreadService(worker_threads);
        return workerThreadService.formatMessagesSync(messages2, options3);
      }
      let result;
      runServiceSync((service) => service.formatMessages({
        callName: "formatMessagesSync",
        refs: null,
        messages: messages2,
        options: options3,
        callback: (err2, res) => {
          if (err2)
            throw err2;
          result = res;
        }
      }));
      return result;
    };
    var analyzeMetafileSync = (metafile, options3) => {
      if (worker_threads && !isInternalWorkerThread) {
        if (!workerThreadService)
          workerThreadService = startWorkerThreadService(worker_threads);
        return workerThreadService.analyzeMetafileSync(metafile, options3);
      }
      let result;
      runServiceSync((service) => service.analyzeMetafile({
        callName: "analyzeMetafileSync",
        refs: null,
        metafile: typeof metafile === "string" ? metafile : JSON.stringify(metafile),
        options: options3,
        callback: (err2, res) => {
          if (err2)
            throw err2;
          result = res;
        }
      }));
      return result;
    };
    var initializeWasCalled = false;
    var initialize = (options3) => {
      options3 = validateInitializeOptions(options3 || {});
      if (options3.wasmURL)
        throw new Error(`The "wasmURL" option only works in the browser`);
      if (options3.wasmModule)
        throw new Error(`The "wasmModule" option only works in the browser`);
      if (options3.worker)
        throw new Error(`The "worker" option only works in the browser`);
      if (initializeWasCalled)
        throw new Error('Cannot call "initialize" more than once');
      ensureServiceIsRunning();
      initializeWasCalled = true;
      return Promise.resolve();
    };
    var defaultWD = process.cwd();
    var longLivedService;
    var ensureServiceIsRunning = () => {
      if (longLivedService)
        return longLivedService;
      let [command, args] = esbuildCommandAndArgs();
      let child = child_process.spawn(command, args.concat(`--service=${"0.16.17"}`, "--ping"), {
        windowsHide: true,
        stdio: ["pipe", "pipe", "inherit"],
        cwd: defaultWD
      });
      let { readFromStdout, afterClose, service } = createChannel({
        writeToStdin(bytes) {
          child.stdin.write(bytes, (err2) => {
            if (err2)
              afterClose(err2);
          });
        },
        readFileSync: fs22.readFileSync,
        isSync: false,
        isWriteUnavailable: false,
        esbuild: node_exports
      });
      child.stdin.on("error", afterClose);
      child.on("error", afterClose);
      const stdin = child.stdin;
      const stdout = child.stdout;
      stdout.on("data", readFromStdout);
      stdout.on("end", afterClose);
      let refCount = 0;
      child.unref();
      if (stdin.unref) {
        stdin.unref();
      }
      if (stdout.unref) {
        stdout.unref();
      }
      const refs = {
        ref() {
          if (++refCount === 1)
            child.ref();
        },
        unref() {
          if (--refCount === 0)
            child.unref();
        }
      };
      longLivedService = {
        build: (options3) => {
          return new Promise((resolve4, reject) => {
            service.buildOrServe({
              callName: "build",
              refs,
              serveOptions: null,
              options: options3,
              isTTY: isTTY(),
              defaultWD,
              callback: (err2, res) => err2 ? reject(err2) : resolve4(res)
            });
          });
        },
        serve: (serveOptions, buildOptions) => {
          if (serveOptions === null || typeof serveOptions !== "object")
            throw new Error("The first argument must be an object");
          return new Promise((resolve4, reject) => service.buildOrServe({
            callName: "serve",
            refs,
            serveOptions,
            options: buildOptions,
            isTTY: isTTY(),
            defaultWD,
            callback: (err2, res) => err2 ? reject(err2) : resolve4(res)
          }));
        },
        transform: (input, options3) => {
          return new Promise((resolve4, reject) => service.transform({
            callName: "transform",
            refs,
            input,
            options: options3 || {},
            isTTY: isTTY(),
            fs: fsAsync,
            callback: (err2, res) => err2 ? reject(err2) : resolve4(res)
          }));
        },
        formatMessages: (messages2, options3) => {
          return new Promise((resolve4, reject) => service.formatMessages({
            callName: "formatMessages",
            refs,
            messages: messages2,
            options: options3,
            callback: (err2, res) => err2 ? reject(err2) : resolve4(res)
          }));
        },
        analyzeMetafile: (metafile, options3) => {
          return new Promise((resolve4, reject) => service.analyzeMetafile({
            callName: "analyzeMetafile",
            refs,
            metafile: typeof metafile === "string" ? metafile : JSON.stringify(metafile),
            options: options3,
            callback: (err2, res) => err2 ? reject(err2) : resolve4(res)
          }));
        }
      };
      return longLivedService;
    };
    var runServiceSync = (callback) => {
      let [command, args] = esbuildCommandAndArgs();
      let stdin = new Uint8Array();
      let { readFromStdout, afterClose, service } = createChannel({
        writeToStdin(bytes) {
          if (stdin.length !== 0)
            throw new Error("Must run at most one command");
          stdin = bytes;
        },
        isSync: true,
        isWriteUnavailable: false,
        esbuild: node_exports
      });
      callback(service);
      let stdout = child_process.execFileSync(command, args.concat(`--service=${"0.16.17"}`), {
        cwd: defaultWD,
        windowsHide: true,
        input: stdin,
        // We don't know how large the output could be. If it's too large, the
        // command will fail with ENOBUFS. Reserve 16mb for now since that feels
        // like it should be enough. Also allow overriding this with an environment
        // variable.
        maxBuffer: +process.env.ESBUILD_MAX_BUFFER || 16 * 1024 * 1024
      });
      readFromStdout(stdout);
      afterClose(null);
    };
    var randomFileName = () => {
      return path23.join(os22.tmpdir(), `esbuild-${crypto2.randomBytes(32).toString("hex")}`);
    };
    var workerThreadService = null;
    var startWorkerThreadService = (worker_threads2) => {
      let { port1: mainPort, port2: workerPort } = new worker_threads2.MessageChannel();
      let worker = new worker_threads2.Worker(__filename, {
        workerData: { workerPort, defaultWD, esbuildVersion: "0.16.17" },
        transferList: [workerPort],
        // From node's documentation: https://nodejs.org/api/worker_threads.html
        //
        //   Take care when launching worker threads from preload scripts (scripts loaded
        //   and run using the `-r` command line flag). Unless the `execArgv` option is
        //   explicitly set, new Worker threads automatically inherit the command line flags
        //   from the running process and will preload the same preload scripts as the main
        //   thread. If the preload script unconditionally launches a worker thread, every
        //   thread spawned will spawn another until the application crashes.
        //
        execArgv: []
      });
      let nextID = 0;
      let fakeBuildError = (text) => {
        let error3 = new Error(`Build failed with 1 error:
error: ${text}`);
        let errors = [{ id: "", pluginName: "", text, location: null, notes: [], detail: void 0 }];
        error3.errors = errors;
        error3.warnings = [];
        return error3;
      };
      let validateBuildSyncOptions = (options3) => {
        if (!options3)
          return;
        let plugins2 = options3.plugins;
        let incremental = options3.incremental;
        let watch2 = options3.watch;
        if (plugins2 && plugins2.length > 0)
          throw fakeBuildError(`Cannot use plugins in synchronous API calls`);
        if (incremental)
          throw fakeBuildError(`Cannot use "incremental" with a synchronous build`);
        if (watch2)
          throw fakeBuildError(`Cannot use "watch" with a synchronous build`);
      };
      let applyProperties = (object, properties) => {
        for (let key in properties) {
          object[key] = properties[key];
        }
      };
      let runCallSync = (command, args) => {
        let id = nextID++;
        let sharedBuffer = new SharedArrayBuffer(8);
        let sharedBufferView = new Int32Array(sharedBuffer);
        let msg = { sharedBuffer, id, command, args };
        worker.postMessage(msg);
        let status2 = Atomics.wait(sharedBufferView, 0, 0);
        if (status2 !== "ok" && status2 !== "not-equal")
          throw new Error("Internal error: Atomics.wait() failed: " + status2);
        let { message: { id: id2, resolve: resolve4, reject, properties } } = worker_threads2.receiveMessageOnPort(mainPort);
        if (id !== id2)
          throw new Error(`Internal error: Expected id ${id} but got id ${id2}`);
        if (reject) {
          applyProperties(reject, properties);
          throw reject;
        }
        return resolve4;
      };
      worker.unref();
      return {
        buildSync(options3) {
          validateBuildSyncOptions(options3);
          return runCallSync("build", [options3]);
        },
        transformSync(input, options3) {
          return runCallSync("transform", [input, options3]);
        },
        formatMessagesSync(messages2, options3) {
          return runCallSync("formatMessages", [messages2, options3]);
        },
        analyzeMetafileSync(metafile, options3) {
          return runCallSync("analyzeMetafile", [metafile, options3]);
        }
      };
    };
    var startSyncServiceWorker = () => {
      let workerPort = worker_threads.workerData.workerPort;
      let parentPort = worker_threads.parentPort;
      let extractProperties = (object) => {
        let properties = {};
        if (object && typeof object === "object") {
          for (let key in object) {
            properties[key] = object[key];
          }
        }
        return properties;
      };
      try {
        let service = ensureServiceIsRunning();
        defaultWD = worker_threads.workerData.defaultWD;
        parentPort.on("message", (msg) => {
          (async () => {
            let { sharedBuffer, id, command, args } = msg;
            let sharedBufferView = new Int32Array(sharedBuffer);
            try {
              switch (command) {
                case "build":
                  workerPort.postMessage({ id, resolve: await service.build(args[0]) });
                  break;
                case "transform":
                  workerPort.postMessage({ id, resolve: await service.transform(args[0], args[1]) });
                  break;
                case "formatMessages":
                  workerPort.postMessage({ id, resolve: await service.formatMessages(args[0], args[1]) });
                  break;
                case "analyzeMetafile":
                  workerPort.postMessage({ id, resolve: await service.analyzeMetafile(args[0], args[1]) });
                  break;
                default:
                  throw new Error(`Invalid command: ${command}`);
              }
            } catch (reject) {
              workerPort.postMessage({ id, reject, properties: extractProperties(reject) });
            }
            Atomics.add(sharedBufferView, 0, 1);
            Atomics.notify(sharedBufferView, 0, Infinity);
          })();
        });
      } catch (reject) {
        parentPort.on("message", (msg) => {
          let { sharedBuffer, id } = msg;
          let sharedBufferView = new Int32Array(sharedBuffer);
          workerPort.postMessage({ id, reject, properties: extractProperties(reject) });
          Atomics.add(sharedBufferView, 0, 1);
          Atomics.notify(sharedBufferView, 0, Infinity);
        });
      }
    };
    if (isInternalWorkerThread) {
      startSyncServiceWorker();
    }
    var node_default = node_exports;
  }
});

// browser-external:net
var require_net = __commonJS({
  "browser-external:net"(exports3, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "net" has been externalized for browser compatibility. Cannot access "net.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:http
var require_http = __commonJS({
  "browser-external:http"(exports3, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "http" has been externalized for browser compatibility. Cannot access "http.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:node:util
var require_node_util = __commonJS({
  "browser-external:node:util"(exports3, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:util" has been externalized for browser compatibility. Cannot access "node:util.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:node:dns
var require_node_dns = __commonJS({
  "browser-external:node:dns"(exports3, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:dns" has been externalized for browser compatibility. Cannot access "node:dns.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:node:buffer
var require_node_buffer = __commonJS({
  "browser-external:node:buffer"(exports3, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:buffer" has been externalized for browser compatibility. Cannot access "node:buffer.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:module
var require_module = __commonJS({
  "browser-external:module"(exports3, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "module" has been externalized for browser compatibility. Cannot access "module.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:node:assert
var require_node_assert = __commonJS({
  "browser-external:node:assert"(exports3, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:assert" has been externalized for browser compatibility. Cannot access "node:assert.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:node:v8
var require_node_v8 = __commonJS({
  "browser-external:node:v8"(exports3, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:v8" has been externalized for browser compatibility. Cannot access "node:v8.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:zlib
var require_zlib = __commonJS({
  "browser-external:zlib"(exports3, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "zlib" has been externalized for browser compatibility. Cannot access "zlib.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:https
var require_https = __commonJS({
  "browser-external:https"(exports3, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "https" has been externalized for browser compatibility. Cannot access "https.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:tls
var require_tls = __commonJS({
  "browser-external:tls"(exports3, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "tls" has been externalized for browser compatibility. Cannot access "tls.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:querystring
var require_querystring = __commonJS({
  "browser-external:querystring"(exports3, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "querystring" has been externalized for browser compatibility. Cannot access "querystring.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:node:child_process
var require_node_child_process = __commonJS({
  "browser-external:node:child_process"(exports3, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:child_process" has been externalized for browser compatibility. Cannot access "node:child_process.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:node:zlib
var require_node_zlib = __commonJS({
  "browser-external:node:zlib"(exports3, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "node:zlib" has been externalized for browser compatibility. Cannot access "node:zlib.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/.pnpm/node-releases@2.0.10/node_modules/node-releases/data/processed/envs.json
var require_envs = __commonJS({
  "node_modules/.pnpm/node-releases@2.0.10/node_modules/node-releases/data/processed/envs.json"(exports3, module2) {
    module2.exports = [{ name: "nodejs", version: "0.2.0", date: "2011-08-26", lts: false, security: false }, { name: "nodejs", version: "0.3.0", date: "2011-08-26", lts: false, security: false }, { name: "nodejs", version: "0.4.0", date: "2011-08-26", lts: false, security: false }, { name: "nodejs", version: "0.5.0", date: "2011-08-26", lts: false, security: false }, { name: "nodejs", version: "0.6.0", date: "2011-11-04", lts: false, security: false }, { name: "nodejs", version: "0.7.0", date: "2012-01-17", lts: false, security: false }, { name: "nodejs", version: "0.8.0", date: "2012-06-22", lts: false, security: false }, { name: "nodejs", version: "0.9.0", date: "2012-07-20", lts: false, security: false }, { name: "nodejs", version: "0.10.0", date: "2013-03-11", lts: false, security: false }, { name: "nodejs", version: "0.11.0", date: "2013-03-28", lts: false, security: false }, { name: "nodejs", version: "0.12.0", date: "2015-02-06", lts: false, security: false }, { name: "nodejs", version: "4.0.0", date: "2015-09-08", lts: false, security: false }, { name: "nodejs", version: "4.1.0", date: "2015-09-17", lts: false, security: false }, { name: "nodejs", version: "4.2.0", date: "2015-10-12", lts: "Argon", security: false }, { name: "nodejs", version: "4.3.0", date: "2016-02-09", lts: "Argon", security: false }, { name: "nodejs", version: "4.4.0", date: "2016-03-08", lts: "Argon", security: false }, { name: "nodejs", version: "4.5.0", date: "2016-08-16", lts: "Argon", security: false }, { name: "nodejs", version: "4.6.0", date: "2016-09-27", lts: "Argon", security: true }, { name: "nodejs", version: "4.7.0", date: "2016-12-06", lts: "Argon", security: false }, { name: "nodejs", version: "4.8.0", date: "2017-02-21", lts: "Argon", security: false }, { name: "nodejs", version: "4.9.0", date: "2018-03-28", lts: "Argon", security: true }, { name: "nodejs", version: "5.0.0", date: "2015-10-29", lts: false, security: false }, { name: "nodejs", version: "5.1.0", date: "2015-11-17", lts: false, security: false }, { name: "nodejs", version: "5.2.0", date: "2015-12-09", lts: false, security: false }, { name: "nodejs", version: "5.3.0", date: "2015-12-15", lts: false, security: false }, { name: "nodejs", version: "5.4.0", date: "2016-01-06", lts: false, security: false }, { name: "nodejs", version: "5.5.0", date: "2016-01-21", lts: false, security: false }, { name: "nodejs", version: "5.6.0", date: "2016-02-09", lts: false, security: false }, { name: "nodejs", version: "5.7.0", date: "2016-02-23", lts: false, security: false }, { name: "nodejs", version: "5.8.0", date: "2016-03-09", lts: false, security: false }, { name: "nodejs", version: "5.9.0", date: "2016-03-16", lts: false, security: false }, { name: "nodejs", version: "5.10.0", date: "2016-04-01", lts: false, security: false }, { name: "nodejs", version: "5.11.0", date: "2016-04-21", lts: false, security: false }, { name: "nodejs", version: "5.12.0", date: "2016-06-23", lts: false, security: false }, { name: "nodejs", version: "6.0.0", date: "2016-04-26", lts: false, security: false }, { name: "nodejs", version: "6.1.0", date: "2016-05-05", lts: false, security: false }, { name: "nodejs", version: "6.2.0", date: "2016-05-17", lts: false, security: false }, { name: "nodejs", version: "6.3.0", date: "2016-07-06", lts: false, security: false }, { name: "nodejs", version: "6.4.0", date: "2016-08-12", lts: false, security: false }, { name: "nodejs", version: "6.5.0", date: "2016-08-26", lts: false, security: false }, { name: "nodejs", version: "6.6.0", date: "2016-09-14", lts: false, security: false }, { name: "nodejs", version: "6.7.0", date: "2016-09-27", lts: false, security: true }, { name: "nodejs", version: "6.8.0", date: "2016-10-12", lts: false, security: false }, { name: "nodejs", version: "6.9.0", date: "2016-10-18", lts: "Boron", security: false }, { name: "nodejs", version: "6.10.0", date: "2017-02-21", lts: "Boron", security: false }, { name: "nodejs", version: "6.11.0", date: "2017-06-06", lts: "Boron", security: false }, { name: "nodejs", version: "6.12.0", date: "2017-11-06", lts: "Boron", security: false }, { name: "nodejs", version: "6.13.0", date: "2018-02-10", lts: "Boron", security: false }, { name: "nodejs", version: "6.14.0", date: "2018-03-28", lts: "Boron", security: true }, { name: "nodejs", version: "6.15.0", date: "2018-11-27", lts: "Boron", security: true }, { name: "nodejs", version: "6.16.0", date: "2018-12-26", lts: "Boron", security: false }, { name: "nodejs", version: "6.17.0", date: "2019-02-28", lts: "Boron", security: true }, { name: "nodejs", version: "7.0.0", date: "2016-10-25", lts: false, security: false }, { name: "nodejs", version: "7.1.0", date: "2016-11-08", lts: false, security: false }, { name: "nodejs", version: "7.2.0", date: "2016-11-22", lts: false, security: false }, { name: "nodejs", version: "7.3.0", date: "2016-12-20", lts: false, security: false }, { name: "nodejs", version: "7.4.0", date: "2017-01-04", lts: false, security: false }, { name: "nodejs", version: "7.5.0", date: "2017-01-31", lts: false, security: false }, { name: "nodejs", version: "7.6.0", date: "2017-02-21", lts: false, security: false }, { name: "nodejs", version: "7.7.0", date: "2017-02-28", lts: false, security: false }, { name: "nodejs", version: "7.8.0", date: "2017-03-29", lts: false, security: false }, { name: "nodejs", version: "7.9.0", date: "2017-04-11", lts: false, security: false }, { name: "nodejs", version: "7.10.0", date: "2017-05-02", lts: false, security: false }, { name: "nodejs", version: "8.0.0", date: "2017-05-30", lts: false, security: false }, { name: "nodejs", version: "8.1.0", date: "2017-06-08", lts: false, security: false }, { name: "nodejs", version: "8.2.0", date: "2017-07-19", lts: false, security: false }, { name: "nodejs", version: "8.3.0", date: "2017-08-08", lts: false, security: false }, { name: "nodejs", version: "8.4.0", date: "2017-08-15", lts: false, security: false }, { name: "nodejs", version: "8.5.0", date: "2017-09-12", lts: false, security: false }, { name: "nodejs", version: "8.6.0", date: "2017-09-26", lts: false, security: false }, { name: "nodejs", version: "8.7.0", date: "2017-10-11", lts: false, security: false }, { name: "nodejs", version: "8.8.0", date: "2017-10-24", lts: false, security: false }, { name: "nodejs", version: "8.9.0", date: "2017-10-31", lts: "Carbon", security: false }, { name: "nodejs", version: "8.10.0", date: "2018-03-06", lts: "Carbon", security: false }, { name: "nodejs", version: "8.11.0", date: "2018-03-28", lts: "Carbon", security: true }, { name: "nodejs", version: "8.12.0", date: "2018-09-10", lts: "Carbon", security: false }, { name: "nodejs", version: "8.13.0", date: "2018-11-20", lts: "Carbon", security: false }, { name: "nodejs", version: "8.14.0", date: "2018-11-27", lts: "Carbon", security: true }, { name: "nodejs", version: "8.15.0", date: "2018-12-26", lts: "Carbon", security: false }, { name: "nodejs", version: "8.16.0", date: "2019-04-16", lts: "Carbon", security: false }, { name: "nodejs", version: "8.17.0", date: "2019-12-17", lts: "Carbon", security: true }, { name: "nodejs", version: "9.0.0", date: "2017-10-31", lts: false, security: false }, { name: "nodejs", version: "9.1.0", date: "2017-11-07", lts: false, security: false }, { name: "nodejs", version: "9.2.0", date: "2017-11-14", lts: false, security: false }, { name: "nodejs", version: "9.3.0", date: "2017-12-12", lts: false, security: false }, { name: "nodejs", version: "9.4.0", date: "2018-01-10", lts: false, security: false }, { name: "nodejs", version: "9.5.0", date: "2018-01-31", lts: false, security: false }, { name: "nodejs", version: "9.6.0", date: "2018-02-21", lts: false, security: false }, { name: "nodejs", version: "9.7.0", date: "2018-03-01", lts: false, security: false }, { name: "nodejs", version: "9.8.0", date: "2018-03-07", lts: false, security: false }, { name: "nodejs", version: "9.9.0", date: "2018-03-21", lts: false, security: false }, { name: "nodejs", version: "9.10.0", date: "2018-03-28", lts: false, security: true }, { name: "nodejs", version: "9.11.0", date: "2018-04-04", lts: false, security: false }, { name: "nodejs", version: "10.0.0", date: "2018-04-24", lts: false, security: false }, { name: "nodejs", version: "10.1.0", date: "2018-05-08", lts: false, security: false }, { name: "nodejs", version: "10.2.0", date: "2018-05-23", lts: false, security: false }, { name: "nodejs", version: "10.3.0", date: "2018-05-29", lts: false, security: false }, { name: "nodejs", version: "10.4.0", date: "2018-06-06", lts: false, security: false }, { name: "nodejs", version: "10.5.0", date: "2018-06-20", lts: false, security: false }, { name: "nodejs", version: "10.6.0", date: "2018-07-04", lts: false, security: false }, { name: "nodejs", version: "10.7.0", date: "2018-07-18", lts: false, security: false }, { name: "nodejs", version: "10.8.0", date: "2018-08-01", lts: false, security: false }, { name: "nodejs", version: "10.9.0", date: "2018-08-15", lts: false, security: false }, { name: "nodejs", version: "10.10.0", date: "2018-09-06", lts: false, security: false }, { name: "nodejs", version: "10.11.0", date: "2018-09-19", lts: false, security: false }, { name: "nodejs", version: "10.12.0", date: "2018-10-10", lts: false, security: false }, { name: "nodejs", version: "10.13.0", date: "2018-10-30", lts: "Dubnium", security: false }, { name: "nodejs", version: "10.14.0", date: "2018-11-27", lts: "Dubnium", security: true }, { name: "nodejs", version: "10.15.0", date: "2018-12-26", lts: "Dubnium", security: false }, { name: "nodejs", version: "10.16.0", date: "2019-05-28", lts: "Dubnium", security: false }, { name: "nodejs", version: "10.17.0", date: "2019-10-22", lts: "Dubnium", security: false }, { name: "nodejs", version: "10.18.0", date: "2019-12-17", lts: "Dubnium", security: true }, { name: "nodejs", version: "10.19.0", date: "2020-02-05", lts: "Dubnium", security: true }, { name: "nodejs", version: "10.20.0", date: "2020-03-26", lts: "Dubnium", security: false }, { name: "nodejs", version: "10.21.0", date: "2020-06-02", lts: "Dubnium", security: true }, { name: "nodejs", version: "10.22.0", date: "2020-07-21", lts: "Dubnium", security: false }, { name: "nodejs", version: "10.23.0", date: "2020-10-27", lts: "Dubnium", security: false }, { name: "nodejs", version: "10.24.0", date: "2021-02-23", lts: "Dubnium", security: true }, { name: "nodejs", version: "11.0.0", date: "2018-10-23", lts: false, security: false }, { name: "nodejs", version: "11.1.0", date: "2018-10-30", lts: false, security: false }, { name: "nodejs", version: "11.2.0", date: "2018-11-15", lts: false, security: false }, { name: "nodejs", version: "11.3.0", date: "2018-11-27", lts: false, security: true }, { name: "nodejs", version: "11.4.0", date: "2018-12-07", lts: false, security: false }, { name: "nodejs", version: "11.5.0", date: "2018-12-18", lts: false, security: false }, { name: "nodejs", version: "11.6.0", date: "2018-12-26", lts: false, security: false }, { name: "nodejs", version: "11.7.0", date: "2019-01-17", lts: false, security: false }, { name: "nodejs", version: "11.8.0", date: "2019-01-24", lts: false, security: false }, { name: "nodejs", version: "11.9.0", date: "2019-01-30", lts: false, security: false }, { name: "nodejs", version: "11.10.0", date: "2019-02-14", lts: false, security: false }, { name: "nodejs", version: "11.11.0", date: "2019-03-05", lts: false, security: false }, { name: "nodejs", version: "11.12.0", date: "2019-03-14", lts: false, security: false }, { name: "nodejs", version: "11.13.0", date: "2019-03-28", lts: false, security: false }, { name: "nodejs", version: "11.14.0", date: "2019-04-10", lts: false, security: false }, { name: "nodejs", version: "11.15.0", date: "2019-04-30", lts: false, security: false }, { name: "nodejs", version: "12.0.0", date: "2019-04-23", lts: false, security: false }, { name: "nodejs", version: "12.1.0", date: "2019-04-29", lts: false, security: false }, { name: "nodejs", version: "12.2.0", date: "2019-05-07", lts: false, security: false }, { name: "nodejs", version: "12.3.0", date: "2019-05-21", lts: false, security: false }, { name: "nodejs", version: "12.4.0", date: "2019-06-04", lts: false, security: false }, { name: "nodejs", version: "12.5.0", date: "2019-06-26", lts: false, security: false }, { name: "nodejs", version: "12.6.0", date: "2019-07-03", lts: false, security: false }, { name: "nodejs", version: "12.7.0", date: "2019-07-23", lts: false, security: false }, { name: "nodejs", version: "12.8.0", date: "2019-08-06", lts: false, security: false }, { name: "nodejs", version: "12.9.0", date: "2019-08-20", lts: false, security: false }, { name: "nodejs", version: "12.10.0", date: "2019-09-04", lts: false, security: false }, { name: "nodejs", version: "12.11.0", date: "2019-09-25", lts: false, security: false }, { name: "nodejs", version: "12.12.0", date: "2019-10-11", lts: false, security: false }, { name: "nodejs", version: "12.13.0", date: "2019-10-21", lts: "Erbium", security: false }, { name: "nodejs", version: "12.14.0", date: "2019-12-17", lts: "Erbium", security: true }, { name: "nodejs", version: "12.15.0", date: "2020-02-05", lts: "Erbium", security: true }, { name: "nodejs", version: "12.16.0", date: "2020-02-11", lts: "Erbium", security: false }, { name: "nodejs", version: "12.17.0", date: "2020-05-26", lts: "Erbium", security: false }, { name: "nodejs", version: "12.18.0", date: "2020-06-02", lts: "Erbium", security: true }, { name: "nodejs", version: "12.19.0", date: "2020-10-06", lts: "Erbium", security: false }, { name: "nodejs", version: "12.20.0", date: "2020-11-24", lts: "Erbium", security: false }, { name: "nodejs", version: "12.21.0", date: "2021-02-23", lts: "Erbium", security: true }, { name: "nodejs", version: "12.22.0", date: "2021-03-30", lts: "Erbium", security: false }, { name: "nodejs", version: "13.0.0", date: "2019-10-22", lts: false, security: false }, { name: "nodejs", version: "13.1.0", date: "2019-11-05", lts: false, security: false }, { name: "nodejs", version: "13.2.0", date: "2019-11-21", lts: false, security: false }, { name: "nodejs", version: "13.3.0", date: "2019-12-03", lts: false, security: false }, { name: "nodejs", version: "13.4.0", date: "2019-12-17", lts: false, security: true }, { name: "nodejs", version: "13.5.0", date: "2019-12-18", lts: false, security: false }, { name: "nodejs", version: "13.6.0", date: "2020-01-07", lts: false, security: false }, { name: "nodejs", version: "13.7.0", date: "2020-01-21", lts: false, security: false }, { name: "nodejs", version: "13.8.0", date: "2020-02-05", lts: false, security: true }, { name: "nodejs", version: "13.9.0", date: "2020-02-18", lts: false, security: false }, { name: "nodejs", version: "13.10.0", date: "2020-03-04", lts: false, security: false }, { name: "nodejs", version: "13.11.0", date: "2020-03-12", lts: false, security: false }, { name: "nodejs", version: "13.12.0", date: "2020-03-26", lts: false, security: false }, { name: "nodejs", version: "13.13.0", date: "2020-04-14", lts: false, security: false }, { name: "nodejs", version: "13.14.0", date: "2020-04-29", lts: false, security: false }, { name: "nodejs", version: "14.0.0", date: "2020-04-21", lts: false, security: false }, { name: "nodejs", version: "14.1.0", date: "2020-04-29", lts: false, security: false }, { name: "nodejs", version: "14.2.0", date: "2020-05-05", lts: false, security: false }, { name: "nodejs", version: "14.3.0", date: "2020-05-19", lts: false, security: false }, { name: "nodejs", version: "14.4.0", date: "2020-06-02", lts: false, security: true }, { name: "nodejs", version: "14.5.0", date: "2020-06-30", lts: false, security: false }, { name: "nodejs", version: "14.6.0", date: "2020-07-20", lts: false, security: false }, { name: "nodejs", version: "14.7.0", date: "2020-07-29", lts: false, security: false }, { name: "nodejs", version: "14.8.0", date: "2020-08-11", lts: false, security: false }, { name: "nodejs", version: "14.9.0", date: "2020-08-27", lts: false, security: false }, { name: "nodejs", version: "14.10.0", date: "2020-09-08", lts: false, security: false }, { name: "nodejs", version: "14.11.0", date: "2020-09-15", lts: false, security: true }, { name: "nodejs", version: "14.12.0", date: "2020-09-22", lts: false, security: false }, { name: "nodejs", version: "14.13.0", date: "2020-09-29", lts: false, security: false }, { name: "nodejs", version: "14.14.0", date: "2020-10-15", lts: false, security: false }, { name: "nodejs", version: "14.15.0", date: "2020-10-27", lts: "Fermium", security: false }, { name: "nodejs", version: "14.16.0", date: "2021-02-23", lts: "Fermium", security: true }, { name: "nodejs", version: "14.17.0", date: "2021-05-11", lts: "Fermium", security: false }, { name: "nodejs", version: "14.18.0", date: "2021-09-28", lts: "Fermium", security: false }, { name: "nodejs", version: "14.19.0", date: "2022-02-01", lts: "Fermium", security: false }, { name: "nodejs", version: "14.20.0", date: "2022-07-07", lts: "Fermium", security: true }, { name: "nodejs", version: "14.21.0", date: "2022-11-01", lts: "Fermium", security: false }, { name: "nodejs", version: "15.0.0", date: "2020-10-20", lts: false, security: false }, { name: "nodejs", version: "15.1.0", date: "2020-11-04", lts: false, security: false }, { name: "nodejs", version: "15.2.0", date: "2020-11-10", lts: false, security: false }, { name: "nodejs", version: "15.3.0", date: "2020-11-24", lts: false, security: false }, { name: "nodejs", version: "15.4.0", date: "2020-12-09", lts: false, security: false }, { name: "nodejs", version: "15.5.0", date: "2020-12-22", lts: false, security: false }, { name: "nodejs", version: "15.6.0", date: "2021-01-14", lts: false, security: false }, { name: "nodejs", version: "15.7.0", date: "2021-01-25", lts: false, security: false }, { name: "nodejs", version: "15.8.0", date: "2021-02-02", lts: false, security: false }, { name: "nodejs", version: "15.9.0", date: "2021-02-18", lts: false, security: false }, { name: "nodejs", version: "15.10.0", date: "2021-02-23", lts: false, security: true }, { name: "nodejs", version: "15.11.0", date: "2021-03-03", lts: false, security: false }, { name: "nodejs", version: "15.12.0", date: "2021-03-17", lts: false, security: false }, { name: "nodejs", version: "15.13.0", date: "2021-03-31", lts: false, security: false }, { name: "nodejs", version: "15.14.0", date: "2021-04-06", lts: false, security: false }, { name: "nodejs", version: "16.0.0", date: "2021-04-20", lts: false, security: false }, { name: "nodejs", version: "16.1.0", date: "2021-05-04", lts: false, security: false }, { name: "nodejs", version: "16.2.0", date: "2021-05-19", lts: false, security: false }, { name: "nodejs", version: "16.3.0", date: "2021-06-03", lts: false, security: false }, { name: "nodejs", version: "16.4.0", date: "2021-06-23", lts: false, security: false }, { name: "nodejs", version: "16.5.0", date: "2021-07-14", lts: false, security: false }, { name: "nodejs", version: "16.6.0", date: "2021-07-29", lts: false, security: true }, { name: "nodejs", version: "16.7.0", date: "2021-08-18", lts: false, security: false }, { name: "nodejs", version: "16.8.0", date: "2021-08-25", lts: false, security: false }, { name: "nodejs", version: "16.9.0", date: "2021-09-07", lts: false, security: false }, { name: "nodejs", version: "16.10.0", date: "2021-09-22", lts: false, security: false }, { name: "nodejs", version: "16.11.0", date: "2021-10-08", lts: false, security: false }, { name: "nodejs", version: "16.12.0", date: "2021-10-20", lts: false, security: false }, { name: "nodejs", version: "16.13.0", date: "2021-10-26", lts: "Gallium", security: false }, { name: "nodejs", version: "16.14.0", date: "2022-02-08", lts: "Gallium", security: false }, { name: "nodejs", version: "16.15.0", date: "2022-04-26", lts: "Gallium", security: false }, { name: "nodejs", version: "16.16.0", date: "2022-07-07", lts: "Gallium", security: true }, { name: "nodejs", version: "16.17.0", date: "2022-08-16", lts: "Gallium", security: false }, { name: "nodejs", version: "16.18.0", date: "2022-10-12", lts: "Gallium", security: false }, { name: "nodejs", version: "16.19.0", date: "2022-12-13", lts: "Gallium", security: false }, { name: "nodejs", version: "17.0.0", date: "2021-10-19", lts: false, security: false }, { name: "nodejs", version: "17.1.0", date: "2021-11-09", lts: false, security: false }, { name: "nodejs", version: "17.2.0", date: "2021-11-30", lts: false, security: false }, { name: "nodejs", version: "17.3.0", date: "2021-12-17", lts: false, security: false }, { name: "nodejs", version: "17.4.0", date: "2022-01-18", lts: false, security: false }, { name: "nodejs", version: "17.5.0", date: "2022-02-10", lts: false, security: false }, { name: "nodejs", version: "17.6.0", date: "2022-02-22", lts: false, security: false }, { name: "nodejs", version: "17.7.0", date: "2022-03-09", lts: false, security: false }, { name: "nodejs", version: "17.8.0", date: "2022-03-22", lts: false, security: false }, { name: "nodejs", version: "17.9.0", date: "2022-04-07", lts: false, security: false }, { name: "nodejs", version: "18.0.0", date: "2022-04-18", lts: false, security: false }, { name: "nodejs", version: "18.1.0", date: "2022-05-03", lts: false, security: false }, { name: "nodejs", version: "18.2.0", date: "2022-05-17", lts: false, security: false }, { name: "nodejs", version: "18.3.0", date: "2022-06-02", lts: false, security: false }, { name: "nodejs", version: "18.4.0", date: "2022-06-16", lts: false, security: false }, { name: "nodejs", version: "18.5.0", date: "2022-07-06", lts: false, security: true }, { name: "nodejs", version: "18.6.0", date: "2022-07-13", lts: false, security: false }, { name: "nodejs", version: "18.7.0", date: "2022-07-26", lts: false, security: false }, { name: "nodejs", version: "18.8.0", date: "2022-08-24", lts: false, security: false }, { name: "nodejs", version: "18.9.0", date: "2022-09-07", lts: false, security: false }, { name: "nodejs", version: "18.10.0", date: "2022-09-28", lts: false, security: false }, { name: "nodejs", version: "18.11.0", date: "2022-10-13", lts: false, security: false }, { name: "nodejs", version: "18.12.0", date: "2022-10-25", lts: "Hydrogen", security: false }, { name: "nodejs", version: "18.13.0", date: "2023-01-05", lts: "Hydrogen", security: false }, { name: "nodejs", version: "18.14.0", date: "2023-02-01", lts: "Hydrogen", security: false }, { name: "nodejs", version: "19.0.0", date: "2022-10-17", lts: false, security: false }, { name: "nodejs", version: "19.1.0", date: "2022-11-14", lts: false, security: false }, { name: "nodejs", version: "19.2.0", date: "2022-11-29", lts: false, security: false }, { name: "nodejs", version: "19.3.0", date: "2022-12-14", lts: false, security: false }, { name: "nodejs", version: "19.4.0", date: "2023-01-05", lts: false, security: false }, { name: "nodejs", version: "19.5.0", date: "2023-01-24", lts: false, security: false }, { name: "nodejs", version: "19.6.0", date: "2023-02-01", lts: false, security: false }];
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/browsers.js
var require_browsers = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/browsers.js"(exports3, module2) {
    module2.exports = { A: "ie", B: "edge", C: "firefox", D: "chrome", E: "safari", F: "opera", G: "ios_saf", H: "op_mini", I: "android", J: "bb", K: "op_mob", L: "and_chr", M: "and_ff", N: "ie_mob", O: "and_uc", P: "samsung", Q: "and_qq", R: "baidu", S: "kaios" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/dist/unpacker/browsers.js
var require_browsers2 = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/dist/unpacker/browsers.js"(exports3, module2) {
    module2.exports.browsers = require_browsers();
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/browserVersions.js
var require_browserVersions = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/browserVersions.js"(exports3, module2) {
    module2.exports = { "0": "21", "1": "22", "2": "23", "3": "24", "4": "25", "5": "26", "6": "27", "7": "28", "8": "29", "9": "30", A: "10", B: "11", C: "12", D: "7", E: "8", F: "9", G: "15", H: "112", I: "4", J: "6", K: "13", L: "14", M: "16", N: "17", O: "18", P: "79", Q: "80", R: "81", S: "83", T: "84", U: "85", V: "86", W: "87", X: "88", Y: "89", Z: "90", a: "91", b: "92", c: "93", d: "94", e: "95", f: "96", g: "97", h: "98", i: "110", j: "20", k: "73", l: "99", m: "100", n: "101", o: "102", p: "103", q: "104", r: "105", s: "106", t: "107", u: "108", v: "109", w: "111", x: "113", y: "5", z: "19", AB: "31", BB: "32", CB: "33", DB: "34", EB: "35", FB: "36", GB: "37", HB: "38", IB: "39", JB: "40", KB: "41", LB: "42", MB: "43", NB: "44", OB: "45", PB: "46", QB: "47", RB: "48", SB: "49", TB: "50", UB: "51", VB: "52", WB: "53", XB: "54", YB: "55", ZB: "56", aB: "57", bB: "58", cB: "60", dB: "62", eB: "63", fB: "64", gB: "65", hB: "66", iB: "67", jB: "68", kB: "69", lB: "70", mB: "71", nB: "72", oB: "74", pB: "75", qB: "76", rB: "77", sB: "78", tB: "11.1", uB: "12.1", vB: "16.0", wB: "3", xB: "59", yB: "61", zB: "82", "0B": "114", "1B": "3.2", "2B": "10.1", "3B": "13.1", "4B": "15.2-15.3", "5B": "15.4", "6B": "15.5", "7B": "15.6", "8B": "16.1", "9B": "16.2", AC: "16.3", BC: "16.4", CC: "16.5", DC: "11.5", EC: "4.2-4.3", FC: "5.5", GC: "2", HC: "3.5", IC: "3.6", JC: "115", KC: "116", LC: "3.1", MC: "5.1", NC: "6.1", OC: "7.1", PC: "9.1", QC: "14.1", RC: "15.1", SC: "TP", TC: "9.5-9.6", UC: "10.0-10.1", VC: "10.5", WC: "10.6", XC: "11.6", YC: "4.0-4.1", ZC: "5.0-5.1", aC: "6.0-6.1", bC: "7.0-7.1", cC: "8.1-8.4", dC: "9.0-9.2", eC: "9.3", fC: "10.0-10.2", gC: "10.3", hC: "11.0-11.2", iC: "11.3-11.4", jC: "12.0-12.1", kC: "12.2-12.5", lC: "13.0-13.1", mC: "13.2", nC: "13.3", oC: "13.4-13.7", pC: "14.0-14.4", qC: "14.5-14.8", rC: "15.0-15.1", sC: "all", tC: "2.1", uC: "2.2", vC: "2.3", wC: "4.1", xC: "4.4", yC: "4.4.3-4.4.4", zC: "13.4", "0C": "5.0-5.4", "1C": "6.2-6.4", "2C": "7.2-7.4", "3C": "8.2", "4C": "9.2", "5C": "11.1-11.2", "6C": "12.0", "7C": "13.0", "8C": "14.0", "9C": "15.0", AD: "17.0", BD: "18.0", CD: "19.0", DD: "13.18", ED: "2.5", FD: "3.0-3.1" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/dist/unpacker/browserVersions.js
var require_browserVersions2 = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/dist/unpacker/browserVersions.js"(exports3, module2) {
    module2.exports.browserVersions = require_browserVersions();
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/agents.js
var require_agents = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/agents.js"(exports3, module2) {
    module2.exports = { A: { A: { J: 0.0131217, D: 621152e-8, E: 0.0497493, F: 0.0580409, A: 829156e-8, B: 0.406286, FC: 9298e-6 }, B: "ms", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "FC", "J", "D", "E", "F", "A", "B", "", "", ""], E: "IE", F: { FC: 962323200, J: 998870400, D: 1161129600, E: 1237420800, F: 1300060800, A: 1346716800, B: 1381968e3 } }, B: { A: { C: 4081e-6, K: 4267e-6, L: 4268e-6, G: 4081e-6, M: 3702e-6, N: 4081e-6, O: 0.016324, P: 0, Q: 4298e-6, R: 944e-5, S: 4043e-6, T: 4081e-6, U: 3861e-6, V: 3861e-6, W: 4081e-6, X: 3943e-6, Y: 4081e-6, Z: 3943e-6, a: 3943e-6, b: 8162e-6, c: 4118e-6, d: 3939e-6, e: 3943e-6, f: 3943e-6, g: 3943e-6, h: 3929e-6, l: 3901e-6, m: 0.011829, n: 7886e-6, o: 3943e-6, p: 8162e-6, q: 4081e-6, r: 4081e-6, s: 8162e-6, t: 0.016324, u: 0.044891, v: 0.118349, i: 2.0609, w: 2.19966, H: 0, x: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "C", "K", "L", "G", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "i", "w", "H", "x", "", "", ""], E: "Edge", F: { C: 1438128e3, K: 1447286400, L: 1470096e3, G: 1491868800, M: 1508198400, N: 1525046400, O: 1542067200, P: 1579046400, Q: 1581033600, R: 1586736e3, S: 1590019200, T: 1594857600, U: 1598486400, V: 1602201600, W: 1605830400, X: 161136e4, Y: 1614816e3, Z: 1618358400, a: 1622073600, b: 1626912e3, c: 1630627200, d: 1632441600, e: 1634774400, f: 1637539200, g: 1641427200, h: 1643932800, l: 1646265600, m: 1649635200, n: 1651190400, o: 1653955200, p: 1655942400, q: 1659657600, r: 1661990400, s: 1664755200, t: 1666915200, u: 1670198400, v: 1673481600, i: 1675900800, w: 1678665600, H: 1680825600, x: 1683158400 }, D: { C: "ms", K: "ms", L: "ms", G: "ms", M: "ms", N: "ms", O: "ms" } }, C: { A: { "0": 8322e-6, "1": 0.013698, "2": 4161e-6, "3": 8786e-6, "4": 4118e-6, "5": 4317e-6, "6": 4393e-6, "7": 4418e-6, "8": 8834e-6, "9": 8322e-6, GC: 4118e-6, wB: 4271e-6, I: 0.011703, y: 4879e-6, J: 0.020136, D: 5725e-6, E: 4525e-6, F: 533e-5, A: 4283e-6, B: 8162e-6, C: 4471e-6, K: 4486e-6, L: 453e-5, G: 8322e-6, M: 4417e-6, N: 4425e-6, O: 4161e-6, z: 4443e-6, j: 4283e-6, AB: 8928e-6, BB: 4471e-6, CB: 9284e-6, DB: 4707e-6, EB: 9076e-6, FB: 4081e-6, GB: 4783e-6, HB: 3929e-6, IB: 4783e-6, JB: 487e-5, KB: 5029e-6, LB: 47e-4, MB: 0.012243, NB: 4081e-6, OB: 3867e-6, PB: 4525e-6, QB: 4293e-6, RB: 4081e-6, SB: 4538e-6, TB: 8282e-6, UB: 0.011601, VB: 0.044891, WB: 0.011601, XB: 3929e-6, YB: 3974e-6, ZB: 8162e-6, aB: 0.011601, bB: 3939e-6, xB: 4081e-6, cB: 3929e-6, yB: 4356e-6, dB: 4425e-6, eB: 8322e-6, fB: 415e-5, gB: 4267e-6, hB: 3801e-6, iB: 4267e-6, jB: 4081e-6, kB: 415e-5, lB: 4293e-6, mB: 4425e-6, nB: 8162e-6, k: 415e-5, oB: 415e-5, pB: 4318e-6, qB: 4356e-6, rB: 3974e-6, sB: 0.036729, P: 4081e-6, Q: 4081e-6, R: 4081e-6, zB: 3861e-6, S: 4081e-6, T: 3929e-6, U: 4268e-6, V: 3801e-6, W: 0.012243, X: 8162e-6, Y: 3943e-6, Z: 3943e-6, a: 0.012243, b: 3801e-6, c: 7722e-6, d: 0.016324, e: 3773e-6, f: 7886e-6, g: 3901e-6, h: 3901e-6, l: 4081e-6, m: 3861e-6, n: 4081e-6, o: 0.110187, p: 0.036729, q: 8162e-6, r: 8162e-6, s: 8162e-6, t: 0.012243, u: 0.024486, v: 0.053053, i: 1.10187, w: 0.926387, H: 8162e-6, x: 0, "0B": 0, HC: 8786e-6, IC: 487e-5 }, B: "moz", C: ["GC", "wB", "HC", "IC", "I", "y", "J", "D", "E", "F", "A", "B", "C", "K", "L", "G", "M", "N", "O", "z", "j", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "AB", "BB", "CB", "DB", "EB", "FB", "GB", "HB", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "VB", "WB", "XB", "YB", "ZB", "aB", "bB", "xB", "cB", "yB", "dB", "eB", "fB", "gB", "hB", "iB", "jB", "kB", "lB", "mB", "nB", "k", "oB", "pB", "qB", "rB", "sB", "P", "Q", "R", "zB", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "i", "w", "H", "x", "0B", ""], E: "Firefox", F: { "0": 1364860800, "1": 1368489600, "2": 1372118400, "3": 1375747200, "4": 1379376e3, "5": 1386633600, "6": 1391472e3, "7": 1395100800, "8": 1398729600, "9": 1402358400, GC: 1161648e3, wB: 1213660800, HC: 124632e4, IC: 1264032e3, I: 1300752e3, y: 1308614400, J: 1313452800, D: 1317081600, E: 1317081600, F: 1320710400, A: 1324339200, B: 1327968e3, C: 1331596800, K: 1335225600, L: 1338854400, G: 1342483200, M: 1346112e3, N: 1349740800, O: 1353628800, z: 1357603200, j: 1361232e3, AB: 1405987200, BB: 1409616e3, CB: 1413244800, DB: 1417392e3, EB: 1421107200, FB: 1424736e3, GB: 1428278400, HB: 1431475200, IB: 1435881600, JB: 1439251200, KB: 144288e4, LB: 1446508800, MB: 1450137600, NB: 1453852800, OB: 1457395200, PB: 1461628800, QB: 1465257600, RB: 1470096e3, SB: 1474329600, TB: 1479168e3, UB: 1485216e3, VB: 1488844800, WB: 149256e4, XB: 1497312e3, YB: 1502150400, ZB: 1506556800, aB: 1510617600, bB: 1516665600, xB: 1520985600, cB: 1525824e3, yB: 1529971200, dB: 1536105600, eB: 1540252800, fB: 1544486400, gB: 154872e4, hB: 1552953600, iB: 1558396800, jB: 1562630400, kB: 1567468800, lB: 1571788800, mB: 1575331200, nB: 1578355200, k: 1581379200, oB: 1583798400, pB: 1586304e3, qB: 1588636800, rB: 1591056e3, sB: 1593475200, P: 1595894400, Q: 1598313600, R: 1600732800, zB: 1603152e3, S: 1605571200, T: 1607990400, U: 1611619200, V: 1614038400, W: 1616457600, X: 1618790400, Y: 1622505600, Z: 1626134400, a: 1628553600, b: 1630972800, c: 1633392e3, d: 1635811200, e: 1638835200, f: 1641859200, g: 1644364800, h: 1646697600, l: 1649116800, m: 1651536e3, n: 1653955200, o: 1656374400, p: 1658793600, q: 1661212800, r: 1663632e3, s: 1666051200, t: 1668470400, u: 1670889600, v: 1673913600, i: 1676332800, w: 1678752e3, H: 1681171200, x: null, "0B": null } }, D: { A: { "0": 4317e-6, "1": 3901e-6, "2": 8786e-6, "3": 3939e-6, "4": 4461e-6, "5": 4141e-6, "6": 4326e-6, "7": 47e-4, "8": 4538e-6, "9": 8322e-6, I: 4706e-6, y: 4879e-6, J: 4879e-6, D: 5591e-6, E: 5591e-6, F: 5591e-6, A: 4534e-6, B: 4464e-6, C: 0.010424, K: 83e-4, L: 4706e-6, G: 0.015087, M: 4393e-6, N: 4393e-6, O: 8652e-6, z: 8322e-6, j: 4393e-6, AB: 8596e-6, BB: 4566e-6, CB: 4118e-6, DB: 4081e-6, EB: 8162e-6, FB: 4335e-6, GB: 4464e-6, HB: 0.016324, IB: 3867e-6, JB: 0.016324, KB: 3773e-6, LB: 3974e-6, MB: 8162e-6, NB: 7948e-6, OB: 3974e-6, PB: 3867e-6, QB: 8162e-6, RB: 0.020405, SB: 0.036729, TB: 3867e-6, UB: 4081e-6, VB: 8162e-6, WB: 8162e-6, XB: 3867e-6, YB: 4081e-6, ZB: 0.073458, aB: 4081e-6, bB: 0.015772, xB: 3773e-6, cB: 0.016324, yB: 8162e-6, dB: 3773e-6, eB: 0.012243, fB: 3943e-6, gB: 8162e-6, hB: 0.028567, iB: 8162e-6, jB: 8162e-6, kB: 0.036729, lB: 0.016324, mB: 0.012243, nB: 0.020405, k: 8162e-6, oB: 0.036729, pB: 0.048972, qB: 0.044891, rB: 0.016324, sB: 0.024486, P: 0.134673, Q: 0.036729, R: 0.04081, S: 0.065296, T: 0.04081, U: 0.089782, V: 0.065296, W: 0.097944, X: 0.020405, Y: 0.036729, Z: 0.04081, a: 0.077539, b: 0.044891, c: 0.085701, d: 0.044891, e: 0.032648, f: 0.04081, g: 0.053053, h: 0.04081, l: 0.053053, m: 0.053053, n: 0.048972, o: 0.073458, p: 0.355047, q: 0.114268, r: 0.106106, s: 0.077539, t: 0.126511, u: 0.399938, v: 2.73019, i: 7.54169, w: 10.7208, H: 0.020405, x: 0.020405, "0B": 4081e-6, JC: 0, KC: 0 }, B: "webkit", C: ["", "", "", "", "I", "y", "J", "D", "E", "F", "A", "B", "C", "K", "L", "G", "M", "N", "O", "z", "j", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "AB", "BB", "CB", "DB", "EB", "FB", "GB", "HB", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "VB", "WB", "XB", "YB", "ZB", "aB", "bB", "xB", "cB", "yB", "dB", "eB", "fB", "gB", "hB", "iB", "jB", "kB", "lB", "mB", "nB", "k", "oB", "pB", "qB", "rB", "sB", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "i", "w", "H", "x", "0B", "JC", "KC"], E: "Chrome", F: { "0": 1340668800, "1": 1343692800, "2": 1348531200, "3": 1352246400, "4": 1357862400, "5": 1361404800, "6": 1364428800, "7": 1369094400, "8": 1374105600, "9": 1376956800, I: 1264377600, y: 1274745600, J: 1283385600, D: 1287619200, E: 1291248e3, F: 1296777600, A: 1299542400, B: 1303862400, C: 1307404800, K: 1312243200, L: 1316131200, G: 1316131200, M: 1319500800, N: 1323734400, O: 1328659200, z: 1332892800, j: 133704e4, AB: 1384214400, BB: 1389657600, CB: 1392940800, DB: 1397001600, EB: 1400544e3, FB: 1405468800, GB: 1409011200, HB: 141264e4, IB: 1416268800, JB: 1421798400, KB: 1425513600, LB: 1429401600, MB: 143208e4, NB: 1437523200, OB: 1441152e3, PB: 1444780800, QB: 1449014400, RB: 1453248e3, SB: 1456963200, TB: 1460592e3, UB: 1464134400, VB: 1469059200, WB: 1472601600, XB: 1476230400, YB: 1480550400, ZB: 1485302400, aB: 1489017600, bB: 149256e4, xB: 1496707200, cB: 1500940800, yB: 1504569600, dB: 1508198400, eB: 1512518400, fB: 1516752e3, gB: 1520294400, hB: 1523923200, iB: 1527552e3, jB: 1532390400, kB: 1536019200, lB: 1539648e3, mB: 1543968e3, nB: 154872e4, k: 1552348800, oB: 1555977600, pB: 1559606400, qB: 1564444800, rB: 1568073600, sB: 1571702400, P: 1575936e3, Q: 1580860800, R: 1586304e3, S: 1589846400, T: 1594684800, U: 1598313600, V: 1601942400, W: 1605571200, X: 1611014400, Y: 1614556800, Z: 1618272e3, a: 1621987200, b: 1626739200, c: 1630368e3, d: 1632268800, e: 1634601600, f: 1637020800, g: 1641340800, h: 1643673600, l: 1646092800, m: 1648512e3, n: 1650931200, o: 1653350400, p: 1655769600, q: 1659398400, r: 1661817600, s: 1664236800, t: 1666656e3, u: 166968e4, v: 1673308800, i: 1675728e3, w: 1678147200, H: 1680566400, x: 1682985600, "0B": null, JC: null, KC: null } }, E: { A: { I: 0, y: 8322e-6, J: 4656e-6, D: 4465e-6, E: 3974e-6, F: 3929e-6, A: 4425e-6, B: 4318e-6, C: 3801e-6, K: 0.020405, L: 0.102025, G: 0.024486, LC: 0, "1B": 8692e-6, MC: 8162e-6, NC: 456e-5, OC: 4283e-6, PC: 0.028567, "2B": 7802e-6, tB: 8162e-6, uB: 0.036729, "3B": 0.183645, QC: 0.289751, RC: 0.044891, "4B": 0.036729, "5B": 0.093863, "6B": 0.171402, "7B": 0.754985, vB: 0.08162, "8B": 0.261184, "9B": 0.465234, AC: 1.69361, BC: 0.028567, CC: 0, SC: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "LC", "1B", "I", "y", "MC", "J", "NC", "D", "OC", "E", "F", "PC", "A", "2B", "B", "tB", "C", "uB", "K", "3B", "L", "QC", "G", "RC", "4B", "5B", "6B", "7B", "vB", "8B", "9B", "AC", "BC", "CC", "SC", ""], E: "Safari", F: { LC: 1205798400, "1B": 1226534400, I: 1244419200, y: 1275868800, MC: 131112e4, J: 1343174400, NC: 13824e5, D: 13824e5, OC: 1410998400, E: 1413417600, F: 1443657600, PC: 1458518400, A: 1474329600, "2B": 1490572800, B: 1505779200, tB: 1522281600, C: 1537142400, uB: 1553472e3, K: 1568851200, "3B": 1585008e3, L: 1600214400, QC: 1619395200, G: 1632096e3, RC: 1635292800, "4B": 1639353600, "5B": 1647216e3, "6B": 1652745600, "7B": 1658275200, vB: 1662940800, "8B": 1666569600, "9B": 1670889600, AC: 1674432e3, BC: 1679875200, CC: null, SC: null } }, F: { A: { "0": 6597e-6, "1": 6597e-6, "2": 0.013434, "3": 6702e-6, "4": 6015e-6, "5": 5595e-6, "6": 4393e-6, "7": 8162e-6, "8": 4879e-6, "9": 4879e-6, F: 82e-4, B: 0.016581, C: 4317e-6, G: 685e-5, M: 685e-5, N: 685e-5, O: 5014e-6, z: 6015e-6, j: 4879e-6, AB: 3861e-6, BB: 5152e-6, CB: 5014e-6, DB: 9758e-6, EB: 4879e-6, FB: 4081e-6, GB: 4283e-6, HB: 4367e-6, IB: 4534e-6, JB: 4081e-6, KB: 4227e-6, LB: 4418e-6, MB: 4161e-6, NB: 4227e-6, OB: 4725e-6, PB: 0.012243, QB: 8942e-6, RB: 4707e-6, SB: 4827e-6, TB: 4707e-6, UB: 4707e-6, VB: 4326e-6, WB: 8922e-6, XB: 0.014349, YB: 4425e-6, ZB: 472e-5, aB: 4425e-6, bB: 4425e-6, cB: 472e-5, dB: 4532e-6, eB: 4566e-6, fB: 0.02283, gB: 867e-5, hB: 4656e-6, iB: 4642e-6, jB: 3929e-6, kB: 944e-5, lB: 4293e-6, mB: 3929e-6, nB: 4298e-6, k: 0.096692, oB: 8162e-6, pB: 4141e-6, qB: 4257e-6, rB: 3939e-6, sB: 8236e-6, P: 3855e-6, Q: 3939e-6, R: 8514e-6, zB: 3939e-6, S: 3939e-6, T: 3702e-6, U: 4081e-6, V: 3855e-6, W: 3855e-6, X: 3929e-6, Y: 3861e-6, Z: 0.011703, a: 7546e-6, b: 0.011829, c: 0.069498, d: 0.020405, e: 0.514206, f: 0, g: 0, h: 0, TC: 685e-5, UC: 0, VC: 8392e-6, WC: 4706e-6, tB: 6229e-6, DC: 4879e-6, XC: 8786e-6, uB: 472e-5 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "F", "TC", "UC", "VC", "WC", "B", "tB", "DC", "XC", "C", "uB", "G", "M", "N", "O", "z", "j", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "AB", "BB", "CB", "DB", "EB", "FB", "GB", "HB", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "VB", "WB", "XB", "YB", "ZB", "aB", "bB", "cB", "dB", "eB", "fB", "gB", "hB", "iB", "jB", "kB", "lB", "mB", "nB", "k", "oB", "pB", "qB", "rB", "sB", "P", "Q", "R", "zB", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "", "", ""], E: "Opera", F: { "0": 1399334400, "1": 1401753600, "2": 1405987200, "3": 1409616e3, "4": 1413331200, "5": 1417132800, "6": 1422316800, "7": 1425945600, "8": 1430179200, "9": 1433808e3, F: 1150761600, TC: 1223424e3, UC: 1251763200, VC: 1267488e3, WC: 1277942400, B: 1292457600, tB: 1302566400, DC: 1309219200, XC: 1323129600, C: 1323129600, uB: 1352073600, G: 1372723200, M: 1377561600, N: 1381104e3, O: 1386288e3, z: 1390867200, j: 1393891200, AB: 1438646400, BB: 1442448e3, CB: 1445904e3, DB: 1449100800, EB: 1454371200, FB: 1457308800, GB: 146232e4, HB: 1465344e3, IB: 1470096e3, JB: 1474329600, KB: 1477267200, LB: 1481587200, MB: 1486425600, NB: 1490054400, OB: 1494374400, PB: 1498003200, QB: 1502236800, RB: 1506470400, SB: 1510099200, TB: 1515024e3, UB: 1517961600, VB: 1521676800, WB: 1525910400, XB: 1530144e3, YB: 1534982400, ZB: 1537833600, aB: 1543363200, bB: 1548201600, cB: 1554768e3, dB: 1561593600, eB: 1566259200, fB: 1570406400, gB: 1573689600, hB: 1578441600, iB: 1583971200, jB: 1587513600, kB: 1592956800, lB: 1595894400, mB: 1600128e3, nB: 1603238400, k: 161352e4, oB: 1612224e3, pB: 1616544e3, qB: 1619568e3, rB: 1623715200, sB: 1627948800, P: 1631577600, Q: 1633392e3, R: 1635984e3, zB: 1638403200, S: 1642550400, T: 1644969600, U: 1647993600, V: 1650412800, W: 1652745600, X: 1654646400, Y: 1657152e3, Z: 1660780800, a: 1663113600, b: 1668816e3, c: 1668643200, d: 1671062400, e: 1675209600, f: 1677024e3, g: 1679529600, h: 1681948800 }, D: { F: "o", B: "o", C: "o", TC: "o", UC: "o", VC: "o", WC: "o", tB: "o", DC: "o", XC: "o", uB: "o" } }, G: { A: { E: 0, "1B": 0, YC: 0, EC: 316399e-8, ZC: 474599e-8, aC: 316399e-8, bC: 0.014238, cC: 790998e-8, dC: 0.018984, eC: 0.0569519, fC: 316399e-8, gC: 0.0696078, hC: 0.0205659, iC: 0.0237299, jC: 0.0205659, kC: 0.376515, lC: 0.012656, mC: 0.0348039, nC: 0.0316399, oC: 0.0996657, pC: 0.259447, qC: 0.480927, rC: 0.14238, "4B": 0.177184, "5B": 0.207241, "6B": 0.357531, "7B": 1.01406, vB: 1.11214, "8B": 2.47741, "9B": 1.67533, AC: 6.04164, BC: 0.11865, CC: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "1B", "YC", "EC", "ZC", "aC", "bC", "E", "cC", "dC", "eC", "fC", "gC", "hC", "iC", "jC", "kC", "lC", "mC", "nC", "oC", "pC", "qC", "rC", "4B", "5B", "6B", "7B", "vB", "8B", "9B", "AC", "BC", "CC", "", ""], E: "Safari on iOS", F: { "1B": 1270252800, YC: 1283904e3, EC: 1299628800, ZC: 1331078400, aC: 1359331200, bC: 1394409600, E: 1410912e3, cC: 1413763200, dC: 1442361600, eC: 1458518400, fC: 1473724800, gC: 1490572800, hC: 1505779200, iC: 1522281600, jC: 1537142400, kC: 1553472e3, lC: 1568851200, mC: 1572220800, nC: 1580169600, oC: 1585008e3, pC: 1600214400, qC: 1619395200, rC: 1632096e3, "4B": 1639353600, "5B": 1647216e3, "6B": 1652659200, "7B": 1658275200, vB: 1662940800, "8B": 1666569600, "9B": 1670889600, AC: 1674432e3, BC: 1679875200, CC: null } }, H: { A: { sC: 1.0085 }, B: "o", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "sC", "", "", ""], E: "Opera Mini", F: { sC: 1426464e3 } }, I: { A: { wB: 0, I: 0.0240008, H: 0, tC: 0, uC: 0.0720023, vC: 0, wC: 0.0160005, EC: 0.0720023, xC: 0, yC: 0.248008 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "tC", "uC", "vC", "wB", "I", "wC", "EC", "xC", "yC", "H", "", "", ""], E: "Android Browser", F: { tC: 1256515200, uC: 1274313600, vC: 1291593600, wB: 1298332800, I: 1318896e3, wC: 1341792e3, EC: 1374624e3, xC: 1386547200, yC: 1401667200, H: 1680652800 } }, J: { A: { D: 0, A: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "D", "A", "", "", ""], E: "Blackberry Browser", F: { D: 1325376e3, A: 1359504e3 } }, K: { A: { A: 0, B: 0, C: 0, k: 0.0111391, tB: 0, DC: 0, uB: 0 }, B: "o", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "A", "B", "tB", "DC", "C", "uB", "k", "", "", ""], E: "Opera Mobile", F: { A: 1287100800, B: 1300752e3, tB: 1314835200, DC: 1318291200, C: 1330300800, uB: 1349740800, k: 1673827200 }, D: { k: "webkit" } }, L: { A: { H: 40.8907 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "H", "", "", ""], E: "Chrome for Android", F: { H: 1680652800 } }, M: { A: { i: 0.2959 }, B: "moz", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "i", "", "", ""], E: "Firefox for Android", F: { i: 1676332800 } }, N: { A: { A: 0.0115934, B: 0.022664 }, B: "ms", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "A", "B", "", "", ""], E: "IE Mobile", F: { A: 1340150400, B: 1353456e3 } }, O: { A: { zC: 0.905454 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "zC", "", "", ""], E: "UC Browser for Android", F: { zC: 1634688e3 }, D: { zC: "webkit" } }, P: { A: { I: 0.147621, j: 1.90853, "0C": 0.0103543, "1C": 0.010304, "2C": 0.0527219, "3C": 0.0103584, "4C": 0.0104443, "2B": 0.0105043, "5C": 0.0210887, "6C": 0.0103982, "7C": 0.0316331, "8C": 0.0316331, "9C": 0.0210887, vB: 0.0527219, AD: 0.0632662, BD: 0.0738106, CD: 0.253065 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "I", "0C", "1C", "2C", "3C", "4C", "2B", "5C", "6C", "7C", "8C", "9C", "vB", "AD", "BD", "CD", "j", "", "", ""], E: "Samsung Internet", F: { I: 1461024e3, "0C": 1481846400, "1C": 1509408e3, "2C": 1528329600, "3C": 1546128e3, "4C": 1554163200, "2B": 1567900800, "5C": 1582588800, "6C": 1593475200, "7C": 1605657600, "8C": 1618531200, "9C": 1629072e3, vB: 1640736e3, AD: 1651708800, BD: 1659657600, CD: 1667260800, j: 1677369600 } }, Q: { A: { "3B": 0.11836 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "3B", "", "", ""], E: "QQ Browser", F: { "3B": 1663718400 } }, R: { A: { DD: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "DD", "", "", ""], E: "Baidu Browser", F: { DD: 1663027200 } }, S: { A: { ED: 0.071016, FD: 0 }, B: "moz", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "ED", "FD", "", "", ""], E: "KaiOS Browser", F: { ED: 1527811200, FD: 1631664e3 } } };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/dist/unpacker/agents.js
var require_agents2 = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/dist/unpacker/agents.js"(exports3, module2) {
    "use strict";
    var browsers = require_browsers2().browsers;
    var versions = require_browserVersions2().browserVersions;
    var agentsData = require_agents();
    function unpackBrowserVersions(versionsData) {
      return Object.keys(versionsData).reduce((usage, version4) => {
        usage[versions[version4]] = versionsData[version4];
        return usage;
      }, {});
    }
    module2.exports.agents = Object.keys(agentsData).reduce((map3, key) => {
      let versionsData = agentsData[key];
      map3[browsers[key]] = Object.keys(versionsData).reduce((data2, entry2) => {
        if (entry2 === "A") {
          data2.usage_global = unpackBrowserVersions(versionsData[entry2]);
        } else if (entry2 === "C") {
          data2.versions = versionsData[entry2].reduce((list, version4) => {
            if (version4 === "") {
              list.push(null);
            } else {
              list.push(versions[version4]);
            }
            return list;
          }, []);
        } else if (entry2 === "D") {
          data2.prefix_exceptions = unpackBrowserVersions(versionsData[entry2]);
        } else if (entry2 === "E") {
          data2.browser = versionsData[entry2];
        } else if (entry2 === "F") {
          data2.release_date = Object.keys(versionsData[entry2]).reduce(
            (map22, key2) => {
              map22[versions[key2]] = versionsData[entry2][key2];
              return map22;
            },
            {}
          );
        } else {
          data2.prefix = versionsData[entry2];
        }
        return data2;
      }, {});
      return map3;
    }, {});
  }
});

// node_modules/.pnpm/node-releases@2.0.10/node_modules/node-releases/data/release-schedule/release-schedule.json
var require_release_schedule = __commonJS({
  "node_modules/.pnpm/node-releases@2.0.10/node_modules/node-releases/data/release-schedule/release-schedule.json"(exports3, module2) {
    module2.exports = { "v0.8": { start: "2012-06-25", end: "2014-07-31" }, "v0.10": { start: "2013-03-11", end: "2016-10-31" }, "v0.12": { start: "2015-02-06", end: "2016-12-31" }, v4: { start: "2015-09-08", lts: "2015-10-12", maintenance: "2017-04-01", end: "2018-04-30", codename: "Argon" }, v5: { start: "2015-10-29", maintenance: "2016-04-30", end: "2016-06-30" }, v6: { start: "2016-04-26", lts: "2016-10-18", maintenance: "2018-04-30", end: "2019-04-30", codename: "Boron" }, v7: { start: "2016-10-25", maintenance: "2017-04-30", end: "2017-06-30" }, v8: { start: "2017-05-30", lts: "2017-10-31", maintenance: "2019-01-01", end: "2019-12-31", codename: "Carbon" }, v9: { start: "2017-10-01", maintenance: "2018-04-01", end: "2018-06-30" }, v10: { start: "2018-04-24", lts: "2018-10-30", maintenance: "2020-05-19", end: "2021-04-30", codename: "Dubnium" }, v11: { start: "2018-10-23", maintenance: "2019-04-22", end: "2019-06-01" }, v12: { start: "2019-04-23", lts: "2019-10-21", maintenance: "2020-11-30", end: "2022-04-30", codename: "Erbium" }, v13: { start: "2019-10-22", maintenance: "2020-04-01", end: "2020-06-01" }, v14: { start: "2020-04-21", lts: "2020-10-27", maintenance: "2021-10-19", end: "2023-04-30", codename: "Fermium" }, v15: { start: "2020-10-20", maintenance: "2021-04-01", end: "2021-06-01" }, v16: { start: "2021-04-20", lts: "2021-10-26", maintenance: "2022-10-18", end: "2023-09-11", codename: "Gallium" }, v17: { start: "2021-10-19", maintenance: "2022-04-01", end: "2022-06-01" }, v18: { start: "2022-04-19", lts: "2022-10-25", maintenance: "2023-10-18", end: "2025-04-30", codename: "Hydrogen" }, v19: { start: "2022-10-18", maintenance: "2023-04-01", end: "2023-06-01" }, v20: { start: "2023-04-18", lts: "2023-10-24", maintenance: "2024-10-22", end: "2026-04-30", codename: "" } };
  }
});

// node_modules/.pnpm/electron-to-chromium@1.4.385/node_modules/electron-to-chromium/versions.js
var require_versions = __commonJS({
  "node_modules/.pnpm/electron-to-chromium@1.4.385/node_modules/electron-to-chromium/versions.js"(exports3, module2) {
    module2.exports = {
      "0.20": "39",
      "0.21": "41",
      "0.22": "41",
      "0.23": "41",
      "0.24": "41",
      "0.25": "42",
      "0.26": "42",
      "0.27": "43",
      "0.28": "43",
      "0.29": "43",
      "0.30": "44",
      "0.31": "45",
      "0.32": "45",
      "0.33": "45",
      "0.34": "45",
      "0.35": "45",
      "0.36": "47",
      "0.37": "49",
      "1.0": "49",
      "1.1": "50",
      "1.2": "51",
      "1.3": "52",
      "1.4": "53",
      "1.5": "54",
      "1.6": "56",
      "1.7": "58",
      "1.8": "59",
      "2.0": "61",
      "2.1": "61",
      "3.0": "66",
      "3.1": "66",
      "4.0": "69",
      "4.1": "69",
      "4.2": "69",
      "5.0": "73",
      "6.0": "76",
      "6.1": "76",
      "7.0": "78",
      "7.1": "78",
      "7.2": "78",
      "7.3": "78",
      "8.0": "80",
      "8.1": "80",
      "8.2": "80",
      "8.3": "80",
      "8.4": "80",
      "8.5": "80",
      "9.0": "83",
      "9.1": "83",
      "9.2": "83",
      "9.3": "83",
      "9.4": "83",
      "10.0": "85",
      "10.1": "85",
      "10.2": "85",
      "10.3": "85",
      "10.4": "85",
      "11.0": "87",
      "11.1": "87",
      "11.2": "87",
      "11.3": "87",
      "11.4": "87",
      "11.5": "87",
      "12.0": "89",
      "12.1": "89",
      "12.2": "89",
      "13.0": "91",
      "13.1": "91",
      "13.2": "91",
      "13.3": "91",
      "13.4": "91",
      "13.5": "91",
      "13.6": "91",
      "14.0": "93",
      "14.1": "93",
      "14.2": "93",
      "15.0": "94",
      "15.1": "94",
      "15.2": "94",
      "15.3": "94",
      "15.4": "94",
      "15.5": "94",
      "16.0": "96",
      "16.1": "96",
      "16.2": "96",
      "17.0": "98",
      "17.1": "98",
      "17.2": "98",
      "17.3": "98",
      "17.4": "98",
      "18.0": "100",
      "18.1": "100",
      "18.2": "100",
      "18.3": "100",
      "19.0": "102",
      "19.1": "102",
      "20.0": "104",
      "20.1": "104",
      "20.2": "104",
      "20.3": "104",
      "21.0": "106",
      "21.1": "106",
      "21.2": "106",
      "21.3": "106",
      "21.4": "106",
      "22.0": "108",
      "22.1": "108",
      "22.2": "108",
      "22.3": "108",
      "23.0": "110",
      "23.1": "110",
      "23.2": "110",
      "23.3": "110",
      "24.0": "112",
      "24.1": "112",
      "24.2": "112",
      "25.0": "114"
    };
  }
});

// node_modules/.pnpm/browserslist@4.21.5/node_modules/browserslist/error.js
var require_error2 = __commonJS({
  "node_modules/.pnpm/browserslist@4.21.5/node_modules/browserslist/error.js"(exports3, module2) {
    function BrowserslistError(message) {
      this.name = "BrowserslistError";
      this.message = message;
      this.browserslist = true;
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, BrowserslistError);
      }
    }
    BrowserslistError.prototype = Error.prototype;
    module2.exports = BrowserslistError;
  }
});

// node_modules/.pnpm/browserslist@4.21.5/node_modules/browserslist/parse.js
var require_parse3 = __commonJS({
  "node_modules/.pnpm/browserslist@4.21.5/node_modules/browserslist/parse.js"(exports3, module2) {
    var AND_REGEXP = /^\s+and\s+(.*)/i;
    var OR_REGEXP = /^(?:,\s*|\s+or\s+)(.*)/i;
    function flatten2(array2) {
      if (!Array.isArray(array2))
        return [array2];
      return array2.reduce(function(a2, b) {
        return a2.concat(flatten2(b));
      }, []);
    }
    function find2(string3, predicate) {
      for (var n3 = 1, max = string3.length; n3 <= max; n3++) {
        var parsed = string3.substr(-n3, n3);
        if (predicate(parsed, n3, max)) {
          return string3.slice(0, -n3);
        }
      }
      return "";
    }
    function matchQuery(all, query) {
      var node3 = { query };
      if (query.indexOf("not ") === 0) {
        node3.not = true;
        query = query.slice(4);
      }
      for (var name2 in all) {
        var type = all[name2];
        var match = query.match(type.regexp);
        if (match) {
          node3.type = name2;
          for (var i2 = 0; i2 < type.matches.length; i2++) {
            node3[type.matches[i2]] = match[i2 + 1];
          }
          return node3;
        }
      }
      node3.type = "unknown";
      return node3;
    }
    function matchBlock(all, string3, qs2) {
      var node3;
      return find2(string3, function(parsed, n3, max) {
        if (AND_REGEXP.test(parsed)) {
          node3 = matchQuery(all, parsed.match(AND_REGEXP)[1]);
          node3.compose = "and";
          qs2.unshift(node3);
          return true;
        } else if (OR_REGEXP.test(parsed)) {
          node3 = matchQuery(all, parsed.match(OR_REGEXP)[1]);
          node3.compose = "or";
          qs2.unshift(node3);
          return true;
        } else if (n3 === max) {
          node3 = matchQuery(all, parsed.trim());
          node3.compose = "or";
          qs2.unshift(node3);
          return true;
        }
        return false;
      });
    }
    module2.exports = function parse7(all, queries) {
      if (!Array.isArray(queries))
        queries = [queries];
      return flatten2(
        queries.map(function(block) {
          var qs2 = [];
          do {
            block = matchBlock(all, block, qs2);
          } while (block);
          return qs2;
        })
      );
    };
  }
});

// node_modules/.pnpm/browserslist@4.21.5/node_modules/browserslist/browser.js
var require_browser3 = __commonJS({
  "node_modules/.pnpm/browserslist@4.21.5/node_modules/browserslist/browser.js"(exports3, module2) {
    var BrowserslistError = require_error2();
    function noop2() {
    }
    module2.exports = {
      loadQueries: function loadQueries() {
        throw new BrowserslistError(
          "Sharable configs are not supported in client-side build of Browserslist"
        );
      },
      getStat: function getStat(opts) {
        return opts.stats;
      },
      loadConfig: function loadConfig(opts) {
        if (opts.config) {
          throw new BrowserslistError(
            "Browserslist config are not supported in client-side build"
          );
        }
      },
      loadCountry: function loadCountry() {
        throw new BrowserslistError(
          "Country statistics are not supported in client-side build of Browserslist"
        );
      },
      loadFeature: function loadFeature() {
        throw new BrowserslistError(
          "Supports queries are not available in client-side build of Browserslist"
        );
      },
      currentNode: function currentNode(resolve4, context) {
        return resolve4(["maintained node versions"], context)[0];
      },
      parseConfig: noop2,
      readConfig: noop2,
      findConfig: noop2,
      clearCaches: noop2,
      oldDataWarning: noop2,
      env: {}
    };
  }
});

// node_modules/.pnpm/browserslist@4.21.5/node_modules/browserslist/index.js
var require_browserslist = __commonJS({
  "node_modules/.pnpm/browserslist@4.21.5/node_modules/browserslist/index.js"(exports3, module2) {
    var jsReleases = require_envs();
    var agents = require_agents2().agents;
    var jsEOL = require_release_schedule();
    var path8 = require_path();
    var e2c = require_versions();
    var BrowserslistError = require_error2();
    var parse7 = require_parse3();
    var env2 = require_browser3();
    var YEAR = 365.259641 * 24 * 60 * 60 * 1e3;
    var ANDROID_EVERGREEN_FIRST = 37;
    function isVersionsMatch(versionA, versionB) {
      return (versionA + ".").indexOf(versionB + ".") === 0;
    }
    function isEolReleased(name2) {
      var version4 = name2.slice(1);
      return browserslist.nodeVersions.some(function(i2) {
        return isVersionsMatch(i2, version4);
      });
    }
    function normalize2(versions) {
      return versions.filter(function(version4) {
        return typeof version4 === "string";
      });
    }
    function normalizeElectron(version4) {
      var versionToUse = version4;
      if (version4.split(".").length === 3) {
        versionToUse = version4.split(".").slice(0, -1).join(".");
      }
      return versionToUse;
    }
    function nameMapper(name2) {
      return function mapName(version4) {
        return name2 + " " + version4;
      };
    }
    function getMajor(version4) {
      return parseInt(version4.split(".")[0]);
    }
    function getMajorVersions(released, number) {
      if (released.length === 0)
        return [];
      var majorVersions = uniq(released.map(getMajor));
      var minimum = majorVersions[majorVersions.length - number];
      if (!minimum) {
        return released;
      }
      var selected = [];
      for (var i2 = released.length - 1; i2 >= 0; i2--) {
        if (minimum > getMajor(released[i2]))
          break;
        selected.unshift(released[i2]);
      }
      return selected;
    }
    function uniq(array2) {
      var filtered = [];
      for (var i2 = 0; i2 < array2.length; i2++) {
        if (filtered.indexOf(array2[i2]) === -1)
          filtered.push(array2[i2]);
      }
      return filtered;
    }
    function fillUsage(result, name2, data2) {
      for (var i2 in data2) {
        result[name2 + " " + i2] = data2[i2];
      }
    }
    function generateFilter(sign, version4) {
      version4 = parseFloat(version4);
      if (sign === ">") {
        return function(v) {
          return parseFloat(v) > version4;
        };
      } else if (sign === ">=") {
        return function(v) {
          return parseFloat(v) >= version4;
        };
      } else if (sign === "<") {
        return function(v) {
          return parseFloat(v) < version4;
        };
      } else {
        return function(v) {
          return parseFloat(v) <= version4;
        };
      }
    }
    function generateSemverFilter(sign, version4) {
      version4 = version4.split(".").map(parseSimpleInt);
      version4[1] = version4[1] || 0;
      version4[2] = version4[2] || 0;
      if (sign === ">") {
        return function(v) {
          v = v.split(".").map(parseSimpleInt);
          return compareSemver(v, version4) > 0;
        };
      } else if (sign === ">=") {
        return function(v) {
          v = v.split(".").map(parseSimpleInt);
          return compareSemver(v, version4) >= 0;
        };
      } else if (sign === "<") {
        return function(v) {
          v = v.split(".").map(parseSimpleInt);
          return compareSemver(version4, v) > 0;
        };
      } else {
        return function(v) {
          v = v.split(".").map(parseSimpleInt);
          return compareSemver(version4, v) >= 0;
        };
      }
    }
    function parseSimpleInt(x) {
      return parseInt(x);
    }
    function compare2(a2, b) {
      if (a2 < b)
        return -1;
      if (a2 > b)
        return 1;
      return 0;
    }
    function compareSemver(a2, b) {
      return compare2(parseInt(a2[0]), parseInt(b[0])) || compare2(parseInt(a2[1] || "0"), parseInt(b[1] || "0")) || compare2(parseInt(a2[2] || "0"), parseInt(b[2] || "0"));
    }
    function semverFilterLoose(operator, range2) {
      range2 = range2.split(".").map(parseSimpleInt);
      if (typeof range2[1] === "undefined") {
        range2[1] = "x";
      }
      switch (operator) {
        case "<=":
          return function(version4) {
            version4 = version4.split(".").map(parseSimpleInt);
            return compareSemverLoose(version4, range2) <= 0;
          };
        case ">=":
        default:
          return function(version4) {
            version4 = version4.split(".").map(parseSimpleInt);
            return compareSemverLoose(version4, range2) >= 0;
          };
      }
    }
    function compareSemverLoose(version4, range2) {
      if (version4[0] !== range2[0]) {
        return version4[0] < range2[0] ? -1 : 1;
      }
      if (range2[1] === "x") {
        return 0;
      }
      if (version4[1] !== range2[1]) {
        return version4[1] < range2[1] ? -1 : 1;
      }
      return 0;
    }
    function resolveVersion(data2, version4) {
      if (data2.versions.indexOf(version4) !== -1) {
        return version4;
      } else if (browserslist.versionAliases[data2.name][version4]) {
        return browserslist.versionAliases[data2.name][version4];
      } else {
        return false;
      }
    }
    function normalizeVersion(data2, version4) {
      var resolved = resolveVersion(data2, version4);
      if (resolved) {
        return resolved;
      } else if (data2.versions.length === 1) {
        return data2.versions[0];
      } else {
        return false;
      }
    }
    function filterByYear(since, context) {
      since = since / 1e3;
      return Object.keys(agents).reduce(function(selected, name2) {
        var data2 = byName(name2, context);
        if (!data2)
          return selected;
        var versions = Object.keys(data2.releaseDate).filter(function(v) {
          var date = data2.releaseDate[v];
          return date !== null && date >= since;
        });
        return selected.concat(versions.map(nameMapper(data2.name)));
      }, []);
    }
    function cloneData(data2) {
      return {
        name: data2.name,
        versions: data2.versions,
        released: data2.released,
        releaseDate: data2.releaseDate
      };
    }
    function mapVersions(data2, map3) {
      data2.versions = data2.versions.map(function(i3) {
        return map3[i3] || i3;
      });
      data2.released = data2.released.map(function(i3) {
        return map3[i3] || i3;
      });
      var fixedDate = {};
      for (var i2 in data2.releaseDate) {
        fixedDate[map3[i2] || i2] = data2.releaseDate[i2];
      }
      data2.releaseDate = fixedDate;
      return data2;
    }
    function byName(name2, context) {
      name2 = name2.toLowerCase();
      name2 = browserslist.aliases[name2] || name2;
      if (context.mobileToDesktop && browserslist.desktopNames[name2]) {
        var desktop = browserslist.data[browserslist.desktopNames[name2]];
        if (name2 === "android") {
          return normalizeAndroidData(cloneData(browserslist.data[name2]), desktop);
        } else {
          var cloned = cloneData(desktop);
          cloned.name = name2;
          if (name2 === "op_mob") {
            cloned = mapVersions(cloned, { "10.0-10.1": "10" });
          }
          return cloned;
        }
      }
      return browserslist.data[name2];
    }
    function normalizeAndroidVersions(androidVersions, chromeVersions) {
      var firstEvergreen = ANDROID_EVERGREEN_FIRST;
      var last = chromeVersions[chromeVersions.length - 1];
      return androidVersions.filter(function(version4) {
        return /^(?:[2-4]\.|[34]$)/.test(version4);
      }).concat(chromeVersions.slice(firstEvergreen - last - 1));
    }
    function normalizeAndroidData(android, chrome2) {
      android.released = normalizeAndroidVersions(android.released, chrome2.released);
      android.versions = normalizeAndroidVersions(android.versions, chrome2.versions);
      return android;
    }
    function checkName(name2, context) {
      var data2 = byName(name2, context);
      if (!data2)
        throw new BrowserslistError("Unknown browser " + name2);
      return data2;
    }
    function unknownQuery(query) {
      return new BrowserslistError(
        "Unknown browser query `" + query + "`. Maybe you are using old Browserslist or made typo in query."
      );
    }
    function filterAndroid(list, versions, context) {
      if (context.mobileToDesktop)
        return list;
      var released = browserslist.data.android.released;
      var last = released[released.length - 1];
      var diff = last - ANDROID_EVERGREEN_FIRST - versions;
      if (diff > 0) {
        return list.slice(-1);
      } else {
        return list.slice(diff - 1);
      }
    }
    function resolve4(queries, context) {
      return parse7(QUERIES, queries).reduce(function(result, node3, index2) {
        if (node3.not && index2 === 0) {
          throw new BrowserslistError(
            "Write any browsers query (for instance, `defaults`) before `" + node3.query + "`"
          );
        }
        var type = QUERIES[node3.type];
        var array2 = type.select.call(browserslist, context, node3).map(function(j) {
          var parts = j.split(" ");
          if (parts[1] === "0") {
            return parts[0] + " " + byName(parts[0], context).versions[0];
          } else {
            return j;
          }
        });
        if (node3.compose === "and") {
          if (node3.not) {
            return result.filter(function(j) {
              return array2.indexOf(j) === -1;
            });
          } else {
            return result.filter(function(j) {
              return array2.indexOf(j) !== -1;
            });
          }
        } else {
          if (node3.not) {
            var filter2 = {};
            array2.forEach(function(j) {
              filter2[j] = true;
            });
            return result.filter(function(j) {
              return !filter2[j];
            });
          }
          return result.concat(array2);
        }
      }, []);
    }
    function prepareOpts(opts) {
      if (typeof opts === "undefined")
        opts = {};
      if (typeof opts.path === "undefined") {
        opts.path = path8.resolve ? path8.resolve(".") : ".";
      }
      return opts;
    }
    function prepareQueries(queries, opts) {
      if (typeof queries === "undefined" || queries === null) {
        var config2 = browserslist.loadConfig(opts);
        if (config2) {
          queries = config2;
        } else {
          queries = browserslist.defaults;
        }
      }
      return queries;
    }
    function checkQueries(queries) {
      if (!(typeof queries === "string" || Array.isArray(queries))) {
        throw new BrowserslistError(
          "Browser queries must be an array or string. Got " + typeof queries + "."
        );
      }
    }
    var cache2 = {};
    function browserslist(queries, opts) {
      opts = prepareOpts(opts);
      queries = prepareQueries(queries, opts);
      checkQueries(queries);
      var context = {
        ignoreUnknownVersions: opts.ignoreUnknownVersions,
        dangerousExtend: opts.dangerousExtend,
        mobileToDesktop: opts.mobileToDesktop,
        path: opts.path,
        env: opts.env
      };
      env2.oldDataWarning(browserslist.data);
      var stats = env2.getStat(opts, browserslist.data);
      if (stats) {
        context.customUsage = {};
        for (var browser3 in stats) {
          fillUsage(context.customUsage, browser3, stats[browser3]);
        }
      }
      var cacheKey = JSON.stringify([queries, context]);
      if (cache2[cacheKey])
        return cache2[cacheKey];
      var result = uniq(resolve4(queries, context)).sort(function(name1, name2) {
        name1 = name1.split(" ");
        name2 = name2.split(" ");
        if (name1[0] === name2[0]) {
          var version1 = name1[1].split("-")[0];
          var version22 = name2[1].split("-")[0];
          return compareSemver(version22.split("."), version1.split("."));
        } else {
          return compare2(name1[0], name2[0]);
        }
      });
      if (!env2.env.BROWSERSLIST_DISABLE_CACHE) {
        cache2[cacheKey] = result;
      }
      return result;
    }
    browserslist.parse = function(queries, opts) {
      opts = prepareOpts(opts);
      queries = prepareQueries(queries, opts);
      checkQueries(queries);
      return parse7(QUERIES, queries);
    };
    browserslist.cache = {};
    browserslist.data = {};
    browserslist.usage = {
      global: {},
      custom: null
    };
    browserslist.defaults = ["> 0.5%", "last 2 versions", "Firefox ESR", "not dead"];
    browserslist.aliases = {
      fx: "firefox",
      ff: "firefox",
      ios: "ios_saf",
      explorer: "ie",
      blackberry: "bb",
      explorermobile: "ie_mob",
      operamini: "op_mini",
      operamobile: "op_mob",
      chromeandroid: "and_chr",
      firefoxandroid: "and_ff",
      ucandroid: "and_uc",
      qqandroid: "and_qq"
    };
    browserslist.desktopNames = {
      and_chr: "chrome",
      and_ff: "firefox",
      ie_mob: "ie",
      op_mob: "opera",
      android: "chrome"
      // has extra processing logic
    };
    browserslist.versionAliases = {};
    browserslist.clearCaches = env2.clearCaches;
    browserslist.parseConfig = env2.parseConfig;
    browserslist.readConfig = env2.readConfig;
    browserslist.findConfig = env2.findConfig;
    browserslist.loadConfig = env2.loadConfig;
    browserslist.coverage = function(browsers, stats) {
      var data2;
      if (typeof stats === "undefined") {
        data2 = browserslist.usage.global;
      } else if (stats === "my stats") {
        var opts = {};
        opts.path = path8.resolve ? path8.resolve(".") : ".";
        var customStats = env2.getStat(opts);
        if (!customStats) {
          throw new BrowserslistError("Custom usage statistics was not provided");
        }
        data2 = {};
        for (var browser3 in customStats) {
          fillUsage(data2, browser3, customStats[browser3]);
        }
      } else if (typeof stats === "string") {
        if (stats.length > 2) {
          stats = stats.toLowerCase();
        } else {
          stats = stats.toUpperCase();
        }
        env2.loadCountry(browserslist.usage, stats, browserslist.data);
        data2 = browserslist.usage[stats];
      } else {
        if ("dataByBrowser" in stats) {
          stats = stats.dataByBrowser;
        }
        data2 = {};
        for (var name2 in stats) {
          for (var version4 in stats[name2]) {
            data2[name2 + " " + version4] = stats[name2][version4];
          }
        }
      }
      return browsers.reduce(function(all, i2) {
        var usage = data2[i2];
        if (usage === void 0) {
          usage = data2[i2.replace(/ \S+$/, " 0")];
        }
        return all + (usage || 0);
      }, 0);
    };
    function nodeQuery(context, node3) {
      var matched = browserslist.nodeVersions.filter(function(i2) {
        return isVersionsMatch(i2, node3.version);
      });
      if (matched.length === 0) {
        if (context.ignoreUnknownVersions) {
          return [];
        } else {
          throw new BrowserslistError(
            "Unknown version " + node3.version + " of Node.js"
          );
        }
      }
      return ["node " + matched[matched.length - 1]];
    }
    function sinceQuery(context, node3) {
      var year = parseInt(node3.year);
      var month = parseInt(node3.month || "01") - 1;
      var day = parseInt(node3.day || "01");
      return filterByYear(Date.UTC(year, month, day, 0, 0, 0), context);
    }
    function coverQuery(context, node3) {
      var coverage = parseFloat(node3.coverage);
      var usage = browserslist.usage.global;
      if (node3.place) {
        if (node3.place.match(/^my\s+stats$/i)) {
          if (!context.customUsage) {
            throw new BrowserslistError("Custom usage statistics was not provided");
          }
          usage = context.customUsage;
        } else {
          var place;
          if (node3.place.length === 2) {
            place = node3.place.toUpperCase();
          } else {
            place = node3.place.toLowerCase();
          }
          env2.loadCountry(browserslist.usage, place, browserslist.data);
          usage = browserslist.usage[place];
        }
      }
      var versions = Object.keys(usage).sort(function(a2, b) {
        return usage[b] - usage[a2];
      });
      var coveraged = 0;
      var result = [];
      var version4;
      for (var i2 = 0; i2 < versions.length; i2++) {
        version4 = versions[i2];
        if (usage[version4] === 0)
          break;
        coveraged += usage[version4];
        result.push(version4);
        if (coveraged >= coverage)
          break;
      }
      return result;
    }
    var QUERIES = {
      last_major_versions: {
        matches: ["versions"],
        regexp: /^last\s+(\d+)\s+major\s+versions?$/i,
        select: function(context, node3) {
          return Object.keys(agents).reduce(function(selected, name2) {
            var data2 = byName(name2, context);
            if (!data2)
              return selected;
            var list = getMajorVersions(data2.released, node3.versions);
            list = list.map(nameMapper(data2.name));
            if (data2.name === "android") {
              list = filterAndroid(list, node3.versions, context);
            }
            return selected.concat(list);
          }, []);
        }
      },
      last_versions: {
        matches: ["versions"],
        regexp: /^last\s+(\d+)\s+versions?$/i,
        select: function(context, node3) {
          return Object.keys(agents).reduce(function(selected, name2) {
            var data2 = byName(name2, context);
            if (!data2)
              return selected;
            var list = data2.released.slice(-node3.versions);
            list = list.map(nameMapper(data2.name));
            if (data2.name === "android") {
              list = filterAndroid(list, node3.versions, context);
            }
            return selected.concat(list);
          }, []);
        }
      },
      last_electron_major_versions: {
        matches: ["versions"],
        regexp: /^last\s+(\d+)\s+electron\s+major\s+versions?$/i,
        select: function(context, node3) {
          var validVersions = getMajorVersions(Object.keys(e2c), node3.versions);
          return validVersions.map(function(i2) {
            return "chrome " + e2c[i2];
          });
        }
      },
      last_node_major_versions: {
        matches: ["versions"],
        regexp: /^last\s+(\d+)\s+node\s+major\s+versions?$/i,
        select: function(context, node3) {
          return getMajorVersions(browserslist.nodeVersions, node3.versions).map(
            function(version4) {
              return "node " + version4;
            }
          );
        }
      },
      last_browser_major_versions: {
        matches: ["versions", "browser"],
        regexp: /^last\s+(\d+)\s+(\w+)\s+major\s+versions?$/i,
        select: function(context, node3) {
          var data2 = checkName(node3.browser, context);
          var validVersions = getMajorVersions(data2.released, node3.versions);
          var list = validVersions.map(nameMapper(data2.name));
          if (data2.name === "android") {
            list = filterAndroid(list, node3.versions, context);
          }
          return list;
        }
      },
      last_electron_versions: {
        matches: ["versions"],
        regexp: /^last\s+(\d+)\s+electron\s+versions?$/i,
        select: function(context, node3) {
          return Object.keys(e2c).slice(-node3.versions).map(function(i2) {
            return "chrome " + e2c[i2];
          });
        }
      },
      last_node_versions: {
        matches: ["versions"],
        regexp: /^last\s+(\d+)\s+node\s+versions?$/i,
        select: function(context, node3) {
          return browserslist.nodeVersions.slice(-node3.versions).map(function(version4) {
            return "node " + version4;
          });
        }
      },
      last_browser_versions: {
        matches: ["versions", "browser"],
        regexp: /^last\s+(\d+)\s+(\w+)\s+versions?$/i,
        select: function(context, node3) {
          var data2 = checkName(node3.browser, context);
          var list = data2.released.slice(-node3.versions).map(nameMapper(data2.name));
          if (data2.name === "android") {
            list = filterAndroid(list, node3.versions, context);
          }
          return list;
        }
      },
      unreleased_versions: {
        matches: [],
        regexp: /^unreleased\s+versions$/i,
        select: function(context) {
          return Object.keys(agents).reduce(function(selected, name2) {
            var data2 = byName(name2, context);
            if (!data2)
              return selected;
            var list = data2.versions.filter(function(v) {
              return data2.released.indexOf(v) === -1;
            });
            list = list.map(nameMapper(data2.name));
            return selected.concat(list);
          }, []);
        }
      },
      unreleased_electron_versions: {
        matches: [],
        regexp: /^unreleased\s+electron\s+versions?$/i,
        select: function() {
          return [];
        }
      },
      unreleased_browser_versions: {
        matches: ["browser"],
        regexp: /^unreleased\s+(\w+)\s+versions?$/i,
        select: function(context, node3) {
          var data2 = checkName(node3.browser, context);
          return data2.versions.filter(function(v) {
            return data2.released.indexOf(v) === -1;
          }).map(nameMapper(data2.name));
        }
      },
      last_years: {
        matches: ["years"],
        regexp: /^last\s+(\d*.?\d+)\s+years?$/i,
        select: function(context, node3) {
          return filterByYear(Date.now() - YEAR * node3.years, context);
        }
      },
      since_y: {
        matches: ["year"],
        regexp: /^since (\d+)$/i,
        select: sinceQuery
      },
      since_y_m: {
        matches: ["year", "month"],
        regexp: /^since (\d+)-(\d+)$/i,
        select: sinceQuery
      },
      since_y_m_d: {
        matches: ["year", "month", "day"],
        regexp: /^since (\d+)-(\d+)-(\d+)$/i,
        select: sinceQuery
      },
      popularity: {
        matches: ["sign", "popularity"],
        regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%$/,
        select: function(context, node3) {
          var popularity = parseFloat(node3.popularity);
          var usage = browserslist.usage.global;
          return Object.keys(usage).reduce(function(result, version4) {
            if (node3.sign === ">") {
              if (usage[version4] > popularity) {
                result.push(version4);
              }
            } else if (node3.sign === "<") {
              if (usage[version4] < popularity) {
                result.push(version4);
              }
            } else if (node3.sign === "<=") {
              if (usage[version4] <= popularity) {
                result.push(version4);
              }
            } else if (usage[version4] >= popularity) {
              result.push(version4);
            }
            return result;
          }, []);
        }
      },
      popularity_in_my_stats: {
        matches: ["sign", "popularity"],
        regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+my\s+stats$/,
        select: function(context, node3) {
          var popularity = parseFloat(node3.popularity);
          if (!context.customUsage) {
            throw new BrowserslistError("Custom usage statistics was not provided");
          }
          var usage = context.customUsage;
          return Object.keys(usage).reduce(function(result, version4) {
            var percentage = usage[version4];
            if (percentage == null) {
              return result;
            }
            if (node3.sign === ">") {
              if (percentage > popularity) {
                result.push(version4);
              }
            } else if (node3.sign === "<") {
              if (percentage < popularity) {
                result.push(version4);
              }
            } else if (node3.sign === "<=") {
              if (percentage <= popularity) {
                result.push(version4);
              }
            } else if (percentage >= popularity) {
              result.push(version4);
            }
            return result;
          }, []);
        }
      },
      popularity_in_config_stats: {
        matches: ["sign", "popularity", "config"],
        regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+(\S+)\s+stats$/,
        select: function(context, node3) {
          var popularity = parseFloat(node3.popularity);
          var stats = env2.loadStat(context, node3.config, browserslist.data);
          if (stats) {
            context.customUsage = {};
            for (var browser3 in stats) {
              fillUsage(context.customUsage, browser3, stats[browser3]);
            }
          }
          if (!context.customUsage) {
            throw new BrowserslistError("Custom usage statistics was not provided");
          }
          var usage = context.customUsage;
          return Object.keys(usage).reduce(function(result, version4) {
            var percentage = usage[version4];
            if (percentage == null) {
              return result;
            }
            if (node3.sign === ">") {
              if (percentage > popularity) {
                result.push(version4);
              }
            } else if (node3.sign === "<") {
              if (percentage < popularity) {
                result.push(version4);
              }
            } else if (node3.sign === "<=") {
              if (percentage <= popularity) {
                result.push(version4);
              }
            } else if (percentage >= popularity) {
              result.push(version4);
            }
            return result;
          }, []);
        }
      },
      popularity_in_place: {
        matches: ["sign", "popularity", "place"],
        regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+((alt-)?\w\w)$/,
        select: function(context, node3) {
          var popularity = parseFloat(node3.popularity);
          var place = node3.place;
          if (place.length === 2) {
            place = place.toUpperCase();
          } else {
            place = place.toLowerCase();
          }
          env2.loadCountry(browserslist.usage, place, browserslist.data);
          var usage = browserslist.usage[place];
          return Object.keys(usage).reduce(function(result, version4) {
            var percentage = usage[version4];
            if (percentage == null) {
              return result;
            }
            if (node3.sign === ">") {
              if (percentage > popularity) {
                result.push(version4);
              }
            } else if (node3.sign === "<") {
              if (percentage < popularity) {
                result.push(version4);
              }
            } else if (node3.sign === "<=") {
              if (percentage <= popularity) {
                result.push(version4);
              }
            } else if (percentage >= popularity) {
              result.push(version4);
            }
            return result;
          }, []);
        }
      },
      cover: {
        matches: ["coverage"],
        regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%$/i,
        select: coverQuery
      },
      cover_in: {
        matches: ["coverage", "place"],
        regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%\s+in\s+(my\s+stats|(alt-)?\w\w)$/i,
        select: coverQuery
      },
      supports: {
        matches: ["feature"],
        regexp: /^supports\s+([\w-]+)$/,
        select: function(context, node3) {
          env2.loadFeature(browserslist.cache, node3.feature);
          var features = browserslist.cache[node3.feature];
          return Object.keys(features).reduce(function(result, version4) {
            var flags = features[version4];
            if (flags.indexOf("y") >= 0 || flags.indexOf("a") >= 0) {
              result.push(version4);
            }
            return result;
          }, []);
        }
      },
      electron_range: {
        matches: ["from", "to"],
        regexp: /^electron\s+([\d.]+)\s*-\s*([\d.]+)$/i,
        select: function(context, node3) {
          var fromToUse = normalizeElectron(node3.from);
          var toToUse = normalizeElectron(node3.to);
          var from = parseFloat(node3.from);
          var to = parseFloat(node3.to);
          if (!e2c[fromToUse]) {
            throw new BrowserslistError("Unknown version " + from + " of electron");
          }
          if (!e2c[toToUse]) {
            throw new BrowserslistError("Unknown version " + to + " of electron");
          }
          return Object.keys(e2c).filter(function(i2) {
            var parsed = parseFloat(i2);
            return parsed >= from && parsed <= to;
          }).map(function(i2) {
            return "chrome " + e2c[i2];
          });
        }
      },
      node_range: {
        matches: ["from", "to"],
        regexp: /^node\s+([\d.]+)\s*-\s*([\d.]+)$/i,
        select: function(context, node3) {
          return browserslist.nodeVersions.filter(semverFilterLoose(">=", node3.from)).filter(semverFilterLoose("<=", node3.to)).map(function(v) {
            return "node " + v;
          });
        }
      },
      browser_range: {
        matches: ["browser", "from", "to"],
        regexp: /^(\w+)\s+([\d.]+)\s*-\s*([\d.]+)$/i,
        select: function(context, node3) {
          var data2 = checkName(node3.browser, context);
          var from = parseFloat(normalizeVersion(data2, node3.from) || node3.from);
          var to = parseFloat(normalizeVersion(data2, node3.to) || node3.to);
          function filter2(v) {
            var parsed = parseFloat(v);
            return parsed >= from && parsed <= to;
          }
          return data2.released.filter(filter2).map(nameMapper(data2.name));
        }
      },
      electron_ray: {
        matches: ["sign", "version"],
        regexp: /^electron\s*(>=?|<=?)\s*([\d.]+)$/i,
        select: function(context, node3) {
          var versionToUse = normalizeElectron(node3.version);
          return Object.keys(e2c).filter(generateFilter(node3.sign, versionToUse)).map(function(i2) {
            return "chrome " + e2c[i2];
          });
        }
      },
      node_ray: {
        matches: ["sign", "version"],
        regexp: /^node\s*(>=?|<=?)\s*([\d.]+)$/i,
        select: function(context, node3) {
          return browserslist.nodeVersions.filter(generateSemverFilter(node3.sign, node3.version)).map(function(v) {
            return "node " + v;
          });
        }
      },
      browser_ray: {
        matches: ["browser", "sign", "version"],
        regexp: /^(\w+)\s*(>=?|<=?)\s*([\d.]+)$/,
        select: function(context, node3) {
          var version4 = node3.version;
          var data2 = checkName(node3.browser, context);
          var alias2 = browserslist.versionAliases[data2.name][version4];
          if (alias2)
            version4 = alias2;
          return data2.released.filter(generateFilter(node3.sign, version4)).map(function(v) {
            return data2.name + " " + v;
          });
        }
      },
      firefox_esr: {
        matches: [],
        regexp: /^(firefox|ff|fx)\s+esr$/i,
        select: function() {
          return ["firefox 102"];
        }
      },
      opera_mini_all: {
        matches: [],
        regexp: /(operamini|op_mini)\s+all/i,
        select: function() {
          return ["op_mini all"];
        }
      },
      electron_version: {
        matches: ["version"],
        regexp: /^electron\s+([\d.]+)$/i,
        select: function(context, node3) {
          var versionToUse = normalizeElectron(node3.version);
          var chrome2 = e2c[versionToUse];
          if (!chrome2) {
            throw new BrowserslistError(
              "Unknown version " + node3.version + " of electron"
            );
          }
          return ["chrome " + chrome2];
        }
      },
      node_major_version: {
        matches: ["version"],
        regexp: /^node\s+(\d+)$/i,
        select: nodeQuery
      },
      node_minor_version: {
        matches: ["version"],
        regexp: /^node\s+(\d+\.\d+)$/i,
        select: nodeQuery
      },
      node_patch_version: {
        matches: ["version"],
        regexp: /^node\s+(\d+\.\d+\.\d+)$/i,
        select: nodeQuery
      },
      current_node: {
        matches: [],
        regexp: /^current\s+node$/i,
        select: function(context) {
          return [env2.currentNode(resolve4, context)];
        }
      },
      maintained_node: {
        matches: [],
        regexp: /^maintained\s+node\s+versions$/i,
        select: function(context) {
          var now = Date.now();
          var queries = Object.keys(jsEOL).filter(function(key) {
            return now < Date.parse(jsEOL[key].end) && now > Date.parse(jsEOL[key].start) && isEolReleased(key);
          }).map(function(key) {
            return "node " + key.slice(1);
          });
          return resolve4(queries, context);
        }
      },
      phantomjs_1_9: {
        matches: [],
        regexp: /^phantomjs\s+1.9$/i,
        select: function() {
          return ["safari 5"];
        }
      },
      phantomjs_2_1: {
        matches: [],
        regexp: /^phantomjs\s+2.1$/i,
        select: function() {
          return ["safari 6"];
        }
      },
      browser_version: {
        matches: ["browser", "version"],
        regexp: /^(\w+)\s+(tp|[\d.]+)$/i,
        select: function(context, node3) {
          var version4 = node3.version;
          if (/^tp$/i.test(version4))
            version4 = "TP";
          var data2 = checkName(node3.browser, context);
          var alias2 = normalizeVersion(data2, version4);
          if (alias2) {
            version4 = alias2;
          } else {
            if (version4.indexOf(".") === -1) {
              alias2 = version4 + ".0";
            } else {
              alias2 = version4.replace(/\.0$/, "");
            }
            alias2 = normalizeVersion(data2, alias2);
            if (alias2) {
              version4 = alias2;
            } else if (context.ignoreUnknownVersions) {
              return [];
            } else {
              throw new BrowserslistError(
                "Unknown version " + version4 + " of " + node3.browser
              );
            }
          }
          return [data2.name + " " + version4];
        }
      },
      browserslist_config: {
        matches: [],
        regexp: /^browserslist config$/i,
        select: function(context) {
          return browserslist(void 0, context);
        }
      },
      extends: {
        matches: ["config"],
        regexp: /^extends (.+)$/i,
        select: function(context, node3) {
          return resolve4(env2.loadQueries(context, node3.config), context);
        }
      },
      defaults: {
        matches: [],
        regexp: /^defaults$/i,
        select: function(context) {
          return resolve4(browserslist.defaults, context);
        }
      },
      dead: {
        matches: [],
        regexp: /^dead$/i,
        select: function(context) {
          var dead = [
            "Baidu >= 0",
            "ie <= 11",
            "ie_mob <= 11",
            "bb <= 10",
            "op_mob <= 12.1",
            "samsung 4"
          ];
          return resolve4(dead, context);
        }
      },
      unknown: {
        matches: [],
        regexp: /^(\w+)$/i,
        select: function(context, node3) {
          if (byName(node3.query, context)) {
            throw new BrowserslistError(
              "Specify versions in Browserslist query for browser " + node3.query
            );
          } else {
            throw unknownQuery(node3.query);
          }
        }
      }
    };
    (function() {
      for (var name2 in agents) {
        var browser3 = agents[name2];
        browserslist.data[name2] = {
          name: name2,
          versions: normalize2(agents[name2].versions),
          released: normalize2(agents[name2].versions.slice(0, -3)),
          releaseDate: agents[name2].release_date
        };
        fillUsage(browserslist.usage.global, name2, browser3.usage_global);
        browserslist.versionAliases[name2] = {};
        for (var i2 = 0; i2 < browser3.versions.length; i2++) {
          var full = browser3.versions[i2];
          if (!full)
            continue;
          if (full.indexOf("-") !== -1) {
            var interval = full.split("-");
            for (var j = 0; j < interval.length; j++) {
              browserslist.versionAliases[name2][interval[j]] = full;
            }
          }
        }
      }
      browserslist.versionAliases.op_mob["59"] = "58";
      browserslist.nodeVersions = jsReleases.map(function(release) {
        return release.version;
      });
    })();
    module2.exports = browserslist;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/utils.js
var require_utils7 = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/utils.js"(exports3, module2) {
    var { list } = require_postcss();
    module2.exports.error = function(text) {
      let err2 = new Error(text);
      err2.autoprefixer = true;
      throw err2;
    };
    module2.exports.uniq = function(array2) {
      return [...new Set(array2)];
    };
    module2.exports.removeNote = function(string3) {
      if (!string3.includes(" ")) {
        return string3;
      }
      return string3.split(" ")[0];
    };
    module2.exports.escapeRegexp = function(string3) {
      return string3.replace(/[$()*+-.?[\\\]^{|}]/g, "\\$&");
    };
    module2.exports.regexp = function(word, escape2 = true) {
      if (escape2) {
        word = this.escapeRegexp(word);
      }
      return new RegExp(`(^|[\\s,(])(${word}($|[\\s(,]))`, "gi");
    };
    module2.exports.editList = function(value2, callback) {
      let origin = list.comma(value2);
      let changed = callback(origin, []);
      if (origin === changed) {
        return value2;
      }
      let join2 = value2.match(/,\s*/);
      join2 = join2 ? join2[0] : ", ";
      return changed.join(join2);
    };
    module2.exports.splitSelector = function(selector) {
      return list.comma(selector).map((i2) => {
        return list.space(i2).map((k) => {
          return k.split(/(?=\.|#)/g);
        });
      });
    };
    module2.exports.isPureNumber = function(value2) {
      if (typeof value2 === "number") {
        return true;
      }
      if (typeof value2 === "string") {
        return /^[0-9]+$/.test(value2);
      }
      return false;
    };
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/browsers.js
var require_browsers3 = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/browsers.js"(exports3, module2) {
    var browserslist = require_browserslist();
    var { agents } = require_agents2();
    var utils2 = require_utils7();
    var Browsers = class {
      /**
       * Return all prefixes for default browser data
       */
      static prefixes() {
        if (this.prefixesCache) {
          return this.prefixesCache;
        }
        this.prefixesCache = [];
        for (let name2 in agents) {
          this.prefixesCache.push(`-${agents[name2].prefix}-`);
        }
        this.prefixesCache = utils2.uniq(this.prefixesCache).sort((a2, b) => b.length - a2.length);
        return this.prefixesCache;
      }
      /**
       * Check is value contain any possible prefix
       */
      static withPrefix(value2) {
        if (!this.prefixesRegexp) {
          this.prefixesRegexp = new RegExp(this.prefixes().join("|"));
        }
        return this.prefixesRegexp.test(value2);
      }
      constructor(data2, requirements, options3, browserslistOpts) {
        this.data = data2;
        this.options = options3 || {};
        this.browserslistOpts = browserslistOpts || {};
        this.selected = this.parse(requirements);
      }
      /**
       * Return browsers selected by requirements
       */
      parse(requirements) {
        let opts = {};
        for (let i2 in this.browserslistOpts) {
          opts[i2] = this.browserslistOpts[i2];
        }
        opts.path = this.options.from;
        return browserslist(requirements, opts);
      }
      /**
       * Return prefix for selected browser
       */
      prefix(browser3) {
        let [name2, version4] = browser3.split(" ");
        let data2 = this.data[name2];
        let prefix = data2.prefix_exceptions && data2.prefix_exceptions[version4];
        if (!prefix) {
          prefix = data2.prefix;
        }
        return `-${prefix}-`;
      }
      /**
       * Is browser is selected by requirements
       */
      isSelected(browser3) {
        return this.selected.includes(browser3);
      }
    };
    module2.exports = Browsers;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/vendor.js
var require_vendor = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/vendor.js"(exports3, module2) {
    module2.exports = {
      prefix(prop) {
        let match = prop.match(/^(-\w+-)/);
        if (match) {
          return match[0];
        }
        return "";
      },
      unprefixed(prop) {
        return prop.replace(/^-\w+-/, "");
      }
    };
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/prefixer.js
var require_prefixer = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/prefixer.js"(exports3, module2) {
    var Browsers = require_browsers3();
    var vendor = require_vendor();
    var utils2 = require_utils7();
    function clone(obj, parent) {
      let cloned = new obj.constructor();
      for (let i2 of Object.keys(obj || {})) {
        let value2 = obj[i2];
        if (i2 === "parent" && typeof value2 === "object") {
          if (parent) {
            cloned[i2] = parent;
          }
        } else if (i2 === "source" || i2 === null) {
          cloned[i2] = value2;
        } else if (Array.isArray(value2)) {
          cloned[i2] = value2.map((x) => clone(x, cloned));
        } else if (i2 !== "_autoprefixerPrefix" && i2 !== "_autoprefixerValues" && i2 !== "proxyCache") {
          if (typeof value2 === "object" && value2 !== null) {
            value2 = clone(value2, cloned);
          }
          cloned[i2] = value2;
        }
      }
      return cloned;
    }
    var Prefixer = class {
      /**
       * Add hack to selected names
       */
      static hack(klass) {
        if (!this.hacks) {
          this.hacks = {};
        }
        return klass.names.map((name2) => {
          this.hacks[name2] = klass;
          return this.hacks[name2];
        });
      }
      /**
       * Load hacks for some names
       */
      static load(name2, prefixes, all) {
        let Klass = this.hacks && this.hacks[name2];
        if (Klass) {
          return new Klass(name2, prefixes, all);
        } else {
          return new this(name2, prefixes, all);
        }
      }
      /**
       * Clone node and clean autprefixer custom caches
       */
      static clone(node3, overrides) {
        let cloned = clone(node3);
        for (let name2 in overrides) {
          cloned[name2] = overrides[name2];
        }
        return cloned;
      }
      constructor(name2, prefixes, all) {
        this.prefixes = prefixes;
        this.name = name2;
        this.all = all;
      }
      /**
       * Find prefix in node parents
       */
      parentPrefix(node3) {
        let prefix;
        if (typeof node3._autoprefixerPrefix !== "undefined") {
          prefix = node3._autoprefixerPrefix;
        } else if (node3.type === "decl" && node3.prop[0] === "-") {
          prefix = vendor.prefix(node3.prop);
        } else if (node3.type === "root") {
          prefix = false;
        } else if (node3.type === "rule" && node3.selector.includes(":-") && /:(-\w+-)/.test(node3.selector)) {
          prefix = node3.selector.match(/:(-\w+-)/)[1];
        } else if (node3.type === "atrule" && node3.name[0] === "-") {
          prefix = vendor.prefix(node3.name);
        } else {
          prefix = this.parentPrefix(node3.parent);
        }
        if (!Browsers.prefixes().includes(prefix)) {
          prefix = false;
        }
        node3._autoprefixerPrefix = prefix;
        return node3._autoprefixerPrefix;
      }
      /**
       * Clone node with prefixes
       */
      process(node3, result) {
        if (!this.check(node3)) {
          return void 0;
        }
        let parent = this.parentPrefix(node3);
        let prefixes = this.prefixes.filter(
          (prefix) => !parent || parent === utils2.removeNote(prefix)
        );
        let added = [];
        for (let prefix of prefixes) {
          if (this.add(node3, prefix, added.concat([prefix]), result)) {
            added.push(prefix);
          }
        }
        return added;
      }
      /**
       * Shortcut for Prefixer.clone
       */
      clone(node3, overrides) {
        return Prefixer.clone(node3, overrides);
      }
    };
    module2.exports = Prefixer;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/declaration.js
var require_declaration = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/declaration.js"(exports3, module2) {
    var Prefixer = require_prefixer();
    var Browsers = require_browsers3();
    var utils2 = require_utils7();
    var Declaration = class extends Prefixer {
      /**
       * Always true, because we already get prefixer by property name
       */
      check() {
        return true;
      }
      /**
       * Return prefixed version of property
       */
      prefixed(prop, prefix) {
        return prefix + prop;
      }
      /**
       * Return unprefixed version of property
       */
      normalize(prop) {
        return prop;
      }
      /**
       * Check `value`, that it contain other prefixes, rather than `prefix`
       */
      otherPrefixes(value2, prefix) {
        for (let other of Browsers.prefixes()) {
          if (other === prefix) {
            continue;
          }
          if (value2.includes(other)) {
            return value2.replace(/var\([^)]+\)/, "").includes(other);
          }
        }
        return false;
      }
      /**
       * Set prefix to declaration
       */
      set(decl, prefix) {
        decl.prop = this.prefixed(decl.prop, prefix);
        return decl;
      }
      /**
       * Should we use visual cascade for prefixes
       */
      needCascade(decl) {
        if (!decl._autoprefixerCascade) {
          decl._autoprefixerCascade = this.all.options.cascade !== false && decl.raw("before").includes("\n");
        }
        return decl._autoprefixerCascade;
      }
      /**
       * Return maximum length of possible prefixed property
       */
      maxPrefixed(prefixes, decl) {
        if (decl._autoprefixerMax) {
          return decl._autoprefixerMax;
        }
        let max = 0;
        for (let prefix of prefixes) {
          prefix = utils2.removeNote(prefix);
          if (prefix.length > max) {
            max = prefix.length;
          }
        }
        decl._autoprefixerMax = max;
        return decl._autoprefixerMax;
      }
      /**
       * Calculate indentation to create visual cascade
       */
      calcBefore(prefixes, decl, prefix = "") {
        let max = this.maxPrefixed(prefixes, decl);
        let diff = max - utils2.removeNote(prefix).length;
        let before = decl.raw("before");
        if (diff > 0) {
          before += Array(diff).fill(" ").join("");
        }
        return before;
      }
      /**
       * Remove visual cascade
       */
      restoreBefore(decl) {
        let lines = decl.raw("before").split("\n");
        let min2 = lines[lines.length - 1];
        this.all.group(decl).up((prefixed) => {
          let array2 = prefixed.raw("before").split("\n");
          let last = array2[array2.length - 1];
          if (last.length < min2.length) {
            min2 = last;
          }
        });
        lines[lines.length - 1] = min2;
        decl.raws.before = lines.join("\n");
      }
      /**
       * Clone and insert new declaration
       */
      insert(decl, prefix, prefixes) {
        let cloned = this.set(this.clone(decl), prefix);
        if (!cloned)
          return void 0;
        let already = decl.parent.some(
          (i2) => i2.prop === cloned.prop && i2.value === cloned.value
        );
        if (already) {
          return void 0;
        }
        if (this.needCascade(decl)) {
          cloned.raws.before = this.calcBefore(prefixes, decl, prefix);
        }
        return decl.parent.insertBefore(decl, cloned);
      }
      /**
       * Did this declaration has this prefix above
       */
      isAlready(decl, prefixed) {
        let already = this.all.group(decl).up((i2) => i2.prop === prefixed);
        if (!already) {
          already = this.all.group(decl).down((i2) => i2.prop === prefixed);
        }
        return already;
      }
      /**
       * Clone and add prefixes for declaration
       */
      add(decl, prefix, prefixes, result) {
        let prefixed = this.prefixed(decl.prop, prefix);
        if (this.isAlready(decl, prefixed) || this.otherPrefixes(decl.value, prefix)) {
          return void 0;
        }
        return this.insert(decl, prefix, prefixes, result);
      }
      /**
       * Add spaces for visual cascade
       */
      process(decl, result) {
        if (!this.needCascade(decl)) {
          super.process(decl, result);
          return;
        }
        let prefixes = super.process(decl, result);
        if (!prefixes || !prefixes.length) {
          return;
        }
        this.restoreBefore(decl);
        decl.raws.before = this.calcBefore(prefixes, decl);
      }
      /**
       * Return list of prefixed properties to clean old prefixes
       */
      old(prop, prefix) {
        return [this.prefixed(prop, prefix)];
      }
    };
    module2.exports = Declaration;
  }
});

// node_modules/.pnpm/fraction.js@4.2.0/node_modules/fraction.js/fraction.js
var require_fraction = __commonJS({
  "node_modules/.pnpm/fraction.js@4.2.0/node_modules/fraction.js/fraction.js"(exports3, module2) {
    (function(root) {
      "use strict";
      var MAX_CYCLE_LEN = 2e3;
      var P = {
        "s": 1,
        "n": 0,
        "d": 1
      };
      function assign(n3, s2) {
        if (isNaN(n3 = parseInt(n3, 10))) {
          throw Fraction["InvalidParameter"];
        }
        return n3 * s2;
      }
      function newFraction(n3, d2) {
        if (d2 === 0) {
          throw Fraction["DivisionByZero"];
        }
        var f2 = Object.create(Fraction.prototype);
        f2["s"] = n3 < 0 ? -1 : 1;
        n3 = n3 < 0 ? -n3 : n3;
        var a2 = gcd(n3, d2);
        f2["n"] = n3 / a2;
        f2["d"] = d2 / a2;
        return f2;
      }
      function factorize(num) {
        var factors = {};
        var n3 = num;
        var i2 = 2;
        var s2 = 4;
        while (s2 <= n3) {
          while (n3 % i2 === 0) {
            n3 /= i2;
            factors[i2] = (factors[i2] || 0) + 1;
          }
          s2 += 1 + 2 * i2++;
        }
        if (n3 !== num) {
          if (n3 > 1)
            factors[n3] = (factors[n3] || 0) + 1;
        } else {
          factors[num] = (factors[num] || 0) + 1;
        }
        return factors;
      }
      var parse7 = function(p1, p2) {
        var n3 = 0, d2 = 1, s2 = 1;
        var v = 0, w = 0, x = 0, y = 1, z = 1;
        var A2 = 0, B2 = 1;
        var C2 = 1, D = 1;
        var N = 1e7;
        var M;
        if (p1 === void 0 || p1 === null) {
        } else if (p2 !== void 0) {
          n3 = p1;
          d2 = p2;
          s2 = n3 * d2;
          if (n3 % 1 !== 0 || d2 % 1 !== 0) {
            throw Fraction["NonIntegerParameter"];
          }
        } else
          switch (typeof p1) {
            case "object": {
              if ("d" in p1 && "n" in p1) {
                n3 = p1["n"];
                d2 = p1["d"];
                if ("s" in p1)
                  n3 *= p1["s"];
              } else if (0 in p1) {
                n3 = p1[0];
                if (1 in p1)
                  d2 = p1[1];
              } else {
                throw Fraction["InvalidParameter"];
              }
              s2 = n3 * d2;
              break;
            }
            case "number": {
              if (p1 < 0) {
                s2 = p1;
                p1 = -p1;
              }
              if (p1 % 1 === 0) {
                n3 = p1;
              } else if (p1 > 0) {
                if (p1 >= 1) {
                  z = Math.pow(10, Math.floor(1 + Math.log(p1) / Math.LN10));
                  p1 /= z;
                }
                while (B2 <= N && D <= N) {
                  M = (A2 + C2) / (B2 + D);
                  if (p1 === M) {
                    if (B2 + D <= N) {
                      n3 = A2 + C2;
                      d2 = B2 + D;
                    } else if (D > B2) {
                      n3 = C2;
                      d2 = D;
                    } else {
                      n3 = A2;
                      d2 = B2;
                    }
                    break;
                  } else {
                    if (p1 > M) {
                      A2 += C2;
                      B2 += D;
                    } else {
                      C2 += A2;
                      D += B2;
                    }
                    if (B2 > N) {
                      n3 = C2;
                      d2 = D;
                    } else {
                      n3 = A2;
                      d2 = B2;
                    }
                  }
                }
                n3 *= z;
              } else if (isNaN(p1) || isNaN(p2)) {
                d2 = n3 = NaN;
              }
              break;
            }
            case "string": {
              B2 = p1.match(/\d+|./g);
              if (B2 === null)
                throw Fraction["InvalidParameter"];
              if (B2[A2] === "-") {
                s2 = -1;
                A2++;
              } else if (B2[A2] === "+") {
                A2++;
              }
              if (B2.length === A2 + 1) {
                w = assign(B2[A2++], s2);
              } else if (B2[A2 + 1] === "." || B2[A2] === ".") {
                if (B2[A2] !== ".") {
                  v = assign(B2[A2++], s2);
                }
                A2++;
                if (A2 + 1 === B2.length || B2[A2 + 1] === "(" && B2[A2 + 3] === ")" || B2[A2 + 1] === "'" && B2[A2 + 3] === "'") {
                  w = assign(B2[A2], s2);
                  y = Math.pow(10, B2[A2].length);
                  A2++;
                }
                if (B2[A2] === "(" && B2[A2 + 2] === ")" || B2[A2] === "'" && B2[A2 + 2] === "'") {
                  x = assign(B2[A2 + 1], s2);
                  z = Math.pow(10, B2[A2 + 1].length) - 1;
                  A2 += 3;
                }
              } else if (B2[A2 + 1] === "/" || B2[A2 + 1] === ":") {
                w = assign(B2[A2], s2);
                y = assign(B2[A2 + 2], 1);
                A2 += 3;
              } else if (B2[A2 + 3] === "/" && B2[A2 + 1] === " ") {
                v = assign(B2[A2], s2);
                w = assign(B2[A2 + 2], s2);
                y = assign(B2[A2 + 4], 1);
                A2 += 5;
              }
              if (B2.length <= A2) {
                d2 = y * z;
                s2 = /* void */
                n3 = x + d2 * v + z * w;
                break;
              }
            }
            default:
              throw Fraction["InvalidParameter"];
          }
        if (d2 === 0) {
          throw Fraction["DivisionByZero"];
        }
        P["s"] = s2 < 0 ? -1 : 1;
        P["n"] = Math.abs(n3);
        P["d"] = Math.abs(d2);
      };
      function modpow(b, e3, m) {
        var r3 = 1;
        for (; e3 > 0; b = b * b % m, e3 >>= 1) {
          if (e3 & 1) {
            r3 = r3 * b % m;
          }
        }
        return r3;
      }
      function cycleLen(n3, d2) {
        for (; d2 % 2 === 0; d2 /= 2) {
        }
        for (; d2 % 5 === 0; d2 /= 5) {
        }
        if (d2 === 1)
          return 0;
        var rem = 10 % d2;
        var t3 = 1;
        for (; rem !== 1; t3++) {
          rem = rem * 10 % d2;
          if (t3 > MAX_CYCLE_LEN)
            return 0;
        }
        return t3;
      }
      function cycleStart(n3, d2, len) {
        var rem1 = 1;
        var rem2 = modpow(10, len, d2);
        for (var t3 = 0; t3 < 300; t3++) {
          if (rem1 === rem2)
            return t3;
          rem1 = rem1 * 10 % d2;
          rem2 = rem2 * 10 % d2;
        }
        return 0;
      }
      function gcd(a2, b) {
        if (!a2)
          return b;
        if (!b)
          return a2;
        while (1) {
          a2 %= b;
          if (!a2)
            return b;
          b %= a2;
          if (!b)
            return a2;
        }
      }
      ;
      function Fraction(a2, b) {
        parse7(a2, b);
        if (this instanceof Fraction) {
          a2 = gcd(P["d"], P["n"]);
          this["s"] = P["s"];
          this["n"] = P["n"] / a2;
          this["d"] = P["d"] / a2;
        } else {
          return newFraction(P["s"] * P["n"], P["d"]);
        }
      }
      Fraction["DivisionByZero"] = new Error("Division by Zero");
      Fraction["InvalidParameter"] = new Error("Invalid argument");
      Fraction["NonIntegerParameter"] = new Error("Parameters must be integer");
      Fraction.prototype = {
        "s": 1,
        "n": 0,
        "d": 1,
        /**
         * Calculates the absolute value
         *
         * Ex: new Fraction(-4).abs() => 4
         **/
        "abs": function() {
          return newFraction(this["n"], this["d"]);
        },
        /**
         * Inverts the sign of the current fraction
         *
         * Ex: new Fraction(-4).neg() => 4
         **/
        "neg": function() {
          return newFraction(-this["s"] * this["n"], this["d"]);
        },
        /**
         * Adds two rational numbers
         *
         * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
         **/
        "add": function(a2, b) {
          parse7(a2, b);
          return newFraction(
            this["s"] * this["n"] * P["d"] + P["s"] * this["d"] * P["n"],
            this["d"] * P["d"]
          );
        },
        /**
         * Subtracts two rational numbers
         *
         * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
         **/
        "sub": function(a2, b) {
          parse7(a2, b);
          return newFraction(
            this["s"] * this["n"] * P["d"] - P["s"] * this["d"] * P["n"],
            this["d"] * P["d"]
          );
        },
        /**
         * Multiplies two rational numbers
         *
         * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
         **/
        "mul": function(a2, b) {
          parse7(a2, b);
          return newFraction(
            this["s"] * P["s"] * this["n"] * P["n"],
            this["d"] * P["d"]
          );
        },
        /**
         * Divides two rational numbers
         *
         * Ex: new Fraction("-17.(345)").inverse().div(3)
         **/
        "div": function(a2, b) {
          parse7(a2, b);
          return newFraction(
            this["s"] * P["s"] * this["n"] * P["d"],
            this["d"] * P["n"]
          );
        },
        /**
         * Clones the actual object
         *
         * Ex: new Fraction("-17.(345)").clone()
         **/
        "clone": function() {
          return newFraction(this["s"] * this["n"], this["d"]);
        },
        /**
         * Calculates the modulo of two rational numbers - a more precise fmod
         *
         * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
         **/
        "mod": function(a2, b) {
          if (isNaN(this["n"]) || isNaN(this["d"])) {
            return new Fraction(NaN);
          }
          if (a2 === void 0) {
            return newFraction(this["s"] * this["n"] % this["d"], 1);
          }
          parse7(a2, b);
          if (0 === P["n"] && 0 === this["d"]) {
            throw Fraction["DivisionByZero"];
          }
          return newFraction(
            this["s"] * (P["d"] * this["n"]) % (P["n"] * this["d"]),
            P["d"] * this["d"]
          );
        },
        /**
         * Calculates the fractional gcd of two rational numbers
         *
         * Ex: new Fraction(5,8).gcd(3,7) => 1/56
         */
        "gcd": function(a2, b) {
          parse7(a2, b);
          return newFraction(gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]), P["d"] * this["d"]);
        },
        /**
         * Calculates the fractional lcm of two rational numbers
         *
         * Ex: new Fraction(5,8).lcm(3,7) => 15
         */
        "lcm": function(a2, b) {
          parse7(a2, b);
          if (P["n"] === 0 && this["n"] === 0) {
            return newFraction(0, 1);
          }
          return newFraction(P["n"] * this["n"], gcd(P["n"], this["n"]) * gcd(P["d"], this["d"]));
        },
        /**
         * Calculates the ceil of a rational number
         *
         * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
         **/
        "ceil": function(places) {
          places = Math.pow(10, places || 0);
          if (isNaN(this["n"]) || isNaN(this["d"])) {
            return new Fraction(NaN);
          }
          return newFraction(Math.ceil(places * this["s"] * this["n"] / this["d"]), places);
        },
        /**
         * Calculates the floor of a rational number
         *
         * Ex: new Fraction('4.(3)').floor() => (4 / 1)
         **/
        "floor": function(places) {
          places = Math.pow(10, places || 0);
          if (isNaN(this["n"]) || isNaN(this["d"])) {
            return new Fraction(NaN);
          }
          return newFraction(Math.floor(places * this["s"] * this["n"] / this["d"]), places);
        },
        /**
         * Rounds a rational numbers
         *
         * Ex: new Fraction('4.(3)').round() => (4 / 1)
         **/
        "round": function(places) {
          places = Math.pow(10, places || 0);
          if (isNaN(this["n"]) || isNaN(this["d"])) {
            return new Fraction(NaN);
          }
          return newFraction(Math.round(places * this["s"] * this["n"] / this["d"]), places);
        },
        /**
         * Gets the inverse of the fraction, means numerator and denominator are exchanged
         *
         * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
         **/
        "inverse": function() {
          return newFraction(this["s"] * this["d"], this["n"]);
        },
        /**
         * Calculates the fraction to some rational exponent, if possible
         *
         * Ex: new Fraction(-1,2).pow(-3) => -8
         */
        "pow": function(a2, b) {
          parse7(a2, b);
          if (P["d"] === 1) {
            if (P["s"] < 0) {
              return newFraction(Math.pow(this["s"] * this["d"], P["n"]), Math.pow(this["n"], P["n"]));
            } else {
              return newFraction(Math.pow(this["s"] * this["n"], P["n"]), Math.pow(this["d"], P["n"]));
            }
          }
          if (this["s"] < 0)
            return null;
          var N = factorize(this["n"]);
          var D = factorize(this["d"]);
          var n3 = 1;
          var d2 = 1;
          for (var k in N) {
            if (k === "1")
              continue;
            if (k === "0") {
              n3 = 0;
              break;
            }
            N[k] *= P["n"];
            if (N[k] % P["d"] === 0) {
              N[k] /= P["d"];
            } else
              return null;
            n3 *= Math.pow(k, N[k]);
          }
          for (var k in D) {
            if (k === "1")
              continue;
            D[k] *= P["n"];
            if (D[k] % P["d"] === 0) {
              D[k] /= P["d"];
            } else
              return null;
            d2 *= Math.pow(k, D[k]);
          }
          if (P["s"] < 0) {
            return newFraction(d2, n3);
          }
          return newFraction(n3, d2);
        },
        /**
         * Check if two rational numbers are the same
         *
         * Ex: new Fraction(19.6).equals([98, 5]);
         **/
        "equals": function(a2, b) {
          parse7(a2, b);
          return this["s"] * this["n"] * P["d"] === P["s"] * P["n"] * this["d"];
        },
        /**
         * Check if two rational numbers are the same
         *
         * Ex: new Fraction(19.6).equals([98, 5]);
         **/
        "compare": function(a2, b) {
          parse7(a2, b);
          var t3 = this["s"] * this["n"] * P["d"] - P["s"] * P["n"] * this["d"];
          return (0 < t3) - (t3 < 0);
        },
        "simplify": function(eps) {
          if (isNaN(this["n"]) || isNaN(this["d"])) {
            return this;
          }
          eps = eps || 1e-3;
          var thisABS = this["abs"]();
          var cont = thisABS["toContinued"]();
          for (var i2 = 1; i2 < cont.length; i2++) {
            var s2 = newFraction(cont[i2 - 1], 1);
            for (var k = i2 - 2; k >= 0; k--) {
              s2 = s2["inverse"]()["add"](cont[k]);
            }
            if (s2["sub"](thisABS)["abs"]().valueOf() < eps) {
              return s2["mul"](this["s"]);
            }
          }
          return this;
        },
        /**
         * Check if two rational numbers are divisible
         *
         * Ex: new Fraction(19.6).divisible(1.5);
         */
        "divisible": function(a2, b) {
          parse7(a2, b);
          return !(!(P["n"] * this["d"]) || this["n"] * P["d"] % (P["n"] * this["d"]));
        },
        /**
         * Returns a decimal representation of the fraction
         *
         * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
         **/
        "valueOf": function() {
          return this["s"] * this["n"] / this["d"];
        },
        /**
         * Returns a string-fraction representation of a Fraction object
         *
         * Ex: new Fraction("1.'3'").toFraction(true) => "4 1/3"
         **/
        "toFraction": function(excludeWhole) {
          var whole, str2 = "";
          var n3 = this["n"];
          var d2 = this["d"];
          if (this["s"] < 0) {
            str2 += "-";
          }
          if (d2 === 1) {
            str2 += n3;
          } else {
            if (excludeWhole && (whole = Math.floor(n3 / d2)) > 0) {
              str2 += whole;
              str2 += " ";
              n3 %= d2;
            }
            str2 += n3;
            str2 += "/";
            str2 += d2;
          }
          return str2;
        },
        /**
         * Returns a latex representation of a Fraction object
         *
         * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
         **/
        "toLatex": function(excludeWhole) {
          var whole, str2 = "";
          var n3 = this["n"];
          var d2 = this["d"];
          if (this["s"] < 0) {
            str2 += "-";
          }
          if (d2 === 1) {
            str2 += n3;
          } else {
            if (excludeWhole && (whole = Math.floor(n3 / d2)) > 0) {
              str2 += whole;
              n3 %= d2;
            }
            str2 += "\\frac{";
            str2 += n3;
            str2 += "}{";
            str2 += d2;
            str2 += "}";
          }
          return str2;
        },
        /**
         * Returns an array of continued fraction elements
         *
         * Ex: new Fraction("7/8").toContinued() => [0,1,7]
         */
        "toContinued": function() {
          var t3;
          var a2 = this["n"];
          var b = this["d"];
          var res = [];
          if (isNaN(a2) || isNaN(b)) {
            return res;
          }
          do {
            res.push(Math.floor(a2 / b));
            t3 = a2 % b;
            a2 = b;
            b = t3;
          } while (a2 !== 1);
          return res;
        },
        /**
         * Creates a string representation of a fraction with all digits
         *
         * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
         **/
        "toString": function(dec) {
          var N = this["n"];
          var D = this["d"];
          if (isNaN(N) || isNaN(D)) {
            return "NaN";
          }
          dec = dec || 15;
          var cycLen = cycleLen(N, D);
          var cycOff = cycleStart(N, D, cycLen);
          var str2 = this["s"] < 0 ? "-" : "";
          str2 += N / D | 0;
          N %= D;
          N *= 10;
          if (N)
            str2 += ".";
          if (cycLen) {
            for (var i2 = cycOff; i2--; ) {
              str2 += N / D | 0;
              N %= D;
              N *= 10;
            }
            str2 += "(";
            for (var i2 = cycLen; i2--; ) {
              str2 += N / D | 0;
              N %= D;
              N *= 10;
            }
            str2 += ")";
          } else {
            for (var i2 = dec; N && i2--; ) {
              str2 += N / D | 0;
              N %= D;
              N *= 10;
            }
          }
          return str2;
        }
      };
      if (typeof define === "function" && define["amd"]) {
        define([], function() {
          return Fraction;
        });
      } else if (typeof exports3 === "object") {
        Object.defineProperty(Fraction, "__esModule", { "value": true });
        Fraction["default"] = Fraction;
        Fraction["Fraction"] = Fraction;
        module2["exports"] = Fraction;
      } else {
        root["Fraction"] = Fraction;
      }
    })(exports3);
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/resolution.js
var require_resolution = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/resolution.js"(exports3, module2) {
    var FractionJs = require_fraction();
    var Prefixer = require_prefixer();
    var utils2 = require_utils7();
    var REGEXP = /(min|max)-resolution\s*:\s*\d*\.?\d+(dppx|dpcm|dpi|x)/gi;
    var SPLIT = /(min|max)-resolution(\s*:\s*)(\d*\.?\d+)(dppx|dpcm|dpi|x)/i;
    var Resolution = class extends Prefixer {
      /**
       * Return prefixed query name
       */
      prefixName(prefix, name2) {
        if (prefix === "-moz-") {
          return name2 + "--moz-device-pixel-ratio";
        } else {
          return prefix + name2 + "-device-pixel-ratio";
        }
      }
      /**
       * Return prefixed query
       */
      prefixQuery(prefix, name2, colon, value2, units) {
        value2 = new FractionJs(value2);
        if (units === "dpi") {
          value2 = value2.div(96);
        } else if (units === "dpcm") {
          value2 = value2.mul(2.54).div(96);
        }
        value2 = value2.simplify();
        if (prefix === "-o-") {
          value2 = value2.n + "/" + value2.d;
        }
        return this.prefixName(prefix, name2) + colon + value2;
      }
      /**
       * Remove prefixed queries
       */
      clean(rule) {
        if (!this.bad) {
          this.bad = [];
          for (let prefix of this.prefixes) {
            this.bad.push(this.prefixName(prefix, "min"));
            this.bad.push(this.prefixName(prefix, "max"));
          }
        }
        rule.params = utils2.editList(rule.params, (queries) => {
          return queries.filter((query) => this.bad.every((i2) => !query.includes(i2)));
        });
      }
      /**
       * Add prefixed queries
       */
      process(rule) {
        let parent = this.parentPrefix(rule);
        let prefixes = parent ? [parent] : this.prefixes;
        rule.params = utils2.editList(rule.params, (origin, prefixed) => {
          for (let query of origin) {
            if (!query.includes("min-resolution") && !query.includes("max-resolution")) {
              prefixed.push(query);
              continue;
            }
            for (let prefix of prefixes) {
              let processed = query.replace(REGEXP, (str2) => {
                let parts = str2.match(SPLIT);
                return this.prefixQuery(
                  prefix,
                  parts[1],
                  parts[2],
                  parts[3],
                  parts[4]
                );
              });
              prefixed.push(processed);
            }
            prefixed.push(query);
          }
          return utils2.uniq(prefixed);
        });
      }
    };
    module2.exports = Resolution;
  }
});

// node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/parse.js
var require_parse4 = __commonJS({
  "node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/parse.js"(exports3, module2) {
    var openParentheses = "(".charCodeAt(0);
    var closeParentheses = ")".charCodeAt(0);
    var singleQuote = "'".charCodeAt(0);
    var doubleQuote = '"'.charCodeAt(0);
    var backslash2 = "\\".charCodeAt(0);
    var slash4 = "/".charCodeAt(0);
    var comma3 = ",".charCodeAt(0);
    var colon = ":".charCodeAt(0);
    var star2 = "*".charCodeAt(0);
    var uLower = "u".charCodeAt(0);
    var uUpper = "U".charCodeAt(0);
    var plus = "+".charCodeAt(0);
    var isUnicodeRange = /^[a-f0-9?-]+$/i;
    module2.exports = function(input) {
      var tokens = [];
      var value2 = input;
      var next, quote, prev, token, escape2, escapePos, whitespacePos, parenthesesOpenPos;
      var pos = 0;
      var code = value2.charCodeAt(pos);
      var max = value2.length;
      var stack = [{ nodes: tokens }];
      var balanced2 = 0;
      var parent;
      var name2 = "";
      var before = "";
      var after = "";
      while (pos < max) {
        if (code <= 32) {
          next = pos;
          do {
            next += 1;
            code = value2.charCodeAt(next);
          } while (code <= 32);
          token = value2.slice(pos, next);
          prev = tokens[tokens.length - 1];
          if (code === closeParentheses && balanced2) {
            after = token;
          } else if (prev && prev.type === "div") {
            prev.after = token;
            prev.sourceEndIndex += token.length;
          } else if (code === comma3 || code === colon || code === slash4 && value2.charCodeAt(next + 1) !== star2 && (!parent || parent && parent.type === "function" && parent.value !== "calc")) {
            before = token;
          } else {
            tokens.push({
              type: "space",
              sourceIndex: pos,
              sourceEndIndex: next,
              value: token
            });
          }
          pos = next;
        } else if (code === singleQuote || code === doubleQuote) {
          next = pos;
          quote = code === singleQuote ? "'" : '"';
          token = {
            type: "string",
            sourceIndex: pos,
            quote
          };
          do {
            escape2 = false;
            next = value2.indexOf(quote, next + 1);
            if (~next) {
              escapePos = next;
              while (value2.charCodeAt(escapePos - 1) === backslash2) {
                escapePos -= 1;
                escape2 = !escape2;
              }
            } else {
              value2 += quote;
              next = value2.length - 1;
              token.unclosed = true;
            }
          } while (escape2);
          token.value = value2.slice(pos + 1, next);
          token.sourceEndIndex = token.unclosed ? next : next + 1;
          tokens.push(token);
          pos = next + 1;
          code = value2.charCodeAt(pos);
        } else if (code === slash4 && value2.charCodeAt(pos + 1) === star2) {
          next = value2.indexOf("*/", pos);
          token = {
            type: "comment",
            sourceIndex: pos,
            sourceEndIndex: next + 2
          };
          if (next === -1) {
            token.unclosed = true;
            next = value2.length;
            token.sourceEndIndex = next;
          }
          token.value = value2.slice(pos + 2, next);
          tokens.push(token);
          pos = next + 2;
          code = value2.charCodeAt(pos);
        } else if ((code === slash4 || code === star2) && parent && parent.type === "function" && parent.value === "calc") {
          token = value2[pos];
          tokens.push({
            type: "word",
            sourceIndex: pos - before.length,
            sourceEndIndex: pos + token.length,
            value: token
          });
          pos += 1;
          code = value2.charCodeAt(pos);
        } else if (code === slash4 || code === comma3 || code === colon) {
          token = value2[pos];
          tokens.push({
            type: "div",
            sourceIndex: pos - before.length,
            sourceEndIndex: pos + token.length,
            value: token,
            before,
            after: ""
          });
          before = "";
          pos += 1;
          code = value2.charCodeAt(pos);
        } else if (openParentheses === code) {
          next = pos;
          do {
            next += 1;
            code = value2.charCodeAt(next);
          } while (code <= 32);
          parenthesesOpenPos = pos;
          token = {
            type: "function",
            sourceIndex: pos - name2.length,
            value: name2,
            before: value2.slice(parenthesesOpenPos + 1, next)
          };
          pos = next;
          if (name2 === "url" && code !== singleQuote && code !== doubleQuote) {
            next -= 1;
            do {
              escape2 = false;
              next = value2.indexOf(")", next + 1);
              if (~next) {
                escapePos = next;
                while (value2.charCodeAt(escapePos - 1) === backslash2) {
                  escapePos -= 1;
                  escape2 = !escape2;
                }
              } else {
                value2 += ")";
                next = value2.length - 1;
                token.unclosed = true;
              }
            } while (escape2);
            whitespacePos = next;
            do {
              whitespacePos -= 1;
              code = value2.charCodeAt(whitespacePos);
            } while (code <= 32);
            if (parenthesesOpenPos < whitespacePos) {
              if (pos !== whitespacePos + 1) {
                token.nodes = [
                  {
                    type: "word",
                    sourceIndex: pos,
                    sourceEndIndex: whitespacePos + 1,
                    value: value2.slice(pos, whitespacePos + 1)
                  }
                ];
              } else {
                token.nodes = [];
              }
              if (token.unclosed && whitespacePos + 1 !== next) {
                token.after = "";
                token.nodes.push({
                  type: "space",
                  sourceIndex: whitespacePos + 1,
                  sourceEndIndex: next,
                  value: value2.slice(whitespacePos + 1, next)
                });
              } else {
                token.after = value2.slice(whitespacePos + 1, next);
                token.sourceEndIndex = next;
              }
            } else {
              token.after = "";
              token.nodes = [];
            }
            pos = next + 1;
            token.sourceEndIndex = token.unclosed ? next : pos;
            code = value2.charCodeAt(pos);
            tokens.push(token);
          } else {
            balanced2 += 1;
            token.after = "";
            token.sourceEndIndex = pos + 1;
            tokens.push(token);
            stack.push(token);
            tokens = token.nodes = [];
            parent = token;
          }
          name2 = "";
        } else if (closeParentheses === code && balanced2) {
          pos += 1;
          code = value2.charCodeAt(pos);
          parent.after = after;
          parent.sourceEndIndex += after.length;
          after = "";
          balanced2 -= 1;
          stack[stack.length - 1].sourceEndIndex = pos;
          stack.pop();
          parent = stack[balanced2];
          tokens = parent.nodes;
        } else {
          next = pos;
          do {
            if (code === backslash2) {
              next += 1;
            }
            next += 1;
            code = value2.charCodeAt(next);
          } while (next < max && !(code <= 32 || code === singleQuote || code === doubleQuote || code === comma3 || code === colon || code === slash4 || code === openParentheses || code === star2 && parent && parent.type === "function" && parent.value === "calc" || code === slash4 && parent.type === "function" && parent.value === "calc" || code === closeParentheses && balanced2));
          token = value2.slice(pos, next);
          if (openParentheses === code) {
            name2 = token;
          } else if ((uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) && plus === token.charCodeAt(1) && isUnicodeRange.test(token.slice(2))) {
            tokens.push({
              type: "unicode-range",
              sourceIndex: pos,
              sourceEndIndex: next,
              value: token
            });
          } else {
            tokens.push({
              type: "word",
              sourceIndex: pos,
              sourceEndIndex: next,
              value: token
            });
          }
          pos = next;
        }
      }
      for (pos = stack.length - 1; pos; pos -= 1) {
        stack[pos].unclosed = true;
        stack[pos].sourceEndIndex = value2.length;
      }
      return stack[0].nodes;
    };
  }
});

// node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/walk.js
var require_walk = __commonJS({
  "node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/walk.js"(exports3, module2) {
    module2.exports = function walk2(nodes, cb, bubble) {
      var i2, max, node3, result;
      for (i2 = 0, max = nodes.length; i2 < max; i2 += 1) {
        node3 = nodes[i2];
        if (!bubble) {
          result = cb(node3, i2, nodes);
        }
        if (result !== false && node3.type === "function" && Array.isArray(node3.nodes)) {
          walk2(node3.nodes, cb, bubble);
        }
        if (bubble) {
          cb(node3, i2, nodes);
        }
      }
    };
  }
});

// node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/stringify.js
var require_stringify2 = __commonJS({
  "node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/stringify.js"(exports3, module2) {
    function stringifyNode(node3, custom) {
      var type = node3.type;
      var value2 = node3.value;
      var buf;
      var customResult;
      if (custom && (customResult = custom(node3)) !== void 0) {
        return customResult;
      } else if (type === "word" || type === "space") {
        return value2;
      } else if (type === "string") {
        buf = node3.quote || "";
        return buf + value2 + (node3.unclosed ? "" : buf);
      } else if (type === "comment") {
        return "/*" + value2 + (node3.unclosed ? "" : "*/");
      } else if (type === "div") {
        return (node3.before || "") + value2 + (node3.after || "");
      } else if (Array.isArray(node3.nodes)) {
        buf = stringify5(node3.nodes, custom);
        if (type !== "function") {
          return buf;
        }
        return value2 + "(" + (node3.before || "") + buf + (node3.after || "") + (node3.unclosed ? "" : ")");
      }
      return value2;
    }
    function stringify5(nodes, custom) {
      var result, i2;
      if (Array.isArray(nodes)) {
        result = "";
        for (i2 = nodes.length - 1; ~i2; i2 -= 1) {
          result = stringifyNode(nodes[i2], custom) + result;
        }
        return result;
      }
      return stringifyNode(nodes, custom);
    }
    module2.exports = stringify5;
  }
});

// node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/unit.js
var require_unit = __commonJS({
  "node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/unit.js"(exports3, module2) {
    var minus = "-".charCodeAt(0);
    var plus = "+".charCodeAt(0);
    var dot = ".".charCodeAt(0);
    var exp = "e".charCodeAt(0);
    var EXP = "E".charCodeAt(0);
    function likeNumber(value2) {
      var code = value2.charCodeAt(0);
      var nextCode;
      if (code === plus || code === minus) {
        nextCode = value2.charCodeAt(1);
        if (nextCode >= 48 && nextCode <= 57) {
          return true;
        }
        var nextNextCode = value2.charCodeAt(2);
        if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {
          return true;
        }
        return false;
      }
      if (code === dot) {
        nextCode = value2.charCodeAt(1);
        if (nextCode >= 48 && nextCode <= 57) {
          return true;
        }
        return false;
      }
      if (code >= 48 && code <= 57) {
        return true;
      }
      return false;
    }
    module2.exports = function(value2) {
      var pos = 0;
      var length = value2.length;
      var code;
      var nextCode;
      var nextNextCode;
      if (length === 0 || !likeNumber(value2)) {
        return false;
      }
      code = value2.charCodeAt(pos);
      if (code === plus || code === minus) {
        pos++;
      }
      while (pos < length) {
        code = value2.charCodeAt(pos);
        if (code < 48 || code > 57) {
          break;
        }
        pos += 1;
      }
      code = value2.charCodeAt(pos);
      nextCode = value2.charCodeAt(pos + 1);
      if (code === dot && nextCode >= 48 && nextCode <= 57) {
        pos += 2;
        while (pos < length) {
          code = value2.charCodeAt(pos);
          if (code < 48 || code > 57) {
            break;
          }
          pos += 1;
        }
      }
      code = value2.charCodeAt(pos);
      nextCode = value2.charCodeAt(pos + 1);
      nextNextCode = value2.charCodeAt(pos + 2);
      if ((code === exp || code === EXP) && (nextCode >= 48 && nextCode <= 57 || (nextCode === plus || nextCode === minus) && nextNextCode >= 48 && nextNextCode <= 57)) {
        pos += nextCode === plus || nextCode === minus ? 3 : 2;
        while (pos < length) {
          code = value2.charCodeAt(pos);
          if (code < 48 || code > 57) {
            break;
          }
          pos += 1;
        }
      }
      return {
        number: value2.slice(0, pos),
        unit: value2.slice(pos)
      };
    };
  }
});

// node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/.pnpm/postcss-value-parser@4.2.0/node_modules/postcss-value-parser/lib/index.js"(exports3, module2) {
    var parse7 = require_parse4();
    var walk2 = require_walk();
    var stringify5 = require_stringify2();
    function ValueParser(value2) {
      if (this instanceof ValueParser) {
        this.nodes = parse7(value2);
        return this;
      }
      return new ValueParser(value2);
    }
    ValueParser.prototype.toString = function() {
      return Array.isArray(this.nodes) ? stringify5(this.nodes) : "";
    };
    ValueParser.prototype.walk = function(cb, bubble) {
      walk2(this.nodes, cb, bubble);
      return this;
    };
    ValueParser.unit = require_unit();
    ValueParser.walk = walk2;
    ValueParser.stringify = stringify5;
    module2.exports = ValueParser;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/transition.js
var require_transition = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/transition.js"(exports3, module2) {
    var { list } = require_postcss();
    var parser2 = require_lib2();
    var Browsers = require_browsers3();
    var vendor = require_vendor();
    var Transition = class {
      constructor(prefixes) {
        this.props = ["transition", "transition-property"];
        this.prefixes = prefixes;
      }
      /**
       * Process transition and add prefixes for all necessary properties
       */
      add(decl, result) {
        let prefix, prop;
        let add = this.prefixes.add[decl.prop];
        let vendorPrefixes = this.ruleVendorPrefixes(decl);
        let declPrefixes = vendorPrefixes || add && add.prefixes || [];
        let params = this.parse(decl.value);
        let names = params.map((i2) => this.findProp(i2));
        let added = [];
        if (names.some((i2) => i2[0] === "-")) {
          return;
        }
        for (let param of params) {
          prop = this.findProp(param);
          if (prop[0] === "-")
            continue;
          let prefixer = this.prefixes.add[prop];
          if (!prefixer || !prefixer.prefixes)
            continue;
          for (prefix of prefixer.prefixes) {
            if (vendorPrefixes && !vendorPrefixes.some((p2) => prefix.includes(p2))) {
              continue;
            }
            let prefixed = this.prefixes.prefixed(prop, prefix);
            if (prefixed !== "-ms-transform" && !names.includes(prefixed)) {
              if (!this.disabled(prop, prefix)) {
                added.push(this.clone(prop, prefixed, param));
              }
            }
          }
        }
        params = params.concat(added);
        let value2 = this.stringify(params);
        let webkitClean = this.stringify(
          this.cleanFromUnprefixed(params, "-webkit-")
        );
        if (declPrefixes.includes("-webkit-")) {
          this.cloneBefore(decl, `-webkit-${decl.prop}`, webkitClean);
        }
        this.cloneBefore(decl, decl.prop, webkitClean);
        if (declPrefixes.includes("-o-")) {
          let operaClean = this.stringify(this.cleanFromUnprefixed(params, "-o-"));
          this.cloneBefore(decl, `-o-${decl.prop}`, operaClean);
        }
        for (prefix of declPrefixes) {
          if (prefix !== "-webkit-" && prefix !== "-o-") {
            let prefixValue = this.stringify(
              this.cleanOtherPrefixes(params, prefix)
            );
            this.cloneBefore(decl, prefix + decl.prop, prefixValue);
          }
        }
        if (value2 !== decl.value && !this.already(decl, decl.prop, value2)) {
          this.checkForWarning(result, decl);
          decl.cloneBefore();
          decl.value = value2;
        }
      }
      /**
       * Find property name
       */
      findProp(param) {
        let prop = param[0].value;
        if (/^\d/.test(prop)) {
          for (let [i2, token] of param.entries()) {
            if (i2 !== 0 && token.type === "word") {
              return token.value;
            }
          }
        }
        return prop;
      }
      /**
       * Does we already have this declaration
       */
      already(decl, prop, value2) {
        return decl.parent.some((i2) => i2.prop === prop && i2.value === value2);
      }
      /**
       * Add declaration if it is not exist
       */
      cloneBefore(decl, prop, value2) {
        if (!this.already(decl, prop, value2)) {
          decl.cloneBefore({ prop, value: value2 });
        }
      }
      /**
       * Show transition-property warning
       */
      checkForWarning(result, decl) {
        if (decl.prop !== "transition-property") {
          return;
        }
        let isPrefixed = false;
        let hasAssociatedProp = false;
        decl.parent.each((i2) => {
          if (i2.type !== "decl") {
            return void 0;
          }
          if (i2.prop.indexOf("transition-") !== 0) {
            return void 0;
          }
          let values = list.comma(i2.value);
          if (i2.prop === "transition-property") {
            values.forEach((value2) => {
              let lookup2 = this.prefixes.add[value2];
              if (lookup2 && lookup2.prefixes && lookup2.prefixes.length > 0) {
                isPrefixed = true;
              }
            });
            return void 0;
          }
          hasAssociatedProp = hasAssociatedProp || values.length > 1;
          return false;
        });
        if (isPrefixed && hasAssociatedProp) {
          decl.warn(
            result,
            "Replace transition-property to transition, because Autoprefixer could not support any cases of transition-property and other transition-*"
          );
        }
      }
      /**
       * Process transition and remove all unnecessary properties
       */
      remove(decl) {
        let params = this.parse(decl.value);
        params = params.filter((i2) => {
          let prop = this.prefixes.remove[this.findProp(i2)];
          return !prop || !prop.remove;
        });
        let value2 = this.stringify(params);
        if (decl.value === value2) {
          return;
        }
        if (params.length === 0) {
          decl.remove();
          return;
        }
        let double = decl.parent.some((i2) => {
          return i2.prop === decl.prop && i2.value === value2;
        });
        let smaller = decl.parent.some((i2) => {
          return i2 !== decl && i2.prop === decl.prop && i2.value.length > value2.length;
        });
        if (double || smaller) {
          decl.remove();
          return;
        }
        decl.value = value2;
      }
      /**
       * Parse properties list to array
       */
      parse(value2) {
        let ast = parser2(value2);
        let result = [];
        let param = [];
        for (let node3 of ast.nodes) {
          param.push(node3);
          if (node3.type === "div" && node3.value === ",") {
            result.push(param);
            param = [];
          }
        }
        result.push(param);
        return result.filter((i2) => i2.length > 0);
      }
      /**
       * Return properties string from array
       */
      stringify(params) {
        if (params.length === 0) {
          return "";
        }
        let nodes = [];
        for (let param of params) {
          if (param[param.length - 1].type !== "div") {
            param.push(this.div(params));
          }
          nodes = nodes.concat(param);
        }
        if (nodes[0].type === "div") {
          nodes = nodes.slice(1);
        }
        if (nodes[nodes.length - 1].type === "div") {
          nodes = nodes.slice(0, -2 + 1 || void 0);
        }
        return parser2.stringify({ nodes });
      }
      /**
       * Return new param array with different name
       */
      clone(origin, name2, param) {
        let result = [];
        let changed = false;
        for (let i2 of param) {
          if (!changed && i2.type === "word" && i2.value === origin) {
            result.push({ type: "word", value: name2 });
            changed = true;
          } else {
            result.push(i2);
          }
        }
        return result;
      }
      /**
       * Find or create separator
       */
      div(params) {
        for (let param of params) {
          for (let node3 of param) {
            if (node3.type === "div" && node3.value === ",") {
              return node3;
            }
          }
        }
        return { type: "div", value: ",", after: " " };
      }
      cleanOtherPrefixes(params, prefix) {
        return params.filter((param) => {
          let current2 = vendor.prefix(this.findProp(param));
          return current2 === "" || current2 === prefix;
        });
      }
      /**
       * Remove all non-webkit prefixes and unprefixed params if we have prefixed
       */
      cleanFromUnprefixed(params, prefix) {
        let remove = params.map((i2) => this.findProp(i2)).filter((i2) => i2.slice(0, prefix.length) === prefix).map((i2) => this.prefixes.unprefixed(i2));
        let result = [];
        for (let param of params) {
          let prop = this.findProp(param);
          let p2 = vendor.prefix(prop);
          if (!remove.includes(prop) && (p2 === prefix || p2 === "")) {
            result.push(param);
          }
        }
        return result;
      }
      /**
       * Check property for disabled by option
       */
      disabled(prop, prefix) {
        let other = ["order", "justify-content", "align-self", "align-content"];
        if (prop.includes("flex") || other.includes(prop)) {
          if (this.prefixes.options.flexbox === false) {
            return true;
          }
          if (this.prefixes.options.flexbox === "no-2009") {
            return prefix.includes("2009");
          }
        }
        return void 0;
      }
      /**
       * Check if transition prop is inside vendor specific rule
       */
      ruleVendorPrefixes(decl) {
        let { parent } = decl;
        if (parent.type !== "rule") {
          return false;
        } else if (!parent.selector.includes(":-")) {
          return false;
        }
        let selectors = Browsers.prefixes().filter(
          (s2) => parent.selector.includes(":" + s2)
        );
        return selectors.length > 0 ? selectors : false;
      }
    };
    module2.exports = Transition;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/old-value.js
var require_old_value = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/old-value.js"(exports3, module2) {
    var utils2 = require_utils7();
    var OldValue = class {
      constructor(unprefixed, prefixed, string3, regexp) {
        this.unprefixed = unprefixed;
        this.prefixed = prefixed;
        this.string = string3 || prefixed;
        this.regexp = regexp || utils2.regexp(prefixed);
      }
      /**
       * Check, that value contain old value
       */
      check(value2) {
        if (value2.includes(this.string)) {
          return !!value2.match(this.regexp);
        }
        return false;
      }
    };
    module2.exports = OldValue;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/value.js
var require_value = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/value.js"(exports3, module2) {
    var Prefixer = require_prefixer();
    var OldValue = require_old_value();
    var vendor = require_vendor();
    var utils2 = require_utils7();
    var Value = class extends Prefixer {
      /**
       * Clone decl for each prefixed values
       */
      static save(prefixes, decl) {
        let prop = decl.prop;
        let result = [];
        for (let prefix in decl._autoprefixerValues) {
          let value2 = decl._autoprefixerValues[prefix];
          if (value2 === decl.value) {
            continue;
          }
          let item;
          let propPrefix = vendor.prefix(prop);
          if (propPrefix === "-pie-") {
            continue;
          }
          if (propPrefix === prefix) {
            item = decl.value = value2;
            result.push(item);
            continue;
          }
          let prefixed = prefixes.prefixed(prop, prefix);
          let rule = decl.parent;
          if (!rule.every((i2) => i2.prop !== prefixed)) {
            result.push(item);
            continue;
          }
          let trimmed = value2.replace(/\s+/, " ");
          let already = rule.some(
            (i2) => i2.prop === decl.prop && i2.value.replace(/\s+/, " ") === trimmed
          );
          if (already) {
            result.push(item);
            continue;
          }
          let cloned = this.clone(decl, { value: value2 });
          item = decl.parent.insertBefore(decl, cloned);
          result.push(item);
        }
        return result;
      }
      /**
       * Is declaration need to be prefixed
       */
      check(decl) {
        let value2 = decl.value;
        if (!value2.includes(this.name)) {
          return false;
        }
        return !!value2.match(this.regexp());
      }
      /**
       * Lazy regexp loading
       */
      regexp() {
        return this.regexpCache || (this.regexpCache = utils2.regexp(this.name));
      }
      /**
       * Add prefix to values in string
       */
      replace(string3, prefix) {
        return string3.replace(this.regexp(), `$1${prefix}$2`);
      }
      /**
       * Get value with comments if it was not changed
       */
      value(decl) {
        if (decl.raws.value && decl.raws.value.value === decl.value) {
          return decl.raws.value.raw;
        } else {
          return decl.value;
        }
      }
      /**
       * Save values with next prefixed token
       */
      add(decl, prefix) {
        if (!decl._autoprefixerValues) {
          decl._autoprefixerValues = {};
        }
        let value2 = decl._autoprefixerValues[prefix] || this.value(decl);
        let before;
        do {
          before = value2;
          value2 = this.replace(value2, prefix);
          if (value2 === false)
            return;
        } while (value2 !== before);
        decl._autoprefixerValues[prefix] = value2;
      }
      /**
       * Return function to fast find prefixed value
       */
      old(prefix) {
        return new OldValue(this.name, prefix + this.name);
      }
    };
    module2.exports = Value;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/grid-utils.js
var require_grid_utils = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/grid-utils.js"(exports3) {
    var parser2 = require_lib2();
    var list = require_postcss().list;
    var uniq = require_utils7().uniq;
    var escapeRegexp = require_utils7().escapeRegexp;
    var splitSelector = require_utils7().splitSelector;
    function convert(value2) {
      if (value2 && value2.length === 2 && value2[0] === "span" && parseInt(value2[1], 10) > 0) {
        return [false, parseInt(value2[1], 10)];
      }
      if (value2 && value2.length === 1 && parseInt(value2[0], 10) > 0) {
        return [parseInt(value2[0], 10), false];
      }
      return [false, false];
    }
    exports3.translate = translate;
    function translate(values, startIndex, endIndex) {
      let startValue = values[startIndex];
      let endValue = values[endIndex];
      if (!startValue) {
        return [false, false];
      }
      let [start, spanStart] = convert(startValue);
      let [end, spanEnd] = convert(endValue);
      if (start && !endValue) {
        return [start, false];
      }
      if (spanStart && end) {
        return [end - spanStart, spanStart];
      }
      if (start && spanEnd) {
        return [start, spanEnd];
      }
      if (start && end) {
        return [start, end - start];
      }
      return [false, false];
    }
    exports3.parse = parse7;
    function parse7(decl) {
      let node3 = parser2(decl.value);
      let values = [];
      let current2 = 0;
      values[current2] = [];
      for (let i2 of node3.nodes) {
        if (i2.type === "div") {
          current2 += 1;
          values[current2] = [];
        } else if (i2.type === "word") {
          values[current2].push(i2.value);
        }
      }
      return values;
    }
    exports3.insertDecl = insertDecl;
    function insertDecl(decl, prop, value2) {
      if (value2 && !decl.parent.some((i2) => i2.prop === `-ms-${prop}`)) {
        decl.cloneBefore({
          prop: `-ms-${prop}`,
          value: value2.toString()
        });
      }
    }
    exports3.prefixTrackProp = prefixTrackProp;
    function prefixTrackProp({ prop, prefix }) {
      return prefix + prop.replace("template-", "");
    }
    function transformRepeat({ nodes }, { gap }) {
      let { count, size } = nodes.reduce(
        (result, node3) => {
          if (node3.type === "div" && node3.value === ",") {
            result.key = "size";
          } else {
            result[result.key].push(parser2.stringify(node3));
          }
          return result;
        },
        {
          key: "count",
          size: [],
          count: []
        }
      );
      if (gap) {
        size = size.filter((i2) => i2.trim());
        let val = [];
        for (let i2 = 1; i2 <= count; i2++) {
          size.forEach((item, index2) => {
            if (index2 > 0 || i2 > 1) {
              val.push(gap);
            }
            val.push(item);
          });
        }
        return val.join(" ");
      }
      return `(${size.join("")})[${count.join("")}]`;
    }
    exports3.prefixTrackValue = prefixTrackValue;
    function prefixTrackValue({ value: value2, gap }) {
      let result = parser2(value2).nodes.reduce((nodes, node3) => {
        if (node3.type === "function" && node3.value === "repeat") {
          return nodes.concat({
            type: "word",
            value: transformRepeat(node3, { gap })
          });
        }
        if (gap && node3.type === "space") {
          return nodes.concat(
            {
              type: "space",
              value: " "
            },
            {
              type: "word",
              value: gap
            },
            node3
          );
        }
        return nodes.concat(node3);
      }, []);
      return parser2.stringify(result);
    }
    var DOTS = /^\.+$/;
    function track(start, end) {
      return { start, end, span: end - start };
    }
    function getColumns(line) {
      return line.trim().split(/\s+/g);
    }
    exports3.parseGridAreas = parseGridAreas;
    function parseGridAreas({ rows, gap }) {
      return rows.reduce((areas, line, rowIndex) => {
        if (gap.row)
          rowIndex *= 2;
        if (line.trim() === "")
          return areas;
        getColumns(line).forEach((area, columnIndex) => {
          if (DOTS.test(area))
            return;
          if (gap.column)
            columnIndex *= 2;
          if (typeof areas[area] === "undefined") {
            areas[area] = {
              column: track(columnIndex + 1, columnIndex + 2),
              row: track(rowIndex + 1, rowIndex + 2)
            };
          } else {
            let { column, row } = areas[area];
            column.start = Math.min(column.start, columnIndex + 1);
            column.end = Math.max(column.end, columnIndex + 2);
            column.span = column.end - column.start;
            row.start = Math.min(row.start, rowIndex + 1);
            row.end = Math.max(row.end, rowIndex + 2);
            row.span = row.end - row.start;
          }
        });
        return areas;
      }, {});
    }
    function testTrack(node3) {
      return node3.type === "word" && /^\[.+]$/.test(node3.value);
    }
    function verifyRowSize(result) {
      if (result.areas.length > result.rows.length) {
        result.rows.push("auto");
      }
      return result;
    }
    exports3.parseTemplate = parseTemplate;
    function parseTemplate({ decl, gap }) {
      let gridTemplate = parser2(decl.value).nodes.reduce(
        (result, node3) => {
          let { type, value: value2 } = node3;
          if (testTrack(node3) || type === "space")
            return result;
          if (type === "string") {
            result = verifyRowSize(result);
            result.areas.push(value2);
          }
          if (type === "word" || type === "function") {
            result[result.key].push(parser2.stringify(node3));
          }
          if (type === "div" && value2 === "/") {
            result.key = "columns";
            result = verifyRowSize(result);
          }
          return result;
        },
        {
          key: "rows",
          columns: [],
          rows: [],
          areas: []
        }
      );
      return {
        areas: parseGridAreas({
          rows: gridTemplate.areas,
          gap
        }),
        columns: prefixTrackValue({
          value: gridTemplate.columns.join(" "),
          gap: gap.column
        }),
        rows: prefixTrackValue({
          value: gridTemplate.rows.join(" "),
          gap: gap.row
        })
      };
    }
    function getMSDecls(area, addRowSpan = false, addColumnSpan = false) {
      let result = [
        {
          prop: "-ms-grid-row",
          value: String(area.row.start)
        }
      ];
      if (area.row.span > 1 || addRowSpan) {
        result.push({
          prop: "-ms-grid-row-span",
          value: String(area.row.span)
        });
      }
      result.push({
        prop: "-ms-grid-column",
        value: String(area.column.start)
      });
      if (area.column.span > 1 || addColumnSpan) {
        result.push({
          prop: "-ms-grid-column-span",
          value: String(area.column.span)
        });
      }
      return result;
    }
    function getParentMedia(parent) {
      if (parent.type === "atrule" && parent.name === "media") {
        return parent;
      }
      if (!parent.parent) {
        return false;
      }
      return getParentMedia(parent.parent);
    }
    function changeDuplicateAreaSelectors(ruleSelectors, templateSelectors) {
      ruleSelectors = ruleSelectors.map((selector) => {
        let selectorBySpace = list.space(selector);
        let selectorByComma = list.comma(selector);
        if (selectorBySpace.length > selectorByComma.length) {
          selector = selectorBySpace.slice(-1).join("");
        }
        return selector;
      });
      return ruleSelectors.map((ruleSelector) => {
        let newSelector = templateSelectors.map((tplSelector, index2) => {
          let space = index2 === 0 ? "" : " ";
          return `${space}${tplSelector} > ${ruleSelector}`;
        });
        return newSelector;
      });
    }
    function selectorsEqual(ruleA, ruleB) {
      return ruleA.selectors.some((sel) => {
        return ruleB.selectors.includes(sel);
      });
    }
    function parseGridTemplatesData(css) {
      let parsed = [];
      css.walkDecls(/grid-template(-areas)?$/, (d2) => {
        let rule = d2.parent;
        let media = getParentMedia(rule);
        let gap = getGridGap(d2);
        let inheritedGap = inheritGridGap(d2, gap);
        let { areas } = parseTemplate({ decl: d2, gap: inheritedGap || gap });
        let areaNames = Object.keys(areas);
        if (areaNames.length === 0) {
          return true;
        }
        let index2 = parsed.reduce((acc, { allAreas }, idx) => {
          let hasAreas = allAreas && areaNames.some((area) => allAreas.includes(area));
          return hasAreas ? idx : acc;
        }, null);
        if (index2 !== null) {
          let { allAreas, rules } = parsed[index2];
          let hasNoDuplicates = rules.some((r3) => {
            return r3.hasDuplicates === false && selectorsEqual(r3, rule);
          });
          let duplicatesFound = false;
          let duplicateAreaNames = rules.reduce((acc, r3) => {
            if (!r3.params && selectorsEqual(r3, rule)) {
              duplicatesFound = true;
              return r3.duplicateAreaNames;
            }
            if (!duplicatesFound) {
              areaNames.forEach((name2) => {
                if (r3.areas[name2]) {
                  acc.push(name2);
                }
              });
            }
            return uniq(acc);
          }, []);
          rules.forEach((r3) => {
            areaNames.forEach((name2) => {
              let area = r3.areas[name2];
              if (area && area.row.span !== areas[name2].row.span) {
                areas[name2].row.updateSpan = true;
              }
              if (area && area.column.span !== areas[name2].column.span) {
                areas[name2].column.updateSpan = true;
              }
            });
          });
          parsed[index2].allAreas = uniq([...allAreas, ...areaNames]);
          parsed[index2].rules.push({
            hasDuplicates: !hasNoDuplicates,
            params: media.params,
            selectors: rule.selectors,
            node: rule,
            duplicateAreaNames,
            areas
          });
        } else {
          parsed.push({
            allAreas: areaNames,
            areasCount: 0,
            rules: [
              {
                hasDuplicates: false,
                duplicateRules: [],
                params: media.params,
                selectors: rule.selectors,
                node: rule,
                duplicateAreaNames: [],
                areas
              }
            ]
          });
        }
        return void 0;
      });
      return parsed;
    }
    exports3.insertAreas = insertAreas;
    function insertAreas(css, isDisabled) {
      let gridTemplatesData = parseGridTemplatesData(css);
      if (gridTemplatesData.length === 0) {
        return void 0;
      }
      let rulesToInsert = {};
      css.walkDecls("grid-area", (gridArea) => {
        let gridAreaRule = gridArea.parent;
        let hasPrefixedRow = gridAreaRule.first.prop === "-ms-grid-row";
        let gridAreaMedia = getParentMedia(gridAreaRule);
        if (isDisabled(gridArea)) {
          return void 0;
        }
        let gridAreaRuleIndex = css.index(gridAreaMedia || gridAreaRule);
        let value2 = gridArea.value;
        let data2 = gridTemplatesData.filter((d2) => d2.allAreas.includes(value2))[0];
        if (!data2) {
          return true;
        }
        let lastArea = data2.allAreas[data2.allAreas.length - 1];
        let selectorBySpace = list.space(gridAreaRule.selector);
        let selectorByComma = list.comma(gridAreaRule.selector);
        let selectorIsComplex = selectorBySpace.length > 1 && selectorBySpace.length > selectorByComma.length;
        if (hasPrefixedRow) {
          return false;
        }
        if (!rulesToInsert[lastArea]) {
          rulesToInsert[lastArea] = {};
        }
        let lastRuleIsSet = false;
        for (let rule of data2.rules) {
          let area = rule.areas[value2];
          let hasDuplicateName = rule.duplicateAreaNames.includes(value2);
          if (!area) {
            let lastRule = rulesToInsert[lastArea].lastRule;
            let lastRuleIndex;
            if (lastRule) {
              lastRuleIndex = css.index(lastRule);
            } else {
              lastRuleIndex = -1;
            }
            if (gridAreaRuleIndex > lastRuleIndex) {
              rulesToInsert[lastArea].lastRule = gridAreaMedia || gridAreaRule;
            }
            continue;
          }
          if (rule.params && !rulesToInsert[lastArea][rule.params]) {
            rulesToInsert[lastArea][rule.params] = [];
          }
          if ((!rule.hasDuplicates || !hasDuplicateName) && !rule.params) {
            getMSDecls(area, false, false).reverse().forEach(
              (i2) => gridAreaRule.prepend(
                Object.assign(i2, {
                  raws: {
                    between: gridArea.raws.between
                  }
                })
              )
            );
            rulesToInsert[lastArea].lastRule = gridAreaRule;
            lastRuleIsSet = true;
          } else if (rule.hasDuplicates && !rule.params && !selectorIsComplex) {
            let cloned = gridAreaRule.clone();
            cloned.removeAll();
            getMSDecls(area, area.row.updateSpan, area.column.updateSpan).reverse().forEach(
              (i2) => cloned.prepend(
                Object.assign(i2, {
                  raws: {
                    between: gridArea.raws.between
                  }
                })
              )
            );
            cloned.selectors = changeDuplicateAreaSelectors(
              cloned.selectors,
              rule.selectors
            );
            if (rulesToInsert[lastArea].lastRule) {
              rulesToInsert[lastArea].lastRule.after(cloned);
            }
            rulesToInsert[lastArea].lastRule = cloned;
            lastRuleIsSet = true;
          } else if (rule.hasDuplicates && !rule.params && selectorIsComplex && gridAreaRule.selector.includes(rule.selectors[0])) {
            gridAreaRule.walkDecls(/-ms-grid-(row|column)/, (d2) => d2.remove());
            getMSDecls(area, area.row.updateSpan, area.column.updateSpan).reverse().forEach(
              (i2) => gridAreaRule.prepend(
                Object.assign(i2, {
                  raws: {
                    between: gridArea.raws.between
                  }
                })
              )
            );
          } else if (rule.params) {
            let cloned = gridAreaRule.clone();
            cloned.removeAll();
            getMSDecls(area, area.row.updateSpan, area.column.updateSpan).reverse().forEach(
              (i2) => cloned.prepend(
                Object.assign(i2, {
                  raws: {
                    between: gridArea.raws.between
                  }
                })
              )
            );
            if (rule.hasDuplicates && hasDuplicateName) {
              cloned.selectors = changeDuplicateAreaSelectors(
                cloned.selectors,
                rule.selectors
              );
            }
            cloned.raws = rule.node.raws;
            if (css.index(rule.node.parent) > gridAreaRuleIndex) {
              rule.node.parent.append(cloned);
            } else {
              rulesToInsert[lastArea][rule.params].push(cloned);
            }
            if (!lastRuleIsSet) {
              rulesToInsert[lastArea].lastRule = gridAreaMedia || gridAreaRule;
            }
          }
        }
        return void 0;
      });
      Object.keys(rulesToInsert).forEach((area) => {
        let data2 = rulesToInsert[area];
        let lastRule = data2.lastRule;
        Object.keys(data2).reverse().filter((p2) => p2 !== "lastRule").forEach((params) => {
          if (data2[params].length > 0 && lastRule) {
            lastRule.after({ name: "media", params });
            lastRule.next().append(data2[params]);
          }
        });
      });
      return void 0;
    }
    exports3.warnMissedAreas = warnMissedAreas;
    function warnMissedAreas(areas, decl, result) {
      let missed = Object.keys(areas);
      decl.root().walkDecls("grid-area", (gridArea) => {
        missed = missed.filter((e3) => e3 !== gridArea.value);
      });
      if (missed.length > 0) {
        decl.warn(result, "Can not find grid areas: " + missed.join(", "));
      }
      return void 0;
    }
    exports3.warnTemplateSelectorNotFound = warnTemplateSelectorNotFound;
    function warnTemplateSelectorNotFound(decl, result) {
      let rule = decl.parent;
      let root = decl.root();
      let duplicatesFound = false;
      let slicedSelectorArr = list.space(rule.selector).filter((str2) => str2 !== ">").slice(0, -1);
      if (slicedSelectorArr.length > 0) {
        let gridTemplateFound = false;
        let foundAreaSelector = null;
        root.walkDecls(/grid-template(-areas)?$/, (d2) => {
          let parent = d2.parent;
          let templateSelectors = parent.selectors;
          let { areas } = parseTemplate({ decl: d2, gap: getGridGap(d2) });
          let hasArea = areas[decl.value];
          for (let tplSelector of templateSelectors) {
            if (gridTemplateFound) {
              break;
            }
            let tplSelectorArr = list.space(tplSelector).filter((str2) => str2 !== ">");
            gridTemplateFound = tplSelectorArr.every(
              (item, idx) => item === slicedSelectorArr[idx]
            );
          }
          if (gridTemplateFound || !hasArea) {
            return true;
          }
          if (!foundAreaSelector) {
            foundAreaSelector = parent.selector;
          }
          if (foundAreaSelector && foundAreaSelector !== parent.selector) {
            duplicatesFound = true;
          }
          return void 0;
        });
        if (!gridTemplateFound && duplicatesFound) {
          decl.warn(
            result,
            `Autoprefixer cannot find a grid-template containing the duplicate grid-area "${decl.value}" with full selector matching: ${slicedSelectorArr.join(" ")}`
          );
        }
      }
    }
    exports3.warnIfGridRowColumnExists = warnIfGridRowColumnExists;
    function warnIfGridRowColumnExists(decl, result) {
      let rule = decl.parent;
      let decls = [];
      rule.walkDecls(/^grid-(row|column)/, (d2) => {
        if (!d2.prop.endsWith("-end") && !d2.value.startsWith("span") && !d2.prop.endsWith("-gap")) {
          decls.push(d2);
        }
      });
      if (decls.length > 0) {
        decls.forEach((d2) => {
          d2.warn(
            result,
            `You already have a grid-area declaration present in the rule. You should use either grid-area or ${d2.prop}, not both`
          );
        });
      }
      return void 0;
    }
    exports3.getGridGap = getGridGap;
    function getGridGap(decl) {
      let gap = {};
      let testGap = /^(grid-)?((row|column)-)?gap$/;
      decl.parent.walkDecls(testGap, ({ prop, value: value2 }) => {
        if (/^(grid-)?gap$/.test(prop)) {
          let [row, , column] = parser2(value2).nodes;
          gap.row = row && parser2.stringify(row);
          gap.column = column ? parser2.stringify(column) : gap.row;
        }
        if (/^(grid-)?row-gap$/.test(prop))
          gap.row = value2;
        if (/^(grid-)?column-gap$/.test(prop))
          gap.column = value2;
      });
      return gap;
    }
    function parseMediaParams(params) {
      if (!params) {
        return [];
      }
      let parsed = parser2(params);
      let prop;
      let value2;
      parsed.walk((node3) => {
        if (node3.type === "word" && /min|max/g.test(node3.value)) {
          prop = node3.value;
        } else if (node3.value.includes("px")) {
          value2 = parseInt(node3.value.replace(/\D/g, ""));
        }
      });
      return [prop, value2];
    }
    function shouldInheritGap(selA, selB) {
      let result;
      let splitSelectorArrA = splitSelector(selA);
      let splitSelectorArrB = splitSelector(selB);
      if (splitSelectorArrA[0].length < splitSelectorArrB[0].length) {
        return false;
      } else if (splitSelectorArrA[0].length > splitSelectorArrB[0].length) {
        let idx = splitSelectorArrA[0].reduce((res, [item], index2) => {
          let firstSelectorPart = splitSelectorArrB[0][0][0];
          if (item === firstSelectorPart) {
            return index2;
          }
          return false;
        }, false);
        if (idx) {
          result = splitSelectorArrB[0].every((arr, index2) => {
            return arr.every(
              (part, innerIndex) => (
                // because selectorA has more space elements, we need to slice
                // selectorA array by 'idx' number to compare them
                splitSelectorArrA[0].slice(idx)[index2][innerIndex] === part
              )
            );
          });
        }
      } else {
        result = splitSelectorArrB.some((byCommaArr) => {
          return byCommaArr.every((bySpaceArr, index2) => {
            return bySpaceArr.every(
              (part, innerIndex) => splitSelectorArrA[0][index2][innerIndex] === part
            );
          });
        });
      }
      return result;
    }
    exports3.inheritGridGap = inheritGridGap;
    function inheritGridGap(decl, gap) {
      let rule = decl.parent;
      let mediaRule = getParentMedia(rule);
      let root = rule.root();
      let splitSelectorArr = splitSelector(rule.selector);
      if (Object.keys(gap).length > 0) {
        return false;
      }
      let [prop] = parseMediaParams(mediaRule.params);
      let lastBySpace = splitSelectorArr[0];
      let escaped2 = escapeRegexp(lastBySpace[lastBySpace.length - 1][0]);
      let regexp = new RegExp(`(${escaped2}$)|(${escaped2}[,.])`);
      let closestRuleGap;
      root.walkRules(regexp, (r3) => {
        let gridGap;
        if (rule.toString() === r3.toString()) {
          return false;
        }
        r3.walkDecls("grid-gap", (d2) => gridGap = getGridGap(d2));
        if (!gridGap || Object.keys(gridGap).length === 0) {
          return true;
        }
        if (!shouldInheritGap(rule.selector, r3.selector)) {
          return true;
        }
        let media = getParentMedia(r3);
        if (media) {
          let propToCompare = parseMediaParams(media.params)[0];
          if (propToCompare === prop) {
            closestRuleGap = gridGap;
            return true;
          }
        } else {
          closestRuleGap = gridGap;
          return true;
        }
        return void 0;
      });
      if (closestRuleGap && Object.keys(closestRuleGap).length > 0) {
        return closestRuleGap;
      }
      return false;
    }
    exports3.warnGridGap = warnGridGap;
    function warnGridGap({ gap, hasColumns, decl, result }) {
      let hasBothGaps = gap.row && gap.column;
      if (!hasColumns && (hasBothGaps || gap.column && !gap.row)) {
        delete gap.column;
        decl.warn(
          result,
          "Can not implement grid-gap without grid-template-columns"
        );
      }
    }
    function normalizeRowColumn(str2) {
      let normalized = parser2(str2).nodes.reduce((result, node3) => {
        if (node3.type === "function" && node3.value === "repeat") {
          let key = "count";
          let [count, value2] = node3.nodes.reduce(
            (acc, n3) => {
              if (n3.type === "word" && key === "count") {
                acc[0] = Math.abs(parseInt(n3.value));
                return acc;
              }
              if (n3.type === "div" && n3.value === ",") {
                key = "value";
                return acc;
              }
              if (key === "value") {
                acc[1] += parser2.stringify(n3);
              }
              return acc;
            },
            [0, ""]
          );
          if (count) {
            for (let i2 = 0; i2 < count; i2++) {
              result.push(value2);
            }
          }
          return result;
        }
        if (node3.type === "space") {
          return result;
        }
        return result.concat(parser2.stringify(node3));
      }, []);
      return normalized;
    }
    exports3.autoplaceGridItems = autoplaceGridItems;
    function autoplaceGridItems(decl, result, gap, autoflowValue = "row") {
      let { parent } = decl;
      let rowDecl = parent.nodes.find((i2) => i2.prop === "grid-template-rows");
      let rows = normalizeRowColumn(rowDecl.value);
      let columns = normalizeRowColumn(decl.value);
      let filledRows = rows.map((_, rowIndex) => {
        return Array.from(
          { length: columns.length },
          (v, k) => k + rowIndex * columns.length + 1
        ).join(" ");
      });
      let areas = parseGridAreas({ rows: filledRows, gap });
      let keys = Object.keys(areas);
      let items = keys.map((i2) => areas[i2]);
      if (autoflowValue.includes("column")) {
        items = items.sort((a2, b) => a2.column.start - b.column.start);
      }
      items.reverse().forEach((item, index2) => {
        let { column, row } = item;
        let nodeSelector = parent.selectors.map((sel) => sel + ` > *:nth-child(${keys.length - index2})`).join(", ");
        let node3 = parent.clone().removeAll();
        node3.selector = nodeSelector;
        node3.append({ prop: "-ms-grid-row", value: row.start });
        node3.append({ prop: "-ms-grid-column", value: column.start });
        parent.after(node3);
      });
      return void 0;
    }
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/processor.js
var require_processor = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/processor.js"(exports3, module2) {
    var parser2 = require_lib2();
    var Value = require_value();
    var insertAreas = require_grid_utils().insertAreas;
    var OLD_LINEAR = /(^|[^-])linear-gradient\(\s*(top|left|right|bottom)/i;
    var OLD_RADIAL = /(^|[^-])radial-gradient\(\s*\d+(\w*|%)\s+\d+(\w*|%)\s*,/i;
    var IGNORE_NEXT = /(!\s*)?autoprefixer:\s*ignore\s+next/i;
    var GRID_REGEX = /(!\s*)?autoprefixer\s*grid:\s*(on|off|(no-)?autoplace)/i;
    var SIZES = [
      "width",
      "height",
      "min-width",
      "max-width",
      "min-height",
      "max-height",
      "inline-size",
      "min-inline-size",
      "max-inline-size",
      "block-size",
      "min-block-size",
      "max-block-size"
    ];
    function hasGridTemplate(decl) {
      return decl.parent.some(
        (i2) => i2.prop === "grid-template" || i2.prop === "grid-template-areas"
      );
    }
    function hasRowsAndColumns(decl) {
      let hasRows = decl.parent.some((i2) => i2.prop === "grid-template-rows");
      let hasColumns = decl.parent.some((i2) => i2.prop === "grid-template-columns");
      return hasRows && hasColumns;
    }
    var Processor = class {
      constructor(prefixes) {
        this.prefixes = prefixes;
      }
      /**
       * Add necessary prefixes
       */
      add(css, result) {
        let resolution = this.prefixes.add["@resolution"];
        let keyframes = this.prefixes.add["@keyframes"];
        let viewport = this.prefixes.add["@viewport"];
        let supports = this.prefixes.add["@supports"];
        css.walkAtRules((rule) => {
          if (rule.name === "keyframes") {
            if (!this.disabled(rule, result)) {
              return keyframes && keyframes.process(rule);
            }
          } else if (rule.name === "viewport") {
            if (!this.disabled(rule, result)) {
              return viewport && viewport.process(rule);
            }
          } else if (rule.name === "supports") {
            if (this.prefixes.options.supports !== false && !this.disabled(rule, result)) {
              return supports.process(rule);
            }
          } else if (rule.name === "media" && rule.params.includes("-resolution")) {
            if (!this.disabled(rule, result)) {
              return resolution && resolution.process(rule);
            }
          }
          return void 0;
        });
        css.walkRules((rule) => {
          if (this.disabled(rule, result))
            return void 0;
          return this.prefixes.add.selectors.map((selector) => {
            return selector.process(rule, result);
          });
        });
        function insideGrid(decl) {
          return decl.parent.nodes.some((node3) => {
            if (node3.type !== "decl")
              return false;
            let displayGrid = node3.prop === "display" && /(inline-)?grid/.test(node3.value);
            let gridTemplate = node3.prop.startsWith("grid-template");
            let gridGap = /^grid-([A-z]+-)?gap/.test(node3.prop);
            return displayGrid || gridTemplate || gridGap;
          });
        }
        function insideFlex(decl) {
          return decl.parent.some((node3) => {
            return node3.prop === "display" && /(inline-)?flex/.test(node3.value);
          });
        }
        let gridPrefixes = this.gridStatus(css, result) && this.prefixes.add["grid-area"] && this.prefixes.add["grid-area"].prefixes;
        css.walkDecls((decl) => {
          if (this.disabledDecl(decl, result))
            return void 0;
          let parent = decl.parent;
          let prop = decl.prop;
          let value2 = decl.value;
          if (prop === "color-adjust") {
            if (parent.every((i2) => i2.prop !== "print-color-adjust")) {
              result.warn(
                "Replace color-adjust to print-color-adjust. The color-adjust shorthand is currently deprecated.",
                { node: decl }
              );
            }
          } else if (prop === "grid-row-span") {
            result.warn(
              "grid-row-span is not part of final Grid Layout. Use grid-row.",
              { node: decl }
            );
            return void 0;
          } else if (prop === "grid-column-span") {
            result.warn(
              "grid-column-span is not part of final Grid Layout. Use grid-column.",
              { node: decl }
            );
            return void 0;
          } else if (prop === "display" && value2 === "box") {
            result.warn(
              "You should write display: flex by final spec instead of display: box",
              { node: decl }
            );
            return void 0;
          } else if (prop === "text-emphasis-position") {
            if (value2 === "under" || value2 === "over") {
              result.warn(
                "You should use 2 values for text-emphasis-position For example, `under left` instead of just `under`.",
                { node: decl }
              );
            }
          } else if (/^(align|justify|place)-(items|content)$/.test(prop) && insideFlex(decl)) {
            if (value2 === "start" || value2 === "end") {
              result.warn(
                `${value2} value has mixed support, consider using flex-${value2} instead`,
                { node: decl }
              );
            }
          } else if (prop === "text-decoration-skip" && value2 === "ink") {
            result.warn(
              "Replace text-decoration-skip: ink to text-decoration-skip-ink: auto, because spec had been changed",
              { node: decl }
            );
          } else {
            if (gridPrefixes && this.gridStatus(decl, result)) {
              if (decl.value === "subgrid") {
                result.warn("IE does not support subgrid", { node: decl });
              }
              if (/^(align|justify|place)-items$/.test(prop) && insideGrid(decl)) {
                let fixed = prop.replace("-items", "-self");
                result.warn(
                  `IE does not support ${prop} on grid containers. Try using ${fixed} on child elements instead: ${decl.parent.selector} > * { ${fixed}: ${decl.value} }`,
                  { node: decl }
                );
              } else if (/^(align|justify|place)-content$/.test(prop) && insideGrid(decl)) {
                result.warn(`IE does not support ${decl.prop} on grid containers`, {
                  node: decl
                });
              } else if (prop === "display" && decl.value === "contents") {
                result.warn(
                  "Please do not use display: contents; if you have grid setting enabled",
                  { node: decl }
                );
                return void 0;
              } else if (decl.prop === "grid-gap") {
                let status2 = this.gridStatus(decl, result);
                if (status2 === "autoplace" && !hasRowsAndColumns(decl) && !hasGridTemplate(decl)) {
                  result.warn(
                    "grid-gap only works if grid-template(-areas) is being used or both rows and columns have been declared and cells have not been manually placed inside the explicit grid",
                    { node: decl }
                  );
                } else if ((status2 === true || status2 === "no-autoplace") && !hasGridTemplate(decl)) {
                  result.warn(
                    "grid-gap only works if grid-template(-areas) is being used",
                    { node: decl }
                  );
                }
              } else if (prop === "grid-auto-columns") {
                result.warn("grid-auto-columns is not supported by IE", {
                  node: decl
                });
                return void 0;
              } else if (prop === "grid-auto-rows") {
                result.warn("grid-auto-rows is not supported by IE", { node: decl });
                return void 0;
              } else if (prop === "grid-auto-flow") {
                let hasRows = parent.some((i2) => i2.prop === "grid-template-rows");
                let hasCols = parent.some((i2) => i2.prop === "grid-template-columns");
                if (hasGridTemplate(decl)) {
                  result.warn("grid-auto-flow is not supported by IE", {
                    node: decl
                  });
                } else if (value2.includes("dense")) {
                  result.warn("grid-auto-flow: dense is not supported by IE", {
                    node: decl
                  });
                } else if (!hasRows && !hasCols) {
                  result.warn(
                    "grid-auto-flow works only if grid-template-rows and grid-template-columns are present in the same rule",
                    { node: decl }
                  );
                }
                return void 0;
              } else if (value2.includes("auto-fit")) {
                result.warn("auto-fit value is not supported by IE", {
                  node: decl,
                  word: "auto-fit"
                });
                return void 0;
              } else if (value2.includes("auto-fill")) {
                result.warn("auto-fill value is not supported by IE", {
                  node: decl,
                  word: "auto-fill"
                });
                return void 0;
              } else if (prop.startsWith("grid-template") && value2.includes("[")) {
                result.warn(
                  "Autoprefixer currently does not support line names. Try using grid-template-areas instead.",
                  { node: decl, word: "[" }
                );
              }
            }
            if (value2.includes("radial-gradient")) {
              if (OLD_RADIAL.test(decl.value)) {
                result.warn(
                  "Gradient has outdated direction syntax. New syntax is like `closest-side at 0 0` instead of `0 0, closest-side`.",
                  { node: decl }
                );
              } else {
                let ast = parser2(value2);
                for (let i2 of ast.nodes) {
                  if (i2.type === "function" && i2.value === "radial-gradient") {
                    for (let word of i2.nodes) {
                      if (word.type === "word") {
                        if (word.value === "cover") {
                          result.warn(
                            "Gradient has outdated direction syntax. Replace `cover` to `farthest-corner`.",
                            { node: decl }
                          );
                        } else if (word.value === "contain") {
                          result.warn(
                            "Gradient has outdated direction syntax. Replace `contain` to `closest-side`.",
                            { node: decl }
                          );
                        }
                      }
                    }
                  }
                }
              }
            }
            if (value2.includes("linear-gradient")) {
              if (OLD_LINEAR.test(value2)) {
                result.warn(
                  "Gradient has outdated direction syntax. New syntax is like `to left` instead of `right`.",
                  { node: decl }
                );
              }
            }
          }
          if (SIZES.includes(decl.prop)) {
            if (!decl.value.includes("-fill-available")) {
              if (decl.value.includes("fill-available")) {
                result.warn(
                  "Replace fill-available to stretch, because spec had been changed",
                  { node: decl }
                );
              } else if (decl.value.includes("fill")) {
                let ast = parser2(value2);
                if (ast.nodes.some((i2) => i2.type === "word" && i2.value === "fill")) {
                  result.warn(
                    "Replace fill to stretch, because spec had been changed",
                    { node: decl }
                  );
                }
              }
            }
          }
          let prefixer;
          if (decl.prop === "transition" || decl.prop === "transition-property") {
            return this.prefixes.transition.add(decl, result);
          } else if (decl.prop === "align-self") {
            let display = this.displayType(decl);
            if (display !== "grid" && this.prefixes.options.flexbox !== false) {
              prefixer = this.prefixes.add["align-self"];
              if (prefixer && prefixer.prefixes) {
                prefixer.process(decl);
              }
            }
            if (this.gridStatus(decl, result) !== false) {
              prefixer = this.prefixes.add["grid-row-align"];
              if (prefixer && prefixer.prefixes) {
                return prefixer.process(decl, result);
              }
            }
          } else if (decl.prop === "justify-self") {
            if (this.gridStatus(decl, result) !== false) {
              prefixer = this.prefixes.add["grid-column-align"];
              if (prefixer && prefixer.prefixes) {
                return prefixer.process(decl, result);
              }
            }
          } else if (decl.prop === "place-self") {
            prefixer = this.prefixes.add["place-self"];
            if (prefixer && prefixer.prefixes && this.gridStatus(decl, result) !== false) {
              return prefixer.process(decl, result);
            }
          } else {
            prefixer = this.prefixes.add[decl.prop];
            if (prefixer && prefixer.prefixes) {
              return prefixer.process(decl, result);
            }
          }
          return void 0;
        });
        if (this.gridStatus(css, result)) {
          insertAreas(css, this.disabled);
        }
        return css.walkDecls((decl) => {
          if (this.disabledValue(decl, result))
            return;
          let unprefixed = this.prefixes.unprefixed(decl.prop);
          let list = this.prefixes.values("add", unprefixed);
          if (Array.isArray(list)) {
            for (let value2 of list) {
              if (value2.process)
                value2.process(decl, result);
            }
          }
          Value.save(this.prefixes, decl);
        });
      }
      /**
       * Remove unnecessary pefixes
       */
      remove(css, result) {
        let resolution = this.prefixes.remove["@resolution"];
        css.walkAtRules((rule, i2) => {
          if (this.prefixes.remove[`@${rule.name}`]) {
            if (!this.disabled(rule, result)) {
              rule.parent.removeChild(i2);
            }
          } else if (rule.name === "media" && rule.params.includes("-resolution") && resolution) {
            resolution.clean(rule);
          }
        });
        for (let checker of this.prefixes.remove.selectors) {
          css.walkRules((rule, i2) => {
            if (checker.check(rule)) {
              if (!this.disabled(rule, result)) {
                rule.parent.removeChild(i2);
              }
            }
          });
        }
        return css.walkDecls((decl, i2) => {
          if (this.disabled(decl, result))
            return;
          let rule = decl.parent;
          let unprefixed = this.prefixes.unprefixed(decl.prop);
          if (decl.prop === "transition" || decl.prop === "transition-property") {
            this.prefixes.transition.remove(decl);
          }
          if (this.prefixes.remove[decl.prop] && this.prefixes.remove[decl.prop].remove) {
            let notHack = this.prefixes.group(decl).down((other) => {
              return this.prefixes.normalize(other.prop) === unprefixed;
            });
            if (unprefixed === "flex-flow") {
              notHack = true;
            }
            if (decl.prop === "-webkit-box-orient") {
              let hacks = { "flex-direction": true, "flex-flow": true };
              if (!decl.parent.some((j) => hacks[j.prop]))
                return;
            }
            if (notHack && !this.withHackValue(decl)) {
              if (decl.raw("before").includes("\n")) {
                this.reduceSpaces(decl);
              }
              rule.removeChild(i2);
              return;
            }
          }
          for (let checker of this.prefixes.values("remove", unprefixed)) {
            if (!checker.check)
              continue;
            if (!checker.check(decl.value))
              continue;
            unprefixed = checker.unprefixed;
            let notHack = this.prefixes.group(decl).down((other) => {
              return other.value.includes(unprefixed);
            });
            if (notHack) {
              rule.removeChild(i2);
              return;
            }
          }
        });
      }
      /**
       * Some rare old values, which is not in standard
       */
      withHackValue(decl) {
        return decl.prop === "-webkit-background-clip" && decl.value === "text";
      }
      /**
       * Check for grid/flexbox options.
       */
      disabledValue(node3, result) {
        if (this.gridStatus(node3, result) === false && node3.type === "decl") {
          if (node3.prop === "display" && node3.value.includes("grid")) {
            return true;
          }
        }
        if (this.prefixes.options.flexbox === false && node3.type === "decl") {
          if (node3.prop === "display" && node3.value.includes("flex")) {
            return true;
          }
        }
        if (node3.type === "decl" && node3.prop === "content") {
          return true;
        }
        return this.disabled(node3, result);
      }
      /**
       * Check for grid/flexbox options.
       */
      disabledDecl(node3, result) {
        if (this.gridStatus(node3, result) === false && node3.type === "decl") {
          if (node3.prop.includes("grid") || node3.prop === "justify-items") {
            return true;
          }
        }
        if (this.prefixes.options.flexbox === false && node3.type === "decl") {
          let other = ["order", "justify-content", "align-items", "align-content"];
          if (node3.prop.includes("flex") || other.includes(node3.prop)) {
            return true;
          }
        }
        return this.disabled(node3, result);
      }
      /**
       * Check for control comment and global options
       */
      disabled(node3, result) {
        if (!node3)
          return false;
        if (node3._autoprefixerDisabled !== void 0) {
          return node3._autoprefixerDisabled;
        }
        if (node3.parent) {
          let p2 = node3.prev();
          if (p2 && p2.type === "comment" && IGNORE_NEXT.test(p2.text)) {
            node3._autoprefixerDisabled = true;
            node3._autoprefixerSelfDisabled = true;
            return true;
          }
        }
        let value2 = null;
        if (node3.nodes) {
          let status2;
          node3.each((i2) => {
            if (i2.type !== "comment")
              return;
            if (/(!\s*)?autoprefixer:\s*(off|on)/i.test(i2.text)) {
              if (typeof status2 !== "undefined") {
                result.warn(
                  "Second Autoprefixer control comment was ignored. Autoprefixer applies control comment to whole block, not to next rules.",
                  { node: i2 }
                );
              } else {
                status2 = /on/i.test(i2.text);
              }
            }
          });
          if (status2 !== void 0) {
            value2 = !status2;
          }
        }
        if (!node3.nodes || value2 === null) {
          if (node3.parent) {
            let isParentDisabled = this.disabled(node3.parent, result);
            if (node3.parent._autoprefixerSelfDisabled === true) {
              value2 = false;
            } else {
              value2 = isParentDisabled;
            }
          } else {
            value2 = false;
          }
        }
        node3._autoprefixerDisabled = value2;
        return value2;
      }
      /**
       * Normalize spaces in cascade declaration group
       */
      reduceSpaces(decl) {
        let stop = false;
        this.prefixes.group(decl).up(() => {
          stop = true;
          return true;
        });
        if (stop) {
          return;
        }
        let parts = decl.raw("before").split("\n");
        let prevMin = parts[parts.length - 1].length;
        let diff = false;
        this.prefixes.group(decl).down((other) => {
          parts = other.raw("before").split("\n");
          let last = parts.length - 1;
          if (parts[last].length > prevMin) {
            if (diff === false) {
              diff = parts[last].length - prevMin;
            }
            parts[last] = parts[last].slice(0, -diff);
            other.raws.before = parts.join("\n");
          }
        });
      }
      /**
       * Is it flebox or grid rule
       */
      displayType(decl) {
        for (let i2 of decl.parent.nodes) {
          if (i2.prop !== "display") {
            continue;
          }
          if (i2.value.includes("flex")) {
            return "flex";
          }
          if (i2.value.includes("grid")) {
            return "grid";
          }
        }
        return false;
      }
      /**
       * Set grid option via control comment
       */
      gridStatus(node3, result) {
        if (!node3)
          return false;
        if (node3._autoprefixerGridStatus !== void 0) {
          return node3._autoprefixerGridStatus;
        }
        let value2 = null;
        if (node3.nodes) {
          let status2;
          node3.each((i2) => {
            if (i2.type !== "comment")
              return;
            if (GRID_REGEX.test(i2.text)) {
              let hasAutoplace = /:\s*autoplace/i.test(i2.text);
              let noAutoplace = /no-autoplace/i.test(i2.text);
              if (typeof status2 !== "undefined") {
                result.warn(
                  "Second Autoprefixer grid control comment was ignored. Autoprefixer applies control comments to the whole block, not to the next rules.",
                  { node: i2 }
                );
              } else if (hasAutoplace) {
                status2 = "autoplace";
              } else if (noAutoplace) {
                status2 = true;
              } else {
                status2 = /on/i.test(i2.text);
              }
            }
          });
          if (status2 !== void 0) {
            value2 = status2;
          }
        }
        if (node3.type === "atrule" && node3.name === "supports") {
          let params = node3.params;
          if (params.includes("grid") && params.includes("auto")) {
            value2 = false;
          }
        }
        if (!node3.nodes || value2 === null) {
          if (node3.parent) {
            let isParentGrid = this.gridStatus(node3.parent, result);
            if (node3.parent._autoprefixerSelfDisabled === true) {
              value2 = false;
            } else {
              value2 = isParentGrid;
            }
          } else if (typeof this.prefixes.options.grid !== "undefined") {
            value2 = this.prefixes.options.grid;
          } else if (typeof process.env.AUTOPREFIXER_GRID !== "undefined") {
            if (process.env.AUTOPREFIXER_GRID === "autoplace") {
              value2 = "autoplace";
            } else {
              value2 = true;
            }
          } else {
            value2 = false;
          }
        }
        node3._autoprefixerGridStatus = value2;
        return value2;
      }
    };
    module2.exports = Processor;
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-featurequeries.js
var require_css_featurequeries = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-featurequeries.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D E F A B FC" }, B: { "1": "C K L G M N O P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x" }, C: { "1": "1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "0 GC wB I y J D E F A B C K L G M N O z j HC IC" }, D: { "1": "7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "2": "0 1 2 3 4 5 6 I y J D E F A B C K L G M N O z j" }, E: { "1": "F A B C K L G PC 2B tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC", "2": "I y J D E LC 1B MC NC OC" }, F: { "1": "0 1 2 3 4 5 6 7 8 9 G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h uB", "2": "F B C TC UC VC WC tB DC XC" }, G: { "1": "dC eC fC gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "2": "E 1B YC EC ZC aC bC cC" }, H: { "1": "sC" }, I: { "1": "H xC yC", "2": "wB I tC uC vC wC EC" }, J: { "2": "D A" }, K: { "1": "k", "2": "A B C tB DC uB" }, L: { "1": "H" }, M: { "1": "i" }, N: { "2": "A B" }, O: { "1": "zC" }, P: { "1": "I j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD" }, Q: { "1": "3B" }, R: { "1": "DD" }, S: { "1": "ED FD" } }, B: 4, C: "CSS Feature Queries" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/dist/lib/statuses.js
var require_statuses = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/dist/lib/statuses.js"(exports3, module2) {
    module2.exports = {
      1: "ls",
      // WHATWG Living Standard
      2: "rec",
      // W3C Recommendation
      3: "pr",
      // W3C Proposed Recommendation
      4: "cr",
      // W3C Candidate Recommendation
      5: "wd",
      // W3C Working Draft
      6: "other",
      // Non-W3C, but reputable
      7: "unoff"
      // Unofficial, Editor's Draft or W3C "Note"
    };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/dist/lib/supported.js
var require_supported = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/dist/lib/supported.js"(exports3, module2) {
    module2.exports = {
      y: 1 << 0,
      n: 1 << 1,
      a: 1 << 2,
      p: 1 << 3,
      u: 1 << 4,
      x: 1 << 5,
      d: 1 << 6
    };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/dist/unpacker/feature.js
var require_feature = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/dist/unpacker/feature.js"(exports3, module2) {
    "use strict";
    var statuses2 = require_statuses();
    var supported = require_supported();
    var browsers = require_browsers2().browsers;
    var versions = require_browserVersions2().browserVersions;
    var MATH2LOG = Math.log(2);
    function unpackSupport(cipher) {
      let stats = Object.keys(supported).reduce((list, support) => {
        if (cipher & supported[support])
          list.push(support);
        return list;
      }, []);
      let notes = cipher >> 7;
      let notesArray = [];
      while (notes) {
        let note = Math.floor(Math.log(notes) / MATH2LOG) + 1;
        notesArray.unshift(`#${note}`);
        notes -= Math.pow(2, note - 1);
      }
      return stats.concat(notesArray).join(" ");
    }
    function unpackFeature(packed) {
      let unpacked = { status: statuses2[packed.B], title: packed.C };
      unpacked.stats = Object.keys(packed.A).reduce((browserStats, key) => {
        let browser3 = packed.A[key];
        browserStats[browsers[key]] = Object.keys(browser3).reduce(
          (stats, support) => {
            let packedVersions = browser3[support].split(" ");
            let unpacked2 = unpackSupport(support);
            packedVersions.forEach((v) => stats[versions[v]] = unpacked2);
            return stats;
          },
          {}
        );
        return browserStats;
      }, {});
      return unpacked;
    }
    module2.exports = unpackFeature;
    module2.exports.default = unpackFeature;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/brackets.js
var require_brackets = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/brackets.js"(exports3, module2) {
    function last(array2) {
      return array2[array2.length - 1];
    }
    var brackets = {
      /**
       * Parse string to nodes tree
       */
      parse(str2) {
        let current2 = [""];
        let stack = [current2];
        for (let sym of str2) {
          if (sym === "(") {
            current2 = [""];
            last(stack).push(current2);
            stack.push(current2);
            continue;
          }
          if (sym === ")") {
            stack.pop();
            current2 = last(stack);
            current2.push("");
            continue;
          }
          current2[current2.length - 1] += sym;
        }
        return stack[0];
      },
      /**
       * Generate output string by nodes tree
       */
      stringify(ast) {
        let result = "";
        for (let i2 of ast) {
          if (typeof i2 === "object") {
            result += `(${brackets.stringify(i2)})`;
            continue;
          }
          result += i2;
        }
        return result;
      }
    };
    module2.exports = brackets;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/supports.js
var require_supports = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/supports.js"(exports3, module2) {
    var featureQueries = require_css_featurequeries();
    var feature = require_feature();
    var { parse: parse7 } = require_postcss();
    var Browsers = require_browsers3();
    var brackets = require_brackets();
    var Value = require_value();
    var utils2 = require_utils7();
    var data2 = feature(featureQueries);
    var supported = [];
    for (let browser3 in data2.stats) {
      let versions = data2.stats[browser3];
      for (let version4 in versions) {
        let support = versions[version4];
        if (/y/.test(support)) {
          supported.push(browser3 + " " + version4);
        }
      }
    }
    var Supports = class {
      constructor(Prefixes, all) {
        this.Prefixes = Prefixes;
        this.all = all;
      }
      /**
       * Return prefixer only with @supports supported browsers
       */
      prefixer() {
        if (this.prefixerCache) {
          return this.prefixerCache;
        }
        let filtered = this.all.browsers.selected.filter((i2) => {
          return supported.includes(i2);
        });
        let browsers = new Browsers(
          this.all.browsers.data,
          filtered,
          this.all.options
        );
        this.prefixerCache = new this.Prefixes(
          this.all.data,
          browsers,
          this.all.options
        );
        return this.prefixerCache;
      }
      /**
       * Parse string into declaration property and value
       */
      parse(str2) {
        let parts = str2.split(":");
        let prop = parts[0];
        let value2 = parts[1];
        if (!value2)
          value2 = "";
        return [prop.trim(), value2.trim()];
      }
      /**
       * Create virtual rule to process it by prefixer
       */
      virtual(str2) {
        let [prop, value2] = this.parse(str2);
        let rule = parse7("a{}").first;
        rule.append({ prop, value: value2, raws: { before: "" } });
        return rule;
      }
      /**
       * Return array of Declaration with all necessary prefixes
       */
      prefixed(str2) {
        let rule = this.virtual(str2);
        if (this.disabled(rule.first)) {
          return rule.nodes;
        }
        let result = { warn: () => null };
        let prefixer = this.prefixer().add[rule.first.prop];
        prefixer && prefixer.process && prefixer.process(rule.first, result);
        for (let decl of rule.nodes) {
          for (let value2 of this.prefixer().values("add", rule.first.prop)) {
            value2.process(decl);
          }
          Value.save(this.all, decl);
        }
        return rule.nodes;
      }
      /**
       * Return true if brackets node is "not" word
       */
      isNot(node3) {
        return typeof node3 === "string" && /not\s*/i.test(node3);
      }
      /**
       * Return true if brackets node is "or" word
       */
      isOr(node3) {
        return typeof node3 === "string" && /\s*or\s*/i.test(node3);
      }
      /**
       * Return true if brackets node is (prop: value)
       */
      isProp(node3) {
        return typeof node3 === "object" && node3.length === 1 && typeof node3[0] === "string";
      }
      /**
       * Return true if prefixed property has no unprefixed
       */
      isHack(all, unprefixed) {
        let check = new RegExp(`(\\(|\\s)${utils2.escapeRegexp(unprefixed)}:`);
        return !check.test(all);
      }
      /**
       * Return true if we need to remove node
       */
      toRemove(str2, all) {
        let [prop, value2] = this.parse(str2);
        let unprefixed = this.all.unprefixed(prop);
        let cleaner = this.all.cleaner();
        if (cleaner.remove[prop] && cleaner.remove[prop].remove && !this.isHack(all, unprefixed)) {
          return true;
        }
        for (let checker of cleaner.values("remove", unprefixed)) {
          if (checker.check(value2)) {
            return true;
          }
        }
        return false;
      }
      /**
       * Remove all unnecessary prefixes
       */
      remove(nodes, all) {
        let i2 = 0;
        while (i2 < nodes.length) {
          if (!this.isNot(nodes[i2 - 1]) && this.isProp(nodes[i2]) && this.isOr(nodes[i2 + 1])) {
            if (this.toRemove(nodes[i2][0], all)) {
              nodes.splice(i2, 2);
              continue;
            }
            i2 += 2;
            continue;
          }
          if (typeof nodes[i2] === "object") {
            nodes[i2] = this.remove(nodes[i2], all);
          }
          i2 += 1;
        }
        return nodes;
      }
      /**
       * Clean brackets with one child
       */
      cleanBrackets(nodes) {
        return nodes.map((i2) => {
          if (typeof i2 !== "object") {
            return i2;
          }
          if (i2.length === 1 && typeof i2[0] === "object") {
            return this.cleanBrackets(i2[0]);
          }
          return this.cleanBrackets(i2);
        });
      }
      /**
       * Add " or " between properties and convert it to brackets format
       */
      convert(progress) {
        let result = [""];
        for (let i2 of progress) {
          result.push([`${i2.prop}: ${i2.value}`]);
          result.push(" or ");
        }
        result[result.length - 1] = "";
        return result;
      }
      /**
       * Compress value functions into a string nodes
       */
      normalize(nodes) {
        if (typeof nodes !== "object") {
          return nodes;
        }
        nodes = nodes.filter((i2) => i2 !== "");
        if (typeof nodes[0] === "string") {
          let firstNode = nodes[0].trim();
          if (firstNode.includes(":") || firstNode === "selector" || firstNode === "not selector") {
            return [brackets.stringify(nodes)];
          }
        }
        return nodes.map((i2) => this.normalize(i2));
      }
      /**
       * Add prefixes
       */
      add(nodes, all) {
        return nodes.map((i2) => {
          if (this.isProp(i2)) {
            let prefixed = this.prefixed(i2[0]);
            if (prefixed.length > 1) {
              return this.convert(prefixed);
            }
            return i2;
          }
          if (typeof i2 === "object") {
            return this.add(i2, all);
          }
          return i2;
        });
      }
      /**
       * Add prefixed declaration
       */
      process(rule) {
        let ast = brackets.parse(rule.params);
        ast = this.normalize(ast);
        ast = this.remove(ast, rule.params);
        ast = this.add(ast, rule.params);
        ast = this.cleanBrackets(ast);
        rule.params = brackets.stringify(ast);
      }
      /**
       * Check global options
       */
      disabled(node3) {
        if (!this.all.options.grid) {
          if (node3.prop === "display" && node3.value.includes("grid")) {
            return true;
          }
          if (node3.prop.includes("grid") || node3.prop === "justify-items") {
            return true;
          }
        }
        if (this.all.options.flexbox === false) {
          if (node3.prop === "display" && node3.value.includes("flex")) {
            return true;
          }
          let other = ["order", "justify-content", "align-items", "align-content"];
          if (node3.prop.includes("flex") || other.includes(node3.prop)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Supports;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/old-selector.js
var require_old_selector = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/old-selector.js"(exports3, module2) {
    var OldSelector = class {
      constructor(selector, prefix) {
        this.prefix = prefix;
        this.prefixed = selector.prefixed(this.prefix);
        this.regexp = selector.regexp(this.prefix);
        this.prefixeds = selector.possible().map((x) => [selector.prefixed(x), selector.regexp(x)]);
        this.unprefixed = selector.name;
        this.nameRegexp = selector.regexp();
      }
      /**
       * Is rule a hack without unprefixed version bottom
       */
      isHack(rule) {
        let index2 = rule.parent.index(rule) + 1;
        let rules = rule.parent.nodes;
        while (index2 < rules.length) {
          let before = rules[index2].selector;
          if (!before) {
            return true;
          }
          if (before.includes(this.unprefixed) && before.match(this.nameRegexp)) {
            return false;
          }
          let some = false;
          for (let [string3, regexp] of this.prefixeds) {
            if (before.includes(string3) && before.match(regexp)) {
              some = true;
              break;
            }
          }
          if (!some) {
            return true;
          }
          index2 += 1;
        }
        return true;
      }
      /**
       * Does rule contain an unnecessary prefixed selector
       */
      check(rule) {
        if (!rule.selector.includes(this.prefixed)) {
          return false;
        }
        if (!rule.selector.match(this.regexp)) {
          return false;
        }
        if (this.isHack(rule)) {
          return false;
        }
        return true;
      }
    };
    module2.exports = OldSelector;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/selector.js
var require_selector = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/selector.js"(exports3, module2) {
    var { list } = require_postcss();
    var OldSelector = require_old_selector();
    var Prefixer = require_prefixer();
    var Browsers = require_browsers3();
    var utils2 = require_utils7();
    var Selector = class extends Prefixer {
      constructor(name2, prefixes, all) {
        super(name2, prefixes, all);
        this.regexpCache = /* @__PURE__ */ new Map();
      }
      /**
       * Is rule selectors need to be prefixed
       */
      check(rule) {
        if (rule.selector.includes(this.name)) {
          return !!rule.selector.match(this.regexp());
        }
        return false;
      }
      /**
       * Return prefixed version of selector
       */
      prefixed(prefix) {
        return this.name.replace(/^(\W*)/, `$1${prefix}`);
      }
      /**
       * Lazy loadRegExp for name
       */
      regexp(prefix) {
        if (!this.regexpCache.has(prefix)) {
          let name2 = prefix ? this.prefixed(prefix) : this.name;
          this.regexpCache.set(
            prefix,
            new RegExp(`(^|[^:"'=])${utils2.escapeRegexp(name2)}`, "gi")
          );
        }
        return this.regexpCache.get(prefix);
      }
      /**
       * All possible prefixes
       */
      possible() {
        return Browsers.prefixes();
      }
      /**
       * Return all possible selector prefixes
       */
      prefixeds(rule) {
        if (rule._autoprefixerPrefixeds) {
          if (rule._autoprefixerPrefixeds[this.name]) {
            return rule._autoprefixerPrefixeds;
          }
        } else {
          rule._autoprefixerPrefixeds = {};
        }
        let prefixeds = {};
        if (rule.selector.includes(",")) {
          let ruleParts = list.comma(rule.selector);
          let toProcess = ruleParts.filter((el) => el.includes(this.name));
          for (let prefix of this.possible()) {
            prefixeds[prefix] = toProcess.map((el) => this.replace(el, prefix)).join(", ");
          }
        } else {
          for (let prefix of this.possible()) {
            prefixeds[prefix] = this.replace(rule.selector, prefix);
          }
        }
        rule._autoprefixerPrefixeds[this.name] = prefixeds;
        return rule._autoprefixerPrefixeds;
      }
      /**
       * Is rule already prefixed before
       */
      already(rule, prefixeds, prefix) {
        let index2 = rule.parent.index(rule) - 1;
        while (index2 >= 0) {
          let before = rule.parent.nodes[index2];
          if (before.type !== "rule") {
            return false;
          }
          let some = false;
          for (let key in prefixeds[this.name]) {
            let prefixed = prefixeds[this.name][key];
            if (before.selector === prefixed) {
              if (prefix === key) {
                return true;
              } else {
                some = true;
                break;
              }
            }
          }
          if (!some) {
            return false;
          }
          index2 -= 1;
        }
        return false;
      }
      /**
       * Replace selectors by prefixed one
       */
      replace(selector, prefix) {
        return selector.replace(this.regexp(), `$1${this.prefixed(prefix)}`);
      }
      /**
       * Clone and add prefixes for at-rule
       */
      add(rule, prefix) {
        let prefixeds = this.prefixeds(rule);
        if (this.already(rule, prefixeds, prefix)) {
          return;
        }
        let cloned = this.clone(rule, { selector: prefixeds[this.name][prefix] });
        rule.parent.insertBefore(rule, cloned);
      }
      /**
       * Return function to fast find prefixed selector
       */
      old(prefix) {
        return new OldSelector(this, prefix);
      }
    };
    module2.exports = Selector;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/at-rule.js
var require_at_rule = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/at-rule.js"(exports3, module2) {
    var Prefixer = require_prefixer();
    var AtRule = class extends Prefixer {
      /**
       * Clone and add prefixes for at-rule
       */
      add(rule, prefix) {
        let prefixed = prefix + rule.name;
        let already = rule.parent.some(
          (i2) => i2.name === prefixed && i2.params === rule.params
        );
        if (already) {
          return void 0;
        }
        let cloned = this.clone(rule, { name: prefixed });
        return rule.parent.insertBefore(rule, cloned);
      }
      /**
       * Clone node with prefixes
       */
      process(node3) {
        let parent = this.parentPrefix(node3);
        for (let prefix of this.prefixes) {
          if (!parent || parent === prefix) {
            this.add(node3, prefix);
          }
        }
      }
    };
    module2.exports = AtRule;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/fullscreen.js
var require_fullscreen = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/fullscreen.js"(exports3, module2) {
    var Selector = require_selector();
    var Fullscreen = class extends Selector {
      /**
       * Return different selectors depend on prefix
       */
      prefixed(prefix) {
        if (prefix === "-webkit-") {
          return ":-webkit-full-screen";
        }
        if (prefix === "-moz-") {
          return ":-moz-full-screen";
        }
        return `:${prefix}fullscreen`;
      }
    };
    Fullscreen.names = [":fullscreen"];
    module2.exports = Fullscreen;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/placeholder.js
var require_placeholder = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/placeholder.js"(exports3, module2) {
    var Selector = require_selector();
    var Placeholder = class extends Selector {
      /**
       * Add old mozilla to possible prefixes
       */
      possible() {
        return super.possible().concat(["-moz- old", "-ms- old"]);
      }
      /**
       * Return different selectors depend on prefix
       */
      prefixed(prefix) {
        if (prefix === "-webkit-") {
          return "::-webkit-input-placeholder";
        }
        if (prefix === "-ms-") {
          return "::-ms-input-placeholder";
        }
        if (prefix === "-ms- old") {
          return ":-ms-input-placeholder";
        }
        if (prefix === "-moz- old") {
          return ":-moz-placeholder";
        }
        return `::${prefix}placeholder`;
      }
    };
    Placeholder.names = ["::placeholder"];
    module2.exports = Placeholder;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/placeholder-shown.js
var require_placeholder_shown = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/placeholder-shown.js"(exports3, module2) {
    var Selector = require_selector();
    var PlaceholderShown = class extends Selector {
      /**
       * Return different selectors depend on prefix
       */
      prefixed(prefix) {
        if (prefix === "-ms-") {
          return ":-ms-input-placeholder";
        }
        return `:${prefix}placeholder-shown`;
      }
    };
    PlaceholderShown.names = [":placeholder-shown"];
    module2.exports = PlaceholderShown;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/file-selector-button.js
var require_file_selector_button = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/file-selector-button.js"(exports3, module2) {
    var Selector = require_selector();
    var utils2 = require_utils7();
    var FileSelectorButton = class extends Selector {
      constructor(name2, prefixes, all) {
        super(name2, prefixes, all);
        if (this.prefixes) {
          this.prefixes = utils2.uniq(this.prefixes.map(() => "-webkit-"));
        }
      }
      /**
       * Return different selectors depend on prefix
       */
      prefixed(prefix) {
        if (prefix === "-webkit-") {
          return "::-webkit-file-upload-button";
        }
        return `::${prefix}file-selector-button`;
      }
    };
    FileSelectorButton.names = ["::file-selector-button"];
    module2.exports = FileSelectorButton;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/flex-spec.js
var require_flex_spec = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/flex-spec.js"(exports3, module2) {
    module2.exports = function(prefix) {
      let spec;
      if (prefix === "-webkit- 2009" || prefix === "-moz-") {
        spec = 2009;
      } else if (prefix === "-ms-") {
        spec = 2012;
      } else if (prefix === "-webkit-") {
        spec = "final";
      }
      if (prefix === "-webkit- 2009") {
        prefix = "-webkit-";
      }
      return [spec, prefix];
    };
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/flex.js
var require_flex = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/flex.js"(exports3, module2) {
    var list = require_postcss().list;
    var flexSpec = require_flex_spec();
    var Declaration = require_declaration();
    var Flex = class extends Declaration {
      /**
       * Change property name for 2009 spec
       */
      prefixed(prop, prefix) {
        let spec;
        [spec, prefix] = flexSpec(prefix);
        if (spec === 2009) {
          return prefix + "box-flex";
        }
        return super.prefixed(prop, prefix);
      }
      /**
       * Return property name by final spec
       */
      normalize() {
        return "flex";
      }
      /**
       * Spec 2009 supports only first argument
       * Spec 2012 disallows unitless basis
       */
      set(decl, prefix) {
        let spec = flexSpec(prefix)[0];
        if (spec === 2009) {
          decl.value = list.space(decl.value)[0];
          decl.value = Flex.oldValues[decl.value] || decl.value;
          return super.set(decl, prefix);
        }
        if (spec === 2012) {
          let components = list.space(decl.value);
          if (components.length === 3 && components[2] === "0") {
            decl.value = components.slice(0, 2).concat("0px").join(" ");
          }
        }
        return super.set(decl, prefix);
      }
    };
    Flex.names = ["flex", "box-flex"];
    Flex.oldValues = {
      auto: "1",
      none: "0"
    };
    module2.exports = Flex;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/order.js
var require_order = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/order.js"(exports3, module2) {
    var flexSpec = require_flex_spec();
    var Declaration = require_declaration();
    var Order = class extends Declaration {
      /**
       * Change property name for 2009 and 2012 specs
       */
      prefixed(prop, prefix) {
        let spec;
        [spec, prefix] = flexSpec(prefix);
        if (spec === 2009) {
          return prefix + "box-ordinal-group";
        }
        if (spec === 2012) {
          return prefix + "flex-order";
        }
        return super.prefixed(prop, prefix);
      }
      /**
       * Return property name by final spec
       */
      normalize() {
        return "order";
      }
      /**
       * Fix value for 2009 spec
       */
      set(decl, prefix) {
        let spec = flexSpec(prefix)[0];
        if (spec === 2009 && /\d/.test(decl.value)) {
          decl.value = (parseInt(decl.value) + 1).toString();
          return super.set(decl, prefix);
        }
        return super.set(decl, prefix);
      }
    };
    Order.names = ["order", "flex-order", "box-ordinal-group"];
    module2.exports = Order;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/filter.js
var require_filter = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/filter.js"(exports3, module2) {
    var Declaration = require_declaration();
    var Filter = class extends Declaration {
      /**
       * Check is it Internet Explorer filter
       */
      check(decl) {
        let v = decl.value;
        return !v.toLowerCase().includes("alpha(") && !v.includes("DXImageTransform.Microsoft") && !v.includes("data:image/svg+xml");
      }
    };
    Filter.names = ["filter"];
    module2.exports = Filter;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/grid-end.js
var require_grid_end = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/grid-end.js"(exports3, module2) {
    var Declaration = require_declaration();
    var { isPureNumber } = require_utils7();
    var GridEnd = class extends Declaration {
      /**
       * Change repeating syntax for IE
       */
      insert(decl, prefix, prefixes, result) {
        if (prefix !== "-ms-")
          return super.insert(decl, prefix, prefixes);
        let clonedDecl = this.clone(decl);
        let startProp = decl.prop.replace(/end$/, "start");
        let spanProp = prefix + decl.prop.replace(/end$/, "span");
        if (decl.parent.some((i2) => i2.prop === spanProp)) {
          return void 0;
        }
        clonedDecl.prop = spanProp;
        if (decl.value.includes("span")) {
          clonedDecl.value = decl.value.replace(/span\s/i, "");
        } else {
          let startDecl;
          decl.parent.walkDecls(startProp, (d2) => {
            startDecl = d2;
          });
          if (startDecl) {
            if (isPureNumber(startDecl.value)) {
              let value2 = Number(decl.value) - Number(startDecl.value) + "";
              clonedDecl.value = value2;
            } else {
              return void 0;
            }
          } else {
            decl.warn(
              result,
              `Can not prefix ${decl.prop} (${startProp} is not found)`
            );
          }
        }
        decl.cloneBefore(clonedDecl);
        return void 0;
      }
    };
    GridEnd.names = ["grid-row-end", "grid-column-end"];
    module2.exports = GridEnd;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/animation.js
var require_animation = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/animation.js"(exports3, module2) {
    var Declaration = require_declaration();
    var Animation = class extends Declaration {
      /**
       * Don’t add prefixes for modern values.
       */
      check(decl) {
        return !decl.value.split(/\s+/).some((i2) => {
          let lower = i2.toLowerCase();
          return lower === "reverse" || lower === "alternate-reverse";
        });
      }
    };
    Animation.names = ["animation", "animation-direction"];
    module2.exports = Animation;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/flex-flow.js
var require_flex_flow = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/flex-flow.js"(exports3, module2) {
    var flexSpec = require_flex_spec();
    var Declaration = require_declaration();
    var FlexFlow = class extends Declaration {
      /**
       * Use two properties for 2009 spec
       */
      insert(decl, prefix, prefixes) {
        let spec;
        [spec, prefix] = flexSpec(prefix);
        if (spec !== 2009) {
          return super.insert(decl, prefix, prefixes);
        }
        let values = decl.value.split(/\s+/).filter((i2) => i2 !== "wrap" && i2 !== "nowrap" && "wrap-reverse");
        if (values.length === 0) {
          return void 0;
        }
        let already = decl.parent.some(
          (i2) => i2.prop === prefix + "box-orient" || i2.prop === prefix + "box-direction"
        );
        if (already) {
          return void 0;
        }
        let value2 = values[0];
        let orient = value2.includes("row") ? "horizontal" : "vertical";
        let dir = value2.includes("reverse") ? "reverse" : "normal";
        let cloned = this.clone(decl);
        cloned.prop = prefix + "box-orient";
        cloned.value = orient;
        if (this.needCascade(decl)) {
          cloned.raws.before = this.calcBefore(prefixes, decl, prefix);
        }
        decl.parent.insertBefore(decl, cloned);
        cloned = this.clone(decl);
        cloned.prop = prefix + "box-direction";
        cloned.value = dir;
        if (this.needCascade(decl)) {
          cloned.raws.before = this.calcBefore(prefixes, decl, prefix);
        }
        return decl.parent.insertBefore(decl, cloned);
      }
    };
    FlexFlow.names = ["flex-flow", "box-direction", "box-orient"];
    module2.exports = FlexFlow;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/flex-grow.js
var require_flex_grow = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/flex-grow.js"(exports3, module2) {
    var flexSpec = require_flex_spec();
    var Declaration = require_declaration();
    var Flex = class extends Declaration {
      /**
       * Return property name by final spec
       */
      normalize() {
        return "flex";
      }
      /**
       * Return flex property for 2009 and 2012 specs
       */
      prefixed(prop, prefix) {
        let spec;
        [spec, prefix] = flexSpec(prefix);
        if (spec === 2009) {
          return prefix + "box-flex";
        }
        if (spec === 2012) {
          return prefix + "flex-positive";
        }
        return super.prefixed(prop, prefix);
      }
    };
    Flex.names = ["flex-grow", "flex-positive"];
    module2.exports = Flex;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/flex-wrap.js
var require_flex_wrap = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/flex-wrap.js"(exports3, module2) {
    var flexSpec = require_flex_spec();
    var Declaration = require_declaration();
    var FlexWrap = class extends Declaration {
      /**
       * Don't add prefix for 2009 spec
       */
      set(decl, prefix) {
        let spec = flexSpec(prefix)[0];
        if (spec !== 2009) {
          return super.set(decl, prefix);
        }
        return void 0;
      }
    };
    FlexWrap.names = ["flex-wrap"];
    module2.exports = FlexWrap;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/grid-area.js
var require_grid_area = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/grid-area.js"(exports3, module2) {
    var Declaration = require_declaration();
    var utils2 = require_grid_utils();
    var GridArea = class extends Declaration {
      /**
       * Translate grid-area to separate -ms- prefixed properties
       */
      insert(decl, prefix, prefixes, result) {
        if (prefix !== "-ms-")
          return super.insert(decl, prefix, prefixes);
        let values = utils2.parse(decl);
        let [rowStart, rowSpan] = utils2.translate(values, 0, 2);
        let [columnStart, columnSpan] = utils2.translate(values, 1, 3);
        [
          ["grid-row", rowStart],
          ["grid-row-span", rowSpan],
          ["grid-column", columnStart],
          ["grid-column-span", columnSpan]
        ].forEach(([prop, value2]) => {
          utils2.insertDecl(decl, prop, value2);
        });
        utils2.warnTemplateSelectorNotFound(decl, result);
        utils2.warnIfGridRowColumnExists(decl, result);
        return void 0;
      }
    };
    GridArea.names = ["grid-area"];
    module2.exports = GridArea;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/place-self.js
var require_place_self = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/place-self.js"(exports3, module2) {
    var Declaration = require_declaration();
    var utils2 = require_grid_utils();
    var PlaceSelf = class extends Declaration {
      /**
       * Translate place-self to separate -ms- prefixed properties
       */
      insert(decl, prefix, prefixes) {
        if (prefix !== "-ms-")
          return super.insert(decl, prefix, prefixes);
        if (decl.parent.some((i2) => i2.prop === "-ms-grid-row-align")) {
          return void 0;
        }
        let [[first2, second]] = utils2.parse(decl);
        if (second) {
          utils2.insertDecl(decl, "grid-row-align", first2);
          utils2.insertDecl(decl, "grid-column-align", second);
        } else {
          utils2.insertDecl(decl, "grid-row-align", first2);
          utils2.insertDecl(decl, "grid-column-align", first2);
        }
        return void 0;
      }
    };
    PlaceSelf.names = ["place-self"];
    module2.exports = PlaceSelf;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/grid-start.js
var require_grid_start = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/grid-start.js"(exports3, module2) {
    var Declaration = require_declaration();
    var GridStart = class extends Declaration {
      /**
       * Do not add prefix for unsupported value in IE
       */
      check(decl) {
        let value2 = decl.value;
        return !value2.includes("/") && !value2.includes("span");
      }
      /**
       * Return a final spec property
       */
      normalize(prop) {
        return prop.replace("-start", "");
      }
      /**
       * Change property name for IE
       */
      prefixed(prop, prefix) {
        let result = super.prefixed(prop, prefix);
        if (prefix === "-ms-") {
          result = result.replace("-start", "");
        }
        return result;
      }
    };
    GridStart.names = ["grid-row-start", "grid-column-start"];
    module2.exports = GridStart;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/align-self.js
var require_align_self = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/align-self.js"(exports3, module2) {
    var flexSpec = require_flex_spec();
    var Declaration = require_declaration();
    var AlignSelf = class extends Declaration {
      check(decl) {
        return decl.parent && !decl.parent.some((i2) => {
          return i2.prop && i2.prop.startsWith("grid-");
        });
      }
      /**
       * Change property name for 2012 specs
       */
      prefixed(prop, prefix) {
        let spec;
        [spec, prefix] = flexSpec(prefix);
        if (spec === 2012) {
          return prefix + "flex-item-align";
        }
        return super.prefixed(prop, prefix);
      }
      /**
       * Return property name by final spec
       */
      normalize() {
        return "align-self";
      }
      /**
       * Change value for 2012 spec and ignore prefix for 2009
       */
      set(decl, prefix) {
        let spec = flexSpec(prefix)[0];
        if (spec === 2012) {
          decl.value = AlignSelf.oldValues[decl.value] || decl.value;
          return super.set(decl, prefix);
        }
        if (spec === "final") {
          return super.set(decl, prefix);
        }
        return void 0;
      }
    };
    AlignSelf.names = ["align-self", "flex-item-align"];
    AlignSelf.oldValues = {
      "flex-end": "end",
      "flex-start": "start"
    };
    module2.exports = AlignSelf;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/appearance.js
var require_appearance = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/appearance.js"(exports3, module2) {
    var Declaration = require_declaration();
    var utils2 = require_utils7();
    var Appearance = class extends Declaration {
      constructor(name2, prefixes, all) {
        super(name2, prefixes, all);
        if (this.prefixes) {
          this.prefixes = utils2.uniq(
            this.prefixes.map((i2) => {
              if (i2 === "-ms-") {
                return "-webkit-";
              }
              return i2;
            })
          );
        }
      }
    };
    Appearance.names = ["appearance"];
    module2.exports = Appearance;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/flex-basis.js
var require_flex_basis = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/flex-basis.js"(exports3, module2) {
    var flexSpec = require_flex_spec();
    var Declaration = require_declaration();
    var FlexBasis = class extends Declaration {
      /**
       * Return property name by final spec
       */
      normalize() {
        return "flex-basis";
      }
      /**
       * Return flex property for 2012 spec
       */
      prefixed(prop, prefix) {
        let spec;
        [spec, prefix] = flexSpec(prefix);
        if (spec === 2012) {
          return prefix + "flex-preferred-size";
        }
        return super.prefixed(prop, prefix);
      }
      /**
       * Ignore 2009 spec and use flex property for 2012
       */
      set(decl, prefix) {
        let spec;
        [spec, prefix] = flexSpec(prefix);
        if (spec === 2012 || spec === "final") {
          return super.set(decl, prefix);
        }
        return void 0;
      }
    };
    FlexBasis.names = ["flex-basis", "flex-preferred-size"];
    module2.exports = FlexBasis;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/mask-border.js
var require_mask_border = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/mask-border.js"(exports3, module2) {
    var Declaration = require_declaration();
    var MaskBorder = class extends Declaration {
      /**
       * Return property name by final spec
       */
      normalize() {
        return this.name.replace("box-image", "border");
      }
      /**
       * Return flex property for 2012 spec
       */
      prefixed(prop, prefix) {
        let result = super.prefixed(prop, prefix);
        if (prefix === "-webkit-") {
          result = result.replace("border", "box-image");
        }
        return result;
      }
    };
    MaskBorder.names = [
      "mask-border",
      "mask-border-source",
      "mask-border-slice",
      "mask-border-width",
      "mask-border-outset",
      "mask-border-repeat",
      "mask-box-image",
      "mask-box-image-source",
      "mask-box-image-slice",
      "mask-box-image-width",
      "mask-box-image-outset",
      "mask-box-image-repeat"
    ];
    module2.exports = MaskBorder;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/mask-composite.js
var require_mask_composite = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/mask-composite.js"(exports3, module2) {
    var Declaration = require_declaration();
    var MaskComposite = class extends Declaration {
      /**
       * Prefix mask-composite for webkit
       */
      insert(decl, prefix, prefixes) {
        let isCompositeProp = decl.prop === "mask-composite";
        let compositeValues;
        if (isCompositeProp) {
          compositeValues = decl.value.split(",");
        } else {
          compositeValues = decl.value.match(MaskComposite.regexp) || [];
        }
        compositeValues = compositeValues.map((el) => el.trim()).filter((el) => el);
        let hasCompositeValues = compositeValues.length;
        let compositeDecl;
        if (hasCompositeValues) {
          compositeDecl = this.clone(decl);
          compositeDecl.value = compositeValues.map((value2) => MaskComposite.oldValues[value2] || value2).join(", ");
          if (compositeValues.includes("intersect")) {
            compositeDecl.value += ", xor";
          }
          compositeDecl.prop = prefix + "mask-composite";
        }
        if (isCompositeProp) {
          if (!hasCompositeValues) {
            return void 0;
          }
          if (this.needCascade(decl)) {
            compositeDecl.raws.before = this.calcBefore(prefixes, decl, prefix);
          }
          return decl.parent.insertBefore(decl, compositeDecl);
        }
        let cloned = this.clone(decl);
        cloned.prop = prefix + cloned.prop;
        if (hasCompositeValues) {
          cloned.value = cloned.value.replace(MaskComposite.regexp, "");
        }
        if (this.needCascade(decl)) {
          cloned.raws.before = this.calcBefore(prefixes, decl, prefix);
        }
        decl.parent.insertBefore(decl, cloned);
        if (!hasCompositeValues) {
          return decl;
        }
        if (this.needCascade(decl)) {
          compositeDecl.raws.before = this.calcBefore(prefixes, decl, prefix);
        }
        return decl.parent.insertBefore(decl, compositeDecl);
      }
    };
    MaskComposite.names = ["mask", "mask-composite"];
    MaskComposite.oldValues = {
      add: "source-over",
      subtract: "source-out",
      intersect: "source-in",
      exclude: "xor"
    };
    MaskComposite.regexp = new RegExp(
      `\\s+(${Object.keys(MaskComposite.oldValues).join(
        "|"
      )})\\b(?!\\))\\s*(?=[,])`,
      "ig"
    );
    module2.exports = MaskComposite;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/align-items.js
var require_align_items = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/align-items.js"(exports3, module2) {
    var flexSpec = require_flex_spec();
    var Declaration = require_declaration();
    var AlignItems = class extends Declaration {
      /**
       * Change property name for 2009 and 2012 specs
       */
      prefixed(prop, prefix) {
        let spec;
        [spec, prefix] = flexSpec(prefix);
        if (spec === 2009) {
          return prefix + "box-align";
        }
        if (spec === 2012) {
          return prefix + "flex-align";
        }
        return super.prefixed(prop, prefix);
      }
      /**
       * Return property name by final spec
       */
      normalize() {
        return "align-items";
      }
      /**
       * Change value for 2009 and 2012 specs
       */
      set(decl, prefix) {
        let spec = flexSpec(prefix)[0];
        if (spec === 2009 || spec === 2012) {
          decl.value = AlignItems.oldValues[decl.value] || decl.value;
        }
        return super.set(decl, prefix);
      }
    };
    AlignItems.names = ["align-items", "flex-align", "box-align"];
    AlignItems.oldValues = {
      "flex-end": "end",
      "flex-start": "start"
    };
    module2.exports = AlignItems;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/user-select.js
var require_user_select = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/user-select.js"(exports3, module2) {
    var Declaration = require_declaration();
    var UserSelect = class extends Declaration {
      /**
       * Change prefixed value for IE
       */
      set(decl, prefix) {
        if (prefix === "-ms-" && decl.value === "contain") {
          decl.value = "element";
        }
        return super.set(decl, prefix);
      }
      /**
       * Avoid prefixing all in IE
       */
      insert(decl, prefix, prefixes) {
        if (decl.value === "all" && prefix === "-ms-") {
          return void 0;
        } else {
          return super.insert(decl, prefix, prefixes);
        }
      }
    };
    UserSelect.names = ["user-select"];
    module2.exports = UserSelect;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/flex-shrink.js
var require_flex_shrink = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/flex-shrink.js"(exports3, module2) {
    var flexSpec = require_flex_spec();
    var Declaration = require_declaration();
    var FlexShrink = class extends Declaration {
      /**
       * Return property name by final spec
       */
      normalize() {
        return "flex-shrink";
      }
      /**
       * Return flex property for 2012 spec
       */
      prefixed(prop, prefix) {
        let spec;
        [spec, prefix] = flexSpec(prefix);
        if (spec === 2012) {
          return prefix + "flex-negative";
        }
        return super.prefixed(prop, prefix);
      }
      /**
       * Ignore 2009 spec and use flex property for 2012
       */
      set(decl, prefix) {
        let spec;
        [spec, prefix] = flexSpec(prefix);
        if (spec === 2012 || spec === "final") {
          return super.set(decl, prefix);
        }
        return void 0;
      }
    };
    FlexShrink.names = ["flex-shrink", "flex-negative"];
    module2.exports = FlexShrink;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/break-props.js
var require_break_props = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/break-props.js"(exports3, module2) {
    var Declaration = require_declaration();
    var BreakProps = class extends Declaration {
      /**
       * Change name for -webkit- and -moz- prefix
       */
      prefixed(prop, prefix) {
        return `${prefix}column-${prop}`;
      }
      /**
       * Return property name by final spec
       */
      normalize(prop) {
        if (prop.includes("inside")) {
          return "break-inside";
        }
        if (prop.includes("before")) {
          return "break-before";
        }
        return "break-after";
      }
      /**
       * Change prefixed value for avoid-column and avoid-page
       */
      set(decl, prefix) {
        if (decl.prop === "break-inside" && decl.value === "avoid-column" || decl.value === "avoid-page") {
          decl.value = "avoid";
        }
        return super.set(decl, prefix);
      }
      /**
       * Don’t prefix some values
       */
      insert(decl, prefix, prefixes) {
        if (decl.prop !== "break-inside") {
          return super.insert(decl, prefix, prefixes);
        }
        if (/region/i.test(decl.value) || /page/i.test(decl.value)) {
          return void 0;
        }
        return super.insert(decl, prefix, prefixes);
      }
    };
    BreakProps.names = [
      "break-inside",
      "page-break-inside",
      "column-break-inside",
      "break-before",
      "page-break-before",
      "column-break-before",
      "break-after",
      "page-break-after",
      "column-break-after"
    ];
    module2.exports = BreakProps;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/writing-mode.js
var require_writing_mode = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/writing-mode.js"(exports3, module2) {
    var Declaration = require_declaration();
    var WritingMode = class extends Declaration {
      insert(decl, prefix, prefixes) {
        if (prefix === "-ms-") {
          let cloned = this.set(this.clone(decl), prefix);
          if (this.needCascade(decl)) {
            cloned.raws.before = this.calcBefore(prefixes, decl, prefix);
          }
          let direction = "ltr";
          decl.parent.nodes.forEach((i2) => {
            if (i2.prop === "direction") {
              if (i2.value === "rtl" || i2.value === "ltr")
                direction = i2.value;
            }
          });
          cloned.value = WritingMode.msValues[direction][decl.value] || decl.value;
          return decl.parent.insertBefore(decl, cloned);
        }
        return super.insert(decl, prefix, prefixes);
      }
    };
    WritingMode.names = ["writing-mode"];
    WritingMode.msValues = {
      ltr: {
        "horizontal-tb": "lr-tb",
        "vertical-rl": "tb-rl",
        "vertical-lr": "tb-lr"
      },
      rtl: {
        "horizontal-tb": "rl-tb",
        "vertical-rl": "bt-rl",
        "vertical-lr": "bt-lr"
      }
    };
    module2.exports = WritingMode;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/border-image.js
var require_border_image = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/border-image.js"(exports3, module2) {
    var Declaration = require_declaration();
    var BorderImage = class extends Declaration {
      /**
       * Remove fill parameter for prefixed declarations
       */
      set(decl, prefix) {
        decl.value = decl.value.replace(/\s+fill(\s)/, "$1");
        return super.set(decl, prefix);
      }
    };
    BorderImage.names = ["border-image"];
    module2.exports = BorderImage;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/align-content.js
var require_align_content = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/align-content.js"(exports3, module2) {
    var flexSpec = require_flex_spec();
    var Declaration = require_declaration();
    var AlignContent = class extends Declaration {
      /**
       * Change property name for 2012 spec
       */
      prefixed(prop, prefix) {
        let spec;
        [spec, prefix] = flexSpec(prefix);
        if (spec === 2012) {
          return prefix + "flex-line-pack";
        }
        return super.prefixed(prop, prefix);
      }
      /**
       * Return property name by final spec
       */
      normalize() {
        return "align-content";
      }
      /**
       * Change value for 2012 spec and ignore prefix for 2009
       */
      set(decl, prefix) {
        let spec = flexSpec(prefix)[0];
        if (spec === 2012) {
          decl.value = AlignContent.oldValues[decl.value] || decl.value;
          return super.set(decl, prefix);
        }
        if (spec === "final") {
          return super.set(decl, prefix);
        }
        return void 0;
      }
    };
    AlignContent.names = ["align-content", "flex-line-pack"];
    AlignContent.oldValues = {
      "flex-end": "end",
      "flex-start": "start",
      "space-between": "justify",
      "space-around": "distribute"
    };
    module2.exports = AlignContent;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/border-radius.js
var require_border_radius = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/border-radius.js"(exports3, module2) {
    var Declaration = require_declaration();
    var BorderRadius = class extends Declaration {
      /**
       * Change syntax, when add Mozilla prefix
       */
      prefixed(prop, prefix) {
        if (prefix === "-moz-") {
          return prefix + (BorderRadius.toMozilla[prop] || prop);
        }
        return super.prefixed(prop, prefix);
      }
      /**
       * Return unprefixed version of property
       */
      normalize(prop) {
        return BorderRadius.toNormal[prop] || prop;
      }
    };
    BorderRadius.names = ["border-radius"];
    BorderRadius.toMozilla = {};
    BorderRadius.toNormal = {};
    for (let ver of ["top", "bottom"]) {
      for (let hor of ["left", "right"]) {
        let normal = `border-${ver}-${hor}-radius`;
        let mozilla = `border-radius-${ver}${hor}`;
        BorderRadius.names.push(normal);
        BorderRadius.names.push(mozilla);
        BorderRadius.toMozilla[normal] = mozilla;
        BorderRadius.toNormal[mozilla] = normal;
      }
    }
    module2.exports = BorderRadius;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/block-logical.js
var require_block_logical = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/block-logical.js"(exports3, module2) {
    var Declaration = require_declaration();
    var BlockLogical = class extends Declaration {
      /**
       * Use old syntax for -moz- and -webkit-
       */
      prefixed(prop, prefix) {
        if (prop.includes("-start")) {
          return prefix + prop.replace("-block-start", "-before");
        }
        return prefix + prop.replace("-block-end", "-after");
      }
      /**
       * Return property name by spec
       */
      normalize(prop) {
        if (prop.includes("-before")) {
          return prop.replace("-before", "-block-start");
        }
        return prop.replace("-after", "-block-end");
      }
    };
    BlockLogical.names = [
      "border-block-start",
      "border-block-end",
      "margin-block-start",
      "margin-block-end",
      "padding-block-start",
      "padding-block-end",
      "border-before",
      "border-after",
      "margin-before",
      "margin-after",
      "padding-before",
      "padding-after"
    ];
    module2.exports = BlockLogical;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/grid-template.js
var require_grid_template = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/grid-template.js"(exports3, module2) {
    var Declaration = require_declaration();
    var {
      parseTemplate,
      warnMissedAreas,
      getGridGap,
      warnGridGap,
      inheritGridGap
    } = require_grid_utils();
    var GridTemplate = class extends Declaration {
      /**
       * Translate grid-template to separate -ms- prefixed properties
       */
      insert(decl, prefix, prefixes, result) {
        if (prefix !== "-ms-")
          return super.insert(decl, prefix, prefixes);
        if (decl.parent.some((i2) => i2.prop === "-ms-grid-rows")) {
          return void 0;
        }
        let gap = getGridGap(decl);
        let inheritedGap = inheritGridGap(decl, gap);
        let { rows, columns, areas } = parseTemplate({
          decl,
          gap: inheritedGap || gap
        });
        let hasAreas = Object.keys(areas).length > 0;
        let hasRows = Boolean(rows);
        let hasColumns = Boolean(columns);
        warnGridGap({
          gap,
          hasColumns,
          decl,
          result
        });
        warnMissedAreas(areas, decl, result);
        if (hasRows && hasColumns || hasAreas) {
          decl.cloneBefore({
            prop: "-ms-grid-rows",
            value: rows,
            raws: {}
          });
        }
        if (hasColumns) {
          decl.cloneBefore({
            prop: "-ms-grid-columns",
            value: columns,
            raws: {}
          });
        }
        return decl;
      }
    };
    GridTemplate.names = ["grid-template"];
    module2.exports = GridTemplate;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/inline-logical.js
var require_inline_logical = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/inline-logical.js"(exports3, module2) {
    var Declaration = require_declaration();
    var InlineLogical = class extends Declaration {
      /**
       * Use old syntax for -moz- and -webkit-
       */
      prefixed(prop, prefix) {
        return prefix + prop.replace("-inline", "");
      }
      /**
       * Return property name by spec
       */
      normalize(prop) {
        return prop.replace(/(margin|padding|border)-(start|end)/, "$1-inline-$2");
      }
    };
    InlineLogical.names = [
      "border-inline-start",
      "border-inline-end",
      "margin-inline-start",
      "margin-inline-end",
      "padding-inline-start",
      "padding-inline-end",
      "border-start",
      "border-end",
      "margin-start",
      "margin-end",
      "padding-start",
      "padding-end"
    ];
    module2.exports = InlineLogical;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/grid-row-align.js
var require_grid_row_align = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/grid-row-align.js"(exports3, module2) {
    var Declaration = require_declaration();
    var GridRowAlign = class extends Declaration {
      /**
       * Do not prefix flexbox values
       */
      check(decl) {
        return !decl.value.includes("flex-") && decl.value !== "baseline";
      }
      /**
       * Change property name for IE
       */
      prefixed(prop, prefix) {
        return prefix + "grid-row-align";
      }
      /**
       * Change IE property back
       */
      normalize() {
        return "align-self";
      }
    };
    GridRowAlign.names = ["grid-row-align"];
    module2.exports = GridRowAlign;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/transform-decl.js
var require_transform_decl = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/transform-decl.js"(exports3, module2) {
    var Declaration = require_declaration();
    var TransformDecl = class extends Declaration {
      /**
       * Recursively check all parents for @keyframes
       */
      keyframeParents(decl) {
        let { parent } = decl;
        while (parent) {
          if (parent.type === "atrule" && parent.name === "keyframes") {
            return true;
          }
          ;
          ({ parent } = parent);
        }
        return false;
      }
      /**
       * Is transform contain 3D commands
       */
      contain3d(decl) {
        if (decl.prop === "transform-origin") {
          return false;
        }
        for (let func of TransformDecl.functions3d) {
          if (decl.value.includes(`${func}(`)) {
            return true;
          }
        }
        return false;
      }
      /**
       * Replace rotateZ to rotate for IE 9
       */
      set(decl, prefix) {
        decl = super.set(decl, prefix);
        if (prefix === "-ms-") {
          decl.value = decl.value.replace(/rotatez/gi, "rotate");
        }
        return decl;
      }
      /**
       * Don't add prefix for IE in keyframes
       */
      insert(decl, prefix, prefixes) {
        if (prefix === "-ms-") {
          if (!this.contain3d(decl) && !this.keyframeParents(decl)) {
            return super.insert(decl, prefix, prefixes);
          }
        } else if (prefix === "-o-") {
          if (!this.contain3d(decl)) {
            return super.insert(decl, prefix, prefixes);
          }
        } else {
          return super.insert(decl, prefix, prefixes);
        }
        return void 0;
      }
    };
    TransformDecl.names = ["transform", "transform-origin"];
    TransformDecl.functions3d = [
      "matrix3d",
      "translate3d",
      "translateZ",
      "scale3d",
      "scaleZ",
      "rotate3d",
      "rotateX",
      "rotateY",
      "perspective"
    ];
    module2.exports = TransformDecl;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/flex-direction.js
var require_flex_direction = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/flex-direction.js"(exports3, module2) {
    var flexSpec = require_flex_spec();
    var Declaration = require_declaration();
    var FlexDirection = class extends Declaration {
      /**
       * Return property name by final spec
       */
      normalize() {
        return "flex-direction";
      }
      /**
       * Use two properties for 2009 spec
       */
      insert(decl, prefix, prefixes) {
        let spec;
        [spec, prefix] = flexSpec(prefix);
        if (spec !== 2009) {
          return super.insert(decl, prefix, prefixes);
        }
        let already = decl.parent.some(
          (i2) => i2.prop === prefix + "box-orient" || i2.prop === prefix + "box-direction"
        );
        if (already) {
          return void 0;
        }
        let v = decl.value;
        let orient, dir;
        if (v === "inherit" || v === "initial" || v === "unset") {
          orient = v;
          dir = v;
        } else {
          orient = v.includes("row") ? "horizontal" : "vertical";
          dir = v.includes("reverse") ? "reverse" : "normal";
        }
        let cloned = this.clone(decl);
        cloned.prop = prefix + "box-orient";
        cloned.value = orient;
        if (this.needCascade(decl)) {
          cloned.raws.before = this.calcBefore(prefixes, decl, prefix);
        }
        decl.parent.insertBefore(decl, cloned);
        cloned = this.clone(decl);
        cloned.prop = prefix + "box-direction";
        cloned.value = dir;
        if (this.needCascade(decl)) {
          cloned.raws.before = this.calcBefore(prefixes, decl, prefix);
        }
        return decl.parent.insertBefore(decl, cloned);
      }
      /**
       * Clean two properties for 2009 spec
       */
      old(prop, prefix) {
        let spec;
        [spec, prefix] = flexSpec(prefix);
        if (spec === 2009) {
          return [prefix + "box-orient", prefix + "box-direction"];
        } else {
          return super.old(prop, prefix);
        }
      }
    };
    FlexDirection.names = ["flex-direction", "box-direction", "box-orient"];
    module2.exports = FlexDirection;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/image-rendering.js
var require_image_rendering = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/image-rendering.js"(exports3, module2) {
    var Declaration = require_declaration();
    var ImageRendering = class extends Declaration {
      /**
       * Add hack only for crisp-edges
       */
      check(decl) {
        return decl.value === "pixelated";
      }
      /**
       * Change property name for IE
       */
      prefixed(prop, prefix) {
        if (prefix === "-ms-") {
          return "-ms-interpolation-mode";
        }
        return super.prefixed(prop, prefix);
      }
      /**
       * Change property and value for IE
       */
      set(decl, prefix) {
        if (prefix !== "-ms-")
          return super.set(decl, prefix);
        decl.prop = "-ms-interpolation-mode";
        decl.value = "nearest-neighbor";
        return decl;
      }
      /**
       * Return property name by spec
       */
      normalize() {
        return "image-rendering";
      }
      /**
       * Warn on old value
       */
      process(node3, result) {
        return super.process(node3, result);
      }
    };
    ImageRendering.names = ["image-rendering", "interpolation-mode"];
    module2.exports = ImageRendering;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/backdrop-filter.js
var require_backdrop_filter = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/backdrop-filter.js"(exports3, module2) {
    var Declaration = require_declaration();
    var utils2 = require_utils7();
    var BackdropFilter = class extends Declaration {
      constructor(name2, prefixes, all) {
        super(name2, prefixes, all);
        if (this.prefixes) {
          this.prefixes = utils2.uniq(
            this.prefixes.map((i2) => {
              return i2 === "-ms-" ? "-webkit-" : i2;
            })
          );
        }
      }
    };
    BackdropFilter.names = ["backdrop-filter"];
    module2.exports = BackdropFilter;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/background-clip.js
var require_background_clip = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/background-clip.js"(exports3, module2) {
    var Declaration = require_declaration();
    var utils2 = require_utils7();
    var BackgroundClip = class extends Declaration {
      constructor(name2, prefixes, all) {
        super(name2, prefixes, all);
        if (this.prefixes) {
          this.prefixes = utils2.uniq(
            this.prefixes.map((i2) => {
              return i2 === "-ms-" ? "-webkit-" : i2;
            })
          );
        }
      }
      check(decl) {
        return decl.value.toLowerCase() === "text";
      }
    };
    BackgroundClip.names = ["background-clip"];
    module2.exports = BackgroundClip;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/text-decoration.js
var require_text_decoration = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/text-decoration.js"(exports3, module2) {
    var Declaration = require_declaration();
    var BASIC = [
      "none",
      "underline",
      "overline",
      "line-through",
      "blink",
      "inherit",
      "initial",
      "unset"
    ];
    var TextDecoration = class extends Declaration {
      /**
       * Do not add prefixes for basic values.
       */
      check(decl) {
        return decl.value.split(/\s+/).some((i2) => !BASIC.includes(i2));
      }
    };
    TextDecoration.names = ["text-decoration"];
    module2.exports = TextDecoration;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/justify-content.js
var require_justify_content = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/justify-content.js"(exports3, module2) {
    var flexSpec = require_flex_spec();
    var Declaration = require_declaration();
    var JustifyContent = class extends Declaration {
      /**
       * Change property name for 2009 and 2012 specs
       */
      prefixed(prop, prefix) {
        let spec;
        [spec, prefix] = flexSpec(prefix);
        if (spec === 2009) {
          return prefix + "box-pack";
        }
        if (spec === 2012) {
          return prefix + "flex-pack";
        }
        return super.prefixed(prop, prefix);
      }
      /**
       * Return property name by final spec
       */
      normalize() {
        return "justify-content";
      }
      /**
       * Change value for 2009 and 2012 specs
       */
      set(decl, prefix) {
        let spec = flexSpec(prefix)[0];
        if (spec === 2009 || spec === 2012) {
          let value2 = JustifyContent.oldValues[decl.value] || decl.value;
          decl.value = value2;
          if (spec !== 2009 || value2 !== "distribute") {
            return super.set(decl, prefix);
          }
        } else if (spec === "final") {
          return super.set(decl, prefix);
        }
        return void 0;
      }
    };
    JustifyContent.names = ["justify-content", "flex-pack", "box-pack"];
    JustifyContent.oldValues = {
      "flex-end": "end",
      "flex-start": "start",
      "space-between": "justify",
      "space-around": "distribute"
    };
    module2.exports = JustifyContent;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/background-size.js
var require_background_size = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/background-size.js"(exports3, module2) {
    var Declaration = require_declaration();
    var BackgroundSize = class extends Declaration {
      /**
       * Duplication parameter for -webkit- browsers
       */
      set(decl, prefix) {
        let value2 = decl.value.toLowerCase();
        if (prefix === "-webkit-" && !value2.includes(" ") && value2 !== "contain" && value2 !== "cover") {
          decl.value = decl.value + " " + decl.value;
        }
        return super.set(decl, prefix);
      }
    };
    BackgroundSize.names = ["background-size"];
    module2.exports = BackgroundSize;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/grid-row-column.js
var require_grid_row_column = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/grid-row-column.js"(exports3, module2) {
    var Declaration = require_declaration();
    var utils2 = require_grid_utils();
    var GridRowColumn = class extends Declaration {
      /**
       * Translate grid-row / grid-column to separate -ms- prefixed properties
       */
      insert(decl, prefix, prefixes) {
        if (prefix !== "-ms-")
          return super.insert(decl, prefix, prefixes);
        let values = utils2.parse(decl);
        let [start, span] = utils2.translate(values, 0, 1);
        let hasStartValueSpan = values[0] && values[0].includes("span");
        if (hasStartValueSpan) {
          span = values[0].join("").replace(/\D/g, "");
        }
        ;
        [
          [decl.prop, start],
          [`${decl.prop}-span`, span]
        ].forEach(([prop, value2]) => {
          utils2.insertDecl(decl, prop, value2);
        });
        return void 0;
      }
    };
    GridRowColumn.names = ["grid-row", "grid-column"];
    module2.exports = GridRowColumn;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/grid-rows-columns.js
var require_grid_rows_columns = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/grid-rows-columns.js"(exports3, module2) {
    var Declaration = require_declaration();
    var {
      prefixTrackProp,
      prefixTrackValue,
      autoplaceGridItems,
      getGridGap,
      inheritGridGap
    } = require_grid_utils();
    var Processor = require_processor();
    var GridRowsColumns = class extends Declaration {
      /**
       * Change property name for IE
       */
      prefixed(prop, prefix) {
        if (prefix === "-ms-") {
          return prefixTrackProp({ prop, prefix });
        }
        return super.prefixed(prop, prefix);
      }
      /**
       * Change IE property back
       */
      normalize(prop) {
        return prop.replace(/^grid-(rows|columns)/, "grid-template-$1");
      }
      insert(decl, prefix, prefixes, result) {
        if (prefix !== "-ms-")
          return super.insert(decl, prefix, prefixes);
        let { parent, prop, value: value2 } = decl;
        let isRowProp = prop.includes("rows");
        let isColumnProp = prop.includes("columns");
        let hasGridTemplate = parent.some(
          (i2) => i2.prop === "grid-template" || i2.prop === "grid-template-areas"
        );
        if (hasGridTemplate && isRowProp) {
          return false;
        }
        let processor = new Processor({ options: {} });
        let status2 = processor.gridStatus(parent, result);
        let gap = getGridGap(decl);
        gap = inheritGridGap(decl, gap) || gap;
        let gapValue = isRowProp ? gap.row : gap.column;
        if ((status2 === "no-autoplace" || status2 === true) && !hasGridTemplate) {
          gapValue = null;
        }
        let prefixValue = prefixTrackValue({
          value: value2,
          gap: gapValue
        });
        decl.cloneBefore({
          prop: prefixTrackProp({ prop, prefix }),
          value: prefixValue
        });
        let autoflow = parent.nodes.find((i2) => i2.prop === "grid-auto-flow");
        let autoflowValue = "row";
        if (autoflow && !processor.disabled(autoflow, result)) {
          autoflowValue = autoflow.value.trim();
        }
        if (status2 === "autoplace") {
          let rowDecl = parent.nodes.find((i2) => i2.prop === "grid-template-rows");
          if (!rowDecl && hasGridTemplate) {
            return void 0;
          } else if (!rowDecl && !hasGridTemplate) {
            decl.warn(
              result,
              "Autoplacement does not work without grid-template-rows property"
            );
            return void 0;
          }
          let columnDecl = parent.nodes.find((i2) => {
            return i2.prop === "grid-template-columns";
          });
          if (!columnDecl && !hasGridTemplate) {
            decl.warn(
              result,
              "Autoplacement does not work without grid-template-columns property"
            );
          }
          if (isColumnProp && !hasGridTemplate) {
            autoplaceGridItems(decl, result, gap, autoflowValue);
          }
        }
        return void 0;
      }
    };
    GridRowsColumns.names = [
      "grid-template-rows",
      "grid-template-columns",
      "grid-rows",
      "grid-columns"
    ];
    module2.exports = GridRowsColumns;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/grid-column-align.js
var require_grid_column_align = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/grid-column-align.js"(exports3, module2) {
    var Declaration = require_declaration();
    var GridColumnAlign = class extends Declaration {
      /**
       * Do not prefix flexbox values
       */
      check(decl) {
        return !decl.value.includes("flex-") && decl.value !== "baseline";
      }
      /**
       * Change property name for IE
       */
      prefixed(prop, prefix) {
        return prefix + "grid-column-align";
      }
      /**
       * Change IE property back
       */
      normalize() {
        return "justify-self";
      }
    };
    GridColumnAlign.names = ["grid-column-align"];
    module2.exports = GridColumnAlign;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/print-color-adjust.js
var require_print_color_adjust = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/print-color-adjust.js"(exports3, module2) {
    var Declaration = require_declaration();
    var PrintColorAdjust = class extends Declaration {
      /**
       * Change property name for WebKit-based browsers
       */
      prefixed(prop, prefix) {
        if (prefix === "-moz-") {
          return "color-adjust";
        } else {
          return prefix + "print-color-adjust";
        }
      }
      /**
       * Return property name by spec
       */
      normalize() {
        return "print-color-adjust";
      }
    };
    PrintColorAdjust.names = ["print-color-adjust", "color-adjust"];
    module2.exports = PrintColorAdjust;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/overscroll-behavior.js
var require_overscroll_behavior = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/overscroll-behavior.js"(exports3, module2) {
    var Declaration = require_declaration();
    var OverscrollBehavior = class extends Declaration {
      /**
       * Change property name for IE
       */
      prefixed(prop, prefix) {
        return prefix + "scroll-chaining";
      }
      /**
       * Return property name by spec
       */
      normalize() {
        return "overscroll-behavior";
      }
      /**
       * Change value for IE
       */
      set(decl, prefix) {
        if (decl.value === "auto") {
          decl.value = "chained";
        } else if (decl.value === "none" || decl.value === "contain") {
          decl.value = "none";
        }
        return super.set(decl, prefix);
      }
    };
    OverscrollBehavior.names = ["overscroll-behavior", "scroll-chaining"];
    module2.exports = OverscrollBehavior;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/grid-template-areas.js
var require_grid_template_areas = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/grid-template-areas.js"(exports3, module2) {
    var Declaration = require_declaration();
    var {
      parseGridAreas,
      warnMissedAreas,
      prefixTrackProp,
      prefixTrackValue,
      getGridGap,
      warnGridGap,
      inheritGridGap
    } = require_grid_utils();
    function getGridRows(tpl) {
      return tpl.trim().slice(1, -1).split(/["']\s*["']?/g);
    }
    var GridTemplateAreas = class extends Declaration {
      /**
       * Translate grid-template-areas to separate -ms- prefixed properties
       */
      insert(decl, prefix, prefixes, result) {
        if (prefix !== "-ms-")
          return super.insert(decl, prefix, prefixes);
        let hasColumns = false;
        let hasRows = false;
        let parent = decl.parent;
        let gap = getGridGap(decl);
        gap = inheritGridGap(decl, gap) || gap;
        parent.walkDecls(/-ms-grid-rows/, (i2) => i2.remove());
        parent.walkDecls(/grid-template-(rows|columns)/, (trackDecl) => {
          if (trackDecl.prop === "grid-template-rows") {
            hasRows = true;
            let { prop, value: value2 } = trackDecl;
            trackDecl.cloneBefore({
              prop: prefixTrackProp({ prop, prefix }),
              value: prefixTrackValue({ value: value2, gap: gap.row })
            });
          } else {
            hasColumns = true;
          }
        });
        let gridRows = getGridRows(decl.value);
        if (hasColumns && !hasRows && gap.row && gridRows.length > 1) {
          decl.cloneBefore({
            prop: "-ms-grid-rows",
            value: prefixTrackValue({
              value: `repeat(${gridRows.length}, auto)`,
              gap: gap.row
            }),
            raws: {}
          });
        }
        warnGridGap({
          gap,
          hasColumns,
          decl,
          result
        });
        let areas = parseGridAreas({
          rows: gridRows,
          gap
        });
        warnMissedAreas(areas, decl, result);
        return decl;
      }
    };
    GridTemplateAreas.names = ["grid-template-areas"];
    module2.exports = GridTemplateAreas;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/text-emphasis-position.js
var require_text_emphasis_position = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/text-emphasis-position.js"(exports3, module2) {
    var Declaration = require_declaration();
    var TextEmphasisPosition = class extends Declaration {
      set(decl, prefix) {
        if (prefix === "-webkit-") {
          decl.value = decl.value.replace(/\s*(right|left)\s*/i, "");
        }
        return super.set(decl, prefix);
      }
    };
    TextEmphasisPosition.names = ["text-emphasis-position"];
    module2.exports = TextEmphasisPosition;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/text-decoration-skip-ink.js
var require_text_decoration_skip_ink = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/text-decoration-skip-ink.js"(exports3, module2) {
    var Declaration = require_declaration();
    var TextDecorationSkipInk = class extends Declaration {
      /**
       * Change prefix for ink value
       */
      set(decl, prefix) {
        if (decl.prop === "text-decoration-skip-ink" && decl.value === "auto") {
          decl.prop = prefix + "text-decoration-skip";
          decl.value = "ink";
          return decl;
        } else {
          return super.set(decl, prefix);
        }
      }
    };
    TextDecorationSkipInk.names = [
      "text-decoration-skip-ink",
      "text-decoration-skip"
    ];
    module2.exports = TextDecorationSkipInk;
  }
});

// node_modules/.pnpm/normalize-range@0.1.2/node_modules/normalize-range/index.js
var require_normalize_range = __commonJS({
  "node_modules/.pnpm/normalize-range@0.1.2/node_modules/normalize-range/index.js"(exports3, module2) {
    "use strict";
    module2.exports = {
      wrap: wrapRange,
      limit: limitRange,
      validate: validateRange,
      test: testRange,
      curry,
      name: name2
    };
    function wrapRange(min2, max, value2) {
      var maxLessMin = max - min2;
      return ((value2 - min2) % maxLessMin + maxLessMin) % maxLessMin + min2;
    }
    function limitRange(min2, max, value2) {
      return Math.max(min2, Math.min(max, value2));
    }
    function validateRange(min2, max, value2, minExclusive, maxExclusive) {
      if (!testRange(min2, max, value2, minExclusive, maxExclusive)) {
        throw new Error(value2 + " is outside of range [" + min2 + "," + max + ")");
      }
      return value2;
    }
    function testRange(min2, max, value2, minExclusive, maxExclusive) {
      return !(value2 < min2 || value2 > max || maxExclusive && value2 === max || minExclusive && value2 === min2);
    }
    function name2(min2, max, minExcl, maxExcl) {
      return (minExcl ? "(" : "[") + min2 + "," + max + (maxExcl ? ")" : "]");
    }
    function curry(min2, max, minExclusive, maxExclusive) {
      var boundNameFn = name2.bind(null, min2, max, minExclusive, maxExclusive);
      return {
        wrap: wrapRange.bind(null, min2, max),
        limit: limitRange.bind(null, min2, max),
        validate: function(value2) {
          return validateRange(min2, max, value2, minExclusive, maxExclusive);
        },
        test: function(value2) {
          return testRange(min2, max, value2, minExclusive, maxExclusive);
        },
        toString: boundNameFn,
        name: boundNameFn
      };
    }
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/gradient.js
var require_gradient = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/gradient.js"(exports3, module2) {
    var parser2 = require_lib2();
    var range2 = require_normalize_range();
    var OldValue = require_old_value();
    var Value = require_value();
    var utils2 = require_utils7();
    var IS_DIRECTION = /top|left|right|bottom/gi;
    var Gradient = class extends Value {
      /**
       * Change degrees for webkit prefix
       */
      replace(string3, prefix) {
        let ast = parser2(string3);
        for (let node3 of ast.nodes) {
          let gradientName = this.name;
          if (node3.type === "function" && node3.value === gradientName) {
            node3.nodes = this.newDirection(node3.nodes);
            node3.nodes = this.normalize(node3.nodes, gradientName);
            if (prefix === "-webkit- old") {
              let changes = this.oldWebkit(node3);
              if (!changes) {
                return false;
              }
            } else {
              node3.nodes = this.convertDirection(node3.nodes);
              node3.value = prefix + node3.value;
            }
          }
        }
        return ast.toString();
      }
      /**
       * Replace first token
       */
      replaceFirst(params, ...words) {
        let prefix = words.map((i2) => {
          if (i2 === " ") {
            return { type: "space", value: i2 };
          }
          return { type: "word", value: i2 };
        });
        return prefix.concat(params.slice(1));
      }
      /**
       * Convert angle unit to deg
       */
      normalizeUnit(str2, full) {
        let num = parseFloat(str2);
        let deg = num / full * 360;
        return `${deg}deg`;
      }
      /**
       * Normalize angle
       */
      normalize(nodes, gradientName) {
        if (!nodes[0])
          return nodes;
        if (/-?\d+(.\d+)?grad/.test(nodes[0].value)) {
          nodes[0].value = this.normalizeUnit(nodes[0].value, 400);
        } else if (/-?\d+(.\d+)?rad/.test(nodes[0].value)) {
          nodes[0].value = this.normalizeUnit(nodes[0].value, 2 * Math.PI);
        } else if (/-?\d+(.\d+)?turn/.test(nodes[0].value)) {
          nodes[0].value = this.normalizeUnit(nodes[0].value, 1);
        } else if (nodes[0].value.includes("deg")) {
          let num = parseFloat(nodes[0].value);
          num = range2.wrap(0, 360, num);
          nodes[0].value = `${num}deg`;
        }
        if (gradientName === "linear-gradient" || gradientName === "repeating-linear-gradient") {
          let direction = nodes[0].value;
          if (direction === "0deg" || direction === "0") {
            nodes = this.replaceFirst(nodes, "to", " ", "top");
          } else if (direction === "90deg") {
            nodes = this.replaceFirst(nodes, "to", " ", "right");
          } else if (direction === "180deg") {
            nodes = this.replaceFirst(nodes, "to", " ", "bottom");
          } else if (direction === "270deg") {
            nodes = this.replaceFirst(nodes, "to", " ", "left");
          }
        }
        return nodes;
      }
      /**
       * Replace old direction to new
       */
      newDirection(params) {
        if (params[0].value === "to") {
          return params;
        }
        IS_DIRECTION.lastIndex = 0;
        if (!IS_DIRECTION.test(params[0].value)) {
          return params;
        }
        params.unshift(
          {
            type: "word",
            value: "to"
          },
          {
            type: "space",
            value: " "
          }
        );
        for (let i2 = 2; i2 < params.length; i2++) {
          if (params[i2].type === "div") {
            break;
          }
          if (params[i2].type === "word") {
            params[i2].value = this.revertDirection(params[i2].value);
          }
        }
        return params;
      }
      /**
       * Look for at word
       */
      isRadial(params) {
        let state = "before";
        for (let param of params) {
          if (state === "before" && param.type === "space") {
            state = "at";
          } else if (state === "at" && param.value === "at") {
            state = "after";
          } else if (state === "after" && param.type === "space") {
            return true;
          } else if (param.type === "div") {
            break;
          } else {
            state = "before";
          }
        }
        return false;
      }
      /**
       * Change new direction to old
       */
      convertDirection(params) {
        if (params.length > 0) {
          if (params[0].value === "to") {
            this.fixDirection(params);
          } else if (params[0].value.includes("deg")) {
            this.fixAngle(params);
          } else if (this.isRadial(params)) {
            this.fixRadial(params);
          }
        }
        return params;
      }
      /**
       * Replace `to top left` to `bottom right`
       */
      fixDirection(params) {
        params.splice(0, 2);
        for (let param of params) {
          if (param.type === "div") {
            break;
          }
          if (param.type === "word") {
            param.value = this.revertDirection(param.value);
          }
        }
      }
      /**
       * Add 90 degrees
       */
      fixAngle(params) {
        let first2 = params[0].value;
        first2 = parseFloat(first2);
        first2 = Math.abs(450 - first2) % 360;
        first2 = this.roundFloat(first2, 3);
        params[0].value = `${first2}deg`;
      }
      /**
       * Fix radial direction syntax
       */
      fixRadial(params) {
        let first2 = [];
        let second = [];
        let a2, b, c2, i2, next;
        for (i2 = 0; i2 < params.length - 2; i2++) {
          a2 = params[i2];
          b = params[i2 + 1];
          c2 = params[i2 + 2];
          if (a2.type === "space" && b.value === "at" && c2.type === "space") {
            next = i2 + 3;
            break;
          } else {
            first2.push(a2);
          }
        }
        let div;
        for (i2 = next; i2 < params.length; i2++) {
          if (params[i2].type === "div") {
            div = params[i2];
            break;
          } else {
            second.push(params[i2]);
          }
        }
        params.splice(0, i2, ...second, div, ...first2);
      }
      revertDirection(word) {
        return Gradient.directions[word.toLowerCase()] || word;
      }
      /**
       * Round float and save digits under dot
       */
      roundFloat(float4, digits) {
        return parseFloat(float4.toFixed(digits));
      }
      /**
       * Convert to old webkit syntax
       */
      oldWebkit(node3) {
        let { nodes } = node3;
        let string3 = parser2.stringify(node3.nodes);
        if (this.name !== "linear-gradient") {
          return false;
        }
        if (nodes[0] && nodes[0].value.includes("deg")) {
          return false;
        }
        if (string3.includes("px") || string3.includes("-corner") || string3.includes("-side")) {
          return false;
        }
        let params = [[]];
        for (let i2 of nodes) {
          params[params.length - 1].push(i2);
          if (i2.type === "div" && i2.value === ",") {
            params.push([]);
          }
        }
        this.oldDirection(params);
        this.colorStops(params);
        node3.nodes = [];
        for (let param of params) {
          node3.nodes = node3.nodes.concat(param);
        }
        node3.nodes.unshift(
          { type: "word", value: "linear" },
          this.cloneDiv(node3.nodes)
        );
        node3.value = "-webkit-gradient";
        return true;
      }
      /**
       * Change direction syntax to old webkit
       */
      oldDirection(params) {
        let div = this.cloneDiv(params[0]);
        if (params[0][0].value !== "to") {
          return params.unshift([
            { type: "word", value: Gradient.oldDirections.bottom },
            div
          ]);
        } else {
          let words = [];
          for (let node3 of params[0].slice(2)) {
            if (node3.type === "word") {
              words.push(node3.value.toLowerCase());
            }
          }
          words = words.join(" ");
          let old2 = Gradient.oldDirections[words] || words;
          params[0] = [{ type: "word", value: old2 }, div];
          return params[0];
        }
      }
      /**
       * Get div token from exists parameters
       */
      cloneDiv(params) {
        for (let i2 of params) {
          if (i2.type === "div" && i2.value === ",") {
            return i2;
          }
        }
        return { type: "div", value: ",", after: " " };
      }
      /**
       * Change colors syntax to old webkit
       */
      colorStops(params) {
        let result = [];
        for (let i2 = 0; i2 < params.length; i2++) {
          let pos;
          let param = params[i2];
          let item;
          if (i2 === 0) {
            continue;
          }
          let color = parser2.stringify(param[0]);
          if (param[1] && param[1].type === "word") {
            pos = param[1].value;
          } else if (param[2] && param[2].type === "word") {
            pos = param[2].value;
          }
          let stop;
          if (i2 === 1 && (!pos || pos === "0%")) {
            stop = `from(${color})`;
          } else if (i2 === params.length - 1 && (!pos || pos === "100%")) {
            stop = `to(${color})`;
          } else if (pos) {
            stop = `color-stop(${pos}, ${color})`;
          } else {
            stop = `color-stop(${color})`;
          }
          let div = param[param.length - 1];
          params[i2] = [{ type: "word", value: stop }];
          if (div.type === "div" && div.value === ",") {
            item = params[i2].push(div);
          }
          result.push(item);
        }
        return result;
      }
      /**
       * Remove old WebKit gradient too
       */
      old(prefix) {
        if (prefix === "-webkit-") {
          let type;
          if (this.name === "linear-gradient") {
            type = "linear";
          } else if (this.name === "repeating-linear-gradient") {
            type = "repeating-linear";
          } else if (this.name === "repeating-radial-gradient") {
            type = "repeating-radial";
          } else {
            type = "radial";
          }
          let string3 = "-gradient";
          let regexp = utils2.regexp(
            `-webkit-(${type}-gradient|gradient\\(\\s*${type})`,
            false
          );
          return new OldValue(this.name, prefix + this.name, string3, regexp);
        } else {
          return super.old(prefix);
        }
      }
      /**
       * Do not add non-webkit prefixes for list-style and object
       */
      add(decl, prefix) {
        let p2 = decl.prop;
        if (p2.includes("mask")) {
          if (prefix === "-webkit-" || prefix === "-webkit- old") {
            return super.add(decl, prefix);
          }
        } else if (p2 === "list-style" || p2 === "list-style-image" || p2 === "content") {
          if (prefix === "-webkit-" || prefix === "-webkit- old") {
            return super.add(decl, prefix);
          }
        } else {
          return super.add(decl, prefix);
        }
        return void 0;
      }
    };
    Gradient.names = [
      "linear-gradient",
      "repeating-linear-gradient",
      "radial-gradient",
      "repeating-radial-gradient"
    ];
    Gradient.directions = {
      top: "bottom",
      // default value
      left: "right",
      bottom: "top",
      right: "left"
    };
    Gradient.oldDirections = {
      "top": "left bottom, left top",
      "left": "right top, left top",
      "bottom": "left top, left bottom",
      "right": "left top, right top",
      "top right": "left bottom, right top",
      "top left": "right bottom, left top",
      "right top": "left bottom, right top",
      "right bottom": "left top, right bottom",
      "bottom right": "left top, right bottom",
      "bottom left": "right top, left bottom",
      "left top": "right bottom, left top",
      "left bottom": "right top, left bottom"
    };
    module2.exports = Gradient;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/intrinsic.js
var require_intrinsic = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/intrinsic.js"(exports3, module2) {
    var OldValue = require_old_value();
    var Value = require_value();
    function regexp(name2) {
      return new RegExp(`(^|[\\s,(])(${name2}($|[\\s),]))`, "gi");
    }
    var Intrinsic = class extends Value {
      regexp() {
        if (!this.regexpCache)
          this.regexpCache = regexp(this.name);
        return this.regexpCache;
      }
      isStretch() {
        return this.name === "stretch" || this.name === "fill" || this.name === "fill-available";
      }
      replace(string3, prefix) {
        if (prefix === "-moz-" && this.isStretch()) {
          return string3.replace(this.regexp(), "$1-moz-available$3");
        }
        if (prefix === "-webkit-" && this.isStretch()) {
          return string3.replace(this.regexp(), "$1-webkit-fill-available$3");
        }
        return super.replace(string3, prefix);
      }
      old(prefix) {
        let prefixed = prefix + this.name;
        if (this.isStretch()) {
          if (prefix === "-moz-") {
            prefixed = "-moz-available";
          } else if (prefix === "-webkit-") {
            prefixed = "-webkit-fill-available";
          }
        }
        return new OldValue(this.name, prefixed, prefixed, regexp(prefixed));
      }
      add(decl, prefix) {
        if (decl.prop.includes("grid") && prefix !== "-webkit-") {
          return void 0;
        }
        return super.add(decl, prefix);
      }
    };
    Intrinsic.names = [
      "max-content",
      "min-content",
      "fit-content",
      "fill",
      "fill-available",
      "stretch"
    ];
    module2.exports = Intrinsic;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/pixelated.js
var require_pixelated = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/pixelated.js"(exports3, module2) {
    var OldValue = require_old_value();
    var Value = require_value();
    var Pixelated = class extends Value {
      /**
       * Use non-standard name for WebKit and Firefox
       */
      replace(string3, prefix) {
        if (prefix === "-webkit-") {
          return string3.replace(this.regexp(), "$1-webkit-optimize-contrast");
        }
        if (prefix === "-moz-") {
          return string3.replace(this.regexp(), "$1-moz-crisp-edges");
        }
        return super.replace(string3, prefix);
      }
      /**
       * Different name for WebKit and Firefox
       */
      old(prefix) {
        if (prefix === "-webkit-") {
          return new OldValue(this.name, "-webkit-optimize-contrast");
        }
        if (prefix === "-moz-") {
          return new OldValue(this.name, "-moz-crisp-edges");
        }
        return super.old(prefix);
      }
    };
    Pixelated.names = ["pixelated"];
    module2.exports = Pixelated;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/image-set.js
var require_image_set = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/image-set.js"(exports3, module2) {
    var Value = require_value();
    var ImageSet = class extends Value {
      /**
       * Use non-standard name for WebKit and Firefox
       */
      replace(string3, prefix) {
        let fixed = super.replace(string3, prefix);
        if (prefix === "-webkit-") {
          fixed = fixed.replace(/("[^"]+"|'[^']+')(\s+\d+\w)/gi, "url($1)$2");
        }
        return fixed;
      }
    };
    ImageSet.names = ["image-set"];
    module2.exports = ImageSet;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/cross-fade.js
var require_cross_fade = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/cross-fade.js"(exports3, module2) {
    var list = require_postcss().list;
    var Value = require_value();
    var CrossFade = class extends Value {
      replace(string3, prefix) {
        return list.space(string3).map((value2) => {
          if (value2.slice(0, +this.name.length + 1) !== this.name + "(") {
            return value2;
          }
          let close2 = value2.lastIndexOf(")");
          let after = value2.slice(close2 + 1);
          let args = value2.slice(this.name.length + 1, close2);
          if (prefix === "-webkit-") {
            let match = args.match(/\d*.?\d+%?/);
            if (match) {
              args = args.slice(match[0].length).trim();
              args += `, ${match[0]}`;
            } else {
              args += ", 0.5";
            }
          }
          return prefix + this.name + "(" + args + ")" + after;
        }).join(" ");
      }
    };
    CrossFade.names = ["cross-fade"];
    module2.exports = CrossFade;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/display-flex.js
var require_display_flex = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/display-flex.js"(exports3, module2) {
    var flexSpec = require_flex_spec();
    var OldValue = require_old_value();
    var Value = require_value();
    var DisplayFlex = class extends Value {
      constructor(name2, prefixes) {
        super(name2, prefixes);
        if (name2 === "display-flex") {
          this.name = "flex";
        }
      }
      /**
       * Faster check for flex value
       */
      check(decl) {
        return decl.prop === "display" && decl.value === this.name;
      }
      /**
       * Return value by spec
       */
      prefixed(prefix) {
        let spec, value2;
        [spec, prefix] = flexSpec(prefix);
        if (spec === 2009) {
          if (this.name === "flex") {
            value2 = "box";
          } else {
            value2 = "inline-box";
          }
        } else if (spec === 2012) {
          if (this.name === "flex") {
            value2 = "flexbox";
          } else {
            value2 = "inline-flexbox";
          }
        } else if (spec === "final") {
          value2 = this.name;
        }
        return prefix + value2;
      }
      /**
       * Add prefix to value depend on flebox spec version
       */
      replace(string3, prefix) {
        return this.prefixed(prefix);
      }
      /**
       * Change value for old specs
       */
      old(prefix) {
        let prefixed = this.prefixed(prefix);
        if (!prefixed)
          return void 0;
        return new OldValue(this.name, prefixed);
      }
    };
    DisplayFlex.names = ["display-flex", "inline-flex"];
    module2.exports = DisplayFlex;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/display-grid.js
var require_display_grid = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/display-grid.js"(exports3, module2) {
    var Value = require_value();
    var DisplayGrid = class extends Value {
      constructor(name2, prefixes) {
        super(name2, prefixes);
        if (name2 === "display-grid") {
          this.name = "grid";
        }
      }
      /**
       * Faster check for flex value
       */
      check(decl) {
        return decl.prop === "display" && decl.value === this.name;
      }
    };
    DisplayGrid.names = ["display-grid", "inline-grid"];
    module2.exports = DisplayGrid;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/filter-value.js
var require_filter_value = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/filter-value.js"(exports3, module2) {
    var Value = require_value();
    var FilterValue = class extends Value {
      constructor(name2, prefixes) {
        super(name2, prefixes);
        if (name2 === "filter-function") {
          this.name = "filter";
        }
      }
    };
    FilterValue.names = ["filter", "filter-function"];
    module2.exports = FilterValue;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/autofill.js
var require_autofill = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/hacks/autofill.js"(exports3, module2) {
    var Selector = require_selector();
    var utils2 = require_utils7();
    var Autofill = class extends Selector {
      constructor(name2, prefixes, all) {
        super(name2, prefixes, all);
        if (this.prefixes) {
          this.prefixes = utils2.uniq(this.prefixes.map(() => "-webkit-"));
        }
      }
      /**
       * Return different selectors depend on prefix
       */
      prefixed(prefix) {
        if (prefix === "-webkit-") {
          return ":-webkit-autofill";
        }
        return `:${prefix}autofill`;
      }
    };
    Autofill.names = [":autofill"];
    module2.exports = Autofill;
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/prefixes.js
var require_prefixes = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/prefixes.js"(exports3, module2) {
    var vendor = require_vendor();
    var Declaration = require_declaration();
    var Resolution = require_resolution();
    var Transition = require_transition();
    var Processor = require_processor();
    var Supports = require_supports();
    var Browsers = require_browsers3();
    var Selector = require_selector();
    var AtRule = require_at_rule();
    var Value = require_value();
    var utils2 = require_utils7();
    var hackFullscreen = require_fullscreen();
    var hackPlaceholder = require_placeholder();
    var hackPlaceholderShown = require_placeholder_shown();
    var hackFileSelectorButton = require_file_selector_button();
    var hackFlex = require_flex();
    var hackOrder = require_order();
    var hackFilter = require_filter();
    var hackGridEnd = require_grid_end();
    var hackAnimation = require_animation();
    var hackFlexFlow = require_flex_flow();
    var hackFlexGrow = require_flex_grow();
    var hackFlexWrap = require_flex_wrap();
    var hackGridArea = require_grid_area();
    var hackPlaceSelf = require_place_self();
    var hackGridStart = require_grid_start();
    var hackAlignSelf = require_align_self();
    var hackAppearance = require_appearance();
    var hackFlexBasis = require_flex_basis();
    var hackMaskBorder = require_mask_border();
    var hackMaskComposite = require_mask_composite();
    var hackAlignItems = require_align_items();
    var hackUserSelect = require_user_select();
    var hackFlexShrink = require_flex_shrink();
    var hackBreakProps = require_break_props();
    var hackWritingMode = require_writing_mode();
    var hackBorderImage = require_border_image();
    var hackAlignContent = require_align_content();
    var hackBorderRadius = require_border_radius();
    var hackBlockLogical = require_block_logical();
    var hackGridTemplate = require_grid_template();
    var hackInlineLogical = require_inline_logical();
    var hackGridRowAlign = require_grid_row_align();
    var hackTransformDecl = require_transform_decl();
    var hackFlexDirection = require_flex_direction();
    var hackImageRendering = require_image_rendering();
    var hackBackdropFilter = require_backdrop_filter();
    var hackBackgroundClip = require_background_clip();
    var hackTextDecoration = require_text_decoration();
    var hackJustifyContent = require_justify_content();
    var hackBackgroundSize = require_background_size();
    var hackGridRowColumn = require_grid_row_column();
    var hackGridRowsColumns = require_grid_rows_columns();
    var hackGridColumnAlign = require_grid_column_align();
    var hackPrintColorAdjust = require_print_color_adjust();
    var hackOverscrollBehavior = require_overscroll_behavior();
    var hackGridTemplateAreas = require_grid_template_areas();
    var hackTextEmphasisPosition = require_text_emphasis_position();
    var hackTextDecorationSkipInk = require_text_decoration_skip_ink();
    var hackGradient = require_gradient();
    var hackIntrinsic = require_intrinsic();
    var hackPixelated = require_pixelated();
    var hackImageSet = require_image_set();
    var hackCrossFade = require_cross_fade();
    var hackDisplayFlex = require_display_flex();
    var hackDisplayGrid = require_display_grid();
    var hackFilterValue = require_filter_value();
    var hackAutofill = require_autofill();
    Selector.hack(hackAutofill);
    Selector.hack(hackFullscreen);
    Selector.hack(hackPlaceholder);
    Selector.hack(hackPlaceholderShown);
    Selector.hack(hackFileSelectorButton);
    Declaration.hack(hackFlex);
    Declaration.hack(hackOrder);
    Declaration.hack(hackFilter);
    Declaration.hack(hackGridEnd);
    Declaration.hack(hackAnimation);
    Declaration.hack(hackFlexFlow);
    Declaration.hack(hackFlexGrow);
    Declaration.hack(hackFlexWrap);
    Declaration.hack(hackGridArea);
    Declaration.hack(hackPlaceSelf);
    Declaration.hack(hackGridStart);
    Declaration.hack(hackAlignSelf);
    Declaration.hack(hackAppearance);
    Declaration.hack(hackFlexBasis);
    Declaration.hack(hackMaskBorder);
    Declaration.hack(hackMaskComposite);
    Declaration.hack(hackAlignItems);
    Declaration.hack(hackUserSelect);
    Declaration.hack(hackFlexShrink);
    Declaration.hack(hackBreakProps);
    Declaration.hack(hackWritingMode);
    Declaration.hack(hackBorderImage);
    Declaration.hack(hackAlignContent);
    Declaration.hack(hackBorderRadius);
    Declaration.hack(hackBlockLogical);
    Declaration.hack(hackGridTemplate);
    Declaration.hack(hackInlineLogical);
    Declaration.hack(hackGridRowAlign);
    Declaration.hack(hackTransformDecl);
    Declaration.hack(hackFlexDirection);
    Declaration.hack(hackImageRendering);
    Declaration.hack(hackBackdropFilter);
    Declaration.hack(hackBackgroundClip);
    Declaration.hack(hackTextDecoration);
    Declaration.hack(hackJustifyContent);
    Declaration.hack(hackBackgroundSize);
    Declaration.hack(hackGridRowColumn);
    Declaration.hack(hackGridRowsColumns);
    Declaration.hack(hackGridColumnAlign);
    Declaration.hack(hackOverscrollBehavior);
    Declaration.hack(hackGridTemplateAreas);
    Declaration.hack(hackPrintColorAdjust);
    Declaration.hack(hackTextEmphasisPosition);
    Declaration.hack(hackTextDecorationSkipInk);
    Value.hack(hackGradient);
    Value.hack(hackIntrinsic);
    Value.hack(hackPixelated);
    Value.hack(hackImageSet);
    Value.hack(hackCrossFade);
    Value.hack(hackDisplayFlex);
    Value.hack(hackDisplayGrid);
    Value.hack(hackFilterValue);
    var declsCache = /* @__PURE__ */ new Map();
    var Prefixes = class {
      constructor(data2, browsers, options3 = {}) {
        this.data = data2;
        this.browsers = browsers;
        this.options = options3;
        [this.add, this.remove] = this.preprocess(this.select(this.data));
        this.transition = new Transition(this);
        this.processor = new Processor(this);
      }
      /**
       * Return clone instance to remove all prefixes
       */
      cleaner() {
        if (this.cleanerCache) {
          return this.cleanerCache;
        }
        if (this.browsers.selected.length) {
          let empty2 = new Browsers(this.browsers.data, []);
          this.cleanerCache = new Prefixes(this.data, empty2, this.options);
        } else {
          return this;
        }
        return this.cleanerCache;
      }
      /**
       * Select prefixes from data, which is necessary for selected browsers
       */
      select(list) {
        let selected = { add: {}, remove: {} };
        for (let name2 in list) {
          let data2 = list[name2];
          let add = data2.browsers.map((i2) => {
            let params = i2.split(" ");
            return {
              browser: `${params[0]} ${params[1]}`,
              note: params[2]
            };
          });
          let notes = add.filter((i2) => i2.note).map((i2) => `${this.browsers.prefix(i2.browser)} ${i2.note}`);
          notes = utils2.uniq(notes);
          add = add.filter((i2) => this.browsers.isSelected(i2.browser)).map((i2) => {
            let prefix = this.browsers.prefix(i2.browser);
            if (i2.note) {
              return `${prefix} ${i2.note}`;
            } else {
              return prefix;
            }
          });
          add = this.sort(utils2.uniq(add));
          if (this.options.flexbox === "no-2009") {
            add = add.filter((i2) => !i2.includes("2009"));
          }
          let all = data2.browsers.map((i2) => this.browsers.prefix(i2));
          if (data2.mistakes) {
            all = all.concat(data2.mistakes);
          }
          all = all.concat(notes);
          all = utils2.uniq(all);
          if (add.length) {
            selected.add[name2] = add;
            if (add.length < all.length) {
              selected.remove[name2] = all.filter((i2) => !add.includes(i2));
            }
          } else {
            selected.remove[name2] = all;
          }
        }
        return selected;
      }
      /**
       * Sort vendor prefixes
       */
      sort(prefixes) {
        return prefixes.sort((a2, b) => {
          let aLength = utils2.removeNote(a2).length;
          let bLength = utils2.removeNote(b).length;
          if (aLength === bLength) {
            return b.length - a2.length;
          } else {
            return bLength - aLength;
          }
        });
      }
      /**
       * Cache prefixes data to fast CSS processing
       */
      preprocess(selected) {
        let add = {
          "selectors": [],
          "@supports": new Supports(Prefixes, this)
        };
        for (let name2 in selected.add) {
          let prefixes = selected.add[name2];
          if (name2 === "@keyframes" || name2 === "@viewport") {
            add[name2] = new AtRule(name2, prefixes, this);
          } else if (name2 === "@resolution") {
            add[name2] = new Resolution(name2, prefixes, this);
          } else if (this.data[name2].selector) {
            add.selectors.push(Selector.load(name2, prefixes, this));
          } else {
            let props = this.data[name2].props;
            if (props) {
              let value2 = Value.load(name2, prefixes, this);
              for (let prop of props) {
                if (!add[prop]) {
                  add[prop] = { values: [] };
                }
                add[prop].values.push(value2);
              }
            } else {
              let values = add[name2] && add[name2].values || [];
              add[name2] = Declaration.load(name2, prefixes, this);
              add[name2].values = values;
            }
          }
        }
        let remove = { selectors: [] };
        for (let name2 in selected.remove) {
          let prefixes = selected.remove[name2];
          if (this.data[name2].selector) {
            let selector = Selector.load(name2, prefixes);
            for (let prefix of prefixes) {
              remove.selectors.push(selector.old(prefix));
            }
          } else if (name2 === "@keyframes" || name2 === "@viewport") {
            for (let prefix of prefixes) {
              let prefixed = `@${prefix}${name2.slice(1)}`;
              remove[prefixed] = { remove: true };
            }
          } else if (name2 === "@resolution") {
            remove[name2] = new Resolution(name2, prefixes, this);
          } else {
            let props = this.data[name2].props;
            if (props) {
              let value2 = Value.load(name2, [], this);
              for (let prefix of prefixes) {
                let old2 = value2.old(prefix);
                if (old2) {
                  for (let prop of props) {
                    if (!remove[prop]) {
                      remove[prop] = {};
                    }
                    if (!remove[prop].values) {
                      remove[prop].values = [];
                    }
                    remove[prop].values.push(old2);
                  }
                }
              }
            } else {
              for (let p2 of prefixes) {
                let olds = this.decl(name2).old(name2, p2);
                if (name2 === "align-self") {
                  let a2 = add[name2] && add[name2].prefixes;
                  if (a2) {
                    if (p2 === "-webkit- 2009" && a2.includes("-webkit-")) {
                      continue;
                    } else if (p2 === "-webkit-" && a2.includes("-webkit- 2009")) {
                      continue;
                    }
                  }
                }
                for (let prefixed of olds) {
                  if (!remove[prefixed]) {
                    remove[prefixed] = {};
                  }
                  remove[prefixed].remove = true;
                }
              }
            }
          }
        }
        return [add, remove];
      }
      /**
       * Declaration loader with caching
       */
      decl(prop) {
        if (!declsCache.has(prop)) {
          declsCache.set(prop, Declaration.load(prop));
        }
        return declsCache.get(prop);
      }
      /**
       * Return unprefixed version of property
       */
      unprefixed(prop) {
        let value2 = this.normalize(vendor.unprefixed(prop));
        if (value2 === "flex-direction") {
          value2 = "flex-flow";
        }
        return value2;
      }
      /**
       * Normalize prefix for remover
       */
      normalize(prop) {
        return this.decl(prop).normalize(prop);
      }
      /**
       * Return prefixed version of property
       */
      prefixed(prop, prefix) {
        prop = vendor.unprefixed(prop);
        return this.decl(prop).prefixed(prop, prefix);
      }
      /**
       * Return values, which must be prefixed in selected property
       */
      values(type, prop) {
        let data2 = this[type];
        let global2 = data2["*"] && data2["*"].values;
        let values = data2[prop] && data2[prop].values;
        if (global2 && values) {
          return utils2.uniq(global2.concat(values));
        } else {
          return global2 || values || [];
        }
      }
      /**
       * Group declaration by unprefixed property to check them
       */
      group(decl) {
        let rule = decl.parent;
        let index2 = rule.index(decl);
        let { length } = rule.nodes;
        let unprefixed = this.unprefixed(decl.prop);
        let checker = (step, callback) => {
          index2 += step;
          while (index2 >= 0 && index2 < length) {
            let other = rule.nodes[index2];
            if (other.type === "decl") {
              if (step === -1 && other.prop === unprefixed) {
                if (!Browsers.withPrefix(other.value)) {
                  break;
                }
              }
              if (this.unprefixed(other.prop) !== unprefixed) {
                break;
              } else if (callback(other) === true) {
                return true;
              }
              if (step === 1 && other.prop === unprefixed) {
                if (!Browsers.withPrefix(other.value)) {
                  break;
                }
              }
            }
            index2 += step;
          }
          return false;
        };
        return {
          up(callback) {
            return checker(-1, callback);
          },
          down(callback) {
            return checker(1, callback);
          }
        };
      }
    };
    module2.exports = Prefixes;
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/border-radius.js
var require_border_radius2 = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/border-radius.js"(exports3, module2) {
    module2.exports = { A: { A: { "1": "F A B", "2": "J D E FC" }, B: { "1": "C K L G M N O P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x" }, C: { "1": "TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "257": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB", "289": "wB HC IC", "292": "GC" }, D: { "1": "0 1 2 3 4 5 6 7 8 9 y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "33": "I" }, E: { "1": "y D E F A B C K L G OC PC 2B tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC", "33": "I LC 1B", "129": "J MC NC" }, F: { "1": "0 1 2 3 4 5 6 7 8 9 B C G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h VC WC tB DC XC uB", "2": "F TC UC" }, G: { "1": "E YC EC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "33": "1B" }, H: { "2": "sC" }, I: { "1": "wB I H uC vC wC EC xC yC", "33": "tC" }, J: { "1": "D A" }, K: { "1": "B C k tB DC uB", "2": "A" }, L: { "1": "H" }, M: { "1": "i" }, N: { "1": "A B" }, O: { "1": "zC" }, P: { "1": "I j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD" }, Q: { "1": "3B" }, R: { "1": "DD" }, S: { "1": "FD", "257": "ED" } }, B: 4, C: "CSS3 Border-radius (rounded corners)" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-boxshadow.js
var require_css_boxshadow = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-boxshadow.js"(exports3, module2) {
    module2.exports = { A: { A: { "1": "F A B", "2": "J D E FC" }, B: { "1": "C K L G M N O P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x" }, C: { "1": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "GC wB", "33": "HC IC" }, D: { "1": "0 1 2 3 4 5 6 7 8 9 A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "33": "I y J D E F" }, E: { "1": "J D E F A B C K L G MC NC OC PC 2B tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC", "33": "y", "164": "I LC 1B" }, F: { "1": "0 1 2 3 4 5 6 7 8 9 B C G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h VC WC tB DC XC uB", "2": "F TC UC" }, G: { "1": "E ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "33": "YC EC", "164": "1B" }, H: { "2": "sC" }, I: { "1": "I H wC EC xC yC", "164": "wB tC uC vC" }, J: { "1": "A", "33": "D" }, K: { "1": "B C k tB DC uB", "2": "A" }, L: { "1": "H" }, M: { "1": "i" }, N: { "1": "A B" }, O: { "1": "zC" }, P: { "1": "I j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD" }, Q: { "1": "3B" }, R: { "1": "DD" }, S: { "1": "ED FD" } }, B: 4, C: "CSS3 Box-shadow" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-animation.js
var require_css_animation = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-animation.js"(exports3, module2) {
    module2.exports = { A: { A: { "1": "A B", "2": "J D E F FC" }, B: { "1": "C K L G M N O P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x" }, C: { "1": "0 1 2 3 4 5 6 7 8 9 M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "GC wB I HC IC", "33": "y J D E F A B C K L G" }, D: { "1": "MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "33": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB" }, E: { "1": "F A B C K L G PC 2B tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC", "2": "LC 1B", "33": "J D E MC NC OC", "292": "I y" }, F: { "1": "9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h uB", "2": "F B TC UC VC WC tB DC XC", "33": "0 1 2 3 4 5 6 7 8 C G M N O z j" }, G: { "1": "dC eC fC gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "33": "E aC bC cC", "164": "1B YC EC ZC" }, H: { "2": "sC" }, I: { "1": "H", "33": "I wC EC xC yC", "164": "wB tC uC vC" }, J: { "33": "D A" }, K: { "1": "k uB", "2": "A B C tB DC" }, L: { "1": "H" }, M: { "1": "i" }, N: { "1": "A B" }, O: { "1": "zC" }, P: { "1": "I j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD" }, Q: { "1": "3B" }, R: { "1": "DD" }, S: { "1": "ED FD" } }, B: 5, C: "CSS Animation" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-transitions.js
var require_css_transitions = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-transitions.js"(exports3, module2) {
    module2.exports = { A: { A: { "1": "A B", "2": "J D E F FC" }, B: { "1": "C K L G M N O P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x" }, C: { "1": "0 1 2 3 4 5 6 7 8 9 M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "GC wB HC IC", "33": "y J D E F A B C K L G", "164": "I" }, D: { "1": "5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "33": "0 1 2 3 4 I y J D E F A B C K L G M N O z j" }, E: { "1": "D E F A B C K L G NC OC PC 2B tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC", "33": "J MC", "164": "I y LC 1B" }, F: { "1": "0 1 2 3 4 5 6 7 8 9 G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h uB", "2": "F TC UC", "33": "C", "164": "B VC WC tB DC XC" }, G: { "1": "E bC cC dC eC fC gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "33": "aC", "164": "1B YC EC ZC" }, H: { "2": "sC" }, I: { "1": "H xC yC", "33": "wB I tC uC vC wC EC" }, J: { "1": "A", "33": "D" }, K: { "1": "k uB", "33": "C", "164": "A B tB DC" }, L: { "1": "H" }, M: { "1": "i" }, N: { "1": "A B" }, O: { "1": "zC" }, P: { "1": "I j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD" }, Q: { "1": "3B" }, R: { "1": "DD" }, S: { "1": "ED FD" } }, B: 5, C: "CSS3 Transitions" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/transforms2d.js
var require_transforms2d = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/transforms2d.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "FC", "8": "J D E", "129": "A B", "161": "F" }, B: { "1": "N O P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x", "129": "C K L G M" }, C: { "1": "0 1 2 3 4 5 6 7 8 9 M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "GC wB", "33": "I y J D E F A B C K L G HC IC" }, D: { "1": "FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "33": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB EB" }, E: { "1": "F A B C K L G PC 2B tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC", "33": "I y J D E LC 1B MC NC OC" }, F: { "1": "2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h uB", "2": "F TC UC", "33": "0 1 B C G M N O z j VC WC tB DC XC" }, G: { "1": "dC eC fC gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "33": "E 1B YC EC ZC aC bC cC" }, H: { "2": "sC" }, I: { "1": "H", "33": "wB I tC uC vC wC EC xC yC" }, J: { "33": "D A" }, K: { "1": "B C k tB DC uB", "2": "A" }, L: { "1": "H" }, M: { "1": "i" }, N: { "1": "A B" }, O: { "1": "zC" }, P: { "1": "I j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD" }, Q: { "1": "3B" }, R: { "1": "DD" }, S: { "1": "ED FD" } }, B: 4, C: "CSS3 2D Transforms" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/transforms3d.js
var require_transforms3d = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/transforms3d.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D E F FC", "132": "A B" }, B: { "1": "C K L G M N O P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x" }, C: { "1": "0 1 2 3 4 5 6 7 8 9 M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "GC wB I y J D E F HC IC", "33": "A B C K L G" }, D: { "1": "FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "2": "I y J D E F A B", "33": "0 1 2 3 4 5 6 7 8 9 C K L G M N O z j AB BB CB DB EB" }, E: { "1": "5B 6B 7B vB 8B 9B AC BC CC SC", "2": "LC 1B", "33": "I y J D E MC NC OC", "257": "F A B C K L G PC 2B tB uB 3B QC RC 4B" }, F: { "1": "2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h", "2": "F B C TC UC VC WC tB DC XC uB", "33": "0 1 G M N O z j" }, G: { "1": "5B 6B 7B vB 8B 9B AC BC CC", "33": "E 1B YC EC ZC aC bC cC", "257": "dC eC fC gC hC iC jC kC lC mC nC oC pC qC rC 4B" }, H: { "2": "sC" }, I: { "1": "H", "2": "tC uC vC", "33": "wB I wC EC xC yC" }, J: { "33": "D A" }, K: { "1": "k", "2": "A B C tB DC uB" }, L: { "1": "H" }, M: { "1": "i" }, N: { "132": "A B" }, O: { "1": "zC" }, P: { "1": "I j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD" }, Q: { "1": "3B" }, R: { "1": "DD" }, S: { "1": "ED FD" } }, B: 5, C: "CSS3 3D Transforms" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-gradients.js
var require_css_gradients = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-gradients.js"(exports3, module2) {
    module2.exports = { A: { A: { "1": "A B", "2": "J D E F FC" }, B: { "1": "C K L G M N O P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x" }, C: { "1": "FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "GC wB HC", "260": "0 1 2 3 4 5 6 7 8 9 M N O z j AB BB CB DB EB", "292": "I y J D E F A B C K L G IC" }, D: { "1": "5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "33": "0 1 2 3 4 A B C K L G M N O z j", "548": "I y J D E F" }, E: { "1": "5B 6B 7B vB 8B 9B AC BC CC SC", "2": "LC 1B", "260": "D E F A B C K L G NC OC PC 2B tB uB 3B QC RC 4B", "292": "J MC", "804": "I y" }, F: { "1": "0 1 2 3 4 5 6 7 8 9 G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h uB", "2": "F B TC UC VC WC", "33": "C XC", "164": "tB DC" }, G: { "1": "5B 6B 7B vB 8B 9B AC BC CC", "260": "E bC cC dC eC fC gC hC iC jC kC lC mC nC oC pC qC rC 4B", "292": "ZC aC", "804": "1B YC EC" }, H: { "2": "sC" }, I: { "1": "H xC yC", "33": "I wC EC", "548": "wB tC uC vC" }, J: { "1": "A", "548": "D" }, K: { "1": "k uB", "2": "A B", "33": "C", "164": "tB DC" }, L: { "1": "H" }, M: { "1": "i" }, N: { "1": "A B" }, O: { "1": "zC" }, P: { "1": "I j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD" }, Q: { "1": "3B" }, R: { "1": "DD" }, S: { "1": "ED FD" } }, B: 4, C: "CSS Gradients" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css3-boxsizing.js
var require_css3_boxsizing = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css3-boxsizing.js"(exports3, module2) {
    module2.exports = { A: { A: { "1": "E F A B", "8": "J D FC" }, B: { "1": "C K L G M N O P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x" }, C: { "1": "8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "33": "0 1 2 3 4 5 6 7 GC wB I y J D E F A B C K L G M N O z j HC IC" }, D: { "1": "0 1 2 3 4 5 6 7 8 9 A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "33": "I y J D E F" }, E: { "1": "J D E F A B C K L G MC NC OC PC 2B tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC", "33": "I y LC 1B" }, F: { "1": "0 1 2 3 4 5 6 7 8 9 B C G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h TC UC VC WC tB DC XC uB", "2": "F" }, G: { "1": "E ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "33": "1B YC EC" }, H: { "1": "sC" }, I: { "1": "I H wC EC xC yC", "33": "wB tC uC vC" }, J: { "1": "A", "33": "D" }, K: { "1": "A B C k tB DC uB" }, L: { "1": "H" }, M: { "1": "i" }, N: { "1": "A B" }, O: { "1": "zC" }, P: { "1": "I j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD" }, Q: { "1": "3B" }, R: { "1": "DD" }, S: { "1": "ED FD" } }, B: 5, C: "CSS3 Box-sizing" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-filters.js
var require_css_filters = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-filters.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D E F A B FC" }, B: { "1": "P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x", "1028": "K L G M N O", "1346": "C" }, C: { "1": "EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "GC wB HC", "196": "DB", "516": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB IC" }, D: { "1": "WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "2": "I y J D E F A B C K L G M N", "33": "0 1 2 3 4 5 6 7 8 9 O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB" }, E: { "1": "A B C K L G PC 2B tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC", "2": "I y LC 1B MC", "33": "J D E F NC OC" }, F: { "1": "JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h", "2": "F B C TC UC VC WC tB DC XC uB", "33": "0 1 2 3 4 5 6 7 8 9 G M N O z j AB BB CB DB EB FB GB HB IB" }, G: { "1": "eC fC gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "2": "1B YC EC ZC", "33": "E aC bC cC dC" }, H: { "2": "sC" }, I: { "1": "H", "2": "wB I tC uC vC wC EC", "33": "xC yC" }, J: { "2": "D", "33": "A" }, K: { "1": "k", "2": "A B C tB DC uB" }, L: { "1": "H" }, M: { "1": "i" }, N: { "2": "A B" }, O: { "1": "zC" }, P: { "1": "j 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD", "33": "I 0C 1C" }, Q: { "1": "3B" }, R: { "1": "DD" }, S: { "1": "ED FD" } }, B: 5, C: "CSS Filter Effects" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-filter-function.js
var require_css_filter_function = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-filter-function.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D E F A B FC" }, B: { "2": "C K L G M N O P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x" }, C: { "2": "0 1 2 3 4 5 6 7 8 9 GC wB I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B HC IC" }, D: { "2": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC" }, E: { "1": "A B C K L G PC 2B tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC", "2": "I y J D E LC 1B MC NC OC", "33": "F" }, F: { "2": "0 1 2 3 4 5 6 7 8 9 F B C G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h TC UC VC WC tB DC XC uB" }, G: { "1": "fC gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "2": "E 1B YC EC ZC aC bC cC", "33": "dC eC" }, H: { "2": "sC" }, I: { "2": "wB I H tC uC vC wC EC xC yC" }, J: { "2": "D A" }, K: { "2": "A B C k tB DC uB" }, L: { "2": "H" }, M: { "2": "i" }, N: { "2": "A B" }, O: { "2": "zC" }, P: { "2": "I j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD" }, Q: { "2": "3B" }, R: { "2": "DD" }, S: { "2": "ED FD" } }, B: 5, C: "CSS filter() function" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-backdrop-filter.js
var require_css_backdrop_filter = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-backdrop-filter.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D E F A B FC" }, B: { "1": "P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x", "2": "C K L G M", "257": "N O" }, C: { "1": "p q r s t u v i w H x 0B", "2": "0 1 2 3 4 5 6 7 8 9 GC wB I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB HC IC", "578": "lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o" }, D: { "1": "qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "2": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB", "194": "QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB" }, E: { "2": "I y J D E LC 1B MC NC OC", "33": "F A B C K L G PC 2B tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC" }, F: { "1": "fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h", "2": "0 1 2 3 4 5 6 7 8 9 F B C G M N O z j AB BB CB TC UC VC WC tB DC XC uB", "194": "DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB" }, G: { "2": "E 1B YC EC ZC aC bC cC", "33": "dC eC fC gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC" }, H: { "2": "sC" }, I: { "1": "H", "2": "wB I tC uC vC wC EC xC yC" }, J: { "2": "D A" }, K: { "1": "k", "2": "A B C tB DC uB" }, L: { "1": "H" }, M: { "1": "i" }, N: { "2": "A B" }, O: { "1": "zC" }, P: { "1": "j 6C 7C 8C 9C vB AD BD CD", "2": "I", "194": "0C 1C 2C 3C 4C 2B 5C" }, Q: { "2": "3B" }, R: { "1": "DD" }, S: { "2": "ED FD" } }, B: 7, C: "CSS Backdrop Filter" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-element-function.js
var require_css_element_function = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-element-function.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D E F A B FC" }, B: { "2": "C K L G M N O P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x" }, C: { "33": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "164": "GC wB HC IC" }, D: { "2": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC" }, E: { "2": "I y J D E F A B C K L G LC 1B MC NC OC PC 2B tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC" }, F: { "2": "0 1 2 3 4 5 6 7 8 9 F B C G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h TC UC VC WC tB DC XC uB" }, G: { "2": "E 1B YC EC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC" }, H: { "2": "sC" }, I: { "2": "wB I H tC uC vC wC EC xC yC" }, J: { "2": "D A" }, K: { "2": "A B C k tB DC uB" }, L: { "2": "H" }, M: { "33": "i" }, N: { "2": "A B" }, O: { "2": "zC" }, P: { "2": "I j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD" }, Q: { "2": "3B" }, R: { "2": "DD" }, S: { "33": "ED FD" } }, B: 5, C: "CSS element() function" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/multicolumn.js
var require_multicolumn = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/multicolumn.js"(exports3, module2) {
    module2.exports = { A: { A: { "1": "A B", "2": "J D E F FC" }, B: { "1": "C K L G M N O", "516": "P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x" }, C: { "132": "VB WB XB YB ZB aB bB xB cB yB dB eB fB", "164": "0 1 2 3 4 5 6 7 8 9 GC wB I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB HC IC", "516": "gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a", "1028": "b c d e f g h l m n o p q r s t u v i w H x 0B" }, D: { "420": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB", "516": "TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC" }, E: { "1": "A B C K L G 2B tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC", "132": "F PC", "164": "D E OC", "420": "I y J LC 1B MC NC" }, F: { "1": "C tB DC XC uB", "2": "F B TC UC VC WC", "420": "0 1 2 3 4 5 6 7 8 9 G M N O z j AB BB CB DB EB FB", "516": "GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h" }, G: { "1": "fC gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "132": "dC eC", "164": "E bC cC", "420": "1B YC EC ZC aC" }, H: { "1": "sC" }, I: { "420": "wB I tC uC vC wC EC xC yC", "516": "H" }, J: { "420": "D A" }, K: { "1": "C tB DC uB", "2": "A B", "516": "k" }, L: { "516": "H" }, M: { "1028": "i" }, N: { "1": "A B" }, O: { "516": "zC" }, P: { "1": "j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD", "420": "I" }, Q: { "516": "3B" }, R: { "516": "DD" }, S: { "164": "ED FD" } }, B: 4, C: "CSS3 Multiple column layout" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/user-select-none.js
var require_user_select_none = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/user-select-none.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D E F FC", "33": "A B" }, B: { "1": "P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x", "33": "C K L G M N O" }, C: { "1": "kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "33": "0 1 2 3 4 5 6 7 8 9 GC wB I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB HC IC" }, D: { "1": "XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "33": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB" }, E: { "1": "SC", "33": "I y J D E F A B C K L G LC 1B MC NC OC PC 2B tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC" }, F: { "1": "KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h", "2": "F B C TC UC VC WC tB DC XC uB", "33": "0 1 2 3 4 5 6 7 8 9 G M N O z j AB BB CB DB EB FB GB HB IB JB" }, G: { "33": "E 1B YC EC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC" }, H: { "2": "sC" }, I: { "1": "H", "33": "wB I tC uC vC wC EC xC yC" }, J: { "33": "D A" }, K: { "1": "k", "2": "A B C tB DC uB" }, L: { "1": "H" }, M: { "1": "i" }, N: { "33": "A B" }, O: { "1": "zC" }, P: { "1": "j 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD", "33": "I 0C" }, Q: { "1": "3B" }, R: { "1": "DD" }, S: { "1": "FD", "33": "ED" } }, B: 5, C: "CSS user-select: none" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/flexbox.js
var require_flexbox = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/flexbox.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D E F FC", "1028": "B", "1316": "A" }, B: { "1": "C K L G M N O P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x" }, C: { "1": "7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "164": "0 GC wB I y J D E F A B C K L G M N O z j HC IC", "516": "1 2 3 4 5 6" }, D: { "1": "8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "33": "0 1 2 3 4 5 6 7", "164": "I y J D E F A B C K L G M N O z j" }, E: { "1": "F A B C K L G PC 2B tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC", "33": "D E NC OC", "164": "I y J LC 1B MC" }, F: { "1": "0 1 2 3 4 5 6 7 8 9 N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h uB", "2": "F B C TC UC VC WC tB DC XC", "33": "G M" }, G: { "1": "dC eC fC gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "33": "E bC cC", "164": "1B YC EC ZC aC" }, H: { "1": "sC" }, I: { "1": "H xC yC", "164": "wB I tC uC vC wC EC" }, J: { "1": "A", "164": "D" }, K: { "1": "k uB", "2": "A B C tB DC" }, L: { "1": "H" }, M: { "1": "i" }, N: { "1": "B", "292": "A" }, O: { "1": "zC" }, P: { "1": "I j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD" }, Q: { "1": "3B" }, R: { "1": "DD" }, S: { "1": "ED FD" } }, B: 4, C: "CSS Flexible Box Layout Module" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/calc.js
var require_calc = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/calc.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D E FC", "260": "F", "516": "A B" }, B: { "1": "C K L G M N O P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x" }, C: { "1": "0 1 2 3 4 5 6 7 8 9 M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "GC wB HC IC", "33": "I y J D E F A B C K L G" }, D: { "1": "5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "2": "I y J D E F A B C K L G M N O", "33": "0 1 2 3 4 z j" }, E: { "1": "D E F A B C K L G NC OC PC 2B tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC", "2": "I y LC 1B MC", "33": "J" }, F: { "1": "0 1 2 3 4 5 6 7 8 9 G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h", "2": "F B C TC UC VC WC tB DC XC uB" }, G: { "1": "E bC cC dC eC fC gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "2": "1B YC EC ZC", "33": "aC" }, H: { "2": "sC" }, I: { "1": "H", "2": "wB I tC uC vC wC EC", "132": "xC yC" }, J: { "1": "A", "2": "D" }, K: { "1": "k", "2": "A B C tB DC uB" }, L: { "1": "H" }, M: { "1": "i" }, N: { "1": "A B" }, O: { "1": "zC" }, P: { "1": "I j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD" }, Q: { "1": "3B" }, R: { "1": "DD" }, S: { "1": "ED FD" } }, B: 4, C: "calc() as CSS unit value" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/background-img-opts.js
var require_background_img_opts = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/background-img-opts.js"(exports3, module2) {
    module2.exports = { A: { A: { "1": "F A B", "2": "J D E FC" }, B: { "1": "C K L G M N O P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x" }, C: { "1": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "GC wB HC", "36": "IC" }, D: { "1": "0 1 2 3 4 5 6 7 8 9 G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "516": "I y J D E F A B C K L" }, E: { "1": "D E F A B C K L G OC PC 2B tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC", "772": "I y J LC 1B MC NC" }, F: { "1": "0 1 2 3 4 5 6 7 8 9 B C G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h VC WC tB DC XC uB", "2": "F TC", "36": "UC" }, G: { "1": "E bC cC dC eC fC gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "4": "1B YC EC aC", "516": "ZC" }, H: { "132": "sC" }, I: { "1": "H xC yC", "36": "tC", "516": "wB I wC EC", "548": "uC vC" }, J: { "1": "D A" }, K: { "1": "A B C k tB DC uB" }, L: { "1": "H" }, M: { "1": "i" }, N: { "1": "A B" }, O: { "1": "zC" }, P: { "1": "I j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD" }, Q: { "1": "3B" }, R: { "1": "DD" }, S: { "1": "ED FD" } }, B: 4, C: "CSS3 Background-image options" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/background-clip-text.js
var require_background_clip_text = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/background-clip-text.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D E F A B FC" }, B: { "1": "G M N O", "33": "C K L P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x" }, C: { "1": "SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "0 1 2 3 4 5 6 7 8 9 GC wB I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB HC IC" }, D: { "33": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC" }, E: { "1": "L G QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC", "16": "LC 1B", "33": "I y J D E F A B C K MC NC OC PC 2B tB uB 3B" }, F: { "2": "F B C TC UC VC WC tB DC XC uB", "33": "0 1 2 3 4 5 6 7 8 9 G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h" }, G: { "1": "pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "16": "1B YC EC ZC", "33": "E aC bC cC dC eC fC gC hC iC jC kC lC mC nC oC" }, H: { "2": "sC" }, I: { "16": "wB tC uC vC", "33": "I H wC EC xC yC" }, J: { "33": "D A" }, K: { "16": "A B C tB DC uB", "33": "k" }, L: { "33": "H" }, M: { "1": "i" }, N: { "2": "A B" }, O: { "33": "zC" }, P: { "33": "I j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD" }, Q: { "33": "3B" }, R: { "33": "DD" }, S: { "1": "ED FD" } }, B: 7, C: "Background-clip: text" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/font-feature.js
var require_font_feature = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/font-feature.js"(exports3, module2) {
    module2.exports = { A: { A: { "1": "A B", "2": "J D E F FC" }, B: { "1": "C K L G M N O P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x" }, C: { "1": "DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "GC wB HC IC", "33": "0 1 2 3 4 5 6 7 8 9 G M N O z j AB BB CB", "164": "I y J D E F A B C K L" }, D: { "1": "RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "2": "I y J D E F A B C K L G", "33": "0 1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB", "292": "M N O z j" }, E: { "1": "A B C K L G PC 2B tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC", "2": "D E F LC 1B NC OC", "4": "I y J MC" }, F: { "1": "EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h", "2": "F B C TC UC VC WC tB DC XC uB", "33": "0 1 2 3 4 5 6 7 8 9 G M N O z j AB BB CB DB" }, G: { "1": "eC fC gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "2": "E bC cC dC", "4": "1B YC EC ZC aC" }, H: { "2": "sC" }, I: { "1": "H", "2": "wB I tC uC vC wC EC", "33": "xC yC" }, J: { "2": "D", "33": "A" }, K: { "1": "k", "2": "A B C tB DC uB" }, L: { "1": "H" }, M: { "1": "i" }, N: { "2": "A B" }, O: { "1": "zC" }, P: { "1": "j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD", "33": "I" }, Q: { "1": "3B" }, R: { "1": "DD" }, S: { "1": "ED FD" } }, B: 2, C: "CSS font-feature-settings" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/font-kerning.js
var require_font_kerning = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/font-kerning.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D E F A B FC" }, B: { "1": "P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x", "2": "C K L G M N O" }, C: { "1": "DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "0 1 2 GC wB I y J D E F A B C K L G M N O z j HC IC", "194": "3 4 5 6 7 8 9 AB BB CB" }, D: { "1": "CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "2": "0 1 2 3 4 5 6 7 I y J D E F A B C K L G M N O z j", "33": "8 9 AB BB" }, E: { "1": "A B C K L G PC 2B tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC", "2": "I y J LC 1B MC NC", "33": "D E F OC" }, F: { "1": "0 1 2 3 4 5 6 7 8 9 j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h", "2": "F B C G TC UC VC WC tB DC XC uB", "33": "M N O z" }, G: { "1": "jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "2": "1B YC EC ZC aC bC", "33": "E cC dC eC fC gC hC iC" }, H: { "2": "sC" }, I: { "1": "H yC", "2": "wB I tC uC vC wC EC", "33": "xC" }, J: { "2": "D", "33": "A" }, K: { "1": "k", "2": "A B C tB DC uB" }, L: { "1": "H" }, M: { "1": "i" }, N: { "2": "A B" }, O: { "1": "zC" }, P: { "1": "I j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD" }, Q: { "1": "3B" }, R: { "1": "DD" }, S: { "1": "ED FD" } }, B: 4, C: "CSS3 font-kerning" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/border-image.js
var require_border_image2 = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/border-image.js"(exports3, module2) {
    module2.exports = { A: { A: { "1": "B", "2": "J D E F A FC" }, B: { "1": "L G M N O P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x", "129": "C K" }, C: { "1": "TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "GC wB", "260": "0 1 2 3 4 5 6 7 8 9 G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB", "804": "I y J D E F A B C K L HC IC" }, D: { "1": "ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "260": "UB VB WB XB YB", "388": "9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB", "1412": "0 1 2 3 4 5 6 7 8 G M N O z j", "1956": "I y J D E F A B C K L" }, E: { "1": "5B 6B 7B vB 8B 9B AC BC CC SC", "129": "A B C K L G PC 2B tB uB 3B QC RC 4B", "1412": "J D E F NC OC", "1956": "I y LC 1B MC" }, F: { "1": "MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h", "2": "F TC UC", "260": "HB IB JB KB LB", "388": "0 1 2 3 4 5 6 7 8 9 G M N O z j AB BB CB DB EB FB GB", "1796": "VC WC", "1828": "B C tB DC XC uB" }, G: { "1": "5B 6B 7B vB 8B 9B AC BC CC", "129": "eC fC gC hC iC jC kC lC mC nC oC pC qC rC 4B", "1412": "E aC bC cC dC", "1956": "1B YC EC ZC" }, H: { "1828": "sC" }, I: { "1": "H", "388": "xC yC", "1956": "wB I tC uC vC wC EC" }, J: { "1412": "A", "1924": "D" }, K: { "1": "k", "2": "A", "1828": "B C tB DC uB" }, L: { "1": "H" }, M: { "1": "i" }, N: { "1": "B", "2": "A" }, O: { "1": "zC" }, P: { "1": "j 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD", "260": "0C 1C", "388": "I" }, Q: { "1": "3B" }, R: { "1": "DD" }, S: { "1": "FD", "260": "ED" } }, B: 4, C: "CSS3 Border images" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-selection.js
var require_css_selection = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-selection.js"(exports3, module2) {
    module2.exports = { A: { A: { "1": "F A B", "2": "J D E FC" }, B: { "1": "C K L G M N O P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x" }, C: { "1": "dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "33": "0 1 2 3 4 5 6 7 8 9 GC wB I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB HC IC" }, D: { "1": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC" }, E: { "1": "I y J D E F A B C K L G LC 1B MC NC OC PC 2B tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC" }, F: { "1": "0 1 2 3 4 5 6 7 8 9 B C G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h TC UC VC WC tB DC XC uB", "2": "F" }, G: { "2": "E 1B YC EC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC" }, H: { "2": "sC" }, I: { "1": "H xC yC", "2": "wB I tC uC vC wC EC" }, J: { "1": "A", "2": "D" }, K: { "1": "C k DC uB", "16": "A B tB" }, L: { "1": "H" }, M: { "1": "i" }, N: { "1": "A B" }, O: { "1": "zC" }, P: { "1": "I j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD" }, Q: { "1": "3B" }, R: { "1": "DD" }, S: { "1": "FD", "33": "ED" } }, B: 5, C: "::selection CSS pseudo-element" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-placeholder.js
var require_css_placeholder = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-placeholder.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D E F A B FC" }, B: { "1": "P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x", "36": "C K L G M N O" }, C: { "1": "UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "GC wB I y J D E F A B C K L G M N O HC IC", "33": "0 1 2 3 4 5 6 7 8 9 z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB" }, D: { "1": "aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "36": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB" }, E: { "1": "B C K L G 2B tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC", "2": "I LC 1B", "36": "y J D E F A MC NC OC PC" }, F: { "1": "NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h", "2": "F B C TC UC VC WC tB DC XC uB", "36": "0 1 2 3 4 5 6 7 8 9 G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB" }, G: { "1": "gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "2": "1B YC", "36": "E EC ZC aC bC cC dC eC fC" }, H: { "2": "sC" }, I: { "1": "H", "36": "wB I tC uC vC wC EC xC yC" }, J: { "36": "D A" }, K: { "1": "k", "2": "A B C tB DC uB" }, L: { "1": "H" }, M: { "1": "i" }, N: { "36": "A B" }, O: { "1": "zC" }, P: { "1": "j 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD", "36": "I 0C 1C" }, Q: { "1": "3B" }, R: { "1": "DD" }, S: { "1": "FD", "33": "ED" } }, B: 5, C: "::placeholder CSS pseudo-element" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-placeholder-shown.js
var require_css_placeholder_shown = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-placeholder-shown.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D E F FC", "292": "A B" }, B: { "1": "P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x", "2": "C K L G M N O" }, C: { "1": "UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "GC wB HC IC", "164": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB" }, D: { "1": "QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "2": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB" }, E: { "1": "F A B C K L G PC 2B tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC", "2": "I y J D E LC 1B MC NC OC" }, F: { "1": "DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h", "2": "0 1 2 3 4 5 6 7 8 9 F B C G M N O z j AB BB CB TC UC VC WC tB DC XC uB" }, G: { "1": "dC eC fC gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "2": "E 1B YC EC ZC aC bC cC" }, H: { "2": "sC" }, I: { "1": "H", "2": "wB I tC uC vC wC EC xC yC" }, J: { "2": "D A" }, K: { "1": "k", "2": "A B C tB DC uB" }, L: { "1": "H" }, M: { "1": "i" }, N: { "2": "A B" }, O: { "1": "zC" }, P: { "1": "j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD", "2": "I" }, Q: { "1": "3B" }, R: { "1": "DD" }, S: { "1": "FD", "164": "ED" } }, B: 5, C: ":placeholder-shown CSS pseudo-class" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-hyphens.js
var require_css_hyphens = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-hyphens.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D E F FC", "33": "A B" }, B: { "1": "r s t u v i w H x", "33": "C K L G M N O", "132": "P Q R S T U V W", "260": "X Y Z a b c d e f g h l m n o p q" }, C: { "1": "MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "GC wB I y HC IC", "33": "0 1 2 3 4 5 6 7 8 9 J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB" }, D: { "1": "X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "2": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB", "132": "YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W" }, E: { "2": "I y LC 1B", "33": "J D E F A B C K L G MC NC OC PC 2B tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC" }, F: { "1": "a b c d e f g h", "2": "0 1 2 3 4 5 6 7 8 9 F B C G M N O z j AB BB CB DB EB FB GB HB IB JB KB TC UC VC WC tB DC XC uB", "132": "LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z" }, G: { "2": "1B YC", "33": "E EC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC" }, H: { "2": "sC" }, I: { "1": "H", "2": "wB I tC uC vC wC EC xC yC" }, J: { "2": "D A" }, K: { "1": "k", "2": "A B C tB DC uB" }, L: { "1": "H" }, M: { "1": "i" }, N: { "2": "A B" }, O: { "4": "zC" }, P: { "1": "j 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD", "2": "I", "132": "0C" }, Q: { "1": "3B" }, R: { "1": "DD" }, S: { "1": "ED FD" } }, B: 4, C: "CSS Hyphenation" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/fullscreen.js
var require_fullscreen2 = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/fullscreen.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D E F A FC", "548": "B" }, B: { "1": "P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x", "516": "C K L G M N O" }, C: { "1": "fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "GC wB I y J D E F HC IC", "676": "0 1 2 3 4 5 6 7 8 9 A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB", "1700": "QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB" }, D: { "1": "mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "2": "I y J D E F A B C K L", "676": "G M N O z", "804": "0 1 2 3 4 5 6 7 8 9 j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB" }, E: { "1": "BC CC SC", "2": "I y LC 1B", "548": "5B 6B 7B vB 8B 9B AC", "676": "MC", "804": "J D E F A B C K L G NC OC PC 2B tB uB 3B QC RC 4B" }, F: { "1": "fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h uB", "2": "F B C TC UC VC WC tB DC XC", "804": "0 1 2 3 4 5 6 7 8 9 G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB" }, G: { "2": "E 1B YC EC ZC aC bC cC dC eC fC gC hC iC", "2052": "jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC" }, H: { "2": "sC" }, I: { "2": "wB I H tC uC vC wC EC xC yC" }, J: { "2": "D", "292": "A" }, K: { "1": "k", "2": "A B C tB DC uB" }, L: { "1": "H" }, M: { "1": "i" }, N: { "2": "A", "548": "B" }, O: { "1": "zC" }, P: { "1": "j 2B 5C 6C 7C 8C 9C vB AD BD CD", "804": "I 0C 1C 2C 3C 4C" }, Q: { "1": "3B" }, R: { "1": "DD" }, S: { "1": "ED FD" } }, B: 1, C: "Full Screen API" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-file-selector-button.js
var require_css_file_selector_button = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-file-selector-button.js"(exports3, module2) {
    module2.exports = { A: { D: { "1": "Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "33": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X" }, L: { "1": "H" }, B: { "1": "Y Z a b c d e f g h l m n o p q r s t u v i w H x", "33": "C K L G M N O P Q R S T U V W X" }, C: { "1": "zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "0 1 2 3 4 5 6 7 8 9 GC wB I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R HC IC" }, M: { "1": "i" }, A: { "2": "J D E F FC", "33": "A B" }, F: { "1": "pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h", "2": "F B C TC UC VC WC tB DC XC uB", "33": "0 1 2 3 4 5 6 7 8 9 G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB" }, K: { "1": "k", "2": "A B C tB DC uB" }, E: { "1": "G QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC", "2": "SC", "33": "I y J D E F A B C K L LC 1B MC NC OC PC 2B tB uB 3B" }, G: { "1": "qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "33": "E 1B YC EC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC oC pC" }, P: { "1": "j 9C vB AD BD CD", "33": "I 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C" }, I: { "1": "H", "2": "wB I tC uC vC wC EC", "33": "xC yC" } }, B: 6, C: "::file-selector-button CSS pseudo-element" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-autofill.js
var require_css_autofill = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-autofill.js"(exports3, module2) {
    module2.exports = { A: { D: { "33": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC" }, L: { "33": "H" }, B: { "2": "C K L G M N O", "33": "P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x" }, C: { "1": "V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "0 1 2 3 4 5 6 7 8 9 GC wB I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U HC IC" }, M: { "1": "i" }, A: { "2": "J D E F A B FC" }, F: { "2": "F B C TC UC VC WC tB DC XC uB", "33": "0 1 2 3 4 5 6 7 8 9 G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h" }, K: { "2": "A B C tB DC uB", "33": "k" }, E: { "1": "G RC 4B 5B 6B 7B vB 8B 9B AC BC CC", "2": "SC", "33": "I y J D E F A B C K L LC 1B MC NC OC PC 2B tB uB 3B QC" }, G: { "1": "rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "33": "E 1B YC EC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC oC pC qC" }, P: { "33": "I j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD" }, I: { "2": "wB I tC uC vC wC EC", "33": "H xC yC" } }, B: 6, C: ":autofill CSS pseudo-class" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css3-tabsize.js
var require_css3_tabsize = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css3-tabsize.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D E F A B FC" }, B: { "1": "P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x", "2": "C K L G M N O" }, C: { "1": "a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "GC wB HC IC", "33": "WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z", "164": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB" }, D: { "1": "LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "2": "I y J D E F A B C K L G M N O z j", "132": "0 1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB" }, E: { "1": "L G 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC", "2": "I y J LC 1B MC", "132": "D E F A B C K NC OC PC 2B tB uB" }, F: { "1": "8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h", "2": "F TC UC VC", "132": "0 1 2 3 4 5 6 7 G M N O z j", "164": "B C WC tB DC XC uB" }, G: { "1": "oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "2": "1B YC EC ZC aC", "132": "E bC cC dC eC fC gC hC iC jC kC lC mC nC" }, H: { "164": "sC" }, I: { "1": "H", "2": "wB I tC uC vC wC EC", "132": "xC yC" }, J: { "132": "D A" }, K: { "1": "k", "2": "A", "164": "B C tB DC uB" }, L: { "1": "H" }, M: { "1": "i" }, N: { "2": "A B" }, O: { "1": "zC" }, P: { "1": "I j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD" }, Q: { "1": "3B" }, R: { "1": "DD" }, S: { "164": "ED FD" } }, B: 4, C: "CSS3 tab-size" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/intrinsic-width.js
var require_intrinsic_width = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/intrinsic-width.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D E F A B FC" }, B: { "2": "C K L G M N O", "1025": "d e f g h l m n o p q r s t u v i w H x", "1537": "P Q R S T U V W X Y Z a b c" }, C: { "2": "GC", "932": "0 1 2 3 4 5 6 7 8 9 wB I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB HC IC", "2308": "hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B" }, D: { "2": "0 I y J D E F A B C K L G M N O z j", "545": "1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB", "1025": "d e f g h l m n o p q r s t u v i w H x 0B JC KC", "1537": "PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c" }, E: { "1": "vB 8B 9B AC BC CC SC", "2": "I y J LC 1B MC", "516": "B C K L G tB uB 3B QC RC 4B 5B 6B 7B", "548": "F A PC 2B", "676": "D E NC OC" }, F: { "2": "F B C TC UC VC WC tB DC XC uB", "513": "DB", "545": "0 1 2 3 4 5 6 7 8 9 G M N O z j AB BB", "1025": "e f g h", "1537": "CB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d" }, G: { "1": "vB 8B 9B AC BC CC", "2": "1B YC EC ZC aC", "516": "pC qC rC 4B 5B 6B 7B", "548": "dC eC fC gC hC iC jC kC lC mC nC oC", "676": "E bC cC" }, H: { "2": "sC" }, I: { "2": "wB I tC uC vC wC EC", "545": "xC yC", "1025": "H" }, J: { "2": "D", "545": "A" }, K: { "2": "A B C tB DC uB", "1025": "k" }, L: { "1025": "H" }, M: { "2308": "i" }, N: { "2": "A B" }, O: { "1537": "zC" }, P: { "545": "I", "1025": "j AD BD CD", "1537": "0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB" }, Q: { "1537": "3B" }, R: { "1537": "DD" }, S: { "932": "ED", "2308": "FD" } }, B: 5, C: "Intrinsic & Extrinsic Sizing" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-width-stretch.js
var require_css_width_stretch = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-width-stretch.js"(exports3, module2) {
    module2.exports = { A: { D: { "2": "0 I y J D E F A B C K L G M N O z j", "33": "1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC" }, L: { "33": "H" }, B: { "2": "C K L G M N O", "33": "P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x" }, C: { "2": "GC", "33": "0 1 2 3 4 5 6 7 8 9 wB I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B HC IC" }, M: { "33": "i" }, A: { "2": "J D E F A B FC" }, F: { "2": "F B C TC UC VC WC tB DC XC uB", "33": "0 1 2 3 4 5 6 7 8 9 G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h" }, K: { "2": "A B C tB DC uB", "33": "k" }, E: { "2": "I y J LC 1B MC NC SC", "33": "D E F A B C K L G OC PC 2B tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC" }, G: { "2": "1B YC EC ZC aC", "33": "E bC cC dC eC fC gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC" }, P: { "2": "I", "33": "j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD" }, I: { "2": "wB I tC uC vC wC EC", "33": "H xC yC" } }, B: 6, C: "width: stretch property" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css3-cursors-newer.js
var require_css3_cursors_newer = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css3-cursors-newer.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D E F A B FC" }, B: { "1": "C K L G M N O P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x" }, C: { "1": "3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "33": "0 1 2 GC wB I y J D E F A B C K L G M N O z j HC IC" }, D: { "1": "GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "33": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB EB FB" }, E: { "1": "F A B C K L G PC 2B tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC", "33": "I y J D E LC 1B MC NC OC" }, F: { "1": "3 4 5 6 7 8 9 C AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h XC uB", "2": "F B TC UC VC WC tB DC", "33": "0 1 2 G M N O z j" }, G: { "2": "E 1B YC EC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC" }, H: { "2": "sC" }, I: { "1": "H", "2": "wB I tC uC vC wC EC xC yC" }, J: { "33": "D A" }, K: { "1": "k", "2": "A B C tB DC uB" }, L: { "1": "H" }, M: { "2": "i" }, N: { "2": "A B" }, O: { "1": "zC" }, P: { "2": "I j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD" }, Q: { "1": "3B" }, R: { "1": "DD" }, S: { "2": "ED FD" } }, B: 2, C: "CSS3 Cursors: zoom-in & zoom-out" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css3-cursors-grab.js
var require_css3_cursors_grab = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css3-cursors-grab.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D E F A B FC" }, B: { "1": "G M N O P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x", "2": "C K L" }, C: { "1": "6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "33": "0 1 2 3 4 5 GC wB I y J D E F A B C K L G M N O z j HC IC" }, D: { "1": "jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "33": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB" }, E: { "1": "B C K L G tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC", "33": "I y J D E F A LC 1B MC NC OC PC 2B" }, F: { "1": "C YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h XC uB", "2": "F B TC UC VC WC tB DC", "33": "0 1 2 3 4 5 6 7 8 9 G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB" }, G: { "2": "E 1B YC EC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC" }, H: { "2": "sC" }, I: { "1": "H", "2": "wB I tC uC vC wC EC xC yC" }, J: { "33": "D A" }, K: { "1": "k", "2": "A B C tB DC uB" }, L: { "1": "H" }, M: { "2": "i" }, N: { "2": "A B" }, O: { "1": "zC" }, P: { "2": "I j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD" }, Q: { "1": "3B" }, R: { "1": "DD" }, S: { "2": "ED FD" } }, B: 2, C: "CSS grab & grabbing cursors" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-sticky.js
var require_css_sticky = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-sticky.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D E F A B FC" }, B: { "1": "a b c d e f g h l m n o p q r s t u v i w H x", "2": "C K L G", "1028": "P Q R S T U V W X Y Z", "4100": "M N O" }, C: { "1": "xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "0 1 2 3 4 GC wB I y J D E F A B C K L G M N O z j HC IC", "194": "5 6 7 8 9 AB", "516": "BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB" }, D: { "1": "a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "2": "0 1 I y J D E F A B C K L G M N O z j GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB", "322": "2 3 4 5 6 7 8 9 AB BB CB DB EB FB VB WB XB YB", "1028": "ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z" }, E: { "1": "K L G 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC", "2": "I y J LC 1B MC", "33": "E F A B C OC PC 2B tB uB", "2084": "D NC" }, F: { "1": "sB P Q R zB S T U V W X Y Z a b c d e f g h", "2": "0 1 2 3 4 5 6 7 8 9 F B C G M N O z j AB BB CB DB EB FB GB HB TC UC VC WC tB DC XC uB", "322": "IB JB KB", "1028": "LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB" }, G: { "1": "lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "2": "1B YC EC ZC", "33": "E cC dC eC fC gC hC iC jC kC", "2084": "aC bC" }, H: { "2": "sC" }, I: { "1": "H", "2": "wB I tC uC vC wC EC xC yC" }, J: { "2": "D A" }, K: { "1": "k", "2": "A B C tB DC uB" }, L: { "1": "H" }, M: { "1": "i" }, N: { "2": "A B" }, O: { "1028": "zC" }, P: { "1": "j 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD", "2": "I 0C" }, Q: { "1028": "3B" }, R: { "1": "DD" }, S: { "1": "FD", "516": "ED" } }, B: 5, C: "CSS position:sticky" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/pointer.js
var require_pointer = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/pointer.js"(exports3, module2) {
    module2.exports = { A: { A: { "1": "B", "2": "J D E F FC", "164": "A" }, B: { "1": "C K L G M N O P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x" }, C: { "1": "xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "GC wB I y HC IC", "8": "0 1 2 3 4 5 6 7 8 9 J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB", "328": "KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB" }, D: { "1": "YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "2": "0 I y J D E F A B C K L G M N O z j", "8": "1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB", "584": "VB WB XB" }, E: { "1": "K L G 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC", "2": "I y J LC 1B MC", "8": "D E F A B C NC OC PC 2B tB", "1096": "uB" }, F: { "1": "LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h", "2": "F B C TC UC VC WC tB DC XC uB", "8": "0 1 2 3 4 5 6 7 8 9 G M N O z j AB BB CB DB EB FB GB HB", "584": "IB JB KB" }, G: { "1": "mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "8": "E 1B YC EC ZC aC bC cC dC eC fC gC hC iC jC kC", "6148": "lC" }, H: { "2": "sC" }, I: { "1": "H", "8": "wB I tC uC vC wC EC xC yC" }, J: { "8": "D A" }, K: { "1": "k", "2": "A", "8": "B C tB DC uB" }, L: { "1": "H" }, M: { "1": "i" }, N: { "1": "B", "36": "A" }, O: { "1": "zC" }, P: { "1": "j 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD", "2": "0C", "8": "I" }, Q: { "1": "3B" }, R: { "1": "DD" }, S: { "1": "FD", "328": "ED" } }, B: 2, C: "Pointer events" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/text-decoration.js
var require_text_decoration2 = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/text-decoration.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D E F A B FC" }, B: { "2": "C K L G M N O", "2052": "P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x" }, C: { "2": "GC wB I y HC IC", "1028": "FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "1060": "0 1 2 3 4 5 6 7 8 9 J D E F A B C K L G M N O z j AB BB CB DB EB" }, D: { "2": "0 1 2 3 4 I y J D E F A B C K L G M N O z j", "226": "5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB", "2052": "aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC" }, E: { "2": "I y J D LC 1B MC NC", "772": "K L G uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC", "804": "E F A B C PC 2B tB", "1316": "OC" }, F: { "2": "0 1 2 3 4 5 6 7 8 9 F B C G M N O z j AB BB CB DB TC UC VC WC tB DC XC uB", "226": "EB FB GB HB IB JB KB LB MB", "2052": "NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h" }, G: { "2": "1B YC EC ZC aC bC", "292": "E cC dC eC fC gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC" }, H: { "2": "sC" }, I: { "1": "H", "2": "wB I tC uC vC wC EC xC yC" }, J: { "2": "D A" }, K: { "2": "A B C tB DC uB", "2052": "k" }, L: { "2052": "H" }, M: { "1028": "i" }, N: { "2": "A B" }, O: { "2052": "zC" }, P: { "2": "I 0C 1C", "2052": "j 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD" }, Q: { "2052": "3B" }, R: { "2052": "DD" }, S: { "1028": "ED FD" } }, B: 4, C: "text-decoration styling" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/mdn-text-decoration-shorthand.js
var require_mdn_text_decoration_shorthand = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/mdn-text-decoration-shorthand.js"(exports3, module2) {
    module2.exports = { A: { D: { "1": "aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "2": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB" }, L: { "1": "H" }, B: { "1": "P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x", "2": "C K L G M N O" }, C: { "1": "0 1 2 3 4 5 6 7 8 9 J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "GC wB I y HC IC" }, M: { "1": "i" }, A: { "2": "J D E F A B FC" }, F: { "1": "NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h", "2": "0 1 2 3 4 5 6 7 8 9 F B C G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB TC UC VC WC tB DC XC uB" }, K: { "1": "k", "2": "A B C tB DC uB" }, E: { "2": "I y J D LC 1B MC NC OC SC", "33": "E F A B C K L G PC 2B tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC" }, G: { "2": "1B YC EC ZC aC bC", "33": "E cC dC eC fC gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC" }, P: { "1": "j 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD", "2": "I 0C 1C" }, I: { "1": "H", "2": "wB I tC uC vC wC EC xC yC" } }, B: 6, C: "text-decoration shorthand property" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/mdn-text-decoration-color.js
var require_mdn_text_decoration_color = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/mdn-text-decoration-color.js"(exports3, module2) {
    module2.exports = { A: { D: { "1": "aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "2": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB" }, L: { "1": "H" }, B: { "1": "P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x", "2": "C K L G M N O" }, C: { "1": "FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "GC wB I y HC IC", "33": "0 1 2 3 4 5 6 7 8 9 J D E F A B C K L G M N O z j AB BB CB DB EB" }, M: { "1": "i" }, A: { "2": "J D E F A B FC" }, F: { "1": "NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h", "2": "0 1 2 3 4 5 6 7 8 9 F B C G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB TC UC VC WC tB DC XC uB" }, K: { "1": "k", "2": "A B C tB DC uB" }, E: { "1": "K L G uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC", "2": "I y J D LC 1B MC NC OC SC", "33": "E F A B C PC 2B tB" }, G: { "1": "kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "2": "1B YC EC ZC aC bC", "33": "E cC dC eC fC gC hC iC jC" }, P: { "1": "j 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD", "2": "I 0C 1C" }, I: { "1": "H", "2": "wB I tC uC vC wC EC xC yC" } }, B: 6, C: "text-decoration-color property" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/mdn-text-decoration-line.js
var require_mdn_text_decoration_line = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/mdn-text-decoration-line.js"(exports3, module2) {
    module2.exports = { A: { D: { "1": "aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "2": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB" }, L: { "1": "H" }, B: { "1": "P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x", "2": "C K L G M N O" }, C: { "1": "FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "GC wB I y HC IC", "33": "0 1 2 3 4 5 6 7 8 9 J D E F A B C K L G M N O z j AB BB CB DB EB" }, M: { "1": "i" }, A: { "2": "J D E F A B FC" }, F: { "1": "NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h", "2": "0 1 2 3 4 5 6 7 8 9 F B C G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB TC UC VC WC tB DC XC uB" }, K: { "1": "k", "2": "A B C tB DC uB" }, E: { "1": "K L G uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC", "2": "I y J D LC 1B MC NC OC SC", "33": "E F A B C PC 2B tB" }, G: { "1": "kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "2": "1B YC EC ZC aC bC", "33": "E cC dC eC fC gC hC iC jC" }, P: { "1": "j 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD", "2": "I 0C 1C" }, I: { "1": "H", "2": "wB I tC uC vC wC EC xC yC" } }, B: 6, C: "text-decoration-line property" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/mdn-text-decoration-style.js
var require_mdn_text_decoration_style = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/mdn-text-decoration-style.js"(exports3, module2) {
    module2.exports = { A: { D: { "1": "aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "2": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB" }, L: { "1": "H" }, B: { "1": "P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x", "2": "C K L G M N O" }, C: { "1": "FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "GC wB I y HC IC", "33": "0 1 2 3 4 5 6 7 8 9 J D E F A B C K L G M N O z j AB BB CB DB EB" }, M: { "1": "i" }, A: { "2": "J D E F A B FC" }, F: { "1": "NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h", "2": "0 1 2 3 4 5 6 7 8 9 F B C G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB TC UC VC WC tB DC XC uB" }, K: { "1": "k", "2": "A B C tB DC uB" }, E: { "1": "K L G uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC", "2": "I y J D LC 1B MC NC OC SC", "33": "E F A B C PC 2B tB" }, G: { "1": "kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "2": "1B YC EC ZC aC bC", "33": "E cC dC eC fC gC hC iC jC" }, P: { "1": "j 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD", "2": "I 0C 1C" }, I: { "1": "H", "2": "wB I tC uC vC wC EC xC yC" } }, B: 6, C: "text-decoration-style property" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/text-size-adjust.js
var require_text_size_adjust = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/text-size-adjust.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D E F A B FC" }, B: { "1": "P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x", "33": "C K L G M N O" }, C: { "2": "0 1 2 3 4 5 6 7 8 9 GC wB I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B HC IC" }, D: { "1": "XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "2": "0 1 2 3 4 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB", "258": "5" }, E: { "2": "I y J D E F A B C K L G LC 1B NC OC PC 2B tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC", "258": "MC" }, F: { "1": "MB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h", "2": "0 1 2 3 4 5 6 7 8 9 F B C G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB NB TC UC VC WC tB DC XC uB" }, G: { "2": "1B YC EC", "33": "E ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC" }, H: { "2": "sC" }, I: { "1": "H", "2": "wB I tC uC vC wC EC xC yC" }, J: { "2": "D A" }, K: { "1": "k", "2": "A B C tB DC uB" }, L: { "1": "H" }, M: { "33": "i" }, N: { "161": "A B" }, O: { "1": "zC" }, P: { "1": "j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD", "2": "I" }, Q: { "1": "3B" }, R: { "1": "DD" }, S: { "2": "ED FD" } }, B: 7, C: "CSS text-size-adjust" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-masks.js
var require_css_masks = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-masks.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D E F A B FC" }, B: { "2": "C K L G M", "164": "P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x", "3138": "N", "12292": "O" }, C: { "1": "WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "GC wB", "260": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB HC IC" }, D: { "164": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC" }, E: { "1": "5B 6B 7B vB 8B 9B AC BC CC SC", "2": "LC 1B", "164": "I y J D E F A B C K L G MC NC OC PC 2B tB uB 3B QC RC 4B" }, F: { "2": "F B C TC UC VC WC tB DC XC uB", "164": "0 1 2 3 4 5 6 7 8 9 G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h" }, G: { "1": "5B 6B 7B vB 8B 9B AC BC CC", "164": "E 1B YC EC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC oC pC qC rC 4B" }, H: { "2": "sC" }, I: { "164": "H xC yC", "676": "wB I tC uC vC wC EC" }, J: { "164": "D A" }, K: { "2": "A B C tB DC uB", "164": "k" }, L: { "164": "H" }, M: { "1": "i" }, N: { "2": "A B" }, O: { "164": "zC" }, P: { "164": "I j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD" }, Q: { "164": "3B" }, R: { "164": "DD" }, S: { "1": "FD", "260": "ED" } }, B: 4, C: "CSS Masks" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-clip-path.js
var require_css_clip_path = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-clip-path.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D E F A B FC" }, B: { "2": "C K L G M N", "260": "P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x", "3138": "O" }, C: { "1": "XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "GC wB", "132": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB HC IC", "644": "QB RB SB TB UB VB WB" }, D: { "2": "0 1 2 I y J D E F A B C K L G M N O z j", "260": "YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "292": "3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB" }, E: { "2": "I y J LC 1B MC NC", "260": "L G 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC", "292": "D E F A B C K OC PC 2B tB uB" }, F: { "2": "F B C TC UC VC WC tB DC XC uB", "260": "LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h", "292": "0 1 2 3 4 5 6 7 8 9 G M N O z j AB BB CB DB EB FB GB HB IB JB KB" }, G: { "2": "1B YC EC ZC aC", "260": "lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "292": "E bC cC dC eC fC gC hC iC jC kC" }, H: { "2": "sC" }, I: { "2": "wB I tC uC vC wC EC", "260": "H", "292": "xC yC" }, J: { "2": "D A" }, K: { "2": "A B C tB DC uB", "260": "k" }, L: { "260": "H" }, M: { "1": "i" }, N: { "2": "A B" }, O: { "260": "zC" }, P: { "292": "I j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD" }, Q: { "260": "3B" }, R: { "260": "DD" }, S: { "1": "FD", "644": "ED" } }, B: 4, C: "CSS clip-path property (for HTML)" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-boxdecorationbreak.js
var require_css_boxdecorationbreak = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-boxdecorationbreak.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D E F A B FC" }, B: { "2": "C K L G M N O", "164": "P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x" }, C: { "1": "BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "0 1 2 3 4 5 6 7 8 9 GC wB I y J D E F A B C K L G M N O z j AB HC IC" }, D: { "2": "0 I y J D E F A B C K L G M N O z j", "164": "1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC" }, E: { "2": "I y J LC 1B MC", "164": "D E F A B C K L G NC OC PC 2B tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC" }, F: { "2": "F TC UC VC WC", "129": "B C tB DC XC uB", "164": "0 1 2 3 4 5 6 7 8 9 G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h" }, G: { "2": "1B YC EC ZC aC", "164": "E bC cC dC eC fC gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC" }, H: { "132": "sC" }, I: { "2": "wB I tC uC vC wC EC", "164": "H xC yC" }, J: { "2": "D", "164": "A" }, K: { "2": "A", "129": "B C tB DC uB", "164": "k" }, L: { "164": "H" }, M: { "1": "i" }, N: { "2": "A B" }, O: { "164": "zC" }, P: { "164": "I j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD" }, Q: { "164": "3B" }, R: { "164": "DD" }, S: { "1": "ED FD" } }, B: 4, C: "CSS box-decoration-break" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/object-fit.js
var require_object_fit = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/object-fit.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D E F A B FC" }, B: { "1": "P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x", "2": "C K L G", "260": "M N O" }, C: { "1": "FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "0 1 2 3 4 5 6 7 8 9 GC wB I y J D E F A B C K L G M N O z j AB BB CB DB EB HC IC" }, D: { "1": "BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "2": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB" }, E: { "1": "A B C K L G 2B tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC", "2": "I y J D LC 1B MC NC", "132": "E F OC PC" }, F: { "1": "0 1 2 3 4 5 6 7 8 9 z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h", "2": "F G M N O TC UC VC", "33": "B C WC tB DC XC uB" }, G: { "1": "fC gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "2": "1B YC EC ZC aC bC", "132": "E cC dC eC" }, H: { "33": "sC" }, I: { "1": "H yC", "2": "wB I tC uC vC wC EC xC" }, J: { "2": "D A" }, K: { "1": "k", "2": "A", "33": "B C tB DC uB" }, L: { "1": "H" }, M: { "1": "i" }, N: { "2": "A B" }, O: { "1": "zC" }, P: { "1": "I j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD" }, Q: { "1": "3B" }, R: { "1": "DD" }, S: { "1": "ED FD" } }, B: 4, C: "CSS3 object-fit/object-position" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-shapes.js
var require_css_shapes = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-shapes.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D E F A B FC" }, B: { "1": "P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x", "2": "C K L G M N O" }, C: { "1": "dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "0 1 2 3 4 5 6 7 8 9 GC wB I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB HC IC", "322": "UB VB WB XB YB ZB aB bB xB cB yB" }, D: { "1": "GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "2": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB", "194": "DB EB FB" }, E: { "1": "B C K L G 2B tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC", "2": "I y J D LC 1B MC NC", "33": "E F A OC PC" }, F: { "1": "3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h", "2": "0 1 2 F B C G M N O z j TC UC VC WC tB DC XC uB" }, G: { "1": "gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "2": "1B YC EC ZC aC bC", "33": "E cC dC eC fC" }, H: { "2": "sC" }, I: { "1": "H", "2": "wB I tC uC vC wC EC xC yC" }, J: { "2": "D A" }, K: { "1": "k", "2": "A B C tB DC uB" }, L: { "1": "H" }, M: { "1": "i" }, N: { "2": "A B" }, O: { "1": "zC" }, P: { "1": "I j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD" }, Q: { "1": "3B" }, R: { "1": "DD" }, S: { "1": "FD", "2": "ED" } }, B: 4, C: "CSS Shapes Level 1" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/text-overflow.js
var require_text_overflow = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/text-overflow.js"(exports3, module2) {
    module2.exports = { A: { A: { "1": "J D E F A B", "2": "FC" }, B: { "1": "C K L G M N O P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x" }, C: { "1": "0 1 2 3 4 5 6 7 8 9 D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "8": "GC wB I y J HC IC" }, D: { "1": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC" }, E: { "1": "I y J D E F A B C K L G LC 1B MC NC OC PC 2B tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC" }, F: { "1": "0 1 2 3 4 5 6 7 8 9 B C G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h tB DC XC uB", "33": "F TC UC VC WC" }, G: { "1": "E 1B YC EC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC" }, H: { "1": "sC" }, I: { "1": "wB I H tC uC vC wC EC xC yC" }, J: { "1": "D A" }, K: { "1": "k uB", "33": "A B C tB DC" }, L: { "1": "H" }, M: { "1": "i" }, N: { "1": "A B" }, O: { "1": "zC" }, P: { "1": "I j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD" }, Q: { "1": "3B" }, R: { "1": "DD" }, S: { "1": "ED FD" } }, B: 2, C: "CSS3 Text-overflow" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-deviceadaptation.js
var require_css_deviceadaptation = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-deviceadaptation.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D E F FC", "164": "A B" }, B: { "66": "P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x", "164": "C K L G M N O" }, C: { "2": "0 1 2 3 4 5 6 7 8 9 GC wB I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B HC IC" }, D: { "2": "0 1 2 3 4 5 6 7 I y J D E F A B C K L G M N O z j", "66": "8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC" }, E: { "2": "I y J D E F A B C K L G LC 1B MC NC OC PC 2B tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC" }, F: { "2": "0 1 2 3 4 5 6 7 8 9 F B C G M N O z j AB BB CB DB EB FB GB HB IB TC UC VC WC tB DC XC uB", "66": "JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h" }, G: { "2": "E 1B YC EC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC" }, H: { "292": "sC" }, I: { "2": "wB I H tC uC vC wC EC xC yC" }, J: { "2": "D A" }, K: { "2": "A k", "292": "B C tB DC uB" }, L: { "2": "H" }, M: { "2": "i" }, N: { "164": "A B" }, O: { "2": "zC" }, P: { "2": "I j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD" }, Q: { "66": "3B" }, R: { "2": "DD" }, S: { "2": "ED FD" } }, B: 5, C: "CSS Device Adaptation" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-media-resolution.js
var require_css_media_resolution = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-media-resolution.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D E FC", "132": "F A B" }, B: { "1": "P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x", "1028": "C K L G M N O" }, C: { "1": "dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "GC wB", "260": "I y J D E F A B C K L G HC IC", "1028": "0 1 2 3 4 5 6 7 8 9 M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB" }, D: { "1": "jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "548": "0 1 2 3 4 5 6 7 I y J D E F A B C K L G M N O z j", "1028": "8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB" }, E: { "1": "vB 8B 9B AC BC CC SC", "2": "LC 1B", "548": "I y J D E F A B C K L G MC NC OC PC 2B tB uB 3B QC RC 4B 5B 6B 7B" }, F: { "1": "YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h uB", "2": "F", "548": "B C TC UC VC WC tB DC XC", "1028": "0 1 2 3 4 5 6 7 8 9 G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB" }, G: { "1": "vB 8B 9B AC BC CC", "16": "1B", "548": "E YC EC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B" }, H: { "132": "sC" }, I: { "1": "H", "16": "tC uC", "548": "wB I vC wC EC", "1028": "xC yC" }, J: { "548": "D A" }, K: { "1": "k uB", "548": "A B C tB DC" }, L: { "1": "H" }, M: { "1": "i" }, N: { "132": "A B" }, O: { "1": "zC" }, P: { "1": "j 2B 5C 6C 7C 8C 9C vB AD BD CD", "1028": "I 0C 1C 2C 3C 4C" }, Q: { "1": "3B" }, R: { "1": "DD" }, S: { "1": "ED FD" } }, B: 4, C: "Media Queries: resolution feature" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-text-align-last.js
var require_css_text_align_last = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-text-align-last.js"(exports3, module2) {
    module2.exports = { A: { A: { "132": "J D E F A B FC" }, B: { "1": "P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x", "4": "C K L G M N O" }, C: { "1": "SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "GC wB I y J D E F A B HC IC", "33": "0 1 2 3 4 5 6 7 8 9 C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB" }, D: { "1": "QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "2": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB", "322": "EB FB GB HB IB JB KB LB MB NB OB PB" }, E: { "1": "vB 8B 9B AC BC CC SC", "2": "I y J D E F A B C K L G LC 1B MC NC OC PC 2B tB uB 3B QC RC 4B 5B 6B 7B" }, F: { "1": "DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h", "2": "0 F B C G M N O z j TC UC VC WC tB DC XC uB", "578": "1 2 3 4 5 6 7 8 9 AB BB CB" }, G: { "1": "vB 8B 9B AC BC CC", "2": "E 1B YC EC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B" }, H: { "2": "sC" }, I: { "1": "H", "2": "wB I tC uC vC wC EC xC yC" }, J: { "2": "D A" }, K: { "1": "k", "2": "A B C tB DC uB" }, L: { "1": "H" }, M: { "1": "i" }, N: { "132": "A B" }, O: { "1": "zC" }, P: { "1": "j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD", "2": "I" }, Q: { "1": "3B" }, R: { "1": "DD" }, S: { "1": "FD", "33": "ED" } }, B: 4, C: "CSS3 text-align-last" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-crisp-edges.js
var require_css_crisp_edges = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-crisp-edges.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J FC", "2340": "D E F A B" }, B: { "2": "C K L G M N O", "1025": "P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x" }, C: { "1": "c d e f g h l m n o p q r s t u v i w H x 0B", "2": "GC wB HC", "513": "gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b", "545": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB IC" }, D: { "2": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB", "1025": "KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC" }, E: { "1": "A B C K L G 2B tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC", "2": "I y LC 1B MC", "164": "J", "4644": "D E F NC OC PC" }, F: { "2": "0 1 2 3 4 5 6 F B G M N O z j TC UC VC WC tB DC", "545": "C XC uB", "1025": "7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h" }, G: { "1": "fC gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "2": "1B YC EC", "4260": "ZC aC", "4644": "E bC cC dC eC" }, H: { "2": "sC" }, I: { "2": "wB I tC uC vC wC EC xC yC", "1025": "H" }, J: { "2": "D", "4260": "A" }, K: { "2": "A B tB DC", "545": "C uB", "1025": "k" }, L: { "1025": "H" }, M: { "1": "i" }, N: { "2340": "A B" }, O: { "1025": "zC" }, P: { "1025": "I j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD" }, Q: { "1025": "3B" }, R: { "1025": "DD" }, S: { "1": "FD", "4097": "ED" } }, B: 4, C: "Crisp edges/pixelated images" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-logical-props.js
var require_css_logical_props = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-logical-props.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D E F A B FC" }, B: { "1": "Y Z a b c d e f g h l m n o p q r s t u v i w H x", "2": "C K L G M N O", "1028": "W X", "1540": "P Q R S T U V" }, C: { "1": "hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "GC", "164": "0 1 2 3 4 5 6 7 8 9 wB I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB HC IC", "1540": "KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB" }, D: { "1": "Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "292": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB", "1028": "W X", "1540": "kB lB mB nB k oB pB qB rB sB P Q R S T U V" }, E: { "1": "G RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC", "292": "I y J D E F A B C LC 1B MC NC OC PC 2B tB", "1540": "K L uB 3B", "5124": "QC" }, F: { "1": "qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h", "2": "F B C TC UC VC WC tB DC XC uB", "292": "0 1 2 3 4 5 6 7 8 9 G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB", "1028": "oB pB", "1540": "ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k" }, G: { "1": "rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "292": "E 1B YC EC ZC aC bC cC dC eC fC gC hC iC jC", "1540": "kC lC mC nC oC pC", "5124": "qC" }, H: { "2": "sC" }, I: { "1": "H", "292": "wB I tC uC vC wC EC xC yC" }, J: { "292": "D A" }, K: { "1": "k", "2": "A B C tB DC uB" }, L: { "1": "H" }, M: { "1": "i" }, N: { "2": "A B" }, O: { "292": "zC" }, P: { "1": "j 9C vB AD BD CD", "292": "I 0C 1C 2C 3C 4C", "1540": "2B 5C 6C 7C 8C" }, Q: { "1540": "3B" }, R: { "1": "DD" }, S: { "1": "FD", "1540": "ED" } }, B: 5, C: "CSS Logical Properties" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-appearance.js
var require_css_appearance = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-appearance.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D E F A B FC" }, B: { "1": "T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x", "33": "S", "164": "P Q R", "388": "C K L G M N O" }, C: { "1": "Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "164": "EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P", "676": "0 1 2 3 4 5 6 7 8 9 GC wB I y J D E F A B C K L G M N O z j AB BB CB DB HC IC" }, D: { "1": "T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "33": "S", "164": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R" }, E: { "1": "5B 6B 7B vB 8B 9B AC BC CC SC", "164": "I y J D E F A B C K L G LC 1B MC NC OC PC 2B tB uB 3B QC RC 4B" }, F: { "1": "k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h", "2": "F B C TC UC VC WC tB DC XC uB", "33": "lB mB nB", "164": "0 1 2 3 4 5 6 7 8 9 G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB" }, G: { "1": "5B 6B 7B vB 8B 9B AC BC CC", "164": "E 1B YC EC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC oC pC qC rC 4B" }, H: { "2": "sC" }, I: { "1": "H", "164": "wB I tC uC vC wC EC xC yC" }, J: { "164": "D A" }, K: { "1": "k", "2": "A B C tB DC uB" }, L: { "1": "H" }, M: { "1": "i" }, N: { "2": "A", "388": "B" }, O: { "164": "zC" }, P: { "164": "I j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD" }, Q: { "164": "3B" }, R: { "1": "DD" }, S: { "1": "FD", "164": "ED" } }, B: 5, C: "CSS Appearance" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-snappoints.js
var require_css_snappoints = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-snappoints.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D E F FC", "6308": "A", "6436": "B" }, B: { "1": "P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x", "6436": "C K L G M N O" }, C: { "1": "jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "0 1 2 3 4 5 6 7 8 9 GC wB I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB HC IC", "2052": "IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB" }, D: { "1": "kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "2": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB", "8258": "hB iB jB" }, E: { "1": "B C K L G tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC", "2": "I y J D E LC 1B MC NC OC", "3108": "F A PC 2B" }, F: { "1": "fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h", "2": "0 1 2 3 4 5 6 7 8 9 F B C G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB TC UC VC WC tB DC XC uB", "8258": "XB YB ZB aB bB cB dB eB" }, G: { "1": "hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "2": "E 1B YC EC ZC aC bC cC", "3108": "dC eC fC gC" }, H: { "2": "sC" }, I: { "1": "H", "2": "wB I tC uC vC wC EC xC yC" }, J: { "2": "D A" }, K: { "1": "k", "2": "A B C tB DC uB" }, L: { "1": "H" }, M: { "1": "i" }, N: { "2": "A B" }, O: { "1": "zC" }, P: { "1": "j 2B 5C 6C 7C 8C 9C vB AD BD CD", "2": "I 0C 1C 2C 3C 4C" }, Q: { "1": "3B" }, R: { "1": "DD" }, S: { "1": "FD", "2052": "ED" } }, B: 4, C: "CSS Scroll Snap" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-regions.js
var require_css_regions = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-regions.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D E F FC", "420": "A B" }, B: { "2": "P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x", "420": "C K L G M N O" }, C: { "2": "0 1 2 3 4 5 6 7 8 9 GC wB I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B HC IC" }, D: { "2": "I y J D E F A B C K L EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "36": "G M N O", "66": "0 1 2 3 4 5 6 7 8 9 z j AB BB CB DB" }, E: { "2": "I y J C K L G LC 1B MC tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC", "33": "D E F A B NC OC PC 2B" }, F: { "2": "0 1 2 3 4 5 6 7 8 9 F B C G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h TC UC VC WC tB DC XC uB" }, G: { "2": "1B YC EC ZC aC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "33": "E bC cC dC eC fC gC hC" }, H: { "2": "sC" }, I: { "2": "wB I H tC uC vC wC EC xC yC" }, J: { "2": "D A" }, K: { "2": "A B C k tB DC uB" }, L: { "2": "H" }, M: { "2": "i" }, N: { "420": "A B" }, O: { "2": "zC" }, P: { "2": "I j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD" }, Q: { "2": "3B" }, R: { "2": "DD" }, S: { "2": "ED FD" } }, B: 5, C: "CSS Regions" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-image-set.js
var require_css_image_set = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-image-set.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D E F A B FC" }, B: { "2": "C K L G M N O", "164": "P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H", "2049": "x" }, C: { "1": "x 0B", "2": "0 1 2 3 4 5 6 7 8 9 GC wB I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U HC IC", "66": "V W", "2305": "Y Z a b c d e f g h l m n o p q r s t u v i w H", "2820": "X" }, D: { "1": "0B JC KC", "2": "I y J D E F A B C K L G M N O z j", "164": "0 1 2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H", "2049": "x" }, E: { "1": "SC", "2": "I y LC 1B MC", "132": "A B C K 2B tB uB 3B", "164": "J D E F NC OC PC", "1540": "L G QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC" }, F: { "2": "F B C TC UC VC WC tB DC XC uB", "164": "0 1 2 3 4 5 6 7 8 9 G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h" }, G: { "2": "1B YC EC ZC", "132": "fC gC hC iC jC kC lC mC nC oC", "164": "E aC bC cC dC eC", "1540": "pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC" }, H: { "2": "sC" }, I: { "2": "wB I tC uC vC wC EC", "164": "H xC yC" }, J: { "2": "D", "164": "A" }, K: { "2": "A B C tB DC uB", "164": "k" }, L: { "164": "H" }, M: { "2305": "i" }, N: { "2": "A B" }, O: { "164": "zC" }, P: { "164": "I j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD" }, Q: { "164": "3B" }, R: { "164": "DD" }, S: { "2": "ED FD" } }, B: 5, C: "CSS image-set" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-writing-mode.js
var require_css_writing_mode = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-writing-mode.js"(exports3, module2) {
    module2.exports = { A: { A: { "132": "J D E F A B FC" }, B: { "1": "C K L G M N O P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x" }, C: { "1": "KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "0 1 2 3 4 5 6 7 8 9 GC wB I y J D E F A B C K L G M N O z j AB BB CB DB EB HC IC", "322": "FB GB HB IB JB" }, D: { "1": "RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "2": "I y J", "16": "D", "33": "0 1 2 3 4 5 6 7 8 9 E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB" }, E: { "1": "B C K L G tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC", "2": "I LC 1B", "16": "y", "33": "J D E F A MC NC OC PC 2B" }, F: { "1": "EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h", "2": "F B C TC UC VC WC tB DC XC uB", "33": "0 1 2 3 4 5 6 7 8 9 G M N O z j AB BB CB DB" }, G: { "1": "hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "16": "1B YC EC", "33": "E ZC aC bC cC dC eC fC gC" }, H: { "2": "sC" }, I: { "1": "H", "2": "tC uC vC", "33": "wB I wC EC xC yC" }, J: { "33": "D A" }, K: { "1": "k", "2": "A B C tB DC uB" }, L: { "1": "H" }, M: { "1": "i" }, N: { "36": "A B" }, O: { "1": "zC" }, P: { "1": "j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD", "33": "I" }, Q: { "1": "3B" }, R: { "1": "DD" }, S: { "1": "ED FD" } }, B: 2, C: "CSS writing-mode property" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-cross-fade.js
var require_css_cross_fade = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-cross-fade.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D E F A B FC" }, B: { "2": "C K L G M N O", "33": "P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x" }, C: { "2": "0 1 2 3 4 5 6 7 8 9 GC wB I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B HC IC" }, D: { "2": "I y J D E F A B C K L G M", "33": "0 1 2 3 4 5 6 7 8 9 N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC" }, E: { "1": "A B C K L G 2B tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC", "2": "I y LC 1B", "33": "J D E F MC NC OC PC" }, F: { "2": "F B C TC UC VC WC tB DC XC uB", "33": "0 1 2 3 4 5 6 7 8 9 G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h" }, G: { "1": "fC gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "2": "1B YC EC", "33": "E ZC aC bC cC dC eC" }, H: { "2": "sC" }, I: { "2": "wB I tC uC vC wC EC", "33": "H xC yC" }, J: { "2": "D A" }, K: { "2": "A B C tB DC uB", "33": "k" }, L: { "33": "H" }, M: { "2": "i" }, N: { "2": "A B" }, O: { "33": "zC" }, P: { "33": "I j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD" }, Q: { "33": "3B" }, R: { "33": "DD" }, S: { "2": "ED FD" } }, B: 4, C: "CSS Cross-Fade Function" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-read-only-write.js
var require_css_read_only_write = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-read-only-write.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D E F A B FC" }, B: { "1": "K L G M N O P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x", "2": "C" }, C: { "1": "sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "16": "GC", "33": "0 1 2 3 4 5 6 7 8 9 wB I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB HC IC" }, D: { "1": "FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "16": "I y J D E F A B C K L", "132": "0 1 2 3 4 5 6 7 8 9 G M N O z j AB BB CB DB EB" }, E: { "1": "F A B C K L G PC 2B tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC", "16": "LC 1B", "132": "I y J D E MC NC OC" }, F: { "1": "2 3 4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h", "16": "F B TC UC VC WC tB", "132": "0 1 C G M N O z j DC XC uB" }, G: { "1": "dC eC fC gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "16": "1B YC", "132": "E EC ZC aC bC cC" }, H: { "2": "sC" }, I: { "1": "H", "16": "tC uC", "132": "wB I vC wC EC xC yC" }, J: { "1": "A", "132": "D" }, K: { "1": "k", "2": "A B tB", "132": "C DC uB" }, L: { "1": "H" }, M: { "1": "i" }, N: { "2": "A B" }, O: { "1": "zC" }, P: { "1": "I j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD" }, Q: { "1": "3B" }, R: { "1": "DD" }, S: { "1": "FD", "33": "ED" } }, B: 1, C: "CSS :read-only and :read-write selectors" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/text-emphasis.js
var require_text_emphasis = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/text-emphasis.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D E F A B FC" }, B: { "1": "l m n o p q r s t u v i w H x", "2": "C K L G M N O", "164": "P Q R S T U V W X Y Z a b c d e f g h" }, C: { "1": "PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "0 1 2 3 4 5 6 7 8 9 GC wB I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB HC IC", "322": "OB" }, D: { "1": "l m n o p q r s t u v i w H x 0B JC KC", "2": "0 1 2 3 I y J D E F A B C K L G M N O z j", "164": "4 5 6 7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h" }, E: { "1": "E F A B C K L G OC PC 2B tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC", "2": "I y J LC 1B MC", "164": "D NC" }, F: { "1": "V W X Y Z a b c d e f g h", "2": "F B C TC UC VC WC tB DC XC uB", "164": "0 1 2 3 4 5 6 7 8 9 G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U" }, G: { "1": "E bC cC dC eC fC gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "2": "1B YC EC ZC aC" }, H: { "2": "sC" }, I: { "1": "H", "2": "wB I tC uC vC wC EC", "164": "xC yC" }, J: { "2": "D", "164": "A" }, K: { "1": "k", "2": "A B C tB DC uB" }, L: { "1": "H" }, M: { "1": "i" }, N: { "2": "A B" }, O: { "164": "zC" }, P: { "1": "j BD CD", "164": "I 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD" }, Q: { "164": "3B" }, R: { "164": "DD" }, S: { "1": "ED FD" } }, B: 4, C: "text-emphasis styling" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-grid.js
var require_css_grid = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-grid.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D E FC", "8": "F", "292": "A B" }, B: { "1": "M N O P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x", "292": "C K L G" }, C: { "1": "XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "GC wB I y J D E F A B C K L G M N O HC IC", "8": "0 1 2 3 4 5 6 7 8 9 z j AB BB CB DB EB FB GB HB IB", "584": "JB KB LB MB NB OB PB QB RB SB TB UB", "1025": "VB WB" }, D: { "1": "bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "2": "0 1 2 3 I y J D E F A B C K L G M N O z j", "8": "4 5 6 7", "200": "8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB", "1025": "aB" }, E: { "1": "B C K L G 2B tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC", "2": "I y LC 1B MC", "8": "J D E F A NC OC PC" }, F: { "1": "NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h", "2": "0 1 2 3 4 5 6 F B C G M N O z j TC UC VC WC tB DC XC uB", "200": "7 8 9 AB BB CB DB EB FB GB HB IB JB KB LB MB" }, G: { "1": "gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "2": "1B YC EC ZC", "8": "E aC bC cC dC eC fC" }, H: { "2": "sC" }, I: { "1": "H", "2": "wB I tC uC vC wC", "8": "EC xC yC" }, J: { "2": "D A" }, K: { "1": "k", "2": "A B C tB DC uB" }, L: { "1": "H" }, M: { "1": "i" }, N: { "292": "A B" }, O: { "1": "zC" }, P: { "1": "j 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD", "2": "0C", "8": "I" }, Q: { "1": "3B" }, R: { "1": "DD" }, S: { "1": "ED FD" } }, B: 4, C: "CSS Grid Layout (level 1)" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-text-spacing.js
var require_css_text_spacing = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-text-spacing.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D FC", "161": "E F A B" }, B: { "2": "P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x", "161": "C K L G M N O" }, C: { "2": "0 1 2 3 4 5 6 7 8 9 GC wB I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B HC IC" }, D: { "2": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC" }, E: { "2": "I y J D E F A B C K L G LC 1B MC NC OC PC 2B tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC" }, F: { "2": "0 1 2 3 4 5 6 7 8 9 F B C G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h TC UC VC WC tB DC XC uB" }, G: { "2": "E 1B YC EC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC" }, H: { "2": "sC" }, I: { "2": "wB I H tC uC vC wC EC xC yC" }, J: { "2": "D A" }, K: { "2": "A B C k tB DC uB" }, L: { "2": "H" }, M: { "2": "i" }, N: { "16": "A B" }, O: { "2": "zC" }, P: { "2": "I j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD" }, Q: { "2": "3B" }, R: { "2": "DD" }, S: { "2": "ED FD" } }, B: 5, C: "CSS Text 4 text-spacing" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-any-link.js
var require_css_any_link = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-any-link.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D E F A B FC" }, B: { "1": "P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x", "2": "C K L G M N O" }, C: { "1": "TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "16": "GC", "33": "0 1 2 3 4 5 6 7 8 9 wB I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB HC IC" }, D: { "1": "gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "16": "I y J D E F A B C K L", "33": "0 1 2 3 4 5 6 7 8 9 G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB" }, E: { "1": "F A B C K L G PC 2B tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC", "16": "I y J LC 1B MC", "33": "D E NC OC" }, F: { "1": "VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h", "2": "F B C TC UC VC WC tB DC XC uB", "33": "0 1 2 3 4 5 6 7 8 9 G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB" }, G: { "1": "dC eC fC gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "16": "1B YC EC ZC", "33": "E aC bC cC" }, H: { "2": "sC" }, I: { "1": "H", "16": "wB I tC uC vC wC EC", "33": "xC yC" }, J: { "16": "D A" }, K: { "1": "k", "2": "A B C tB DC uB" }, L: { "1": "H" }, M: { "1": "i" }, N: { "2": "A B" }, O: { "1": "zC" }, P: { "1": "j 4C 2B 5C 6C 7C 8C 9C vB AD BD CD", "16": "I", "33": "0C 1C 2C 3C" }, Q: { "1": "3B" }, R: { "1": "DD" }, S: { "1": "FD", "33": "ED" } }, B: 5, C: "CSS :any-link selector" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/mdn-css-unicode-bidi-isolate.js
var require_mdn_css_unicode_bidi_isolate = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/mdn-css-unicode-bidi-isolate.js"(exports3, module2) {
    module2.exports = { A: { D: { "1": "RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "2": "I y J D E F A B C K L G", "33": "0 1 2 3 4 5 6 7 8 9 M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB" }, L: { "1": "H" }, B: { "1": "P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x", "2": "C K L G M N O" }, C: { "1": "TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "GC wB I y J D E F HC IC", "33": "0 1 2 3 4 5 6 7 8 9 A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB" }, M: { "1": "i" }, A: { "2": "J D E F A B FC" }, F: { "1": "EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h", "2": "F B C TC UC VC WC tB DC XC uB", "33": "0 1 2 3 4 5 6 7 8 9 G M N O z j AB BB CB DB" }, K: { "1": "k", "2": "A B C tB DC uB" }, E: { "1": "B C K L G tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC", "2": "I y LC 1B MC SC", "33": "J D E F A NC OC PC 2B" }, G: { "1": "hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "2": "1B YC EC ZC", "33": "E aC bC cC dC eC fC gC" }, P: { "1": "j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD", "2": "I" }, I: { "1": "H", "2": "wB I tC uC vC wC EC xC yC" } }, B: 6, C: "isolate from unicode-bidi" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/mdn-css-unicode-bidi-plaintext.js
var require_mdn_css_unicode_bidi_plaintext = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/mdn-css-unicode-bidi-plaintext.js"(exports3, module2) {
    module2.exports = { A: { D: { "1": "RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "2": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB" }, L: { "1": "H" }, B: { "1": "P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x", "2": "C K L G M N O" }, C: { "1": "TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "GC wB I y J D E F HC IC", "33": "0 1 2 3 4 5 6 7 8 9 A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB" }, M: { "1": "i" }, A: { "2": "J D E F A B FC" }, F: { "1": "EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h", "2": "0 1 2 3 4 5 6 7 8 9 F B C G M N O z j AB BB CB DB TC UC VC WC tB DC XC uB" }, K: { "1": "k", "2": "A B C tB DC uB" }, E: { "1": "B C K L G tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC", "2": "I y LC 1B MC SC", "33": "J D E F A NC OC PC 2B" }, G: { "1": "hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "2": "1B YC EC ZC", "33": "E aC bC cC dC eC fC gC" }, P: { "1": "j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD", "2": "I" }, I: { "1": "H", "2": "wB I tC uC vC wC EC xC yC" } }, B: 6, C: "plaintext from unicode-bidi" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/mdn-css-unicode-bidi-isolate-override.js
var require_mdn_css_unicode_bidi_isolate_override = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/mdn-css-unicode-bidi-isolate-override.js"(exports3, module2) {
    module2.exports = { A: { D: { "1": "RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "2": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB" }, L: { "1": "H" }, B: { "1": "P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x", "2": "C K L G M N O" }, C: { "1": "TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "GC wB I y J D E F A B C K L G M HC IC", "33": "0 1 2 3 4 5 6 7 8 9 N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB" }, M: { "1": "i" }, A: { "2": "J D E F A B FC" }, F: { "1": "EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h", "2": "0 1 2 3 4 5 6 7 8 9 F B C G M N O z j AB BB CB DB TC UC VC WC tB DC XC uB" }, K: { "1": "k", "2": "A B C tB DC uB" }, E: { "1": "B C K L G tB uB 3B QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC", "2": "I y J LC 1B MC NC SC", "33": "D E F A OC PC 2B" }, G: { "1": "hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "2": "1B YC EC ZC aC", "33": "E bC cC dC eC fC gC" }, P: { "1": "j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD", "2": "I" }, I: { "1": "H", "2": "wB I tC uC vC wC EC xC yC" } }, B: 6, C: "isolate-override from unicode-bidi" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-overscroll-behavior.js
var require_css_overscroll_behavior = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-overscroll-behavior.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D E F FC", "132": "A B" }, B: { "1": "P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x", "132": "C K L G M N", "516": "O" }, C: { "1": "xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "0 1 2 3 4 5 6 7 8 9 GC wB I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB HC IC" }, D: { "1": "gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "2": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB", "260": "eB fB" }, E: { "1": "vB 8B 9B AC BC CC SC", "2": "I y J D E F A B C K L LC 1B MC NC OC PC 2B tB uB 3B", "1090": "G QC RC 4B 5B 6B 7B" }, F: { "1": "VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h", "2": "0 1 2 3 4 5 6 7 8 9 F B C G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TC UC VC WC tB DC XC uB", "260": "TB UB" }, G: { "1": "vB 8B 9B AC BC CC", "2": "E 1B YC EC ZC aC bC cC dC eC fC gC hC iC jC kC lC mC nC oC pC", "1090": "qC rC 4B 5B 6B 7B" }, H: { "2": "sC" }, I: { "1": "H", "2": "wB I tC uC vC wC EC xC yC" }, J: { "2": "D A" }, K: { "1": "k", "2": "A B C tB DC uB" }, L: { "1": "H" }, M: { "1": "i" }, N: { "132": "A B" }, O: { "1": "zC" }, P: { "1": "j 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD", "2": "I 0C 1C 2C" }, Q: { "1": "3B" }, R: { "1": "DD" }, S: { "1": "FD", "2": "ED" } }, B: 5, C: "CSS overscroll-behavior" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-text-orientation.js
var require_css_text_orientation = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-text-orientation.js"(exports3, module2) {
    module2.exports = { A: { A: { "2": "J D E F A B FC" }, B: { "1": "P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x", "2": "C K L G M N O" }, C: { "1": "KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B", "2": "0 1 2 3 4 5 6 7 8 9 GC wB I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HC IC", "194": "HB IB JB" }, D: { "1": "RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC", "2": "0 1 2 3 4 5 6 7 8 9 I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB" }, E: { "1": "L G QC RC 4B 5B 6B 7B vB 8B 9B AC BC CC SC", "2": "I y J D E F LC 1B MC NC OC PC", "16": "A", "33": "B C K 2B tB uB 3B" }, F: { "1": "EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h", "2": "0 1 2 3 4 5 6 7 8 9 F B C G M N O z j AB BB CB DB TC UC VC WC tB DC XC uB" }, G: { "1": "fC gC hC iC jC kC lC mC nC oC pC qC rC 4B 5B 6B 7B vB 8B 9B AC BC CC", "2": "E 1B YC EC ZC aC bC cC dC eC" }, H: { "2": "sC" }, I: { "1": "H", "2": "wB I tC uC vC wC EC xC yC" }, J: { "2": "D A" }, K: { "1": "k", "2": "A B C tB DC uB" }, L: { "1": "H" }, M: { "1": "i" }, N: { "2": "A B" }, O: { "1": "zC" }, P: { "1": "j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD", "2": "I" }, Q: { "1": "3B" }, R: { "1": "DD" }, S: { "1": "ED FD" } }, B: 2, C: "CSS text-orientation" };
  }
});

// node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-print-color-adjust.js
var require_css_print_color_adjust = __commonJS({
  "node_modules/.pnpm/caniuse-lite@1.0.30001485/node_modules/caniuse-lite/data/features/css-print-color-adjust.js"(exports3, module2) {
    module2.exports = { A: { D: { "2": "I y J D E F A B C K L G M", "33": "0 1 2 3 4 5 6 7 8 9 N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x 0B JC KC" }, L: { "33": "H" }, B: { "2": "C K L G M N O", "33": "P Q R S T U V W X Y Z a b c d e f g h l m n o p q r s t u v i w H x" }, C: { "1": "g h l m n o p q r s t u v i w H x 0B", "2": "0 1 2 3 4 5 6 7 8 9 GC wB I y J D E F A B C K L G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB HC IC", "33": "RB SB TB UB VB WB XB YB ZB aB bB xB cB yB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f" }, M: { "1": "i" }, A: { "2": "J D E F A B FC" }, F: { "2": "F B C TC UC VC WC tB DC XC uB", "33": "0 1 2 3 4 5 6 7 8 9 G M N O z j AB BB CB DB EB FB GB HB IB JB KB LB MB NB OB PB QB RB SB TB UB VB WB XB YB ZB aB bB cB dB eB fB gB hB iB jB kB lB mB nB k oB pB qB rB sB P Q R zB S T U V W X Y Z a b c d e f g h" }, K: { "2": "A B C tB DC uB", "33": "k" }, E: { "1": "5B 6B 7B vB 8B 9B AC BC CC", "2": "I y LC 1B MC SC", "33": "J D E F A B C K L G NC OC PC 2B tB uB 3B QC RC 4B" }, G: { "1": "5B 6B 7B vB 8B 9B AC BC CC", "2": "1B YC EC ZC", "33": "E aC bC cC dC eC fC gC hC iC jC kC lC mC nC oC pC qC rC 4B" }, P: { "33": "I j 0C 1C 2C 3C 4C 2B 5C 6C 7C 8C 9C vB AD BD CD" }, I: { "2": "wB I tC uC vC wC EC", "33": "H xC yC" } }, B: 6, C: "print-color-adjust property" };
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/data/prefixes.js
var require_prefixes2 = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/data/prefixes.js"(exports3, module2) {
    var unpack = require_feature();
    function browsersSort(a2, b) {
      a2 = a2.split(" ");
      b = b.split(" ");
      if (a2[0] > b[0]) {
        return 1;
      } else if (a2[0] < b[0]) {
        return -1;
      } else {
        return Math.sign(parseFloat(a2[1]) - parseFloat(b[1]));
      }
    }
    function f2(data2, opts, callback) {
      data2 = unpack(data2);
      if (!callback) {
        ;
        [callback, opts] = [opts, {}];
      }
      let match = opts.match || /\sx($|\s)/;
      let need = [];
      for (let browser3 in data2.stats) {
        let versions = data2.stats[browser3];
        for (let version4 in versions) {
          let support = versions[version4];
          if (support.match(match)) {
            need.push(browser3 + " " + version4);
          }
        }
      }
      callback(need.sort(browsersSort));
    }
    var result = {};
    function prefix(names, data2) {
      for (let name2 of names) {
        result[name2] = Object.assign({}, data2);
      }
    }
    function add(names, data2) {
      for (let name2 of names) {
        result[name2].browsers = result[name2].browsers.concat(data2.browsers).sort(browsersSort);
      }
    }
    module2.exports = result;
    var prefixBorderRadius = require_border_radius2();
    f2(
      prefixBorderRadius,
      (browsers) => prefix(
        [
          "border-radius",
          "border-top-left-radius",
          "border-top-right-radius",
          "border-bottom-right-radius",
          "border-bottom-left-radius"
        ],
        {
          mistakes: ["-khtml-", "-ms-", "-o-"],
          feature: "border-radius",
          browsers
        }
      )
    );
    var prefixBoxshadow = require_css_boxshadow();
    f2(
      prefixBoxshadow,
      (browsers) => prefix(["box-shadow"], {
        mistakes: ["-khtml-"],
        feature: "css-boxshadow",
        browsers
      })
    );
    var prefixAnimation = require_css_animation();
    f2(
      prefixAnimation,
      (browsers) => prefix(
        [
          "animation",
          "animation-name",
          "animation-duration",
          "animation-delay",
          "animation-direction",
          "animation-fill-mode",
          "animation-iteration-count",
          "animation-play-state",
          "animation-timing-function",
          "@keyframes"
        ],
        {
          mistakes: ["-khtml-", "-ms-"],
          feature: "css-animation",
          browsers
        }
      )
    );
    var prefixTransition = require_css_transitions();
    f2(
      prefixTransition,
      (browsers) => prefix(
        [
          "transition",
          "transition-property",
          "transition-duration",
          "transition-delay",
          "transition-timing-function"
        ],
        {
          mistakes: ["-khtml-", "-ms-"],
          browsers,
          feature: "css-transitions"
        }
      )
    );
    var prefixTransform2d = require_transforms2d();
    f2(
      prefixTransform2d,
      (browsers) => prefix(["transform", "transform-origin"], {
        feature: "transforms2d",
        browsers
      })
    );
    var prefixTransforms3d = require_transforms3d();
    f2(prefixTransforms3d, (browsers) => {
      prefix(["perspective", "perspective-origin"], {
        feature: "transforms3d",
        browsers
      });
      return prefix(["transform-style"], {
        mistakes: ["-ms-", "-o-"],
        browsers,
        feature: "transforms3d"
      });
    });
    f2(
      prefixTransforms3d,
      { match: /y\sx|y\s#2/ },
      (browsers) => prefix(["backface-visibility"], {
        mistakes: ["-ms-", "-o-"],
        feature: "transforms3d",
        browsers
      })
    );
    var prefixGradients = require_css_gradients();
    f2(
      prefixGradients,
      { match: /y\sx/ },
      (browsers) => prefix(
        [
          "linear-gradient",
          "repeating-linear-gradient",
          "radial-gradient",
          "repeating-radial-gradient"
        ],
        {
          props: [
            "background",
            "background-image",
            "border-image",
            "mask",
            "list-style",
            "list-style-image",
            "content",
            "mask-image"
          ],
          mistakes: ["-ms-"],
          feature: "css-gradients",
          browsers
        }
      )
    );
    f2(prefixGradients, { match: /a\sx/ }, (browsers) => {
      browsers = browsers.map((i2) => {
        if (/firefox|op/.test(i2)) {
          return i2;
        } else {
          return `${i2} old`;
        }
      });
      return add(
        [
          "linear-gradient",
          "repeating-linear-gradient",
          "radial-gradient",
          "repeating-radial-gradient"
        ],
        {
          feature: "css-gradients",
          browsers
        }
      );
    });
    var prefixBoxsizing = require_css3_boxsizing();
    f2(
      prefixBoxsizing,
      (browsers) => prefix(["box-sizing"], {
        feature: "css3-boxsizing",
        browsers
      })
    );
    var prefixFilters = require_css_filters();
    f2(
      prefixFilters,
      (browsers) => prefix(["filter"], {
        feature: "css-filters",
        browsers
      })
    );
    var prefixFilterFunction = require_css_filter_function();
    f2(
      prefixFilterFunction,
      (browsers) => prefix(["filter-function"], {
        props: [
          "background",
          "background-image",
          "border-image",
          "mask",
          "list-style",
          "list-style-image",
          "content",
          "mask-image"
        ],
        feature: "css-filter-function",
        browsers
      })
    );
    var prefixBackdrop = require_css_backdrop_filter();
    f2(
      prefixBackdrop,
      { match: /y\sx|y\s#2/ },
      (browsers) => prefix(["backdrop-filter"], {
        feature: "css-backdrop-filter",
        browsers
      })
    );
    var prefixElementFunction = require_css_element_function();
    f2(
      prefixElementFunction,
      (browsers) => prefix(["element"], {
        props: [
          "background",
          "background-image",
          "border-image",
          "mask",
          "list-style",
          "list-style-image",
          "content",
          "mask-image"
        ],
        feature: "css-element-function",
        browsers
      })
    );
    var prefixMulticolumns = require_multicolumn();
    f2(prefixMulticolumns, (browsers) => {
      prefix(
        [
          "columns",
          "column-width",
          "column-gap",
          "column-rule",
          "column-rule-color",
          "column-rule-width",
          "column-count",
          "column-rule-style",
          "column-span",
          "column-fill"
        ],
        {
          feature: "multicolumn",
          browsers
        }
      );
      let noff = browsers.filter((i2) => !/firefox/.test(i2));
      prefix(["break-before", "break-after", "break-inside"], {
        feature: "multicolumn",
        browsers: noff
      });
    });
    var prefixUserSelect = require_user_select_none();
    f2(
      prefixUserSelect,
      (browsers) => prefix(["user-select"], {
        mistakes: ["-khtml-"],
        feature: "user-select-none",
        browsers
      })
    );
    var prefixFlexbox = require_flexbox();
    f2(prefixFlexbox, { match: /a\sx/ }, (browsers) => {
      browsers = browsers.map((i2) => {
        if (/ie|firefox/.test(i2)) {
          return i2;
        } else {
          return `${i2} 2009`;
        }
      });
      prefix(["display-flex", "inline-flex"], {
        props: ["display"],
        feature: "flexbox",
        browsers
      });
      prefix(["flex", "flex-grow", "flex-shrink", "flex-basis"], {
        feature: "flexbox",
        browsers
      });
      prefix(
        [
          "flex-direction",
          "flex-wrap",
          "flex-flow",
          "justify-content",
          "order",
          "align-items",
          "align-self",
          "align-content"
        ],
        {
          feature: "flexbox",
          browsers
        }
      );
    });
    f2(prefixFlexbox, { match: /y\sx/ }, (browsers) => {
      add(["display-flex", "inline-flex"], {
        feature: "flexbox",
        browsers
      });
      add(["flex", "flex-grow", "flex-shrink", "flex-basis"], {
        feature: "flexbox",
        browsers
      });
      add(
        [
          "flex-direction",
          "flex-wrap",
          "flex-flow",
          "justify-content",
          "order",
          "align-items",
          "align-self",
          "align-content"
        ],
        {
          feature: "flexbox",
          browsers
        }
      );
    });
    var prefixCalc = require_calc();
    f2(
      prefixCalc,
      (browsers) => prefix(["calc"], {
        props: ["*"],
        feature: "calc",
        browsers
      })
    );
    var prefixBackgroundOptions = require_background_img_opts();
    f2(
      prefixBackgroundOptions,
      (browsers) => prefix(["background-origin", "background-size"], {
        feature: "background-img-opts",
        browsers
      })
    );
    var prefixBackgroundClipText = require_background_clip_text();
    f2(
      prefixBackgroundClipText,
      (browsers) => prefix(["background-clip"], {
        feature: "background-clip-text",
        browsers
      })
    );
    var prefixFontFeature = require_font_feature();
    f2(
      prefixFontFeature,
      (browsers) => prefix(
        [
          "font-feature-settings",
          "font-variant-ligatures",
          "font-language-override"
        ],
        {
          feature: "font-feature",
          browsers
        }
      )
    );
    var prefixFontKerning = require_font_kerning();
    f2(
      prefixFontKerning,
      (browsers) => prefix(["font-kerning"], {
        feature: "font-kerning",
        browsers
      })
    );
    var prefixBorderImage = require_border_image2();
    f2(
      prefixBorderImage,
      (browsers) => prefix(["border-image"], {
        feature: "border-image",
        browsers
      })
    );
    var prefixSelection = require_css_selection();
    f2(
      prefixSelection,
      (browsers) => prefix(["::selection"], {
        selector: true,
        feature: "css-selection",
        browsers
      })
    );
    var prefixPlaceholder = require_css_placeholder();
    f2(prefixPlaceholder, (browsers) => {
      prefix(["::placeholder"], {
        selector: true,
        feature: "css-placeholder",
        browsers: browsers.concat(["ie 10 old", "ie 11 old", "firefox 18 old"])
      });
    });
    var prefixPlaceholderShown = require_css_placeholder_shown();
    f2(prefixPlaceholderShown, (browsers) => {
      prefix([":placeholder-shown"], {
        selector: true,
        feature: "css-placeholder-shown",
        browsers
      });
    });
    var prefixHyphens = require_css_hyphens();
    f2(
      prefixHyphens,
      (browsers) => prefix(["hyphens"], {
        feature: "css-hyphens",
        browsers
      })
    );
    var prefixFullscreen = require_fullscreen2();
    f2(
      prefixFullscreen,
      (browsers) => prefix([":fullscreen"], {
        selector: true,
        feature: "fullscreen",
        browsers
      })
    );
    f2(
      prefixFullscreen,
      { match: /x(\s#2|$)/ },
      (browsers) => prefix(["::backdrop"], {
        selector: true,
        feature: "fullscreen",
        browsers
      })
    );
    var prefixFileSelectorButton = require_css_file_selector_button();
    f2(
      prefixFileSelectorButton,
      (browsers) => prefix(["::file-selector-button"], {
        selector: true,
        feature: "file-selector-button",
        browsers
      })
    );
    var prefixAutofill = require_css_autofill();
    f2(
      prefixAutofill,
      (browsers) => prefix([":autofill"], {
        selector: true,
        feature: "css-autofill",
        browsers
      })
    );
    var prefixTabsize = require_css3_tabsize();
    f2(
      prefixTabsize,
      (browsers) => prefix(["tab-size"], {
        feature: "css3-tabsize",
        browsers
      })
    );
    var prefixIntrinsic = require_intrinsic_width();
    var sizeProps = [
      "width",
      "min-width",
      "max-width",
      "height",
      "min-height",
      "max-height",
      "inline-size",
      "min-inline-size",
      "max-inline-size",
      "block-size",
      "min-block-size",
      "max-block-size",
      "grid",
      "grid-template",
      "grid-template-rows",
      "grid-template-columns",
      "grid-auto-columns",
      "grid-auto-rows"
    ];
    f2(
      prefixIntrinsic,
      (browsers) => prefix(["max-content", "min-content"], {
        props: sizeProps,
        feature: "intrinsic-width",
        browsers
      })
    );
    f2(
      prefixIntrinsic,
      { match: /x|\s#4/ },
      (browsers) => prefix(["fill", "fill-available"], {
        props: sizeProps,
        feature: "intrinsic-width",
        browsers
      })
    );
    f2(
      prefixIntrinsic,
      { match: /x|\s#5/ },
      (browsers) => prefix(["fit-content"], {
        props: sizeProps,
        feature: "intrinsic-width",
        browsers
      })
    );
    var prefixStretch = require_css_width_stretch();
    f2(
      prefixStretch,
      (browsers) => prefix(["stretch"], {
        props: sizeProps,
        feature: "css-width-stretch",
        browsers
      })
    );
    var prefixCursorsNewer = require_css3_cursors_newer();
    f2(
      prefixCursorsNewer,
      (browsers) => prefix(["zoom-in", "zoom-out"], {
        props: ["cursor"],
        feature: "css3-cursors-newer",
        browsers
      })
    );
    var prefixCursorsGrab = require_css3_cursors_grab();
    f2(
      prefixCursorsGrab,
      (browsers) => prefix(["grab", "grabbing"], {
        props: ["cursor"],
        feature: "css3-cursors-grab",
        browsers
      })
    );
    var prefixSticky = require_css_sticky();
    f2(
      prefixSticky,
      (browsers) => prefix(["sticky"], {
        props: ["position"],
        feature: "css-sticky",
        browsers
      })
    );
    var prefixPointer = require_pointer();
    f2(
      prefixPointer,
      (browsers) => prefix(["touch-action"], {
        feature: "pointer",
        browsers
      })
    );
    var prefixDecoration = require_text_decoration2();
    f2(
      prefixDecoration,
      { match: /x.*#[235]/ },
      (browsers) => prefix(["text-decoration-skip", "text-decoration-skip-ink"], {
        feature: "text-decoration",
        browsers
      })
    );
    var prefixDecorationShorthand = require_mdn_text_decoration_shorthand();
    f2(
      prefixDecorationShorthand,
      (browsers) => prefix(["text-decoration"], {
        feature: "text-decoration",
        browsers
      })
    );
    var prefixDecorationColor = require_mdn_text_decoration_color();
    f2(
      prefixDecorationColor,
      (browsers) => prefix(["text-decoration-color"], {
        feature: "text-decoration",
        browsers
      })
    );
    var prefixDecorationLine = require_mdn_text_decoration_line();
    f2(
      prefixDecorationLine,
      (browsers) => prefix(["text-decoration-line"], {
        feature: "text-decoration",
        browsers
      })
    );
    var prefixDecorationStyle = require_mdn_text_decoration_style();
    f2(
      prefixDecorationStyle,
      (browsers) => prefix(["text-decoration-style"], {
        feature: "text-decoration",
        browsers
      })
    );
    var prefixTextSizeAdjust = require_text_size_adjust();
    f2(
      prefixTextSizeAdjust,
      (browsers) => prefix(["text-size-adjust"], {
        feature: "text-size-adjust",
        browsers
      })
    );
    var prefixCssMasks = require_css_masks();
    f2(prefixCssMasks, (browsers) => {
      prefix(
        [
          "mask-clip",
          "mask-composite",
          "mask-image",
          "mask-origin",
          "mask-repeat",
          "mask-border-repeat",
          "mask-border-source"
        ],
        {
          feature: "css-masks",
          browsers
        }
      );
      prefix(
        [
          "mask",
          "mask-position",
          "mask-size",
          "mask-border",
          "mask-border-outset",
          "mask-border-width",
          "mask-border-slice"
        ],
        {
          feature: "css-masks",
          browsers
        }
      );
    });
    var prefixClipPath = require_css_clip_path();
    f2(
      prefixClipPath,
      (browsers) => prefix(["clip-path"], {
        feature: "css-clip-path",
        browsers
      })
    );
    var prefixBoxdecoration = require_css_boxdecorationbreak();
    f2(
      prefixBoxdecoration,
      (browsers) => prefix(["box-decoration-break"], {
        feature: "css-boxdecorationbreak",
        browsers
      })
    );
    var prefixObjectFit = require_object_fit();
    f2(
      prefixObjectFit,
      (browsers) => prefix(["object-fit", "object-position"], {
        feature: "object-fit",
        browsers
      })
    );
    var prefixShapes = require_css_shapes();
    f2(
      prefixShapes,
      (browsers) => prefix(["shape-margin", "shape-outside", "shape-image-threshold"], {
        feature: "css-shapes",
        browsers
      })
    );
    var prefixTextOverflow = require_text_overflow();
    f2(
      prefixTextOverflow,
      (browsers) => prefix(["text-overflow"], {
        feature: "text-overflow",
        browsers
      })
    );
    var prefixDeviceadaptation = require_css_deviceadaptation();
    f2(
      prefixDeviceadaptation,
      (browsers) => prefix(["@viewport"], {
        feature: "css-deviceadaptation",
        browsers
      })
    );
    var prefixResolut = require_css_media_resolution();
    f2(
      prefixResolut,
      { match: /( x($| )|a #2)/ },
      (browsers) => prefix(["@resolution"], {
        feature: "css-media-resolution",
        browsers
      })
    );
    var prefixTextAlignLast = require_css_text_align_last();
    f2(
      prefixTextAlignLast,
      (browsers) => prefix(["text-align-last"], {
        feature: "css-text-align-last",
        browsers
      })
    );
    var prefixCrispedges = require_css_crisp_edges();
    f2(
      prefixCrispedges,
      { match: /y x|a x #1/ },
      (browsers) => prefix(["pixelated"], {
        props: ["image-rendering"],
        feature: "css-crisp-edges",
        browsers
      })
    );
    f2(
      prefixCrispedges,
      { match: /a x #2/ },
      (browsers) => prefix(["image-rendering"], {
        feature: "css-crisp-edges",
        browsers
      })
    );
    var prefixLogicalProps = require_css_logical_props();
    f2(
      prefixLogicalProps,
      (browsers) => prefix(
        [
          "border-inline-start",
          "border-inline-end",
          "margin-inline-start",
          "margin-inline-end",
          "padding-inline-start",
          "padding-inline-end"
        ],
        {
          feature: "css-logical-props",
          browsers
        }
      )
    );
    f2(
      prefixLogicalProps,
      { match: /x\s#2/ },
      (browsers) => prefix(
        [
          "border-block-start",
          "border-block-end",
          "margin-block-start",
          "margin-block-end",
          "padding-block-start",
          "padding-block-end"
        ],
        {
          feature: "css-logical-props",
          browsers
        }
      )
    );
    var prefixAppearance = require_css_appearance();
    f2(
      prefixAppearance,
      { match: /#2|x/ },
      (browsers) => prefix(["appearance"], {
        feature: "css-appearance",
        browsers
      })
    );
    var prefixSnappoints = require_css_snappoints();
    f2(
      prefixSnappoints,
      (browsers) => prefix(
        [
          "scroll-snap-type",
          "scroll-snap-coordinate",
          "scroll-snap-destination",
          "scroll-snap-points-x",
          "scroll-snap-points-y"
        ],
        {
          feature: "css-snappoints",
          browsers
        }
      )
    );
    var prefixRegions = require_css_regions();
    f2(
      prefixRegions,
      (browsers) => prefix(["flow-into", "flow-from", "region-fragment"], {
        feature: "css-regions",
        browsers
      })
    );
    var prefixImageSet = require_css_image_set();
    f2(
      prefixImageSet,
      (browsers) => prefix(["image-set"], {
        props: [
          "background",
          "background-image",
          "border-image",
          "cursor",
          "mask",
          "mask-image",
          "list-style",
          "list-style-image",
          "content"
        ],
        feature: "css-image-set",
        browsers
      })
    );
    var prefixWritingMode = require_css_writing_mode();
    f2(
      prefixWritingMode,
      { match: /a|x/ },
      (browsers) => prefix(["writing-mode"], {
        feature: "css-writing-mode",
        browsers
      })
    );
    var prefixCrossFade = require_css_cross_fade();
    f2(
      prefixCrossFade,
      (browsers) => prefix(["cross-fade"], {
        props: [
          "background",
          "background-image",
          "border-image",
          "mask",
          "list-style",
          "list-style-image",
          "content",
          "mask-image"
        ],
        feature: "css-cross-fade",
        browsers
      })
    );
    var prefixReadOnly = require_css_read_only_write();
    f2(
      prefixReadOnly,
      (browsers) => prefix([":read-only", ":read-write"], {
        selector: true,
        feature: "css-read-only-write",
        browsers
      })
    );
    var prefixTextEmphasis = require_text_emphasis();
    f2(
      prefixTextEmphasis,
      (browsers) => prefix(
        [
          "text-emphasis",
          "text-emphasis-position",
          "text-emphasis-style",
          "text-emphasis-color"
        ],
        {
          feature: "text-emphasis",
          browsers
        }
      )
    );
    var prefixGrid = require_css_grid();
    f2(prefixGrid, (browsers) => {
      prefix(["display-grid", "inline-grid"], {
        props: ["display"],
        feature: "css-grid",
        browsers
      });
      prefix(
        [
          "grid-template-columns",
          "grid-template-rows",
          "grid-row-start",
          "grid-column-start",
          "grid-row-end",
          "grid-column-end",
          "grid-row",
          "grid-column",
          "grid-area",
          "grid-template",
          "grid-template-areas",
          "place-self"
        ],
        {
          feature: "css-grid",
          browsers
        }
      );
    });
    f2(
      prefixGrid,
      { match: /a x/ },
      (browsers) => prefix(["grid-column-align", "grid-row-align"], {
        feature: "css-grid",
        browsers
      })
    );
    var prefixTextSpacing = require_css_text_spacing();
    f2(
      prefixTextSpacing,
      (browsers) => prefix(["text-spacing"], {
        feature: "css-text-spacing",
        browsers
      })
    );
    var prefixAnyLink = require_css_any_link();
    f2(
      prefixAnyLink,
      (browsers) => prefix([":any-link"], {
        selector: true,
        feature: "css-any-link",
        browsers
      })
    );
    var bidiIsolate = require_mdn_css_unicode_bidi_isolate();
    f2(
      bidiIsolate,
      (browsers) => prefix(["isolate"], {
        props: ["unicode-bidi"],
        feature: "css-unicode-bidi",
        browsers
      })
    );
    var bidiPlaintext = require_mdn_css_unicode_bidi_plaintext();
    f2(
      bidiPlaintext,
      (browsers) => prefix(["plaintext"], {
        props: ["unicode-bidi"],
        feature: "css-unicode-bidi",
        browsers
      })
    );
    var bidiOverride = require_mdn_css_unicode_bidi_isolate_override();
    f2(
      bidiOverride,
      { match: /y x/ },
      (browsers) => prefix(["isolate-override"], {
        props: ["unicode-bidi"],
        feature: "css-unicode-bidi",
        browsers
      })
    );
    var prefixOverscroll = require_css_overscroll_behavior();
    f2(
      prefixOverscroll,
      { match: /a #1/ },
      (browsers) => prefix(["overscroll-behavior"], {
        feature: "css-overscroll-behavior",
        browsers
      })
    );
    var prefixTextOrientation = require_css_text_orientation();
    f2(
      prefixTextOrientation,
      (browsers) => prefix(["text-orientation"], {
        feature: "css-text-orientation",
        browsers
      })
    );
    var prefixPrintAdjust = require_css_print_color_adjust();
    f2(
      prefixPrintAdjust,
      (browsers) => prefix(["print-color-adjust", "color-adjust"], {
        feature: "css-print-color-adjust",
        browsers
      })
    );
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/info.js
var require_info = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/info.js"(exports3, module2) {
    var browserslist = require_browserslist();
    function capitalize2(str2) {
      return str2.slice(0, 1).toUpperCase() + str2.slice(1);
    }
    var NAMES = {
      ie: "IE",
      ie_mob: "IE Mobile",
      ios_saf: "iOS Safari",
      op_mini: "Opera Mini",
      op_mob: "Opera Mobile",
      and_chr: "Chrome for Android",
      and_ff: "Firefox for Android",
      and_uc: "UC for Android",
      and_qq: "QQ Browser",
      kaios: "KaiOS Browser",
      baidu: "Baidu Browser",
      samsung: "Samsung Internet"
    };
    function prefix(name2, prefixes, note) {
      let out2 = `  ${name2}`;
      if (note)
        out2 += " *";
      out2 += ": ";
      out2 += prefixes.map((i2) => i2.replace(/^-(.*)-$/g, "$1")).join(", ");
      out2 += "\n";
      return out2;
    }
    module2.exports = function(prefixes) {
      if (prefixes.browsers.selected.length === 0) {
        return "No browsers selected";
      }
      let versions = {};
      for (let browser3 of prefixes.browsers.selected) {
        let parts = browser3.split(" ");
        let name2 = parts[0];
        let version4 = parts[1];
        name2 = NAMES[name2] || capitalize2(name2);
        if (versions[name2]) {
          versions[name2].push(version4);
        } else {
          versions[name2] = [version4];
        }
      }
      let out2 = "Browsers:\n";
      for (let browser3 in versions) {
        let list = versions[browser3];
        list = list.sort((a2, b) => parseFloat(b) - parseFloat(a2));
        out2 += `  ${browser3}: ${list.join(", ")}
`;
      }
      let coverage = browserslist.coverage(prefixes.browsers.selected);
      let round = Math.round(coverage * 100) / 100;
      out2 += `
These browsers account for ${round}% of all users globally
`;
      let atrules = [];
      for (let name2 in prefixes.add) {
        let data2 = prefixes.add[name2];
        if (name2[0] === "@" && data2.prefixes) {
          atrules.push(prefix(name2, data2.prefixes));
        }
      }
      if (atrules.length > 0) {
        out2 += `
At-Rules:
${atrules.sort().join("")}`;
      }
      let selectors = [];
      for (let selector of prefixes.add.selectors) {
        if (selector.prefixes) {
          selectors.push(prefix(selector.name, selector.prefixes));
        }
      }
      if (selectors.length > 0) {
        out2 += `
Selectors:
${selectors.sort().join("")}`;
      }
      let values = [];
      let props = [];
      let hadGrid = false;
      for (let name2 in prefixes.add) {
        let data2 = prefixes.add[name2];
        if (name2[0] !== "@" && data2.prefixes) {
          let grid = name2.indexOf("grid-") === 0;
          if (grid)
            hadGrid = true;
          props.push(prefix(name2, data2.prefixes, grid));
        }
        if (!Array.isArray(data2.values)) {
          continue;
        }
        for (let value2 of data2.values) {
          let grid = value2.name.includes("grid");
          if (grid)
            hadGrid = true;
          let string3 = prefix(value2.name, value2.prefixes, grid);
          if (!values.includes(string3)) {
            values.push(string3);
          }
        }
      }
      if (props.length > 0) {
        out2 += `
Properties:
${props.sort().join("")}`;
      }
      if (values.length > 0) {
        out2 += `
Values:
${values.sort().join("")}`;
      }
      if (hadGrid) {
        out2 += "\n* - Prefixes will be added only on grid: true option.\n";
      }
      if (!atrules.length && !selectors.length && !props.length && !values.length) {
        out2 += "\nAwesome! Your browsers don't require any vendor prefixes.\nNow you can remove Autoprefixer from build steps.";
      }
      return out2;
    };
  }
});

// node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/autoprefixer.js
var require_autoprefixer = __commonJS({
  "node_modules/.pnpm/autoprefixer@10.4.14_postcss@8.4.23/node_modules/autoprefixer/lib/autoprefixer.js"(exports3, module2) {
    var browserslist = require_browserslist();
    var { agents } = require_agents2();
    var pico = require_picocolors_browser();
    var Browsers = require_browsers3();
    var Prefixes = require_prefixes();
    var dataPrefixes = require_prefixes2();
    var getInfo = require_info();
    var autoprefixerData = { browsers: agents, prefixes: dataPrefixes };
    var WARNING = "\n  Replace Autoprefixer `browsers` option to Browserslist config.\n  Use `browserslist` key in `package.json` or `.browserslistrc` file.\n\n  Using `browsers` option can cause errors. Browserslist config can\n  be used for Babel, Autoprefixer, postcss-normalize and other tools.\n\n  If you really need to use option, rename it to `overrideBrowserslist`.\n\n  Learn more at:\n  https://github.com/browserslist/browserslist#readme\n  https://twitter.com/browserslist\n\n";
    function isPlainObject(obj) {
      return Object.prototype.toString.apply(obj) === "[object Object]";
    }
    var cache2 = /* @__PURE__ */ new Map();
    function timeCapsule(result, prefixes) {
      if (prefixes.browsers.selected.length === 0) {
        return;
      }
      if (prefixes.add.selectors.length > 0) {
        return;
      }
      if (Object.keys(prefixes.add).length > 2) {
        return;
      }
      result.warn(
        "Autoprefixer target browsers do not need any prefixes.You do not need Autoprefixer anymore.\nCheck your Browserslist config to be sure that your targets are set up correctly.\n\n  Learn more at:\n  https://github.com/postcss/autoprefixer#readme\n  https://github.com/browserslist/browserslist#readme\n\n"
      );
    }
    module2.exports = plugin;
    function plugin(...reqs2) {
      let options3;
      if (reqs2.length === 1 && isPlainObject(reqs2[0])) {
        options3 = reqs2[0];
        reqs2 = void 0;
      } else if (reqs2.length === 0 || reqs2.length === 1 && !reqs2[0]) {
        reqs2 = void 0;
      } else if (reqs2.length <= 2 && (Array.isArray(reqs2[0]) || !reqs2[0])) {
        options3 = reqs2[1];
        reqs2 = reqs2[0];
      } else if (typeof reqs2[reqs2.length - 1] === "object") {
        options3 = reqs2.pop();
      }
      if (!options3) {
        options3 = {};
      }
      if (options3.browser) {
        throw new Error(
          "Change `browser` option to `overrideBrowserslist` in Autoprefixer"
        );
      } else if (options3.browserslist) {
        throw new Error(
          "Change `browserslist` option to `overrideBrowserslist` in Autoprefixer"
        );
      }
      if (options3.overrideBrowserslist) {
        reqs2 = options3.overrideBrowserslist;
      } else if (options3.browsers) {
        if (typeof console !== "undefined" && console.warn) {
          console.warn(
            pico.red(WARNING.replace(/`[^`]+`/g, (i2) => pico.yellow(i2.slice(1, -1))))
          );
        }
        reqs2 = options3.browsers;
      }
      let brwlstOpts = {
        ignoreUnknownVersions: options3.ignoreUnknownVersions,
        stats: options3.stats,
        env: options3.env
      };
      function loadPrefixes(opts) {
        let d2 = autoprefixerData;
        let browsers = new Browsers(d2.browsers, reqs2, opts, brwlstOpts);
        let key = browsers.selected.join(", ") + JSON.stringify(options3);
        if (!cache2.has(key)) {
          cache2.set(key, new Prefixes(d2.prefixes, browsers, options3));
        }
        return cache2.get(key);
      }
      return {
        postcssPlugin: "autoprefixer",
        prepare(result) {
          let prefixes = loadPrefixes({
            from: result.opts.from,
            env: options3.env
          });
          return {
            OnceExit(root) {
              timeCapsule(result, prefixes);
              if (options3.remove !== false) {
                prefixes.processor.remove(root, result);
              }
              if (options3.add !== false) {
                prefixes.processor.add(root, result);
              }
            }
          };
        },
        info(opts) {
          opts = opts || {};
          opts.from = opts.from || process.cwd();
          return getInfo(loadPrefixes(opts));
        },
        options: options3,
        browsers: reqs2
      };
    }
    plugin.postcss = true;
    plugin.data = autoprefixerData;
    plugin.defaults = browserslist.defaults;
    plugin.info = () => plugin().info();
  }
});

// node_modules/.pnpm/connect-history-api-fallback@2.0.0/node_modules/connect-history-api-fallback/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/.pnpm/connect-history-api-fallback@2.0.0/node_modules/connect-history-api-fallback/lib/index.js"(exports3, module2) {
    "use strict";
    var url2 = require_url();
    exports3 = module2.exports = function historyApiFallback(options3) {
      options3 = options3 || {};
      var logger2 = getLogger(options3);
      return function(req2, res, next) {
        var headers = req2.headers;
        if (req2.method !== "GET" && req2.method !== "HEAD") {
          logger2(
            "Not rewriting",
            req2.method,
            req2.url,
            "because the method is not GET or HEAD."
          );
          return next();
        } else if (!headers || typeof headers.accept !== "string") {
          logger2(
            "Not rewriting",
            req2.method,
            req2.url,
            "because the client did not send an HTTP accept header."
          );
          return next();
        } else if (headers.accept.indexOf("application/json") === 0) {
          logger2(
            "Not rewriting",
            req2.method,
            req2.url,
            "because the client prefers JSON."
          );
          return next();
        } else if (!acceptsHtml(headers.accept, options3)) {
          logger2(
            "Not rewriting",
            req2.method,
            req2.url,
            "because the client does not accept HTML."
          );
          return next();
        }
        var parsedUrl = url2.parse(req2.url);
        var rewriteTarget;
        options3.rewrites = options3.rewrites || [];
        for (var i2 = 0; i2 < options3.rewrites.length; i2++) {
          var rewrite = options3.rewrites[i2];
          var match = parsedUrl.pathname.match(rewrite.from);
          if (match !== null) {
            rewriteTarget = evaluateRewriteRule(parsedUrl, match, rewrite.to, req2);
            if (rewriteTarget.charAt(0) !== "/") {
              logger2(
                "We recommend using an absolute path for the rewrite target.",
                "Received a non-absolute rewrite target",
                rewriteTarget,
                "for URL",
                req2.url
              );
            }
            logger2("Rewriting", req2.method, req2.url, "to", rewriteTarget);
            req2.url = rewriteTarget;
            return next();
          }
        }
        var pathname = parsedUrl.pathname;
        if (pathname.lastIndexOf(".") > pathname.lastIndexOf("/") && options3.disableDotRule !== true) {
          logger2(
            "Not rewriting",
            req2.method,
            req2.url,
            "because the path includes a dot (.) character."
          );
          return next();
        }
        rewriteTarget = options3.index || "/index.html";
        logger2("Rewriting", req2.method, req2.url, "to", rewriteTarget);
        req2.url = rewriteTarget;
        next();
      };
    };
    function evaluateRewriteRule(parsedUrl, match, rule, req2) {
      if (typeof rule === "string") {
        return rule;
      } else if (typeof rule !== "function") {
        throw new Error("Rewrite rule can only be of type string or function.");
      }
      return rule({
        parsedUrl,
        match,
        request: req2
      });
    }
    function acceptsHtml(header, options3) {
      options3.htmlAcceptHeaders = options3.htmlAcceptHeaders || ["text/html", "*/*"];
      for (var i2 = 0; i2 < options3.htmlAcceptHeaders.length; i2++) {
        if (header.indexOf(options3.htmlAcceptHeaders[i2]) !== -1) {
          return true;
        }
      }
      return false;
    }
    function getLogger(options3) {
      if (options3 && options3.logger) {
        return options3.logger;
      } else if (options3 && options3.verbose) {
        return console.log.bind(console);
      }
      return function() {
      };
    }
  }
});

// node_modules/.pnpm/lilconfig@2.1.0/node_modules/lilconfig/dist/index.js
var require_dist = __commonJS({
  "node_modules/.pnpm/lilconfig@2.1.0/node_modules/lilconfig/dist/index.js"(exports3) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    exports3.lilconfigSync = exports3.lilconfig = exports3.defaultLoaders = void 0;
    var path8 = require_path();
    var fs6 = require_fs();
    var os2 = require_os();
    var fsReadFileAsync = fs6.promises.readFile;
    function getDefaultSearchPlaces(name2) {
      return [
        "package.json",
        `.${name2}rc.json`,
        `.${name2}rc.js`,
        `.${name2}rc.cjs`,
        `.config/${name2}rc`,
        `.config/${name2}rc.json`,
        `.config/${name2}rc.js`,
        `.config/${name2}rc.cjs`,
        `${name2}.config.js`,
        `${name2}.config.cjs`
      ];
    }
    function getSearchPaths(startDir, stopDir) {
      return startDir.split(path8.sep).reduceRight((acc, _, ind, arr) => {
        const currentPath = arr.slice(0, ind + 1).join(path8.sep);
        if (!acc.passedStopDir)
          acc.searchPlaces.push(currentPath || path8.sep);
        if (currentPath === stopDir)
          acc.passedStopDir = true;
        return acc;
      }, { searchPlaces: [], passedStopDir: false }).searchPlaces;
    }
    exports3.defaultLoaders = Object.freeze({
      ".js": __require,
      ".json": __require,
      ".cjs": __require,
      noExt(_, content) {
        return JSON.parse(content);
      }
    });
    function getExtDesc(ext2) {
      return ext2 === "noExt" ? "files without extensions" : `extension "${ext2}"`;
    }
    function getOptions2(name2, options3 = {}) {
      const conf = {
        stopDir: os2.homedir(),
        searchPlaces: getDefaultSearchPlaces(name2),
        ignoreEmptySearchPlaces: true,
        transform: (x) => x,
        packageProp: [name2],
        ...options3,
        loaders: { ...exports3.defaultLoaders, ...options3.loaders }
      };
      conf.searchPlaces.forEach((place) => {
        const key = path8.extname(place) || "noExt";
        const loader = conf.loaders[key];
        if (!loader) {
          throw new Error(`No loader specified for ${getExtDesc(key)}, so searchPlaces item "${place}" is invalid`);
        }
        if (typeof loader !== "function") {
          throw new Error(`loader for ${getExtDesc(key)} is not a function (type provided: "${typeof loader}"), so searchPlaces item "${place}" is invalid`);
        }
      });
      return conf;
    }
    function getPackageProp(props, obj) {
      if (typeof props === "string" && props in obj)
        return obj[props];
      return (Array.isArray(props) ? props : props.split(".")).reduce((acc, prop) => acc === void 0 ? acc : acc[prop], obj) || null;
    }
    function getSearchItems(searchPlaces, searchPaths) {
      return searchPaths.reduce((acc, searchPath) => {
        searchPlaces.forEach((sp) => acc.push({
          searchPlace: sp,
          filepath: path8.join(searchPath, sp),
          loaderKey: path8.extname(sp) || "noExt"
        }));
        return acc;
      }, []);
    }
    function validateFilePath(filepath) {
      if (!filepath)
        throw new Error("load must pass a non-empty string");
    }
    function validateLoader(loader, ext2) {
      if (!loader)
        throw new Error(`No loader specified for extension "${ext2}"`);
      if (typeof loader !== "function")
        throw new Error("loader is not a function");
    }
    function lilconfig(name2, options3) {
      const { ignoreEmptySearchPlaces, loaders, packageProp, searchPlaces, stopDir, transform: transform2 } = getOptions2(name2, options3);
      return {
        async search(searchFrom = process.cwd()) {
          const searchPaths = getSearchPaths(searchFrom, stopDir);
          const result = {
            config: null,
            filepath: ""
          };
          const searchItems = getSearchItems(searchPlaces, searchPaths);
          for (const { searchPlace, filepath, loaderKey } of searchItems) {
            try {
              await fs6.promises.access(filepath);
            } catch (_a) {
              continue;
            }
            const content = String(await fsReadFileAsync(filepath));
            const loader = loaders[loaderKey];
            if (searchPlace === "package.json") {
              const pkg = await loader(filepath, content);
              const maybeConfig = getPackageProp(packageProp, pkg);
              if (maybeConfig != null) {
                result.config = maybeConfig;
                result.filepath = filepath;
                break;
              }
              continue;
            }
            const isEmpty3 = content.trim() === "";
            if (isEmpty3 && ignoreEmptySearchPlaces)
              continue;
            if (isEmpty3) {
              result.isEmpty = true;
              result.config = void 0;
            } else {
              validateLoader(loader, loaderKey);
              result.config = await loader(filepath, content);
            }
            result.filepath = filepath;
            break;
          }
          if (result.filepath === "" && result.config === null)
            return transform2(null);
          return transform2(result);
        },
        async load(filepath) {
          validateFilePath(filepath);
          const absPath = path8.resolve(process.cwd(), filepath);
          const { base: base2, ext: ext2 } = path8.parse(absPath);
          const loaderKey = ext2 || "noExt";
          const loader = loaders[loaderKey];
          validateLoader(loader, loaderKey);
          const content = String(await fsReadFileAsync(absPath));
          if (base2 === "package.json") {
            const pkg = await loader(absPath, content);
            return transform2({
              config: getPackageProp(packageProp, pkg),
              filepath: absPath
            });
          }
          const result = {
            config: null,
            filepath: absPath
          };
          const isEmpty3 = content.trim() === "";
          if (isEmpty3 && ignoreEmptySearchPlaces)
            return transform2({
              config: void 0,
              filepath: absPath,
              isEmpty: true
            });
          result.config = isEmpty3 ? void 0 : await loader(absPath, content);
          return transform2(isEmpty3 ? { ...result, isEmpty: isEmpty3, config: void 0 } : result);
        }
      };
    }
    exports3.lilconfig = lilconfig;
    function lilconfigSync(name2, options3) {
      const { ignoreEmptySearchPlaces, loaders, packageProp, searchPlaces, stopDir, transform: transform2 } = getOptions2(name2, options3);
      return {
        search(searchFrom = process.cwd()) {
          const searchPaths = getSearchPaths(searchFrom, stopDir);
          const result = {
            config: null,
            filepath: ""
          };
          const searchItems = getSearchItems(searchPlaces, searchPaths);
          for (const { searchPlace, filepath, loaderKey } of searchItems) {
            try {
              fs6.accessSync(filepath);
            } catch (_a) {
              continue;
            }
            const loader = loaders[loaderKey];
            const content = String(fs6.readFileSync(filepath));
            if (searchPlace === "package.json") {
              const pkg = loader(filepath, content);
              const maybeConfig = getPackageProp(packageProp, pkg);
              if (maybeConfig != null) {
                result.config = maybeConfig;
                result.filepath = filepath;
                break;
              }
              continue;
            }
            const isEmpty3 = content.trim() === "";
            if (isEmpty3 && ignoreEmptySearchPlaces)
              continue;
            if (isEmpty3) {
              result.isEmpty = true;
              result.config = void 0;
            } else {
              validateLoader(loader, loaderKey);
              result.config = loader(filepath, content);
            }
            result.filepath = filepath;
            break;
          }
          if (result.filepath === "" && result.config === null)
            return transform2(null);
          return transform2(result);
        },
        load(filepath) {
          validateFilePath(filepath);
          const absPath = path8.resolve(process.cwd(), filepath);
          const { base: base2, ext: ext2 } = path8.parse(absPath);
          const loaderKey = ext2 || "noExt";
          const loader = loaders[loaderKey];
          validateLoader(loader, loaderKey);
          const content = String(fs6.readFileSync(absPath));
          if (base2 === "package.json") {
            const pkg = loader(absPath, content);
            return transform2({
              config: getPackageProp(packageProp, pkg),
              filepath: absPath
            });
          }
          const result = {
            config: null,
            filepath: absPath
          };
          const isEmpty3 = content.trim() === "";
          if (isEmpty3 && ignoreEmptySearchPlaces)
            return transform2({
              filepath: absPath,
              config: void 0,
              isEmpty: true
            });
          result.config = isEmpty3 ? void 0 : loader(absPath, content);
          return transform2(isEmpty3 ? { ...result, isEmpty: isEmpty3, config: void 0 } : result);
        }
      };
    }
    exports3.lilconfigSync = lilconfigSync;
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/nodes/Node.js
function isCollection2(node3) {
  if (node3 && typeof node3 === "object")
    switch (node3[NODE_TYPE2]) {
      case MAP2:
      case SEQ2:
        return true;
    }
  return false;
}
function isNode2(node3) {
  if (node3 && typeof node3 === "object")
    switch (node3[NODE_TYPE2]) {
      case ALIAS2:
      case MAP2:
      case SCALAR2:
      case SEQ2:
        return true;
    }
  return false;
}
var ALIAS2, DOC2, MAP2, PAIR2, SCALAR2, SEQ2, NODE_TYPE2, isAlias2, isDocument2, isMap2, isPair2, isScalar2, isSeq2, hasAnchor2, NodeBase2;
var init_Node = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/nodes/Node.js"() {
    ALIAS2 = Symbol.for("yaml.alias");
    DOC2 = Symbol.for("yaml.document");
    MAP2 = Symbol.for("yaml.map");
    PAIR2 = Symbol.for("yaml.pair");
    SCALAR2 = Symbol.for("yaml.scalar");
    SEQ2 = Symbol.for("yaml.seq");
    NODE_TYPE2 = Symbol.for("yaml.node.type");
    isAlias2 = (node3) => !!node3 && typeof node3 === "object" && node3[NODE_TYPE2] === ALIAS2;
    isDocument2 = (node3) => !!node3 && typeof node3 === "object" && node3[NODE_TYPE2] === DOC2;
    isMap2 = (node3) => !!node3 && typeof node3 === "object" && node3[NODE_TYPE2] === MAP2;
    isPair2 = (node3) => !!node3 && typeof node3 === "object" && node3[NODE_TYPE2] === PAIR2;
    isScalar2 = (node3) => !!node3 && typeof node3 === "object" && node3[NODE_TYPE2] === SCALAR2;
    isSeq2 = (node3) => !!node3 && typeof node3 === "object" && node3[NODE_TYPE2] === SEQ2;
    hasAnchor2 = (node3) => (isScalar2(node3) || isCollection2(node3)) && !!node3.anchor;
    NodeBase2 = class {
      constructor(type) {
        Object.defineProperty(this, NODE_TYPE2, { value: type });
      }
      /** Create a copy of this node.  */
      clone() {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
    };
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/visit.js
function visit2(node3, visitor) {
  const visitor_ = initVisitor2(visitor);
  if (isDocument2(node3)) {
    const cd = visit_2(null, node3.contents, visitor_, Object.freeze([node3]));
    if (cd === REMOVE2)
      node3.contents = null;
  } else
    visit_2(null, node3, visitor_, Object.freeze([]));
}
function visit_2(key, node3, visitor, path8) {
  const ctrl = callVisitor2(key, node3, visitor, path8);
  if (isNode2(ctrl) || isPair2(ctrl)) {
    replaceNode2(key, path8, ctrl);
    return visit_2(key, ctrl, visitor, path8);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection2(node3)) {
      path8 = Object.freeze(path8.concat(node3));
      for (let i2 = 0; i2 < node3.items.length; ++i2) {
        const ci = visit_2(i2, node3.items[i2], visitor, path8);
        if (typeof ci === "number")
          i2 = ci - 1;
        else if (ci === BREAK2)
          return BREAK2;
        else if (ci === REMOVE2) {
          node3.items.splice(i2, 1);
          i2 -= 1;
        }
      }
    } else if (isPair2(node3)) {
      path8 = Object.freeze(path8.concat(node3));
      const ck = visit_2("key", node3.key, visitor, path8);
      if (ck === BREAK2)
        return BREAK2;
      else if (ck === REMOVE2)
        node3.key = null;
      const cv = visit_2("value", node3.value, visitor, path8);
      if (cv === BREAK2)
        return BREAK2;
      else if (cv === REMOVE2)
        node3.value = null;
    }
  }
  return ctrl;
}
async function visitAsync2(node3, visitor) {
  const visitor_ = initVisitor2(visitor);
  if (isDocument2(node3)) {
    const cd = await visitAsync_2(null, node3.contents, visitor_, Object.freeze([node3]));
    if (cd === REMOVE2)
      node3.contents = null;
  } else
    await visitAsync_2(null, node3, visitor_, Object.freeze([]));
}
async function visitAsync_2(key, node3, visitor, path8) {
  const ctrl = await callVisitor2(key, node3, visitor, path8);
  if (isNode2(ctrl) || isPair2(ctrl)) {
    replaceNode2(key, path8, ctrl);
    return visitAsync_2(key, ctrl, visitor, path8);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection2(node3)) {
      path8 = Object.freeze(path8.concat(node3));
      for (let i2 = 0; i2 < node3.items.length; ++i2) {
        const ci = await visitAsync_2(i2, node3.items[i2], visitor, path8);
        if (typeof ci === "number")
          i2 = ci - 1;
        else if (ci === BREAK2)
          return BREAK2;
        else if (ci === REMOVE2) {
          node3.items.splice(i2, 1);
          i2 -= 1;
        }
      }
    } else if (isPair2(node3)) {
      path8 = Object.freeze(path8.concat(node3));
      const ck = await visitAsync_2("key", node3.key, visitor, path8);
      if (ck === BREAK2)
        return BREAK2;
      else if (ck === REMOVE2)
        node3.key = null;
      const cv = await visitAsync_2("value", node3.value, visitor, path8);
      if (cv === BREAK2)
        return BREAK2;
      else if (cv === REMOVE2)
        node3.value = null;
    }
  }
  return ctrl;
}
function initVisitor2(visitor) {
  if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
    return Object.assign({
      Alias: visitor.Node,
      Map: visitor.Node,
      Scalar: visitor.Node,
      Seq: visitor.Node
    }, visitor.Value && {
      Map: visitor.Value,
      Scalar: visitor.Value,
      Seq: visitor.Value
    }, visitor.Collection && {
      Map: visitor.Collection,
      Seq: visitor.Collection
    }, visitor);
  }
  return visitor;
}
function callVisitor2(key, node3, visitor, path8) {
  var _a, _b, _c, _d, _e;
  if (typeof visitor === "function")
    return visitor(key, node3, path8);
  if (isMap2(node3))
    return (_a = visitor.Map) == null ? void 0 : _a.call(visitor, key, node3, path8);
  if (isSeq2(node3))
    return (_b = visitor.Seq) == null ? void 0 : _b.call(visitor, key, node3, path8);
  if (isPair2(node3))
    return (_c = visitor.Pair) == null ? void 0 : _c.call(visitor, key, node3, path8);
  if (isScalar2(node3))
    return (_d = visitor.Scalar) == null ? void 0 : _d.call(visitor, key, node3, path8);
  if (isAlias2(node3))
    return (_e = visitor.Alias) == null ? void 0 : _e.call(visitor, key, node3, path8);
  return void 0;
}
function replaceNode2(key, path8, node3) {
  const parent = path8[path8.length - 1];
  if (isCollection2(parent)) {
    parent.items[key] = node3;
  } else if (isPair2(parent)) {
    if (key === "key")
      parent.key = node3;
    else
      parent.value = node3;
  } else if (isDocument2(parent)) {
    parent.contents = node3;
  } else {
    const pt = isAlias2(parent) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${pt} parent`);
  }
}
var BREAK2, SKIP2, REMOVE2;
var init_visit = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/visit.js"() {
    init_Node();
    BREAK2 = Symbol("break visit");
    SKIP2 = Symbol("skip children");
    REMOVE2 = Symbol("remove node");
    visit2.BREAK = BREAK2;
    visit2.SKIP = SKIP2;
    visit2.REMOVE = REMOVE2;
    visitAsync2.BREAK = BREAK2;
    visitAsync2.SKIP = SKIP2;
    visitAsync2.REMOVE = REMOVE2;
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/doc/directives.js
var escapeChars2, escapeTagName2, Directives2;
var init_directives = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/doc/directives.js"() {
    init_Node();
    init_visit();
    escapeChars2 = {
      "!": "%21",
      ",": "%2C",
      "[": "%5B",
      "]": "%5D",
      "{": "%7B",
      "}": "%7D"
    };
    escapeTagName2 = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars2[ch]);
    Directives2 = class {
      constructor(yaml3, tags) {
        this.docStart = null;
        this.docEnd = false;
        this.yaml = Object.assign({}, Directives2.defaultYaml, yaml3);
        this.tags = Object.assign({}, Directives2.defaultTags, tags);
      }
      clone() {
        const copy = new Directives2(this.yaml, this.tags);
        copy.docStart = this.docStart;
        return copy;
      }
      /**
       * During parsing, get a Directives instance for the current document and
       * update the stream state according to the current version's spec.
       */
      atDocument() {
        const res = new Directives2(this.yaml, this.tags);
        switch (this.yaml.version) {
          case "1.1":
            this.atNextDocument = true;
            break;
          case "1.2":
            this.atNextDocument = false;
            this.yaml = {
              explicit: Directives2.defaultYaml.explicit,
              version: "1.2"
            };
            this.tags = Object.assign({}, Directives2.defaultTags);
            break;
        }
        return res;
      }
      /**
       * @param onError - May be called even if the action was successful
       * @returns `true` on success
       */
      add(line, onError) {
        if (this.atNextDocument) {
          this.yaml = { explicit: Directives2.defaultYaml.explicit, version: "1.1" };
          this.tags = Object.assign({}, Directives2.defaultTags);
          this.atNextDocument = false;
        }
        const parts = line.trim().split(/[ \t]+/);
        const name2 = parts.shift();
        switch (name2) {
          case "%TAG": {
            if (parts.length !== 2) {
              onError(0, "%TAG directive should contain exactly two parts");
              if (parts.length < 2)
                return false;
            }
            const [handle2, prefix] = parts;
            this.tags[handle2] = prefix;
            return true;
          }
          case "%YAML": {
            this.yaml.explicit = true;
            if (parts.length !== 1) {
              onError(0, "%YAML directive should contain exactly one part");
              return false;
            }
            const [version4] = parts;
            if (version4 === "1.1" || version4 === "1.2") {
              this.yaml.version = version4;
              return true;
            } else {
              const isValid = /^\d+\.\d+$/.test(version4);
              onError(6, `Unsupported YAML version ${version4}`, isValid);
              return false;
            }
          }
          default:
            onError(0, `Unknown directive ${name2}`, true);
            return false;
        }
      }
      /**
       * Resolves a tag, matching handles to those defined in %TAG directives.
       *
       * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
       *   `'!local'` tag, or `null` if unresolvable.
       */
      tagName(source, onError) {
        if (source === "!")
          return "!";
        if (source[0] !== "!") {
          onError(`Not a valid tag: ${source}`);
          return null;
        }
        if (source[1] === "<") {
          const verbatim = source.slice(2, -1);
          if (verbatim === "!" || verbatim === "!!") {
            onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
            return null;
          }
          if (source[source.length - 1] !== ">")
            onError("Verbatim tags must end with a >");
          return verbatim;
        }
        const [, handle2, suffix] = source.match(/^(.*!)([^!]*)$/);
        if (!suffix)
          onError(`The ${source} tag has no suffix`);
        const prefix = this.tags[handle2];
        if (prefix)
          return prefix + decodeURIComponent(suffix);
        if (handle2 === "!")
          return source;
        onError(`Could not resolve tag: ${source}`);
        return null;
      }
      /**
       * Given a fully resolved tag, returns its printable string form,
       * taking into account current tag prefixes and defaults.
       */
      tagString(tag) {
        for (const [handle2, prefix] of Object.entries(this.tags)) {
          if (tag.startsWith(prefix))
            return handle2 + escapeTagName2(tag.substring(prefix.length));
        }
        return tag[0] === "!" ? tag : `!<${tag}>`;
      }
      toString(doc) {
        const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
        const tagEntries = Object.entries(this.tags);
        let tagNames;
        if (doc && tagEntries.length > 0 && isNode2(doc.contents)) {
          const tags = {};
          visit2(doc.contents, (_key, node3) => {
            if (isNode2(node3) && node3.tag)
              tags[node3.tag] = true;
          });
          tagNames = Object.keys(tags);
        } else
          tagNames = [];
        for (const [handle2, prefix] of tagEntries) {
          if (handle2 === "!!" && prefix === "tag:yaml.org,2002:")
            continue;
          if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
            lines.push(`%TAG ${handle2} ${prefix}`);
        }
        return lines.join("\n");
      }
    };
    Directives2.defaultYaml = { explicit: false, version: "1.2" };
    Directives2.defaultTags = { "!!": "tag:yaml.org,2002:" };
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/doc/anchors.js
function anchorIsValid2(anchor) {
  if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
    const sa = JSON.stringify(anchor);
    const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
    throw new Error(msg);
  }
  return true;
}
function anchorNames2(root) {
  const anchors = /* @__PURE__ */ new Set();
  visit2(root, {
    Value(_key, node3) {
      if (node3.anchor)
        anchors.add(node3.anchor);
    }
  });
  return anchors;
}
function findNewAnchor2(prefix, exclude) {
  for (let i2 = 1; true; ++i2) {
    const name2 = `${prefix}${i2}`;
    if (!exclude.has(name2))
      return name2;
  }
}
function createNodeAnchors2(doc, prefix) {
  const aliasObjects = [];
  const sourceObjects = /* @__PURE__ */ new Map();
  let prevAnchors = null;
  return {
    onAnchor: (source) => {
      aliasObjects.push(source);
      if (!prevAnchors)
        prevAnchors = anchorNames2(doc);
      const anchor = findNewAnchor2(prefix, prevAnchors);
      prevAnchors.add(anchor);
      return anchor;
    },
    /**
     * With circular references, the source node is only resolved after all
     * of its child nodes are. This is why anchors are set only after all of
     * the nodes have been created.
     */
    setAnchors: () => {
      for (const source of aliasObjects) {
        const ref2 = sourceObjects.get(source);
        if (typeof ref2 === "object" && ref2.anchor && (isScalar2(ref2.node) || isCollection2(ref2.node))) {
          ref2.node.anchor = ref2.anchor;
        } else {
          const error3 = new Error("Failed to resolve repeated object (this should not happen)");
          error3.source = source;
          throw error3;
        }
      }
    },
    sourceObjects
  };
}
var init_anchors = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/doc/anchors.js"() {
    init_Node();
    init_visit();
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/nodes/Alias.js
function getAliasCount2(doc, node3, anchors) {
  if (isAlias2(node3)) {
    const source = node3.resolve(doc);
    const anchor = anchors && source && anchors.get(source);
    return anchor ? anchor.count * anchor.aliasCount : 0;
  } else if (isCollection2(node3)) {
    let count = 0;
    for (const item of node3.items) {
      const c2 = getAliasCount2(doc, item, anchors);
      if (c2 > count)
        count = c2;
    }
    return count;
  } else if (isPair2(node3)) {
    const kc = getAliasCount2(doc, node3.key, anchors);
    const vc = getAliasCount2(doc, node3.value, anchors);
    return Math.max(kc, vc);
  }
  return 1;
}
var Alias2;
var init_Alias = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/nodes/Alias.js"() {
    init_anchors();
    init_visit();
    init_Node();
    Alias2 = class extends NodeBase2 {
      constructor(source) {
        super(ALIAS2);
        this.source = source;
        Object.defineProperty(this, "tag", {
          set() {
            throw new Error("Alias nodes cannot have tags");
          }
        });
      }
      /**
       * Resolve the value of this alias within `doc`, finding the last
       * instance of the `source` anchor before this node.
       */
      resolve(doc) {
        let found2 = void 0;
        visit2(doc, {
          Node: (_key, node3) => {
            if (node3 === this)
              return visit2.BREAK;
            if (node3.anchor === this.source)
              found2 = node3;
          }
        });
        return found2;
      }
      toJSON(_arg, ctx2) {
        if (!ctx2)
          return { source: this.source };
        const { anchors, doc, maxAliasCount } = ctx2;
        const source = this.resolve(doc);
        if (!source) {
          const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
          throw new ReferenceError(msg);
        }
        const data2 = anchors.get(source);
        if (!data2 || data2.res === void 0) {
          const msg = "This should not happen: Alias anchor was not resolved?";
          throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
          data2.count += 1;
          if (data2.aliasCount === 0)
            data2.aliasCount = getAliasCount2(doc, source, anchors);
          if (data2.count * data2.aliasCount > maxAliasCount) {
            const msg = "Excessive alias count indicates a resource exhaustion attack";
            throw new ReferenceError(msg);
          }
        }
        return data2.res;
      }
      toString(ctx2, _onComment, _onChompKeep) {
        const src3 = `*${this.source}`;
        if (ctx2) {
          anchorIsValid2(this.source);
          if (ctx2.options.verifyAliasOrder && !ctx2.anchors.has(this.source)) {
            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
            throw new Error(msg);
          }
          if (ctx2.implicitKey)
            return `${src3} `;
        }
        return src3;
      }
    };
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/nodes/toJS.js
function toJS2(value2, arg, ctx2) {
  if (Array.isArray(value2))
    return value2.map((v, i2) => toJS2(v, String(i2), ctx2));
  if (value2 && typeof value2.toJSON === "function") {
    if (!ctx2 || !hasAnchor2(value2))
      return value2.toJSON(arg, ctx2);
    const data2 = { aliasCount: 0, count: 1, res: void 0 };
    ctx2.anchors.set(value2, data2);
    ctx2.onCreate = (res2) => {
      data2.res = res2;
      delete ctx2.onCreate;
    };
    const res = value2.toJSON(arg, ctx2);
    if (ctx2.onCreate)
      ctx2.onCreate(res);
    return res;
  }
  if (typeof value2 === "bigint" && !(ctx2 == null ? void 0 : ctx2.keep))
    return Number(value2);
  return value2;
}
var init_toJS = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/nodes/toJS.js"() {
    init_Node();
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/nodes/Scalar.js
var isScalarValue2, Scalar2;
var init_Scalar = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/nodes/Scalar.js"() {
    init_Node();
    init_toJS();
    isScalarValue2 = (value2) => !value2 || typeof value2 !== "function" && typeof value2 !== "object";
    Scalar2 = class extends NodeBase2 {
      constructor(value2) {
        super(SCALAR2);
        this.value = value2;
      }
      toJSON(arg, ctx2) {
        return (ctx2 == null ? void 0 : ctx2.keep) ? this.value : toJS2(this.value, arg, ctx2);
      }
      toString() {
        return String(this.value);
      }
    };
    Scalar2.BLOCK_FOLDED = "BLOCK_FOLDED";
    Scalar2.BLOCK_LITERAL = "BLOCK_LITERAL";
    Scalar2.PLAIN = "PLAIN";
    Scalar2.QUOTE_DOUBLE = "QUOTE_DOUBLE";
    Scalar2.QUOTE_SINGLE = "QUOTE_SINGLE";
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/doc/createNode.js
function findTagObject2(value2, tagName, tags) {
  if (tagName) {
    const match = tags.filter((t3) => t3.tag === tagName);
    const tagObj = match.find((t3) => !t3.format) ?? match[0];
    if (!tagObj)
      throw new Error(`Tag ${tagName} not found`);
    return tagObj;
  }
  return tags.find((t3) => {
    var _a;
    return ((_a = t3.identify) == null ? void 0 : _a.call(t3, value2)) && !t3.format;
  });
}
function createNode2(value2, tagName, ctx2) {
  var _a, _b;
  if (isDocument2(value2))
    value2 = value2.contents;
  if (isNode2(value2))
    return value2;
  if (isPair2(value2)) {
    const map3 = (_b = (_a = ctx2.schema[MAP2]).createNode) == null ? void 0 : _b.call(_a, ctx2.schema, null, ctx2);
    map3.items.push(value2);
    return map3;
  }
  if (value2 instanceof String || value2 instanceof Number || value2 instanceof Boolean || typeof BigInt !== "undefined" && value2 instanceof BigInt) {
    value2 = value2.valueOf();
  }
  const { aliasDuplicateObjects, onAnchor, onTagObj, schema: schema5, sourceObjects } = ctx2;
  let ref2 = void 0;
  if (aliasDuplicateObjects && value2 && typeof value2 === "object") {
    ref2 = sourceObjects.get(value2);
    if (ref2) {
      if (!ref2.anchor)
        ref2.anchor = onAnchor(value2);
      return new Alias2(ref2.anchor);
    } else {
      ref2 = { anchor: null, node: null };
      sourceObjects.set(value2, ref2);
    }
  }
  if (tagName == null ? void 0 : tagName.startsWith("!!"))
    tagName = defaultTagPrefix2 + tagName.slice(2);
  let tagObj = findTagObject2(value2, tagName, schema5.tags);
  if (!tagObj) {
    if (value2 && typeof value2.toJSON === "function") {
      value2 = value2.toJSON();
    }
    if (!value2 || typeof value2 !== "object") {
      const node4 = new Scalar2(value2);
      if (ref2)
        ref2.node = node4;
      return node4;
    }
    tagObj = value2 instanceof Map ? schema5[MAP2] : Symbol.iterator in Object(value2) ? schema5[SEQ2] : schema5[MAP2];
  }
  if (onTagObj) {
    onTagObj(tagObj);
    delete ctx2.onTagObj;
  }
  const node3 = (tagObj == null ? void 0 : tagObj.createNode) ? tagObj.createNode(ctx2.schema, value2, ctx2) : new Scalar2(value2);
  if (tagName)
    node3.tag = tagName;
  if (ref2)
    ref2.node = node3;
  return node3;
}
var defaultTagPrefix2;
var init_createNode = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/doc/createNode.js"() {
    init_Alias();
    init_Node();
    init_Scalar();
    defaultTagPrefix2 = "tag:yaml.org,2002:";
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/nodes/Collection.js
function collectionFromPath2(schema5, path8, value2) {
  let v = value2;
  for (let i2 = path8.length - 1; i2 >= 0; --i2) {
    const k = path8[i2];
    if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
      const a2 = [];
      a2[k] = v;
      v = a2;
    } else {
      v = /* @__PURE__ */ new Map([[k, v]]);
    }
  }
  return createNode2(v, void 0, {
    aliasDuplicateObjects: false,
    keepUndefined: false,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: schema5,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
var isEmptyPath2, Collection2;
var init_Collection = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/nodes/Collection.js"() {
    init_createNode();
    init_Node();
    isEmptyPath2 = (path8) => path8 == null || typeof path8 === "object" && !!path8[Symbol.iterator]().next().done;
    Collection2 = class extends NodeBase2 {
      constructor(type, schema5) {
        super(type);
        Object.defineProperty(this, "schema", {
          value: schema5,
          configurable: true,
          enumerable: false,
          writable: true
        });
      }
      /**
       * Create a copy of this collection.
       *
       * @param schema - If defined, overwrites the original's schema
       */
      clone(schema5) {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (schema5)
          copy.schema = schema5;
        copy.items = copy.items.map((it) => isNode2(it) || isPair2(it) ? it.clone(schema5) : it);
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /**
       * Adds a value to the collection. For `!!map` and `!!omap` the value must
       * be a Pair instance or a `{ key, value }` object, which may not have a key
       * that already exists in the map.
       */
      addIn(path8, value2) {
        if (isEmptyPath2(path8))
          this.add(value2);
        else {
          const [key, ...rest] = path8;
          const node3 = this.get(key, true);
          if (isCollection2(node3))
            node3.addIn(rest, value2);
          else if (node3 === void 0 && this.schema)
            this.set(key, collectionFromPath2(this.schema, rest, value2));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
      /**
       * Removes a value from the collection.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path8) {
        const [key, ...rest] = path8;
        if (rest.length === 0)
          return this.delete(key);
        const node3 = this.get(key, true);
        if (isCollection2(node3))
          return node3.deleteIn(rest);
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path8, keepScalar) {
        const [key, ...rest] = path8;
        const node3 = this.get(key, true);
        if (rest.length === 0)
          return !keepScalar && isScalar2(node3) ? node3.value : node3;
        else
          return isCollection2(node3) ? node3.getIn(rest, keepScalar) : void 0;
      }
      hasAllNullValues(allowScalar) {
        return this.items.every((node3) => {
          if (!isPair2(node3))
            return false;
          const n3 = node3.value;
          return n3 == null || allowScalar && isScalar2(n3) && n3.value == null && !n3.commentBefore && !n3.comment && !n3.tag;
        });
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       */
      hasIn(path8) {
        const [key, ...rest] = path8;
        if (rest.length === 0)
          return this.has(key);
        const node3 = this.get(key, true);
        return isCollection2(node3) ? node3.hasIn(rest) : false;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path8, value2) {
        const [key, ...rest] = path8;
        if (rest.length === 0) {
          this.set(key, value2);
        } else {
          const node3 = this.get(key, true);
          if (isCollection2(node3))
            node3.setIn(rest, value2);
          else if (node3 === void 0 && this.schema)
            this.set(key, collectionFromPath2(this.schema, rest, value2));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
    };
    Collection2.maxFlowStringSingleLineLength = 60;
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/stringify/stringifyComment.js
function indentComment2(comment2, indent) {
  if (/^\n+$/.test(comment2))
    return comment2.substring(1);
  return indent ? comment2.replace(/^(?! *$)/gm, indent) : comment2;
}
var stringifyComment2, lineComment2;
var init_stringifyComment = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/stringify/stringifyComment.js"() {
    stringifyComment2 = (str2) => str2.replace(/^(?!$)(?: $)?/gm, "#");
    lineComment2 = (str2, indent, comment2) => str2.endsWith("\n") ? indentComment2(comment2, indent) : comment2.includes("\n") ? "\n" + indentComment2(comment2, indent) : (str2.endsWith(" ") ? "" : " ") + comment2;
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/stringify/foldFlowLines.js
function foldFlowLines2(text, indent, mode2 = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
  if (!lineWidth || lineWidth < 0)
    return text;
  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
  if (text.length <= endStep)
    return text;
  const folds = [];
  const escapedFolds = {};
  let end = lineWidth - indent.length;
  if (typeof indentAtStart === "number") {
    if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
      folds.push(0);
    else
      end = lineWidth - indentAtStart;
  }
  let split = void 0;
  let prev = void 0;
  let overflow = false;
  let i2 = -1;
  let escStart = -1;
  let escEnd = -1;
  if (mode2 === FOLD_BLOCK2) {
    i2 = consumeMoreIndentedLines2(text, i2);
    if (i2 !== -1)
      end = i2 + endStep;
  }
  for (let ch; ch = text[i2 += 1]; ) {
    if (mode2 === FOLD_QUOTED2 && ch === "\\") {
      escStart = i2;
      switch (text[i2 + 1]) {
        case "x":
          i2 += 3;
          break;
        case "u":
          i2 += 5;
          break;
        case "U":
          i2 += 9;
          break;
        default:
          i2 += 1;
      }
      escEnd = i2;
    }
    if (ch === "\n") {
      if (mode2 === FOLD_BLOCK2)
        i2 = consumeMoreIndentedLines2(text, i2);
      end = i2 + endStep;
      split = void 0;
    } else {
      if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
        const next = text[i2 + 1];
        if (next && next !== " " && next !== "\n" && next !== "	")
          split = i2;
      }
      if (i2 >= end) {
        if (split) {
          folds.push(split);
          end = split + endStep;
          split = void 0;
        } else if (mode2 === FOLD_QUOTED2) {
          while (prev === " " || prev === "	") {
            prev = ch;
            ch = text[i2 += 1];
            overflow = true;
          }
          const j = i2 > escEnd + 1 ? i2 - 2 : escStart - 1;
          if (escapedFolds[j])
            return text;
          folds.push(j);
          escapedFolds[j] = true;
          end = j + endStep;
          split = void 0;
        } else {
          overflow = true;
        }
      }
    }
    prev = ch;
  }
  if (overflow && onOverflow)
    onOverflow();
  if (folds.length === 0)
    return text;
  if (onFold)
    onFold();
  let res = text.slice(0, folds[0]);
  for (let i3 = 0; i3 < folds.length; ++i3) {
    const fold = folds[i3];
    const end2 = folds[i3 + 1] || text.length;
    if (fold === 0)
      res = `
${indent}${text.slice(0, end2)}`;
    else {
      if (mode2 === FOLD_QUOTED2 && escapedFolds[fold])
        res += `${text[fold]}\\`;
      res += `
${indent}${text.slice(fold + 1, end2)}`;
    }
  }
  return res;
}
function consumeMoreIndentedLines2(text, i2) {
  let ch = text[i2 + 1];
  while (ch === " " || ch === "	") {
    do {
      ch = text[i2 += 1];
    } while (ch && ch !== "\n");
    ch = text[i2 + 1];
  }
  return i2;
}
var FOLD_FLOW2, FOLD_BLOCK2, FOLD_QUOTED2;
var init_foldFlowLines = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/stringify/foldFlowLines.js"() {
    FOLD_FLOW2 = "flow";
    FOLD_BLOCK2 = "block";
    FOLD_QUOTED2 = "quoted";
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/stringify/stringifyString.js
function lineLengthOverLimit2(str2, lineWidth, indentLength) {
  if (!lineWidth || lineWidth < 0)
    return false;
  const limit = lineWidth - indentLength;
  const strLen = str2.length;
  if (strLen <= limit)
    return false;
  for (let i2 = 0, start = 0; i2 < strLen; ++i2) {
    if (str2[i2] === "\n") {
      if (i2 - start > limit)
        return true;
      start = i2 + 1;
      if (strLen - start <= limit)
        return false;
    }
  }
  return true;
}
function doubleQuotedString2(value2, ctx2) {
  const json2 = JSON.stringify(value2);
  if (ctx2.options.doubleQuotedAsJSON)
    return json2;
  const { implicitKey } = ctx2;
  const minMultiLineLength = ctx2.options.doubleQuotedMinMultiLineLength;
  const indent = ctx2.indent || (containsDocumentMarker2(value2) ? "  " : "");
  let str2 = "";
  let start = 0;
  for (let i2 = 0, ch = json2[i2]; ch; ch = json2[++i2]) {
    if (ch === " " && json2[i2 + 1] === "\\" && json2[i2 + 2] === "n") {
      str2 += json2.slice(start, i2) + "\\ ";
      i2 += 1;
      start = i2;
      ch = "\\";
    }
    if (ch === "\\")
      switch (json2[i2 + 1]) {
        case "u":
          {
            str2 += json2.slice(start, i2);
            const code = json2.substr(i2 + 2, 4);
            switch (code) {
              case "0000":
                str2 += "\\0";
                break;
              case "0007":
                str2 += "\\a";
                break;
              case "000b":
                str2 += "\\v";
                break;
              case "001b":
                str2 += "\\e";
                break;
              case "0085":
                str2 += "\\N";
                break;
              case "00a0":
                str2 += "\\_";
                break;
              case "2028":
                str2 += "\\L";
                break;
              case "2029":
                str2 += "\\P";
                break;
              default:
                if (code.substr(0, 2) === "00")
                  str2 += "\\x" + code.substr(2);
                else
                  str2 += json2.substr(i2, 6);
            }
            i2 += 5;
            start = i2 + 1;
          }
          break;
        case "n":
          if (implicitKey || json2[i2 + 2] === '"' || json2.length < minMultiLineLength) {
            i2 += 1;
          } else {
            str2 += json2.slice(start, i2) + "\n\n";
            while (json2[i2 + 2] === "\\" && json2[i2 + 3] === "n" && json2[i2 + 4] !== '"') {
              str2 += "\n";
              i2 += 2;
            }
            str2 += indent;
            if (json2[i2 + 2] === " ")
              str2 += "\\";
            i2 += 1;
            start = i2 + 1;
          }
          break;
        default:
          i2 += 1;
      }
  }
  str2 = start ? str2 + json2.slice(start) : json2;
  return implicitKey ? str2 : foldFlowLines2(str2, indent, FOLD_QUOTED2, getFoldOptions2(ctx2, false));
}
function singleQuotedString2(value2, ctx2) {
  if (ctx2.options.singleQuote === false || ctx2.implicitKey && value2.includes("\n") || /[ \t]\n|\n[ \t]/.test(value2))
    return doubleQuotedString2(value2, ctx2);
  const indent = ctx2.indent || (containsDocumentMarker2(value2) ? "  " : "");
  const res = "'" + value2.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
  return ctx2.implicitKey ? res : foldFlowLines2(res, indent, FOLD_FLOW2, getFoldOptions2(ctx2, false));
}
function quotedString2(value2, ctx2) {
  const { singleQuote } = ctx2.options;
  let qs2;
  if (singleQuote === false)
    qs2 = doubleQuotedString2;
  else {
    const hasDouble = value2.includes('"');
    const hasSingle = value2.includes("'");
    if (hasDouble && !hasSingle)
      qs2 = singleQuotedString2;
    else if (hasSingle && !hasDouble)
      qs2 = doubleQuotedString2;
    else
      qs2 = singleQuote ? singleQuotedString2 : doubleQuotedString2;
  }
  return qs2(value2, ctx2);
}
function blockString2({ comment: comment2, type, value: value2 }, ctx2, onComment, onChompKeep) {
  const { blockQuote, commentString, lineWidth } = ctx2.options;
  if (!blockQuote || /\n[\t ]+$/.test(value2) || /^\s*$/.test(value2)) {
    return quotedString2(value2, ctx2);
  }
  const indent = ctx2.indent || (ctx2.forceBlockIndent || containsDocumentMarker2(value2) ? "  " : "");
  const literal2 = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar2.BLOCK_FOLDED ? false : type === Scalar2.BLOCK_LITERAL ? true : !lineLengthOverLimit2(value2, lineWidth, indent.length);
  if (!value2)
    return literal2 ? "|\n" : ">\n";
  let chomp;
  let endStart;
  for (endStart = value2.length; endStart > 0; --endStart) {
    const ch = value2[endStart - 1];
    if (ch !== "\n" && ch !== "	" && ch !== " ")
      break;
  }
  let end = value2.substring(endStart);
  const endNlPos = end.indexOf("\n");
  if (endNlPos === -1) {
    chomp = "-";
  } else if (value2 === end || endNlPos !== end.length - 1) {
    chomp = "+";
    if (onChompKeep)
      onChompKeep();
  } else {
    chomp = "";
  }
  if (end) {
    value2 = value2.slice(0, -end.length);
    if (end[end.length - 1] === "\n")
      end = end.slice(0, -1);
    end = end.replace(/\n+(?!\n|$)/g, `$&${indent}`);
  }
  let startWithSpace = false;
  let startEnd;
  let startNlPos = -1;
  for (startEnd = 0; startEnd < value2.length; ++startEnd) {
    const ch = value2[startEnd];
    if (ch === " ")
      startWithSpace = true;
    else if (ch === "\n")
      startNlPos = startEnd;
    else
      break;
  }
  let start = value2.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
  if (start) {
    value2 = value2.substring(start.length);
    start = start.replace(/\n+/g, `$&${indent}`);
  }
  const indentSize = indent ? "2" : "1";
  let header = (literal2 ? "|" : ">") + (startWithSpace ? indentSize : "") + chomp;
  if (comment2) {
    header += " " + commentString(comment2.replace(/ ?[\r\n]+/g, " "));
    if (onComment)
      onComment();
  }
  if (literal2) {
    value2 = value2.replace(/\n+/g, `$&${indent}`);
    return `${header}
${indent}${start}${value2}${end}`;
  }
  value2 = value2.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
  const body = foldFlowLines2(`${start}${value2}${end}`, indent, FOLD_BLOCK2, getFoldOptions2(ctx2, true));
  return `${header}
${indent}${body}`;
}
function plainString2(item, ctx2, onComment, onChompKeep) {
  const { type, value: value2 } = item;
  const { actualString, implicitKey, indent, indentStep, inFlow } = ctx2;
  if (implicitKey && /[\n[\]{},]/.test(value2) || inFlow && /[[\]{},]/.test(value2)) {
    return quotedString2(value2, ctx2);
  }
  if (!value2 || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value2)) {
    return implicitKey || inFlow || !value2.includes("\n") ? quotedString2(value2, ctx2) : blockString2(item, ctx2, onComment, onChompKeep);
  }
  if (!implicitKey && !inFlow && type !== Scalar2.PLAIN && value2.includes("\n")) {
    return blockString2(item, ctx2, onComment, onChompKeep);
  }
  if (containsDocumentMarker2(value2)) {
    if (indent === "") {
      ctx2.forceBlockIndent = true;
      return blockString2(item, ctx2, onComment, onChompKeep);
    } else if (implicitKey && indent === indentStep) {
      return quotedString2(value2, ctx2);
    }
  }
  const str2 = value2.replace(/\n+/g, `$&
${indent}`);
  if (actualString) {
    const test = (tag) => {
      var _a;
      return tag.default && tag.tag !== "tag:yaml.org,2002:str" && ((_a = tag.test) == null ? void 0 : _a.test(str2));
    };
    const { compat, tags } = ctx2.doc.schema;
    if (tags.some(test) || (compat == null ? void 0 : compat.some(test)))
      return quotedString2(value2, ctx2);
  }
  return implicitKey ? str2 : foldFlowLines2(str2, indent, FOLD_FLOW2, getFoldOptions2(ctx2, false));
}
function stringifyString2(item, ctx2, onComment, onChompKeep) {
  const { implicitKey, inFlow } = ctx2;
  const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
  let { type } = item;
  if (type !== Scalar2.QUOTE_DOUBLE) {
    if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
      type = Scalar2.QUOTE_DOUBLE;
  }
  const _stringify = (_type) => {
    switch (_type) {
      case Scalar2.BLOCK_FOLDED:
      case Scalar2.BLOCK_LITERAL:
        return implicitKey || inFlow ? quotedString2(ss.value, ctx2) : blockString2(ss, ctx2, onComment, onChompKeep);
      case Scalar2.QUOTE_DOUBLE:
        return doubleQuotedString2(ss.value, ctx2);
      case Scalar2.QUOTE_SINGLE:
        return singleQuotedString2(ss.value, ctx2);
      case Scalar2.PLAIN:
        return plainString2(ss, ctx2, onComment, onChompKeep);
      default:
        return null;
    }
  };
  let res = _stringify(type);
  if (res === null) {
    const { defaultKeyType, defaultStringType } = ctx2.options;
    const t3 = implicitKey && defaultKeyType || defaultStringType;
    res = _stringify(t3);
    if (res === null)
      throw new Error(`Unsupported default string type ${t3}`);
  }
  return res;
}
var getFoldOptions2, containsDocumentMarker2;
var init_stringifyString = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/stringify/stringifyString.js"() {
    init_Scalar();
    init_foldFlowLines();
    getFoldOptions2 = (ctx2, isBlock3) => ({
      indentAtStart: isBlock3 ? ctx2.indent.length : ctx2.indentAtStart,
      lineWidth: ctx2.options.lineWidth,
      minContentWidth: ctx2.options.minContentWidth
    });
    containsDocumentMarker2 = (str2) => /^(%|---|\.\.\.)/m.test(str2);
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/stringify/stringify.js
function createStringifyContext2(doc, options3) {
  const opt = Object.assign({
    blockQuote: true,
    commentString: stringifyComment2,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: false,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    flowCollectionPadding: true,
    indentSeq: true,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: false,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: true
  }, doc.schema.toStringOptions, options3);
  let inFlow;
  switch (opt.collectionStyle) {
    case "block":
      inFlow = false;
      break;
    case "flow":
      inFlow = true;
      break;
    default:
      inFlow = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc,
    flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
    indent: "",
    indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
    inFlow,
    options: opt
  };
}
function getTagObject2(tags, item) {
  var _a;
  if (item.tag) {
    const match = tags.filter((t3) => t3.tag === item.tag);
    if (match.length > 0)
      return match.find((t3) => t3.format === item.format) ?? match[0];
  }
  let tagObj = void 0;
  let obj;
  if (isScalar2(item)) {
    obj = item.value;
    const match = tags.filter((t3) => {
      var _a2;
      return (_a2 = t3.identify) == null ? void 0 : _a2.call(t3, obj);
    });
    tagObj = match.find((t3) => t3.format === item.format) ?? match.find((t3) => !t3.format);
  } else {
    obj = item;
    tagObj = tags.find((t3) => t3.nodeClass && obj instanceof t3.nodeClass);
  }
  if (!tagObj) {
    const name2 = ((_a = obj == null ? void 0 : obj.constructor) == null ? void 0 : _a.name) ?? typeof obj;
    throw new Error(`Tag not resolved for ${name2} value`);
  }
  return tagObj;
}
function stringifyProps2(node3, tagObj, { anchors, doc }) {
  if (!doc.directives)
    return "";
  const props = [];
  const anchor = (isScalar2(node3) || isCollection2(node3)) && node3.anchor;
  if (anchor && anchorIsValid2(anchor)) {
    anchors.add(anchor);
    props.push(`&${anchor}`);
  }
  const tag = node3.tag ? node3.tag : tagObj.default ? null : tagObj.tag;
  if (tag)
    props.push(doc.directives.tagString(tag));
  return props.join(" ");
}
function stringify2(item, ctx2, onComment, onChompKeep) {
  var _a;
  if (isPair2(item))
    return item.toString(ctx2, onComment, onChompKeep);
  if (isAlias2(item)) {
    if (ctx2.doc.directives)
      return item.toString(ctx2);
    if ((_a = ctx2.resolvedAliases) == null ? void 0 : _a.has(item)) {
      throw new TypeError(`Cannot stringify circular structure without alias nodes`);
    } else {
      if (ctx2.resolvedAliases)
        ctx2.resolvedAliases.add(item);
      else
        ctx2.resolvedAliases = /* @__PURE__ */ new Set([item]);
      item = item.resolve(ctx2.doc);
    }
  }
  let tagObj = void 0;
  const node3 = isNode2(item) ? item : ctx2.doc.createNode(item, { onTagObj: (o3) => tagObj = o3 });
  if (!tagObj)
    tagObj = getTagObject2(ctx2.doc.schema.tags, node3);
  const props = stringifyProps2(node3, tagObj, ctx2);
  if (props.length > 0)
    ctx2.indentAtStart = (ctx2.indentAtStart ?? 0) + props.length + 1;
  const str2 = typeof tagObj.stringify === "function" ? tagObj.stringify(node3, ctx2, onComment, onChompKeep) : isScalar2(node3) ? stringifyString2(node3, ctx2, onComment, onChompKeep) : node3.toString(ctx2, onComment, onChompKeep);
  if (!props)
    return str2;
  return isScalar2(node3) || str2[0] === "{" || str2[0] === "[" ? `${props} ${str2}` : `${props}
${ctx2.indent}${str2}`;
}
var init_stringify = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/stringify/stringify.js"() {
    init_anchors();
    init_Node();
    init_stringifyComment();
    init_stringifyString();
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/stringify/stringifyPair.js
function stringifyPair2({ key, value: value2 }, ctx2, onComment, onChompKeep) {
  const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx2;
  let keyComment = isNode2(key) && key.comment || null;
  if (simpleKeys) {
    if (keyComment) {
      throw new Error("With simple keys, key nodes cannot have comments");
    }
    if (isCollection2(key)) {
      const msg = "With simple keys, collection cannot be used as a key value";
      throw new Error(msg);
    }
  }
  let explicitKey = !simpleKeys && (!key || keyComment && value2 == null && !ctx2.inFlow || isCollection2(key) || (isScalar2(key) ? key.type === Scalar2.BLOCK_FOLDED || key.type === Scalar2.BLOCK_LITERAL : typeof key === "object"));
  ctx2 = Object.assign({}, ctx2, {
    allNullValues: false,
    implicitKey: !explicitKey && (simpleKeys || !allNullValues),
    indent: indent + indentStep
  });
  let keyCommentDone = false;
  let chompKeep = false;
  let str2 = stringify2(key, ctx2, () => keyCommentDone = true, () => chompKeep = true);
  if (!explicitKey && !ctx2.inFlow && str2.length > 1024) {
    if (simpleKeys)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    explicitKey = true;
  }
  if (ctx2.inFlow) {
    if (allNullValues || value2 == null) {
      if (keyCommentDone && onComment)
        onComment();
      return str2 === "" ? "?" : explicitKey ? `? ${str2}` : str2;
    }
  } else if (allNullValues && !simpleKeys || value2 == null && explicitKey) {
    str2 = `? ${str2}`;
    if (keyComment && !keyCommentDone) {
      str2 += lineComment2(str2, ctx2.indent, commentString(keyComment));
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str2;
  }
  if (keyCommentDone)
    keyComment = null;
  if (explicitKey) {
    if (keyComment)
      str2 += lineComment2(str2, ctx2.indent, commentString(keyComment));
    str2 = `? ${str2}
${indent}:`;
  } else {
    str2 = `${str2}:`;
    if (keyComment)
      str2 += lineComment2(str2, ctx2.indent, commentString(keyComment));
  }
  let vsb, vcb, valueComment;
  if (isNode2(value2)) {
    vsb = !!value2.spaceBefore;
    vcb = value2.commentBefore;
    valueComment = value2.comment;
  } else {
    vsb = false;
    vcb = null;
    valueComment = null;
    if (value2 && typeof value2 === "object")
      value2 = doc.createNode(value2);
  }
  ctx2.implicitKey = false;
  if (!explicitKey && !keyComment && isScalar2(value2))
    ctx2.indentAtStart = str2.length + 1;
  chompKeep = false;
  if (!indentSeq && indentStep.length >= 2 && !ctx2.inFlow && !explicitKey && isSeq2(value2) && !value2.flow && !value2.tag && !value2.anchor) {
    ctx2.indent = ctx2.indent.substring(2);
  }
  let valueCommentDone = false;
  const valueStr = stringify2(value2, ctx2, () => valueCommentDone = true, () => chompKeep = true);
  let ws = " ";
  if (keyComment || vsb || vcb) {
    ws = vsb ? "\n" : "";
    if (vcb) {
      const cs = commentString(vcb);
      ws += `
${indentComment2(cs, ctx2.indent)}`;
    }
    if (valueStr === "" && !ctx2.inFlow) {
      if (ws === "\n")
        ws = "\n\n";
    } else {
      ws += `
${ctx2.indent}`;
    }
  } else if (!explicitKey && isCollection2(value2)) {
    const vs0 = valueStr[0];
    const nl0 = valueStr.indexOf("\n");
    const hasNewline = nl0 !== -1;
    const flow = ctx2.inFlow ?? value2.flow ?? value2.items.length === 0;
    if (hasNewline || !flow) {
      let hasPropsLine = false;
      if (hasNewline && (vs0 === "&" || vs0 === "!")) {
        let sp0 = valueStr.indexOf(" ");
        if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
          sp0 = valueStr.indexOf(" ", sp0 + 1);
        }
        if (sp0 === -1 || nl0 < sp0)
          hasPropsLine = true;
      }
      if (!hasPropsLine)
        ws = `
${ctx2.indent}`;
    }
  } else if (valueStr === "" || valueStr[0] === "\n") {
    ws = "";
  }
  str2 += ws + valueStr;
  if (ctx2.inFlow) {
    if (valueCommentDone && onComment)
      onComment();
  } else if (valueComment && !valueCommentDone) {
    str2 += lineComment2(str2, ctx2.indent, commentString(valueComment));
  } else if (chompKeep && onChompKeep) {
    onChompKeep();
  }
  return str2;
}
var init_stringifyPair = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/stringify/stringifyPair.js"() {
    init_Node();
    init_Scalar();
    init_stringify();
    init_stringifyComment();
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/log.js
function warn3(logLevel, warning) {
  if (logLevel === "debug" || logLevel === "warn") {
    if (typeof process !== "undefined" && process.emitWarning)
      process.emitWarning(warning);
    else
      console.warn(warning);
  }
}
var init_log = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/log.js"() {
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/nodes/addPairToJSMap.js
function addPairToJSMap2(ctx2, map3, { key, value: value2 }) {
  if ((ctx2 == null ? void 0 : ctx2.doc.schema.merge) && isMergeKey2(key)) {
    value2 = isAlias2(value2) ? value2.resolve(ctx2.doc) : value2;
    if (isSeq2(value2))
      for (const it of value2.items)
        mergeToJSMap2(ctx2, map3, it);
    else if (Array.isArray(value2))
      for (const it of value2)
        mergeToJSMap2(ctx2, map3, it);
    else
      mergeToJSMap2(ctx2, map3, value2);
  } else {
    const jsKey = toJS2(key, "", ctx2);
    if (map3 instanceof Map) {
      map3.set(jsKey, toJS2(value2, jsKey, ctx2));
    } else if (map3 instanceof Set) {
      map3.add(jsKey);
    } else {
      const stringKey = stringifyKey2(key, jsKey, ctx2);
      const jsValue = toJS2(value2, stringKey, ctx2);
      if (stringKey in map3)
        Object.defineProperty(map3, stringKey, {
          value: jsValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      else
        map3[stringKey] = jsValue;
    }
  }
  return map3;
}
function mergeToJSMap2(ctx2, map3, value2) {
  const source = ctx2 && isAlias2(value2) ? value2.resolve(ctx2.doc) : value2;
  if (!isMap2(source))
    throw new Error("Merge sources must be maps or map aliases");
  const srcMap = source.toJSON(null, ctx2, Map);
  for (const [key, value3] of srcMap) {
    if (map3 instanceof Map) {
      if (!map3.has(key))
        map3.set(key, value3);
    } else if (map3 instanceof Set) {
      map3.add(key);
    } else if (!Object.prototype.hasOwnProperty.call(map3, key)) {
      Object.defineProperty(map3, key, {
        value: value3,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
  return map3;
}
function stringifyKey2(key, jsKey, ctx2) {
  if (jsKey === null)
    return "";
  if (typeof jsKey !== "object")
    return String(jsKey);
  if (isNode2(key) && ctx2 && ctx2.doc) {
    const strCtx = createStringifyContext2(ctx2.doc, {});
    strCtx.anchors = /* @__PURE__ */ new Set();
    for (const node3 of ctx2.anchors.keys())
      strCtx.anchors.add(node3.anchor);
    strCtx.inFlow = true;
    strCtx.inStringifyKey = true;
    const strKey = key.toString(strCtx);
    if (!ctx2.mapKeyWarned) {
      let jsonStr = JSON.stringify(strKey);
      if (jsonStr.length > 40)
        jsonStr = jsonStr.substring(0, 36) + '..."';
      warn3(ctx2.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
      ctx2.mapKeyWarned = true;
    }
    return strKey;
  }
  return JSON.stringify(jsKey);
}
var MERGE_KEY2, isMergeKey2;
var init_addPairToJSMap = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/nodes/addPairToJSMap.js"() {
    init_log();
    init_stringify();
    init_Node();
    init_Scalar();
    init_toJS();
    MERGE_KEY2 = "<<";
    isMergeKey2 = (key) => key === MERGE_KEY2 || isScalar2(key) && key.value === MERGE_KEY2 && (!key.type || key.type === Scalar2.PLAIN);
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/nodes/Pair.js
function createPair2(key, value2, ctx2) {
  const k = createNode2(key, void 0, ctx2);
  const v = createNode2(value2, void 0, ctx2);
  return new Pair2(k, v);
}
var Pair2;
var init_Pair = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/nodes/Pair.js"() {
    init_createNode();
    init_stringifyPair();
    init_addPairToJSMap();
    init_Node();
    Pair2 = class {
      constructor(key, value2 = null) {
        Object.defineProperty(this, NODE_TYPE2, { value: PAIR2 });
        this.key = key;
        this.value = value2;
      }
      clone(schema5) {
        let { key, value: value2 } = this;
        if (isNode2(key))
          key = key.clone(schema5);
        if (isNode2(value2))
          value2 = value2.clone(schema5);
        return new Pair2(key, value2);
      }
      toJSON(_, ctx2) {
        const pair = (ctx2 == null ? void 0 : ctx2.mapAsMap) ? /* @__PURE__ */ new Map() : {};
        return addPairToJSMap2(ctx2, pair, this);
      }
      toString(ctx2, onComment, onChompKeep) {
        return (ctx2 == null ? void 0 : ctx2.doc) ? stringifyPair2(this, ctx2, onComment, onChompKeep) : JSON.stringify(this);
      }
    };
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/stringify/stringifyCollection.js
function stringifyCollection2(collection, ctx2, options3) {
  const flow = ctx2.inFlow ?? collection.flow;
  const stringify5 = flow ? stringifyFlowCollection2 : stringifyBlockCollection2;
  return stringify5(collection, ctx2, options3);
}
function stringifyBlockCollection2({ comment: comment2, items }, ctx2, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
  const { indent, options: { commentString } } = ctx2;
  const itemCtx = Object.assign({}, ctx2, { indent: itemIndent, type: null });
  let chompKeep = false;
  const lines = [];
  for (let i2 = 0; i2 < items.length; ++i2) {
    const item = items[i2];
    let comment3 = null;
    if (isNode2(item)) {
      if (!chompKeep && item.spaceBefore)
        lines.push("");
      addCommentBefore2(ctx2, lines, item.commentBefore, chompKeep);
      if (item.comment)
        comment3 = item.comment;
    } else if (isPair2(item)) {
      const ik = isNode2(item.key) ? item.key : null;
      if (ik) {
        if (!chompKeep && ik.spaceBefore)
          lines.push("");
        addCommentBefore2(ctx2, lines, ik.commentBefore, chompKeep);
      }
    }
    chompKeep = false;
    let str3 = stringify2(item, itemCtx, () => comment3 = null, () => chompKeep = true);
    if (comment3)
      str3 += lineComment2(str3, itemIndent, commentString(comment3));
    if (chompKeep && comment3)
      chompKeep = false;
    lines.push(blockItemPrefix + str3);
  }
  let str2;
  if (lines.length === 0) {
    str2 = flowChars.start + flowChars.end;
  } else {
    str2 = lines[0];
    for (let i2 = 1; i2 < lines.length; ++i2) {
      const line = lines[i2];
      str2 += line ? `
${indent}${line}` : "\n";
    }
  }
  if (comment2) {
    str2 += "\n" + indentComment2(commentString(comment2), indent);
    if (onComment)
      onComment();
  } else if (chompKeep && onChompKeep)
    onChompKeep();
  return str2;
}
function stringifyFlowCollection2({ comment: comment2, items }, ctx2, { flowChars, itemIndent, onComment }) {
  const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx2;
  itemIndent += indentStep;
  const itemCtx = Object.assign({}, ctx2, {
    indent: itemIndent,
    inFlow: true,
    type: null
  });
  let reqNewline = false;
  let linesAtValue = 0;
  const lines = [];
  for (let i2 = 0; i2 < items.length; ++i2) {
    const item = items[i2];
    let comment3 = null;
    if (isNode2(item)) {
      if (item.spaceBefore)
        lines.push("");
      addCommentBefore2(ctx2, lines, item.commentBefore, false);
      if (item.comment)
        comment3 = item.comment;
    } else if (isPair2(item)) {
      const ik = isNode2(item.key) ? item.key : null;
      if (ik) {
        if (ik.spaceBefore)
          lines.push("");
        addCommentBefore2(ctx2, lines, ik.commentBefore, false);
        if (ik.comment)
          reqNewline = true;
      }
      const iv = isNode2(item.value) ? item.value : null;
      if (iv) {
        if (iv.comment)
          comment3 = iv.comment;
        if (iv.commentBefore)
          reqNewline = true;
      } else if (item.value == null && ik && ik.comment) {
        comment3 = ik.comment;
      }
    }
    if (comment3)
      reqNewline = true;
    let str3 = stringify2(item, itemCtx, () => comment3 = null);
    if (i2 < items.length - 1)
      str3 += ",";
    if (comment3)
      str3 += lineComment2(str3, itemIndent, commentString(comment3));
    if (!reqNewline && (lines.length > linesAtValue || str3.includes("\n")))
      reqNewline = true;
    lines.push(str3);
    linesAtValue = lines.length;
  }
  let str2;
  const { start, end } = flowChars;
  if (lines.length === 0) {
    str2 = start + end;
  } else {
    if (!reqNewline) {
      const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
      reqNewline = len > Collection2.maxFlowStringSingleLineLength;
    }
    if (reqNewline) {
      str2 = start;
      for (const line of lines)
        str2 += line ? `
${indentStep}${indent}${line}` : "\n";
      str2 += `
${indent}${end}`;
    } else {
      str2 = `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
    }
  }
  if (comment2) {
    str2 += lineComment2(str2, indent, commentString(comment2));
    if (onComment)
      onComment();
  }
  return str2;
}
function addCommentBefore2({ indent, options: { commentString } }, lines, comment2, chompKeep) {
  if (comment2 && chompKeep)
    comment2 = comment2.replace(/^\n+/, "");
  if (comment2) {
    const ic = indentComment2(commentString(comment2), indent);
    lines.push(ic.trimStart());
  }
}
var init_stringifyCollection = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/stringify/stringifyCollection.js"() {
    init_Collection();
    init_Node();
    init_stringify();
    init_stringifyComment();
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/nodes/YAMLMap.js
function findPair2(items, key) {
  const k = isScalar2(key) ? key.value : key;
  for (const it of items) {
    if (isPair2(it)) {
      if (it.key === key || it.key === k)
        return it;
      if (isScalar2(it.key) && it.key.value === k)
        return it;
    }
  }
  return void 0;
}
var YAMLMap2;
var init_YAMLMap = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/nodes/YAMLMap.js"() {
    init_stringifyCollection();
    init_addPairToJSMap();
    init_Collection();
    init_Node();
    init_Pair();
    init_Scalar();
    YAMLMap2 = class extends Collection2 {
      static get tagName() {
        return "tag:yaml.org,2002:map";
      }
      constructor(schema5) {
        super(MAP2, schema5);
        this.items = [];
      }
      /**
       * Adds a value to the collection.
       *
       * @param overwrite - If not set `true`, using a key that is already in the
       *   collection will throw. Otherwise, overwrites the previous value.
       */
      add(pair, overwrite) {
        var _a;
        let _pair;
        if (isPair2(pair))
          _pair = pair;
        else if (!pair || typeof pair !== "object" || !("key" in pair)) {
          _pair = new Pair2(pair, pair == null ? void 0 : pair.value);
        } else
          _pair = new Pair2(pair.key, pair.value);
        const prev = findPair2(this.items, _pair.key);
        const sortEntries = (_a = this.schema) == null ? void 0 : _a.sortMapEntries;
        if (prev) {
          if (!overwrite)
            throw new Error(`Key ${_pair.key} already set`);
          if (isScalar2(prev.value) && isScalarValue2(_pair.value))
            prev.value.value = _pair.value;
          else
            prev.value = _pair.value;
        } else if (sortEntries) {
          const i2 = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
          if (i2 === -1)
            this.items.push(_pair);
          else
            this.items.splice(i2, 0, _pair);
        } else {
          this.items.push(_pair);
        }
      }
      delete(key) {
        const it = findPair2(this.items, key);
        if (!it)
          return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const it = findPair2(this.items, key);
        const node3 = it == null ? void 0 : it.value;
        return (!keepScalar && isScalar2(node3) ? node3.value : node3) ?? void 0;
      }
      has(key) {
        return !!findPair2(this.items, key);
      }
      set(key, value2) {
        this.add(new Pair2(key, value2), true);
      }
      /**
       * @param ctx - Conversion context, originally set in Document#toJS()
       * @param {Class} Type - If set, forces the returned collection type
       * @returns Instance of Type, Map, or Object
       */
      toJSON(_, ctx2, Type) {
        const map3 = Type ? new Type() : (ctx2 == null ? void 0 : ctx2.mapAsMap) ? /* @__PURE__ */ new Map() : {};
        if (ctx2 == null ? void 0 : ctx2.onCreate)
          ctx2.onCreate(map3);
        for (const item of this.items)
          addPairToJSMap2(ctx2, map3, item);
        return map3;
      }
      toString(ctx2, onComment, onChompKeep) {
        if (!ctx2)
          return JSON.stringify(this);
        for (const item of this.items) {
          if (!isPair2(item))
            throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        if (!ctx2.allNullValues && this.hasAllNullValues(false))
          ctx2 = Object.assign({}, ctx2, { allNullValues: true });
        return stringifyCollection2(this, ctx2, {
          blockItemPrefix: "",
          flowChars: { start: "{", end: "}" },
          itemIndent: ctx2.indent || "",
          onChompKeep,
          onComment
        });
      }
    };
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/schema/common/map.js
function createMap2(schema5, obj, ctx2) {
  const { keepUndefined, replacer } = ctx2;
  const map3 = new YAMLMap2(schema5);
  const add = (key, value2) => {
    if (typeof replacer === "function")
      value2 = replacer.call(obj, key, value2);
    else if (Array.isArray(replacer) && !replacer.includes(key))
      return;
    if (value2 !== void 0 || keepUndefined)
      map3.items.push(createPair2(key, value2, ctx2));
  };
  if (obj instanceof Map) {
    for (const [key, value2] of obj)
      add(key, value2);
  } else if (obj && typeof obj === "object") {
    for (const key of Object.keys(obj))
      add(key, obj[key]);
  }
  if (typeof schema5.sortMapEntries === "function") {
    map3.items.sort(schema5.sortMapEntries);
  }
  return map3;
}
var map2;
var init_map = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/schema/common/map.js"() {
    init_Node();
    init_Pair();
    init_YAMLMap();
    map2 = {
      collection: "map",
      createNode: createMap2,
      default: true,
      nodeClass: YAMLMap2,
      tag: "tag:yaml.org,2002:map",
      resolve(map3, onError) {
        if (!isMap2(map3))
          onError("Expected a mapping for this tag");
        return map3;
      }
    };
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/nodes/YAMLSeq.js
function asItemIndex2(key) {
  let idx = isScalar2(key) ? key.value : key;
  if (idx && typeof idx === "string")
    idx = Number(idx);
  return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
}
var YAMLSeq2;
var init_YAMLSeq = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/nodes/YAMLSeq.js"() {
    init_stringifyCollection();
    init_Collection();
    init_Node();
    init_Scalar();
    init_toJS();
    YAMLSeq2 = class extends Collection2 {
      static get tagName() {
        return "tag:yaml.org,2002:seq";
      }
      constructor(schema5) {
        super(SEQ2, schema5);
        this.items = [];
      }
      add(value2) {
        this.items.push(value2);
      }
      /**
       * Removes a value from the collection.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       *
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        const idx = asItemIndex2(key);
        if (typeof idx !== "number")
          return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const idx = asItemIndex2(key);
        if (typeof idx !== "number")
          return void 0;
        const it = this.items[idx];
        return !keepScalar && isScalar2(it) ? it.value : it;
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       */
      has(key) {
        const idx = asItemIndex2(key);
        return typeof idx === "number" && idx < this.items.length;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       *
       * If `key` does not contain a representation of an integer, this will throw.
       * It may be wrapped in a `Scalar`.
       */
      set(key, value2) {
        const idx = asItemIndex2(key);
        if (typeof idx !== "number")
          throw new Error(`Expected a valid index, not ${key}.`);
        const prev = this.items[idx];
        if (isScalar2(prev) && isScalarValue2(value2))
          prev.value = value2;
        else
          this.items[idx] = value2;
      }
      toJSON(_, ctx2) {
        const seq3 = [];
        if (ctx2 == null ? void 0 : ctx2.onCreate)
          ctx2.onCreate(seq3);
        let i2 = 0;
        for (const item of this.items)
          seq3.push(toJS2(item, String(i2++), ctx2));
        return seq3;
      }
      toString(ctx2, onComment, onChompKeep) {
        if (!ctx2)
          return JSON.stringify(this);
        return stringifyCollection2(this, ctx2, {
          blockItemPrefix: "- ",
          flowChars: { start: "[", end: "]" },
          itemIndent: (ctx2.indent || "") + "  ",
          onChompKeep,
          onComment
        });
      }
    };
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/schema/common/seq.js
function createSeq2(schema5, obj, ctx2) {
  const { replacer } = ctx2;
  const seq3 = new YAMLSeq2(schema5);
  if (obj && Symbol.iterator in Object(obj)) {
    let i2 = 0;
    for (let it of obj) {
      if (typeof replacer === "function") {
        const key = obj instanceof Set ? it : String(i2++);
        it = replacer.call(obj, key, it);
      }
      seq3.items.push(createNode2(it, void 0, ctx2));
    }
  }
  return seq3;
}
var seq2;
var init_seq = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/schema/common/seq.js"() {
    init_createNode();
    init_Node();
    init_YAMLSeq();
    seq2 = {
      collection: "seq",
      createNode: createSeq2,
      default: true,
      nodeClass: YAMLSeq2,
      tag: "tag:yaml.org,2002:seq",
      resolve(seq3, onError) {
        if (!isSeq2(seq3))
          onError("Expected a sequence for this tag");
        return seq3;
      }
    };
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/schema/common/string.js
var string2;
var init_string = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/schema/common/string.js"() {
    init_stringifyString();
    string2 = {
      identify: (value2) => typeof value2 === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: (str2) => str2,
      stringify(item, ctx2, onComment, onChompKeep) {
        ctx2 = Object.assign({ actualString: true }, ctx2);
        return stringifyString2(item, ctx2, onComment, onChompKeep);
      }
    };
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/schema/common/null.js
var nullTag2;
var init_null = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/schema/common/null.js"() {
    init_Scalar();
    nullTag2 = {
      identify: (value2) => value2 == null,
      createNode: () => new Scalar2(null),
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => new Scalar2(null),
      stringify: ({ source }, ctx2) => typeof source === "string" && nullTag2.test.test(source) ? source : ctx2.options.nullStr
    };
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/schema/core/bool.js
var boolTag2;
var init_bool = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/schema/core/bool.js"() {
    init_Scalar();
    boolTag2 = {
      identify: (value2) => typeof value2 === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
      resolve: (str2) => new Scalar2(str2[0] === "t" || str2[0] === "T"),
      stringify({ source, value: value2 }, ctx2) {
        if (source && boolTag2.test.test(source)) {
          const sv = source[0] === "t" || source[0] === "T";
          if (value2 === sv)
            return source;
        }
        return value2 ? ctx2.options.trueStr : ctx2.options.falseStr;
      }
    };
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/stringify/stringifyNumber.js
function stringifyNumber2({ format: format2, minFractionDigits, tag, value: value2 }) {
  if (typeof value2 === "bigint")
    return String(value2);
  const num = typeof value2 === "number" ? value2 : Number(value2);
  if (!isFinite(num))
    return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
  let n3 = JSON.stringify(value2);
  if (!format2 && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n3)) {
    let i2 = n3.indexOf(".");
    if (i2 < 0) {
      i2 = n3.length;
      n3 += ".";
    }
    let d2 = minFractionDigits - (n3.length - i2 - 1);
    while (d2-- > 0)
      n3 += "0";
  }
  return n3;
}
var init_stringifyNumber = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/stringify/stringifyNumber.js"() {
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/schema/core/float.js
var floatNaN2, floatExp2, float2;
var init_float = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/schema/core/float.js"() {
    init_Scalar();
    init_stringifyNumber();
    floatNaN2 = {
      identify: (value2) => typeof value2 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/,
      resolve: (str2) => str2.slice(-3).toLowerCase() === "nan" ? NaN : str2[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber2
    };
    floatExp2 = {
      identify: (value2) => typeof value2 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
      resolve: (str2) => parseFloat(str2),
      stringify(node3) {
        const num = Number(node3.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber2(node3);
      }
    };
    float2 = {
      identify: (value2) => typeof value2 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
      resolve(str2) {
        const node3 = new Scalar2(parseFloat(str2));
        const dot = str2.indexOf(".");
        if (dot !== -1 && str2[str2.length - 1] === "0")
          node3.minFractionDigits = str2.length - dot - 1;
        return node3;
      },
      stringify: stringifyNumber2
    };
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/schema/core/int.js
function intStringify2(node3, radix, prefix) {
  const { value: value2 } = node3;
  if (intIdentify2(value2) && value2 >= 0)
    return prefix + value2.toString(radix);
  return stringifyNumber2(node3);
}
var intIdentify2, intResolve2, intOct2, int2, intHex2;
var init_int = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/schema/core/int.js"() {
    init_stringifyNumber();
    intIdentify2 = (value2) => typeof value2 === "bigint" || Number.isInteger(value2);
    intResolve2 = (str2, offset3, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str2) : parseInt(str2.substring(offset3), radix);
    intOct2 = {
      identify: (value2) => intIdentify2(value2) && value2 >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^0o[0-7]+$/,
      resolve: (str2, _onError, opt) => intResolve2(str2, 2, 8, opt),
      stringify: (node3) => intStringify2(node3, 8, "0o")
    };
    int2 = {
      identify: intIdentify2,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9]+$/,
      resolve: (str2, _onError, opt) => intResolve2(str2, 0, 10, opt),
      stringify: stringifyNumber2
    };
    intHex2 = {
      identify: (value2) => intIdentify2(value2) && value2 >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^0x[0-9a-fA-F]+$/,
      resolve: (str2, _onError, opt) => intResolve2(str2, 2, 16, opt),
      stringify: (node3) => intStringify2(node3, 16, "0x")
    };
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/schema/core/schema.js
var schema2;
var init_schema = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/schema/core/schema.js"() {
    init_map();
    init_null();
    init_seq();
    init_string();
    init_bool();
    init_float();
    init_int();
    schema2 = [
      map2,
      seq2,
      string2,
      nullTag2,
      boolTag2,
      intOct2,
      int2,
      intHex2,
      floatNaN2,
      floatExp2,
      float2
    ];
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/schema/json/schema.js
function intIdentify3(value2) {
  return typeof value2 === "bigint" || Number.isInteger(value2);
}
var stringifyJSON2, jsonScalars2, jsonError2, schema3;
var init_schema2 = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/schema/json/schema.js"() {
    init_Scalar();
    init_map();
    init_seq();
    stringifyJSON2 = ({ value: value2 }) => JSON.stringify(value2);
    jsonScalars2 = [
      {
        identify: (value2) => typeof value2 === "string",
        default: true,
        tag: "tag:yaml.org,2002:str",
        resolve: (str2) => str2,
        stringify: stringifyJSON2
      },
      {
        identify: (value2) => value2 == null,
        createNode: () => new Scalar2(null),
        default: true,
        tag: "tag:yaml.org,2002:null",
        test: /^null$/,
        resolve: () => null,
        stringify: stringifyJSON2
      },
      {
        identify: (value2) => typeof value2 === "boolean",
        default: true,
        tag: "tag:yaml.org,2002:bool",
        test: /^true|false$/,
        resolve: (str2) => str2 === "true",
        stringify: stringifyJSON2
      },
      {
        identify: intIdentify3,
        default: true,
        tag: "tag:yaml.org,2002:int",
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (str2, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str2) : parseInt(str2, 10),
        stringify: ({ value: value2 }) => intIdentify3(value2) ? value2.toString() : JSON.stringify(value2)
      },
      {
        identify: (value2) => typeof value2 === "number",
        default: true,
        tag: "tag:yaml.org,2002:float",
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: (str2) => parseFloat(str2),
        stringify: stringifyJSON2
      }
    ];
    jsonError2 = {
      default: true,
      tag: "",
      test: /^/,
      resolve(str2, onError) {
        onError(`Unresolved plain scalar ${JSON.stringify(str2)}`);
        return str2;
      }
    };
    schema3 = [map2, seq2].concat(jsonScalars2, jsonError2);
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js
var binary2;
var init_binary = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js"() {
    init_Scalar();
    init_stringifyString();
    binary2 = {
      identify: (value2) => value2 instanceof Uint8Array,
      default: false,
      tag: "tag:yaml.org,2002:binary",
      /**
       * Returns a Buffer in node and an Uint8Array in browsers
       *
       * To use the resulting buffer as an image, you'll want to do something like:
       *
       *   const blob = new Blob([buffer], { type: 'image/jpeg' })
       *   document.querySelector('#photo').src = URL.createObjectURL(blob)
       */
      resolve(src3, onError) {
        if (typeof Buffer === "function") {
          return Buffer.from(src3, "base64");
        } else if (typeof atob === "function") {
          const str2 = atob(src3.replace(/[\n\r]/g, ""));
          const buffer = new Uint8Array(str2.length);
          for (let i2 = 0; i2 < str2.length; ++i2)
            buffer[i2] = str2.charCodeAt(i2);
          return buffer;
        } else {
          onError("This environment does not support reading binary tags; either Buffer or atob is required");
          return src3;
        }
      },
      stringify({ comment: comment2, type, value: value2 }, ctx2, onComment, onChompKeep) {
        const buf = value2;
        let str2;
        if (typeof Buffer === "function") {
          str2 = buf instanceof Buffer ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64");
        } else if (typeof btoa === "function") {
          let s2 = "";
          for (let i2 = 0; i2 < buf.length; ++i2)
            s2 += String.fromCharCode(buf[i2]);
          str2 = btoa(s2);
        } else {
          throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
        }
        if (!type)
          type = Scalar2.BLOCK_LITERAL;
        if (type !== Scalar2.QUOTE_DOUBLE) {
          const lineWidth = Math.max(ctx2.options.lineWidth - ctx2.indent.length, ctx2.options.minContentWidth);
          const n3 = Math.ceil(str2.length / lineWidth);
          const lines = new Array(n3);
          for (let i2 = 0, o3 = 0; i2 < n3; ++i2, o3 += lineWidth) {
            lines[i2] = str2.substr(o3, lineWidth);
          }
          str2 = lines.join(type === Scalar2.BLOCK_LITERAL ? "\n" : " ");
        }
        return stringifyString2({ comment: comment2, type, value: str2 }, ctx2, onComment, onChompKeep);
      }
    };
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/schema/yaml-1.1/pairs.js
function resolvePairs2(seq3, onError) {
  if (isSeq2(seq3)) {
    for (let i2 = 0; i2 < seq3.items.length; ++i2) {
      let item = seq3.items[i2];
      if (isPair2(item))
        continue;
      else if (isMap2(item)) {
        if (item.items.length > 1)
          onError("Each pair must have its own sequence indicator");
        const pair = item.items[0] || new Pair2(new Scalar2(null));
        if (item.commentBefore)
          pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
        if (item.comment) {
          const cn = pair.value ?? pair.key;
          cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
        }
        item = pair;
      }
      seq3.items[i2] = isPair2(item) ? item : new Pair2(item);
    }
  } else
    onError("Expected a sequence for this tag");
  return seq3;
}
function createPairs2(schema5, iterable, ctx2) {
  const { replacer } = ctx2;
  const pairs3 = new YAMLSeq2(schema5);
  pairs3.tag = "tag:yaml.org,2002:pairs";
  let i2 = 0;
  if (iterable && Symbol.iterator in Object(iterable))
    for (let it of iterable) {
      if (typeof replacer === "function")
        it = replacer.call(iterable, String(i2++), it);
      let key, value2;
      if (Array.isArray(it)) {
        if (it.length === 2) {
          key = it[0];
          value2 = it[1];
        } else
          throw new TypeError(`Expected [key, value] tuple: ${it}`);
      } else if (it && it instanceof Object) {
        const keys = Object.keys(it);
        if (keys.length === 1) {
          key = keys[0];
          value2 = it[key];
        } else
          throw new TypeError(`Expected { key: value } tuple: ${it}`);
      } else {
        key = it;
      }
      pairs3.items.push(createPair2(key, value2, ctx2));
    }
  return pairs3;
}
var pairs2;
var init_pairs = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/schema/yaml-1.1/pairs.js"() {
    init_Node();
    init_Pair();
    init_Scalar();
    init_YAMLSeq();
    pairs2 = {
      collection: "seq",
      default: false,
      tag: "tag:yaml.org,2002:pairs",
      resolve: resolvePairs2,
      createNode: createPairs2
    };
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/schema/yaml-1.1/omap.js
var YAMLOMap2, omap2;
var init_omap = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/schema/yaml-1.1/omap.js"() {
    init_YAMLSeq();
    init_toJS();
    init_Node();
    init_YAMLMap();
    init_pairs();
    YAMLOMap2 = class extends YAMLSeq2 {
      constructor() {
        super();
        this.add = YAMLMap2.prototype.add.bind(this);
        this.delete = YAMLMap2.prototype.delete.bind(this);
        this.get = YAMLMap2.prototype.get.bind(this);
        this.has = YAMLMap2.prototype.has.bind(this);
        this.set = YAMLMap2.prototype.set.bind(this);
        this.tag = YAMLOMap2.tag;
      }
      /**
       * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
       * but TypeScript won't allow widening the signature of a child method.
       */
      toJSON(_, ctx2) {
        if (!ctx2)
          return super.toJSON(_);
        const map3 = /* @__PURE__ */ new Map();
        if (ctx2 == null ? void 0 : ctx2.onCreate)
          ctx2.onCreate(map3);
        for (const pair of this.items) {
          let key, value2;
          if (isPair2(pair)) {
            key = toJS2(pair.key, "", ctx2);
            value2 = toJS2(pair.value, key, ctx2);
          } else {
            key = toJS2(pair, "", ctx2);
          }
          if (map3.has(key))
            throw new Error("Ordered maps must not include duplicate keys");
          map3.set(key, value2);
        }
        return map3;
      }
    };
    YAMLOMap2.tag = "tag:yaml.org,2002:omap";
    omap2 = {
      collection: "seq",
      identify: (value2) => value2 instanceof Map,
      nodeClass: YAMLOMap2,
      default: false,
      tag: "tag:yaml.org,2002:omap",
      resolve(seq3, onError) {
        const pairs3 = resolvePairs2(seq3, onError);
        const seenKeys = [];
        for (const { key } of pairs3.items) {
          if (isScalar2(key)) {
            if (seenKeys.includes(key.value)) {
              onError(`Ordered maps must not include duplicate keys: ${key.value}`);
            } else {
              seenKeys.push(key.value);
            }
          }
        }
        return Object.assign(new YAMLOMap2(), pairs3);
      },
      createNode(schema5, iterable, ctx2) {
        const pairs3 = createPairs2(schema5, iterable, ctx2);
        const omap3 = new YAMLOMap2();
        omap3.items = pairs3.items;
        return omap3;
      }
    };
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/schema/yaml-1.1/bool.js
function boolStringify2({ value: value2, source }, ctx2) {
  const boolObj = value2 ? trueTag2 : falseTag2;
  if (source && boolObj.test.test(source))
    return source;
  return value2 ? ctx2.options.trueStr : ctx2.options.falseStr;
}
var trueTag2, falseTag2;
var init_bool2 = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/schema/yaml-1.1/bool.js"() {
    init_Scalar();
    trueTag2 = {
      identify: (value2) => value2 === true,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
      resolve: () => new Scalar2(true),
      stringify: boolStringify2
    };
    falseTag2 = {
      identify: (value2) => value2 === false,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
      resolve: () => new Scalar2(false),
      stringify: boolStringify2
    };
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/schema/yaml-1.1/float.js
var floatNaN3, floatExp3, float3;
var init_float2 = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/schema/yaml-1.1/float.js"() {
    init_Scalar();
    init_stringifyNumber();
    floatNaN3 = {
      identify: (value2) => typeof value2 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/,
      resolve: (str2) => str2.slice(-3).toLowerCase() === "nan" ? NaN : str2[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber2
    };
    floatExp3 = {
      identify: (value2) => typeof value2 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
      resolve: (str2) => parseFloat(str2.replace(/_/g, "")),
      stringify(node3) {
        const num = Number(node3.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber2(node3);
      }
    };
    float3 = {
      identify: (value2) => typeof value2 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
      resolve(str2) {
        const node3 = new Scalar2(parseFloat(str2.replace(/_/g, "")));
        const dot = str2.indexOf(".");
        if (dot !== -1) {
          const f2 = str2.substring(dot + 1).replace(/_/g, "");
          if (f2[f2.length - 1] === "0")
            node3.minFractionDigits = f2.length;
        }
        return node3;
      },
      stringify: stringifyNumber2
    };
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/schema/yaml-1.1/int.js
function intResolve3(str2, offset3, radix, { intAsBigInt }) {
  const sign = str2[0];
  if (sign === "-" || sign === "+")
    offset3 += 1;
  str2 = str2.substring(offset3).replace(/_/g, "");
  if (intAsBigInt) {
    switch (radix) {
      case 2:
        str2 = `0b${str2}`;
        break;
      case 8:
        str2 = `0o${str2}`;
        break;
      case 16:
        str2 = `0x${str2}`;
        break;
    }
    const n4 = BigInt(str2);
    return sign === "-" ? BigInt(-1) * n4 : n4;
  }
  const n3 = parseInt(str2, radix);
  return sign === "-" ? -1 * n3 : n3;
}
function intStringify3(node3, radix, prefix) {
  const { value: value2 } = node3;
  if (intIdentify4(value2)) {
    const str2 = value2.toString(radix);
    return value2 < 0 ? "-" + prefix + str2.substr(1) : prefix + str2;
  }
  return stringifyNumber2(node3);
}
var intIdentify4, intBin2, intOct3, int3, intHex3;
var init_int2 = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/schema/yaml-1.1/int.js"() {
    init_stringifyNumber();
    intIdentify4 = (value2) => typeof value2 === "bigint" || Number.isInteger(value2);
    intBin2 = {
      identify: intIdentify4,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "BIN",
      test: /^[-+]?0b[0-1_]+$/,
      resolve: (str2, _onError, opt) => intResolve3(str2, 2, 2, opt),
      stringify: (node3) => intStringify3(node3, 2, "0b")
    };
    intOct3 = {
      identify: intIdentify4,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^[-+]?0[0-7_]+$/,
      resolve: (str2, _onError, opt) => intResolve3(str2, 1, 8, opt),
      stringify: (node3) => intStringify3(node3, 8, "0")
    };
    int3 = {
      identify: intIdentify4,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9][0-9_]*$/,
      resolve: (str2, _onError, opt) => intResolve3(str2, 0, 10, opt),
      stringify: stringifyNumber2
    };
    intHex3 = {
      identify: intIdentify4,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^[-+]?0x[0-9a-fA-F_]+$/,
      resolve: (str2, _onError, opt) => intResolve3(str2, 2, 16, opt),
      stringify: (node3) => intStringify3(node3, 16, "0x")
    };
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/schema/yaml-1.1/set.js
var YAMLSet2, set2;
var init_set = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/schema/yaml-1.1/set.js"() {
    init_Node();
    init_Pair();
    init_YAMLMap();
    YAMLSet2 = class extends YAMLMap2 {
      constructor(schema5) {
        super(schema5);
        this.tag = YAMLSet2.tag;
      }
      add(key) {
        let pair;
        if (isPair2(key))
          pair = key;
        else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
          pair = new Pair2(key.key, null);
        else
          pair = new Pair2(key, null);
        const prev = findPair2(this.items, pair.key);
        if (!prev)
          this.items.push(pair);
      }
      /**
       * If `keepPair` is `true`, returns the Pair matching `key`.
       * Otherwise, returns the value of that Pair's key.
       */
      get(key, keepPair) {
        const pair = findPair2(this.items, key);
        return !keepPair && isPair2(pair) ? isScalar2(pair.key) ? pair.key.value : pair.key : pair;
      }
      set(key, value2) {
        if (typeof value2 !== "boolean")
          throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value2}`);
        const prev = findPair2(this.items, key);
        if (prev && !value2) {
          this.items.splice(this.items.indexOf(prev), 1);
        } else if (!prev && value2) {
          this.items.push(new Pair2(key));
        }
      }
      toJSON(_, ctx2) {
        return super.toJSON(_, ctx2, Set);
      }
      toString(ctx2, onComment, onChompKeep) {
        if (!ctx2)
          return JSON.stringify(this);
        if (this.hasAllNullValues(true))
          return super.toString(Object.assign({}, ctx2, { allNullValues: true }), onComment, onChompKeep);
        else
          throw new Error("Set items must all have null values");
      }
    };
    YAMLSet2.tag = "tag:yaml.org,2002:set";
    set2 = {
      collection: "map",
      identify: (value2) => value2 instanceof Set,
      nodeClass: YAMLSet2,
      default: false,
      tag: "tag:yaml.org,2002:set",
      resolve(map3, onError) {
        if (isMap2(map3)) {
          if (map3.hasAllNullValues(true))
            return Object.assign(new YAMLSet2(), map3);
          else
            onError("Set items must all have null values");
        } else
          onError("Expected a mapping for this tag");
        return map3;
      },
      createNode(schema5, iterable, ctx2) {
        const { replacer } = ctx2;
        const set3 = new YAMLSet2(schema5);
        if (iterable && Symbol.iterator in Object(iterable))
          for (let value2 of iterable) {
            if (typeof replacer === "function")
              value2 = replacer.call(iterable, value2, value2);
            set3.items.push(createPair2(value2, null, ctx2));
          }
        return set3;
      }
    };
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/schema/yaml-1.1/timestamp.js
function parseSexagesimal2(str2, asBigInt) {
  const sign = str2[0];
  const parts = sign === "-" || sign === "+" ? str2.substring(1) : str2;
  const num = (n3) => asBigInt ? BigInt(n3) : Number(n3);
  const res = parts.replace(/_/g, "").split(":").reduce((res2, p2) => res2 * num(60) + num(p2), num(0));
  return sign === "-" ? num(-1) * res : res;
}
function stringifySexagesimal2(node3) {
  let { value: value2 } = node3;
  let num = (n3) => n3;
  if (typeof value2 === "bigint")
    num = (n3) => BigInt(n3);
  else if (isNaN(value2) || !isFinite(value2))
    return stringifyNumber2(node3);
  let sign = "";
  if (value2 < 0) {
    sign = "-";
    value2 *= num(-1);
  }
  const _60 = num(60);
  const parts = [value2 % _60];
  if (value2 < 60) {
    parts.unshift(0);
  } else {
    value2 = (value2 - parts[0]) / _60;
    parts.unshift(value2 % _60);
    if (value2 >= 60) {
      value2 = (value2 - parts[0]) / _60;
      parts.unshift(value2);
    }
  }
  return sign + parts.map((n3) => n3 < 10 ? "0" + String(n3) : String(n3)).join(":").replace(/000000\d*$/, "");
}
var intTime2, floatTime2, timestamp2;
var init_timestamp = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/schema/yaml-1.1/timestamp.js"() {
    init_stringifyNumber();
    intTime2 = {
      identify: (value2) => typeof value2 === "bigint" || Number.isInteger(value2),
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
      resolve: (str2, _onError, { intAsBigInt }) => parseSexagesimal2(str2, intAsBigInt),
      stringify: stringifySexagesimal2
    };
    floatTime2 = {
      identify: (value2) => typeof value2 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
      resolve: (str2) => parseSexagesimal2(str2, false),
      stringify: stringifySexagesimal2
    };
    timestamp2 = {
      identify: (value2) => value2 instanceof Date,
      default: true,
      tag: "tag:yaml.org,2002:timestamp",
      // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
      // may be omitted altogether, resulting in a date format. In such a case, the time part is
      // assumed to be 00:00:00Z (start of day, UTC).
      test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
      resolve(str2) {
        const match = str2.match(timestamp2.test);
        if (!match)
          throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
        const [, year, month, day, hour, minute, second] = match.map(Number);
        const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
        const tz = match[8];
        if (tz && tz !== "Z") {
          let d2 = parseSexagesimal2(tz, false);
          if (Math.abs(d2) < 30)
            d2 *= 60;
          date -= 6e4 * d2;
        }
        return new Date(date);
      },
      stringify: ({ value: value2 }) => value2.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
    };
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/schema/yaml-1.1/schema.js
var schema4;
var init_schema3 = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/schema/yaml-1.1/schema.js"() {
    init_map();
    init_null();
    init_seq();
    init_string();
    init_binary();
    init_bool2();
    init_float2();
    init_int2();
    init_omap();
    init_pairs();
    init_set();
    init_timestamp();
    schema4 = [
      map2,
      seq2,
      string2,
      nullTag2,
      trueTag2,
      falseTag2,
      intBin2,
      intOct3,
      int3,
      intHex3,
      floatNaN3,
      floatExp3,
      float3,
      binary2,
      omap2,
      pairs2,
      set2,
      intTime2,
      floatTime2,
      timestamp2
    ];
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/schema/tags.js
function getTags2(customTags, schemaName) {
  let tags = schemas2.get(schemaName);
  if (!tags) {
    if (Array.isArray(customTags))
      tags = [];
    else {
      const keys = Array.from(schemas2.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
    }
  }
  if (Array.isArray(customTags)) {
    for (const tag of customTags)
      tags = tags.concat(tag);
  } else if (typeof customTags === "function") {
    tags = customTags(tags.slice());
  }
  return tags.map((tag) => {
    if (typeof tag !== "string")
      return tag;
    const tagObj = tagsByName2[tag];
    if (tagObj)
      return tagObj;
    const keys = Object.keys(tagsByName2).map((key) => JSON.stringify(key)).join(", ");
    throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
  });
}
var schemas2, tagsByName2, coreKnownTags2;
var init_tags = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/schema/tags.js"() {
    init_map();
    init_null();
    init_seq();
    init_string();
    init_bool();
    init_float();
    init_int();
    init_schema();
    init_schema2();
    init_binary();
    init_omap();
    init_pairs();
    init_schema3();
    init_set();
    init_timestamp();
    schemas2 = /* @__PURE__ */ new Map([
      ["core", schema2],
      ["failsafe", [map2, seq2, string2]],
      ["json", schema3],
      ["yaml11", schema4],
      ["yaml-1.1", schema4]
    ]);
    tagsByName2 = {
      binary: binary2,
      bool: boolTag2,
      float: float2,
      floatExp: floatExp2,
      floatNaN: floatNaN2,
      floatTime: floatTime2,
      int: int2,
      intHex: intHex2,
      intOct: intOct2,
      intTime: intTime2,
      map: map2,
      null: nullTag2,
      omap: omap2,
      pairs: pairs2,
      seq: seq2,
      set: set2,
      timestamp: timestamp2
    };
    coreKnownTags2 = {
      "tag:yaml.org,2002:binary": binary2,
      "tag:yaml.org,2002:omap": omap2,
      "tag:yaml.org,2002:pairs": pairs2,
      "tag:yaml.org,2002:set": set2,
      "tag:yaml.org,2002:timestamp": timestamp2
    };
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/schema/Schema.js
var sortMapEntriesByKey2, Schema2;
var init_Schema = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/schema/Schema.js"() {
    init_Node();
    init_map();
    init_seq();
    init_string();
    init_tags();
    sortMapEntriesByKey2 = (a2, b) => a2.key < b.key ? -1 : a2.key > b.key ? 1 : 0;
    Schema2 = class {
      constructor({ compat, customTags, merge: merge3, resolveKnownTags, schema: schema5, sortMapEntries, toStringDefaults }) {
        this.compat = Array.isArray(compat) ? getTags2(compat, "compat") : compat ? getTags2(null, compat) : null;
        this.merge = !!merge3;
        this.name = typeof schema5 === "string" && schema5 || "core";
        this.knownTags = resolveKnownTags ? coreKnownTags2 : {};
        this.tags = getTags2(customTags, this.name);
        this.toStringOptions = toStringDefaults ?? null;
        Object.defineProperty(this, MAP2, { value: map2 });
        Object.defineProperty(this, SCALAR2, { value: string2 });
        Object.defineProperty(this, SEQ2, { value: seq2 });
        this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey2 : null;
      }
      clone() {
        const copy = Object.create(Schema2.prototype, Object.getOwnPropertyDescriptors(this));
        copy.tags = this.tags.slice();
        return copy;
      }
    };
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/stringify/stringifyDocument.js
function stringifyDocument2(doc, options3) {
  var _a;
  const lines = [];
  let hasDirectives = options3.directives === true;
  if (options3.directives !== false && doc.directives) {
    const dir = doc.directives.toString(doc);
    if (dir) {
      lines.push(dir);
      hasDirectives = true;
    } else if (doc.directives.docStart)
      hasDirectives = true;
  }
  if (hasDirectives)
    lines.push("---");
  const ctx2 = createStringifyContext2(doc, options3);
  const { commentString } = ctx2.options;
  if (doc.commentBefore) {
    if (lines.length !== 1)
      lines.unshift("");
    const cs = commentString(doc.commentBefore);
    lines.unshift(indentComment2(cs, ""));
  }
  let chompKeep = false;
  let contentComment = null;
  if (doc.contents) {
    if (isNode2(doc.contents)) {
      if (doc.contents.spaceBefore && hasDirectives)
        lines.push("");
      if (doc.contents.commentBefore) {
        const cs = commentString(doc.contents.commentBefore);
        lines.push(indentComment2(cs, ""));
      }
      ctx2.forceBlockIndent = !!doc.comment;
      contentComment = doc.contents.comment;
    }
    const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
    let body = stringify2(doc.contents, ctx2, () => contentComment = null, onChompKeep);
    if (contentComment)
      body += lineComment2(body, "", commentString(contentComment));
    if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
      lines[lines.length - 1] = `--- ${body}`;
    } else
      lines.push(body);
  } else {
    lines.push(stringify2(doc.contents, ctx2));
  }
  if ((_a = doc.directives) == null ? void 0 : _a.docEnd) {
    if (doc.comment) {
      const cs = commentString(doc.comment);
      if (cs.includes("\n")) {
        lines.push("...");
        lines.push(indentComment2(cs, ""));
      } else {
        lines.push(`... ${cs}`);
      }
    } else {
      lines.push("...");
    }
  } else {
    let dc = doc.comment;
    if (dc && chompKeep)
      dc = dc.replace(/^\n+/, "");
    if (dc) {
      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
        lines.push("");
      lines.push(indentComment2(commentString(dc), ""));
    }
  }
  return lines.join("\n") + "\n";
}
var init_stringifyDocument = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/stringify/stringifyDocument.js"() {
    init_Node();
    init_stringify();
    init_stringifyComment();
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/doc/applyReviver.js
function applyReviver2(reviver, obj, key, val) {
  if (val && typeof val === "object") {
    if (Array.isArray(val)) {
      for (let i2 = 0, len = val.length; i2 < len; ++i2) {
        const v0 = val[i2];
        const v1 = applyReviver2(reviver, val, String(i2), v0);
        if (v1 === void 0)
          delete val[i2];
        else if (v1 !== v0)
          val[i2] = v1;
      }
    } else if (val instanceof Map) {
      for (const k of Array.from(val.keys())) {
        const v0 = val.get(k);
        const v1 = applyReviver2(reviver, val, k, v0);
        if (v1 === void 0)
          val.delete(k);
        else if (v1 !== v0)
          val.set(k, v1);
      }
    } else if (val instanceof Set) {
      for (const v0 of Array.from(val)) {
        const v1 = applyReviver2(reviver, val, v0, v0);
        if (v1 === void 0)
          val.delete(v0);
        else if (v1 !== v0) {
          val.delete(v0);
          val.add(v1);
        }
      }
    } else {
      for (const [k, v0] of Object.entries(val)) {
        const v1 = applyReviver2(reviver, val, k, v0);
        if (v1 === void 0)
          delete val[k];
        else if (v1 !== v0)
          val[k] = v1;
      }
    }
  }
  return reviver.call(obj, key, val);
}
var init_applyReviver = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/doc/applyReviver.js"() {
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/doc/Document.js
function assertCollection2(contents) {
  if (isCollection2(contents))
    return true;
  throw new Error("Expected a YAML collection as document contents");
}
var Document2;
var init_Document = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/doc/Document.js"() {
    init_Alias();
    init_Collection();
    init_Node();
    init_Pair();
    init_toJS();
    init_Schema();
    init_stringify();
    init_stringifyDocument();
    init_anchors();
    init_applyReviver();
    init_createNode();
    init_directives();
    Document2 = class {
      constructor(value2, replacer, options3) {
        this.commentBefore = null;
        this.comment = null;
        this.errors = [];
        this.warnings = [];
        Object.defineProperty(this, NODE_TYPE2, { value: DOC2 });
        let _replacer = null;
        if (typeof replacer === "function" || Array.isArray(replacer)) {
          _replacer = replacer;
        } else if (options3 === void 0 && replacer) {
          options3 = replacer;
          replacer = void 0;
        }
        const opt = Object.assign({
          intAsBigInt: false,
          keepSourceTokens: false,
          logLevel: "warn",
          prettyErrors: true,
          strict: true,
          uniqueKeys: true,
          version: "1.2"
        }, options3);
        this.options = opt;
        let { version: version4 } = opt;
        if (options3 == null ? void 0 : options3._directives) {
          this.directives = options3._directives.atDocument();
          if (this.directives.yaml.explicit)
            version4 = this.directives.yaml.version;
        } else
          this.directives = new Directives2({ version: version4 });
        this.setSchema(version4, options3);
        if (value2 === void 0)
          this.contents = null;
        else {
          this.contents = this.createNode(value2, _replacer, options3);
        }
      }
      /**
       * Create a deep copy of this Document and its contents.
       *
       * Custom Node values that inherit from `Object` still refer to their original instances.
       */
      clone() {
        const copy = Object.create(Document2.prototype, {
          [NODE_TYPE2]: { value: DOC2 }
        });
        copy.commentBefore = this.commentBefore;
        copy.comment = this.comment;
        copy.errors = this.errors.slice();
        copy.warnings = this.warnings.slice();
        copy.options = Object.assign({}, this.options);
        if (this.directives)
          copy.directives = this.directives.clone();
        copy.schema = this.schema.clone();
        copy.contents = isNode2(this.contents) ? this.contents.clone(copy.schema) : this.contents;
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /** Adds a value to the document. */
      add(value2) {
        if (assertCollection2(this.contents))
          this.contents.add(value2);
      }
      /** Adds a value to the document. */
      addIn(path8, value2) {
        if (assertCollection2(this.contents))
          this.contents.addIn(path8, value2);
      }
      /**
       * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
       *
       * If `node` already has an anchor, `name` is ignored.
       * Otherwise, the `node.anchor` value will be set to `name`,
       * or if an anchor with that name is already present in the document,
       * `name` will be used as a prefix for a new unique anchor.
       * If `name` is undefined, the generated anchor will use 'a' as a prefix.
       */
      createAlias(node3, name2) {
        if (!node3.anchor) {
          const prev = anchorNames2(this);
          node3.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          !name2 || prev.has(name2) ? findNewAnchor2(name2 || "a", prev) : name2;
        }
        return new Alias2(node3.anchor);
      }
      createNode(value2, replacer, options3) {
        let _replacer = void 0;
        if (typeof replacer === "function") {
          value2 = replacer.call({ "": value2 }, "", value2);
          _replacer = replacer;
        } else if (Array.isArray(replacer)) {
          const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
          const asStr = replacer.filter(keyToStr).map(String);
          if (asStr.length > 0)
            replacer = replacer.concat(asStr);
          _replacer = replacer;
        } else if (options3 === void 0 && replacer) {
          options3 = replacer;
          replacer = void 0;
        }
        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options3 ?? {};
        const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors2(
          this,
          // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          anchorPrefix || "a"
        );
        const ctx2 = {
          aliasDuplicateObjects: aliasDuplicateObjects ?? true,
          keepUndefined: keepUndefined ?? false,
          onAnchor,
          onTagObj,
          replacer: _replacer,
          schema: this.schema,
          sourceObjects
        };
        const node3 = createNode2(value2, tag, ctx2);
        if (flow && isCollection2(node3))
          node3.flow = true;
        setAnchors();
        return node3;
      }
      /**
       * Convert a key and a value into a `Pair` using the current schema,
       * recursively wrapping all values as `Scalar` or `Collection` nodes.
       */
      createPair(key, value2, options3 = {}) {
        const k = this.createNode(key, null, options3);
        const v = this.createNode(value2, null, options3);
        return new Pair2(k, v);
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        return assertCollection2(this.contents) ? this.contents.delete(key) : false;
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path8) {
        if (isEmptyPath2(path8)) {
          if (this.contents == null)
            return false;
          this.contents = null;
          return true;
        }
        return assertCollection2(this.contents) ? this.contents.deleteIn(path8) : false;
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      get(key, keepScalar) {
        return isCollection2(this.contents) ? this.contents.get(key, keepScalar) : void 0;
      }
      /**
       * Returns item at `path`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path8, keepScalar) {
        if (isEmptyPath2(path8))
          return !keepScalar && isScalar2(this.contents) ? this.contents.value : this.contents;
        return isCollection2(this.contents) ? this.contents.getIn(path8, keepScalar) : void 0;
      }
      /**
       * Checks if the document includes a value with the key `key`.
       */
      has(key) {
        return isCollection2(this.contents) ? this.contents.has(key) : false;
      }
      /**
       * Checks if the document includes a value at `path`.
       */
      hasIn(path8) {
        if (isEmptyPath2(path8))
          return this.contents !== void 0;
        return isCollection2(this.contents) ? this.contents.hasIn(path8) : false;
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      set(key, value2) {
        if (this.contents == null) {
          this.contents = collectionFromPath2(this.schema, [key], value2);
        } else if (assertCollection2(this.contents)) {
          this.contents.set(key, value2);
        }
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path8, value2) {
        if (isEmptyPath2(path8))
          this.contents = value2;
        else if (this.contents == null) {
          this.contents = collectionFromPath2(this.schema, Array.from(path8), value2);
        } else if (assertCollection2(this.contents)) {
          this.contents.setIn(path8, value2);
        }
      }
      /**
       * Change the YAML version and schema used by the document.
       * A `null` version disables support for directives, explicit tags, anchors, and aliases.
       * It also requires the `schema` option to be given as a `Schema` instance value.
       *
       * Overrides all previously set schema options.
       */
      setSchema(version4, options3 = {}) {
        if (typeof version4 === "number")
          version4 = String(version4);
        let opt;
        switch (version4) {
          case "1.1":
            if (this.directives)
              this.directives.yaml.version = "1.1";
            else
              this.directives = new Directives2({ version: "1.1" });
            opt = { merge: true, resolveKnownTags: false, schema: "yaml-1.1" };
            break;
          case "1.2":
          case "next":
            if (this.directives)
              this.directives.yaml.version = version4;
            else
              this.directives = new Directives2({ version: version4 });
            opt = { merge: false, resolveKnownTags: true, schema: "core" };
            break;
          case null:
            if (this.directives)
              delete this.directives;
            opt = null;
            break;
          default: {
            const sv = JSON.stringify(version4);
            throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
          }
        }
        if (options3.schema instanceof Object)
          this.schema = options3.schema;
        else if (opt)
          this.schema = new Schema2(Object.assign(opt, options3));
        else
          throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
      }
      // json & jsonArg are only used from toJSON()
      toJS({ json: json2, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        const ctx2 = {
          anchors: /* @__PURE__ */ new Map(),
          doc: this,
          keep: !json2,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100,
          stringify: stringify2
        };
        const res = toJS2(this.contents, jsonArg ?? "", ctx2);
        if (typeof onAnchor === "function")
          for (const { count, res: res2 } of ctx2.anchors.values())
            onAnchor(res2, count);
        return typeof reviver === "function" ? applyReviver2(reviver, { "": res }, "", res) : res;
      }
      /**
       * A JSON representation of the document `contents`.
       *
       * @param jsonArg Used by `JSON.stringify` to indicate the array index or
       *   property name.
       */
      toJSON(jsonArg, onAnchor) {
        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
      }
      /** A YAML representation of the document. */
      toString(options3 = {}) {
        if (this.errors.length > 0)
          throw new Error("Document with errors cannot be stringified");
        if ("indent" in options3 && (!Number.isInteger(options3.indent) || Number(options3.indent) <= 0)) {
          const s2 = JSON.stringify(options3.indent);
          throw new Error(`"indent" option must be a positive integer, not ${s2}`);
        }
        return stringifyDocument2(this, options3);
      }
    };
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/errors.js
var YAMLError2, YAMLParseError2, YAMLWarning2, prettifyError2;
var init_errors = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/errors.js"() {
    YAMLError2 = class extends Error {
      constructor(name2, pos, code, message) {
        super();
        this.name = name2;
        this.code = code;
        this.message = message;
        this.pos = pos;
      }
    };
    YAMLParseError2 = class extends YAMLError2 {
      constructor(pos, code, message) {
        super("YAMLParseError", pos, code, message);
      }
    };
    YAMLWarning2 = class extends YAMLError2 {
      constructor(pos, code, message) {
        super("YAMLWarning", pos, code, message);
      }
    };
    prettifyError2 = (src3, lc) => (error3) => {
      if (error3.pos[0] === -1)
        return;
      error3.linePos = error3.pos.map((pos) => lc.linePos(pos));
      const { line, col } = error3.linePos[0];
      error3.message += ` at line ${line}, column ${col}`;
      let ci = col - 1;
      let lineStr = src3.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
      if (ci >= 60 && lineStr.length > 80) {
        const trimStart = Math.min(ci - 39, lineStr.length - 79);
        lineStr = "…" + lineStr.substring(trimStart);
        ci -= trimStart - 1;
      }
      if (lineStr.length > 80)
        lineStr = lineStr.substring(0, 79) + "…";
      if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
        let prev = src3.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
        if (prev.length > 80)
          prev = prev.substring(0, 79) + "…\n";
        lineStr = prev + lineStr;
      }
      if (/[^ ]/.test(lineStr)) {
        let count = 1;
        const end = error3.linePos[1];
        if (end && end.line === line && end.col > col) {
          count = Math.max(1, Math.min(end.col - col, 80 - ci));
        }
        const pointer = " ".repeat(ci) + "^".repeat(count);
        error3.message += `:

${lineStr}
${pointer}
`;
      }
    };
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/compose/resolve-props.js
function resolveProps2(tokens, { flow, indicator, next, offset: offset3, onError, startOnNewline }) {
  let spaceBefore = false;
  let atNewline = startOnNewline;
  let hasSpace = startOnNewline;
  let comment2 = "";
  let commentSep = "";
  let hasNewline = false;
  let hasNewlineAfterProp = false;
  let reqSpace = false;
  let anchor = null;
  let tag = null;
  let comma3 = null;
  let found2 = null;
  let start = null;
  for (const token of tokens) {
    if (reqSpace) {
      if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
        onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      reqSpace = false;
    }
    switch (token.type) {
      case "space":
        if (!flow && atNewline && indicator !== "doc-start" && token.source[0] === "	")
          onError(token, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
        hasSpace = true;
        break;
      case "comment": {
        if (!hasSpace)
          onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const cb = token.source.substring(1) || " ";
        if (!comment2)
          comment2 = cb;
        else
          comment2 += commentSep + cb;
        commentSep = "";
        atNewline = false;
        break;
      }
      case "newline":
        if (atNewline) {
          if (comment2)
            comment2 += token.source;
          else
            spaceBefore = true;
        } else
          commentSep += token.source;
        atNewline = true;
        hasNewline = true;
        if (anchor || tag)
          hasNewlineAfterProp = true;
        hasSpace = true;
        break;
      case "anchor":
        if (anchor)
          onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
        if (token.source.endsWith(":"))
          onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
        anchor = token;
        if (start === null)
          start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      case "tag": {
        if (tag)
          onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
        tag = token;
        if (start === null)
          start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      }
      case indicator:
        if (anchor || tag)
          onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
        if (found2)
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
        found2 = token;
        atNewline = false;
        hasSpace = false;
        break;
      case "comma":
        if (flow) {
          if (comma3)
            onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
          comma3 = token;
          atNewline = false;
          hasSpace = false;
          break;
        }
      default:
        onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
        atNewline = false;
        hasSpace = false;
    }
  }
  const last = tokens[tokens.length - 1];
  const end = last ? last.offset + last.source.length : offset3;
  if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== ""))
    onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
  return {
    comma: comma3,
    found: found2,
    spaceBefore,
    comment: comment2,
    hasNewline,
    hasNewlineAfterProp,
    anchor,
    tag,
    end,
    start: start ?? end
  };
}
var init_resolve_props = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/compose/resolve-props.js"() {
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/compose/util-contains-newline.js
function containsNewline2(key) {
  if (!key)
    return null;
  switch (key.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (key.source.includes("\n"))
        return true;
      if (key.end) {
        for (const st of key.end)
          if (st.type === "newline")
            return true;
      }
      return false;
    case "flow-collection":
      for (const it of key.items) {
        for (const st of it.start)
          if (st.type === "newline")
            return true;
        if (it.sep) {
          for (const st of it.sep)
            if (st.type === "newline")
              return true;
        }
        if (containsNewline2(it.key) || containsNewline2(it.value))
          return true;
      }
      return false;
    default:
      return true;
  }
}
var init_util_contains_newline = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/compose/util-contains-newline.js"() {
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/compose/util-flow-indent-check.js
function flowIndentCheck2(indent, fc, onError) {
  if ((fc == null ? void 0 : fc.type) === "flow-collection") {
    const end = fc.end[0];
    if (end.indent === indent && (end.source === "]" || end.source === "}") && containsNewline2(fc)) {
      const msg = "Flow end indicator should be more indented than parent";
      onError(end, "BAD_INDENT", msg, true);
    }
  }
}
var init_util_flow_indent_check = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/compose/util-flow-indent-check.js"() {
    init_util_contains_newline();
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/compose/util-map-includes.js
function mapIncludes2(ctx2, items, search) {
  const { uniqueKeys } = ctx2.options;
  if (uniqueKeys === false)
    return false;
  const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a2, b) => a2 === b || isScalar2(a2) && isScalar2(b) && a2.value === b.value && !(a2.value === "<<" && ctx2.schema.merge);
  return items.some((pair) => isEqual(pair.key, search));
}
var init_util_map_includes = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/compose/util-map-includes.js"() {
    init_Node();
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/compose/resolve-block-map.js
function resolveBlockMap2({ composeNode: composeNode3, composeEmptyNode: composeEmptyNode3 }, ctx2, bm, onError) {
  var _a;
  const map3 = new YAMLMap2(ctx2.schema);
  if (ctx2.atRoot)
    ctx2.atRoot = false;
  let offset3 = bm.offset;
  let commentEnd = null;
  for (const collItem of bm.items) {
    const { start, key, sep: sep2, value: value2 } = collItem;
    const keyProps = resolveProps2(start, {
      indicator: "explicit-key-ind",
      next: key ?? (sep2 == null ? void 0 : sep2[0]),
      offset: offset3,
      onError,
      startOnNewline: true
    });
    const implicitKey = !keyProps.found;
    if (implicitKey) {
      if (key) {
        if (key.type === "block-seq")
          onError(offset3, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
        else if ("indent" in key && key.indent !== bm.indent)
          onError(offset3, "BAD_INDENT", startColMsg2);
      }
      if (!keyProps.anchor && !keyProps.tag && !sep2) {
        commentEnd = keyProps.end;
        if (keyProps.comment) {
          if (map3.comment)
            map3.comment += "\n" + keyProps.comment;
          else
            map3.comment = keyProps.comment;
        }
        continue;
      }
      if (keyProps.hasNewlineAfterProp || containsNewline2(key)) {
        onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
      }
    } else if (((_a = keyProps.found) == null ? void 0 : _a.indent) !== bm.indent) {
      onError(offset3, "BAD_INDENT", startColMsg2);
    }
    const keyStart = keyProps.end;
    const keyNode = key ? composeNode3(ctx2, key, keyProps, onError) : composeEmptyNode3(ctx2, keyStart, start, null, keyProps, onError);
    if (ctx2.schema.compat)
      flowIndentCheck2(bm.indent, key, onError);
    if (mapIncludes2(ctx2, map3.items, keyNode))
      onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
    const valueProps = resolveProps2(sep2 ?? [], {
      indicator: "map-value-ind",
      next: value2,
      offset: keyNode.range[2],
      onError,
      startOnNewline: !key || key.type === "block-scalar"
    });
    offset3 = valueProps.end;
    if (valueProps.found) {
      if (implicitKey) {
        if ((value2 == null ? void 0 : value2.type) === "block-map" && !valueProps.hasNewline)
          onError(offset3, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
        if (ctx2.options.strict && keyProps.start < valueProps.found.offset - 1024)
          onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
      }
      const valueNode = value2 ? composeNode3(ctx2, value2, valueProps, onError) : composeEmptyNode3(ctx2, offset3, sep2, null, valueProps, onError);
      if (ctx2.schema.compat)
        flowIndentCheck2(bm.indent, value2, onError);
      offset3 = valueNode.range[2];
      const pair = new Pair2(keyNode, valueNode);
      if (ctx2.options.keepSourceTokens)
        pair.srcToken = collItem;
      map3.items.push(pair);
    } else {
      if (implicitKey)
        onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
      if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair2(keyNode);
      if (ctx2.options.keepSourceTokens)
        pair.srcToken = collItem;
      map3.items.push(pair);
    }
  }
  if (commentEnd && commentEnd < offset3)
    onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
  map3.range = [bm.offset, offset3, commentEnd ?? offset3];
  return map3;
}
var startColMsg2;
var init_resolve_block_map = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/compose/resolve-block-map.js"() {
    init_Pair();
    init_YAMLMap();
    init_resolve_props();
    init_util_contains_newline();
    init_util_flow_indent_check();
    init_util_map_includes();
    startColMsg2 = "All mapping items must start at the same column";
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/compose/resolve-block-seq.js
function resolveBlockSeq2({ composeNode: composeNode3, composeEmptyNode: composeEmptyNode3 }, ctx2, bs, onError) {
  const seq3 = new YAMLSeq2(ctx2.schema);
  if (ctx2.atRoot)
    ctx2.atRoot = false;
  let offset3 = bs.offset;
  let commentEnd = null;
  for (const { start, value: value2 } of bs.items) {
    const props = resolveProps2(start, {
      indicator: "seq-item-ind",
      next: value2,
      offset: offset3,
      onError,
      startOnNewline: true
    });
    if (!props.found) {
      if (props.anchor || props.tag || value2) {
        if (value2 && value2.type === "block-seq")
          onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
        else
          onError(offset3, "MISSING_CHAR", "Sequence item without - indicator");
      } else {
        commentEnd = props.end;
        if (props.comment)
          seq3.comment = props.comment;
        continue;
      }
    }
    const node3 = value2 ? composeNode3(ctx2, value2, props, onError) : composeEmptyNode3(ctx2, props.end, start, null, props, onError);
    if (ctx2.schema.compat)
      flowIndentCheck2(bs.indent, value2, onError);
    offset3 = node3.range[2];
    seq3.items.push(node3);
  }
  seq3.range = [bs.offset, offset3, commentEnd ?? offset3];
  return seq3;
}
var init_resolve_block_seq = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/compose/resolve-block-seq.js"() {
    init_YAMLSeq();
    init_resolve_props();
    init_util_flow_indent_check();
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/compose/resolve-end.js
function resolveEnd2(end, offset3, reqSpace, onError) {
  let comment2 = "";
  if (end) {
    let hasSpace = false;
    let sep2 = "";
    for (const token of end) {
      const { source, type } = token;
      switch (type) {
        case "space":
          hasSpace = true;
          break;
        case "comment": {
          if (reqSpace && !hasSpace)
            onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = source.substring(1) || " ";
          if (!comment2)
            comment2 = cb;
          else
            comment2 += sep2 + cb;
          sep2 = "";
          break;
        }
        case "newline":
          if (comment2)
            sep2 += source;
          hasSpace = true;
          break;
        default:
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
      }
      offset3 += source.length;
    }
  }
  return { comment: comment2, offset: offset3 };
}
var init_resolve_end = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/compose/resolve-end.js"() {
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/compose/resolve-flow-collection.js
function resolveFlowCollection2({ composeNode: composeNode3, composeEmptyNode: composeEmptyNode3 }, ctx2, fc, onError) {
  const isMap3 = fc.start.source === "{";
  const fcName = isMap3 ? "flow map" : "flow sequence";
  const coll = isMap3 ? new YAMLMap2(ctx2.schema) : new YAMLSeq2(ctx2.schema);
  coll.flow = true;
  const atRoot = ctx2.atRoot;
  if (atRoot)
    ctx2.atRoot = false;
  let offset3 = fc.offset + fc.start.source.length;
  for (let i2 = 0; i2 < fc.items.length; ++i2) {
    const collItem = fc.items[i2];
    const { start, key, sep: sep2, value: value2 } = collItem;
    const props = resolveProps2(start, {
      flow: fcName,
      indicator: "explicit-key-ind",
      next: key ?? (sep2 == null ? void 0 : sep2[0]),
      offset: offset3,
      onError,
      startOnNewline: false
    });
    if (!props.found) {
      if (!props.anchor && !props.tag && !sep2 && !value2) {
        if (i2 === 0 && props.comma)
          onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        else if (i2 < fc.items.length - 1)
          onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
        if (props.comment) {
          if (coll.comment)
            coll.comment += "\n" + props.comment;
          else
            coll.comment = props.comment;
        }
        offset3 = props.end;
        continue;
      }
      if (!isMap3 && ctx2.options.strict && containsNewline2(key))
        onError(
          key,
          // checked by containsNewline()
          "MULTILINE_IMPLICIT_KEY",
          "Implicit keys of flow sequence pairs need to be on a single line"
        );
    }
    if (i2 === 0) {
      if (props.comma)
        onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
    } else {
      if (!props.comma)
        onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
      if (props.comment) {
        let prevItemComment = "";
        loop:
          for (const st of start) {
            switch (st.type) {
              case "comma":
              case "space":
                break;
              case "comment":
                prevItemComment = st.source.substring(1);
                break loop;
              default:
                break loop;
            }
          }
        if (prevItemComment) {
          let prev = coll.items[coll.items.length - 1];
          if (isPair2(prev))
            prev = prev.value ?? prev.key;
          if (prev.comment)
            prev.comment += "\n" + prevItemComment;
          else
            prev.comment = prevItemComment;
          props.comment = props.comment.substring(prevItemComment.length + 1);
        }
      }
    }
    if (!isMap3 && !sep2 && !props.found) {
      const valueNode = value2 ? composeNode3(ctx2, value2, props, onError) : composeEmptyNode3(ctx2, props.end, sep2, null, props, onError);
      coll.items.push(valueNode);
      offset3 = valueNode.range[2];
      if (isBlock2(value2))
        onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg2);
    } else {
      const keyStart = props.end;
      const keyNode = key ? composeNode3(ctx2, key, props, onError) : composeEmptyNode3(ctx2, keyStart, start, null, props, onError);
      if (isBlock2(key))
        onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg2);
      const valueProps = resolveProps2(sep2 ?? [], {
        flow: fcName,
        indicator: "map-value-ind",
        next: value2,
        offset: keyNode.range[2],
        onError,
        startOnNewline: false
      });
      if (valueProps.found) {
        if (!isMap3 && !props.found && ctx2.options.strict) {
          if (sep2)
            for (const st of sep2) {
              if (st === valueProps.found)
                break;
              if (st.type === "newline") {
                onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          if (props.start < valueProps.found.offset - 1024)
            onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else if (value2) {
        if ("source" in value2 && value2.source && value2.source[0] === ":")
          onError(value2, "MISSING_CHAR", `Missing space after : in ${fcName}`);
        else
          onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
      }
      const valueNode = value2 ? composeNode3(ctx2, value2, valueProps, onError) : valueProps.found ? composeEmptyNode3(ctx2, valueProps.end, sep2, null, valueProps, onError) : null;
      if (valueNode) {
        if (isBlock2(value2))
          onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg2);
      } else if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair2(keyNode, valueNode);
      if (ctx2.options.keepSourceTokens)
        pair.srcToken = collItem;
      if (isMap3) {
        const map3 = coll;
        if (mapIncludes2(ctx2, map3.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        map3.items.push(pair);
      } else {
        const map3 = new YAMLMap2(ctx2.schema);
        map3.flow = true;
        map3.items.push(pair);
        coll.items.push(map3);
      }
      offset3 = valueNode ? valueNode.range[2] : valueProps.end;
    }
  }
  const expectedEnd = isMap3 ? "}" : "]";
  const [ce, ...ee] = fc.end;
  let cePos = offset3;
  if (ce && ce.source === expectedEnd)
    cePos = ce.offset + ce.source.length;
  else {
    const name2 = fcName[0].toUpperCase() + fcName.substring(1);
    const msg = atRoot ? `${name2} must end with a ${expectedEnd}` : `${name2} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
    onError(offset3, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
    if (ce && ce.source.length !== 1)
      ee.unshift(ce);
  }
  if (ee.length > 0) {
    const end = resolveEnd2(ee, cePos, ctx2.options.strict, onError);
    if (end.comment) {
      if (coll.comment)
        coll.comment += "\n" + end.comment;
      else
        coll.comment = end.comment;
    }
    coll.range = [fc.offset, cePos, end.offset];
  } else {
    coll.range = [fc.offset, cePos, cePos];
  }
  return coll;
}
var blockMsg2, isBlock2;
var init_resolve_flow_collection = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/compose/resolve-flow-collection.js"() {
    init_Node();
    init_Pair();
    init_YAMLMap();
    init_YAMLSeq();
    init_resolve_end();
    init_resolve_props();
    init_util_contains_newline();
    init_util_map_includes();
    blockMsg2 = "Block collections are not allowed within flow collections";
    isBlock2 = (token) => token && (token.type === "block-map" || token.type === "block-seq");
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/compose/compose-collection.js
function composeCollection2(CN3, ctx2, token, tagToken, onError) {
  let coll;
  switch (token.type) {
    case "block-map": {
      coll = resolveBlockMap2(CN3, ctx2, token, onError);
      break;
    }
    case "block-seq": {
      coll = resolveBlockSeq2(CN3, ctx2, token, onError);
      break;
    }
    case "flow-collection": {
      coll = resolveFlowCollection2(CN3, ctx2, token, onError);
      break;
    }
  }
  if (!tagToken)
    return coll;
  const tagName = ctx2.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
  if (!tagName)
    return coll;
  const Coll = coll.constructor;
  if (tagName === "!" || tagName === Coll.tagName) {
    coll.tag = Coll.tagName;
    return coll;
  }
  const expType = isMap2(coll) ? "map" : "seq";
  let tag = ctx2.schema.tags.find((t3) => t3.collection === expType && t3.tag === tagName);
  if (!tag) {
    const kt = ctx2.schema.knownTags[tagName];
    if (kt && kt.collection === expType) {
      ctx2.schema.tags.push(Object.assign({}, kt, { default: false }));
      tag = kt;
    } else {
      onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
      coll.tag = tagName;
      return coll;
    }
  }
  const res = tag.resolve(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx2.options);
  const node3 = isNode2(res) ? res : new Scalar2(res);
  node3.range = coll.range;
  node3.tag = tagName;
  if (tag == null ? void 0 : tag.format)
    node3.format = tag.format;
  return node3;
}
var init_compose_collection = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/compose/compose-collection.js"() {
    init_Node();
    init_Scalar();
    init_resolve_block_map();
    init_resolve_block_seq();
    init_resolve_flow_collection();
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/compose/resolve-block-scalar.js
function resolveBlockScalar2(scalar, strict, onError) {
  const start = scalar.offset;
  const header = parseBlockScalarHeader2(scalar, strict, onError);
  if (!header)
    return { value: "", type: null, comment: "", range: [start, start, start] };
  const type = header.mode === ">" ? Scalar2.BLOCK_FOLDED : Scalar2.BLOCK_LITERAL;
  const lines = scalar.source ? splitLines2(scalar.source) : [];
  let chompStart = lines.length;
  for (let i2 = lines.length - 1; i2 >= 0; --i2) {
    const content = lines[i2][1];
    if (content === "" || content === "\r")
      chompStart = i2;
    else
      break;
  }
  if (chompStart === 0) {
    const value3 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
    let end2 = start + header.length;
    if (scalar.source)
      end2 += scalar.source.length;
    return { value: value3, type, comment: header.comment, range: [start, end2, end2] };
  }
  let trimIndent = scalar.indent + header.indent;
  let offset3 = scalar.offset + header.length;
  let contentStart = 0;
  for (let i2 = 0; i2 < chompStart; ++i2) {
    const [indent, content] = lines[i2];
    if (content === "" || content === "\r") {
      if (header.indent === 0 && indent.length > trimIndent)
        trimIndent = indent.length;
    } else {
      if (indent.length < trimIndent) {
        const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
        onError(offset3 + indent.length, "MISSING_CHAR", message);
      }
      if (header.indent === 0)
        trimIndent = indent.length;
      contentStart = i2;
      break;
    }
    offset3 += indent.length + content.length + 1;
  }
  for (let i2 = lines.length - 1; i2 >= chompStart; --i2) {
    if (lines[i2][0].length > trimIndent)
      chompStart = i2 + 1;
  }
  let value2 = "";
  let sep2 = "";
  let prevMoreIndented = false;
  for (let i2 = 0; i2 < contentStart; ++i2)
    value2 += lines[i2][0].slice(trimIndent) + "\n";
  for (let i2 = contentStart; i2 < chompStart; ++i2) {
    let [indent, content] = lines[i2];
    offset3 += indent.length + content.length + 1;
    const crlf = content[content.length - 1] === "\r";
    if (crlf)
      content = content.slice(0, -1);
    if (content && indent.length < trimIndent) {
      const src3 = header.indent ? "explicit indentation indicator" : "first line";
      const message = `Block scalar lines must not be less indented than their ${src3}`;
      onError(offset3 - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
      indent = "";
    }
    if (type === Scalar2.BLOCK_LITERAL) {
      value2 += sep2 + indent.slice(trimIndent) + content;
      sep2 = "\n";
    } else if (indent.length > trimIndent || content[0] === "	") {
      if (sep2 === " ")
        sep2 = "\n";
      else if (!prevMoreIndented && sep2 === "\n")
        sep2 = "\n\n";
      value2 += sep2 + indent.slice(trimIndent) + content;
      sep2 = "\n";
      prevMoreIndented = true;
    } else if (content === "") {
      if (sep2 === "\n")
        value2 += "\n";
      else
        sep2 = "\n";
    } else {
      value2 += sep2 + content;
      sep2 = " ";
      prevMoreIndented = false;
    }
  }
  switch (header.chomp) {
    case "-":
      break;
    case "+":
      for (let i2 = chompStart; i2 < lines.length; ++i2)
        value2 += "\n" + lines[i2][0].slice(trimIndent);
      if (value2[value2.length - 1] !== "\n")
        value2 += "\n";
      break;
    default:
      value2 += "\n";
  }
  const end = start + header.length + scalar.source.length;
  return { value: value2, type, comment: header.comment, range: [start, end, end] };
}
function parseBlockScalarHeader2({ offset: offset3, props }, strict, onError) {
  if (props[0].type !== "block-scalar-header") {
    onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
    return null;
  }
  const { source } = props[0];
  const mode2 = source[0];
  let indent = 0;
  let chomp = "";
  let error3 = -1;
  for (let i2 = 1; i2 < source.length; ++i2) {
    const ch = source[i2];
    if (!chomp && (ch === "-" || ch === "+"))
      chomp = ch;
    else {
      const n3 = Number(ch);
      if (!indent && n3)
        indent = n3;
      else if (error3 === -1)
        error3 = offset3 + i2;
    }
  }
  if (error3 !== -1)
    onError(error3, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
  let hasSpace = false;
  let comment2 = "";
  let length = source.length;
  for (let i2 = 1; i2 < props.length; ++i2) {
    const token = props[i2];
    switch (token.type) {
      case "space":
        hasSpace = true;
      case "newline":
        length += token.source.length;
        break;
      case "comment":
        if (strict && !hasSpace) {
          const message = "Comments must be separated from other tokens by white space characters";
          onError(token, "MISSING_CHAR", message);
        }
        length += token.source.length;
        comment2 = token.source.substring(1);
        break;
      case "error":
        onError(token, "UNEXPECTED_TOKEN", token.message);
        length += token.source.length;
        break;
      default: {
        const message = `Unexpected token in block scalar header: ${token.type}`;
        onError(token, "UNEXPECTED_TOKEN", message);
        const ts = token.source;
        if (ts && typeof ts === "string")
          length += ts.length;
      }
    }
  }
  return { mode: mode2, indent, chomp, comment: comment2, length };
}
function splitLines2(source) {
  const split = source.split(/\n( *)/);
  const first2 = split[0];
  const m = first2.match(/^( *)/);
  const line0 = (m == null ? void 0 : m[1]) ? [m[1], first2.slice(m[1].length)] : ["", first2];
  const lines = [line0];
  for (let i2 = 1; i2 < split.length; i2 += 2)
    lines.push([split[i2], split[i2 + 1]]);
  return lines;
}
var init_resolve_block_scalar = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/compose/resolve-block-scalar.js"() {
    init_Scalar();
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js
function resolveFlowScalar2(scalar, strict, onError) {
  const { offset: offset3, type, source, end } = scalar;
  let _type;
  let value2;
  const _onError = (rel, code, msg) => onError(offset3 + rel, code, msg);
  switch (type) {
    case "scalar":
      _type = Scalar2.PLAIN;
      value2 = plainValue2(source, _onError);
      break;
    case "single-quoted-scalar":
      _type = Scalar2.QUOTE_SINGLE;
      value2 = singleQuotedValue2(source, _onError);
      break;
    case "double-quoted-scalar":
      _type = Scalar2.QUOTE_DOUBLE;
      value2 = doubleQuotedValue2(source, _onError);
      break;
    default:
      onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
      return {
        value: "",
        type: null,
        comment: "",
        range: [offset3, offset3 + source.length, offset3 + source.length]
      };
  }
  const valueEnd = offset3 + source.length;
  const re = resolveEnd2(end, valueEnd, strict, onError);
  return {
    value: value2,
    type: _type,
    comment: re.comment,
    range: [offset3, valueEnd, re.offset]
  };
}
function plainValue2(source, onError) {
  let badChar = "";
  switch (source[0]) {
    case "	":
      badChar = "a tab character";
      break;
    case ",":
      badChar = "flow indicator character ,";
      break;
    case "%":
      badChar = "directive indicator character %";
      break;
    case "|":
    case ">": {
      badChar = `block scalar indicator ${source[0]}`;
      break;
    }
    case "@":
    case "`": {
      badChar = `reserved character ${source[0]}`;
      break;
    }
  }
  if (badChar)
    onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
  return foldLines2(source);
}
function singleQuotedValue2(source, onError) {
  if (source[source.length - 1] !== "'" || source.length === 1)
    onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
  return foldLines2(source.slice(1, -1)).replace(/''/g, "'");
}
function foldLines2(source) {
  let first2, line;
  try {
    first2 = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
    line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
  } catch (_) {
    first2 = /(.*?)[ \t]*\r?\n/sy;
    line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let match = first2.exec(source);
  if (!match)
    return source;
  let res = match[1];
  let sep2 = " ";
  let pos = first2.lastIndex;
  line.lastIndex = pos;
  while (match = line.exec(source)) {
    if (match[1] === "") {
      if (sep2 === "\n")
        res += sep2;
      else
        sep2 = "\n";
    } else {
      res += sep2 + match[1];
      sep2 = " ";
    }
    pos = line.lastIndex;
  }
  const last = /[ \t]*(.*)/sy;
  last.lastIndex = pos;
  match = last.exec(source);
  return res + sep2 + ((match == null ? void 0 : match[1]) ?? "");
}
function doubleQuotedValue2(source, onError) {
  let res = "";
  for (let i2 = 1; i2 < source.length - 1; ++i2) {
    const ch = source[i2];
    if (ch === "\r" && source[i2 + 1] === "\n")
      continue;
    if (ch === "\n") {
      const { fold, offset: offset3 } = foldNewline2(source, i2);
      res += fold;
      i2 = offset3;
    } else if (ch === "\\") {
      let next = source[++i2];
      const cc = escapeCodes2[next];
      if (cc)
        res += cc;
      else if (next === "\n") {
        next = source[i2 + 1];
        while (next === " " || next === "	")
          next = source[++i2 + 1];
      } else if (next === "\r" && source[i2 + 1] === "\n") {
        next = source[++i2 + 1];
        while (next === " " || next === "	")
          next = source[++i2 + 1];
      } else if (next === "x" || next === "u" || next === "U") {
        const length = { x: 2, u: 4, U: 8 }[next];
        res += parseCharCode2(source, i2 + 1, length, onError);
        i2 += length;
      } else {
        const raw = source.substr(i2 - 1, 2);
        onError(i2 - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        res += raw;
      }
    } else if (ch === " " || ch === "	") {
      const wsStart = i2;
      let next = source[i2 + 1];
      while (next === " " || next === "	")
        next = source[++i2 + 1];
      if (next !== "\n" && !(next === "\r" && source[i2 + 2] === "\n"))
        res += i2 > wsStart ? source.slice(wsStart, i2 + 1) : ch;
    } else {
      res += ch;
    }
  }
  if (source[source.length - 1] !== '"' || source.length === 1)
    onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
  return res;
}
function foldNewline2(source, offset3) {
  let fold = "";
  let ch = source[offset3 + 1];
  while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
    if (ch === "\r" && source[offset3 + 2] !== "\n")
      break;
    if (ch === "\n")
      fold += "\n";
    offset3 += 1;
    ch = source[offset3 + 1];
  }
  if (!fold)
    fold = " ";
  return { fold, offset: offset3 };
}
function parseCharCode2(source, offset3, length, onError) {
  const cc = source.substr(offset3, length);
  const ok2 = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
  const code = ok2 ? parseInt(cc, 16) : NaN;
  if (isNaN(code)) {
    const raw = source.substr(offset3 - 2, length + 2);
    onError(offset3 - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
    return raw;
  }
  return String.fromCodePoint(code);
}
var escapeCodes2;
var init_resolve_flow_scalar = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js"() {
    init_Scalar();
    init_resolve_end();
    escapeCodes2 = {
      "0": "\0",
      a: "\x07",
      b: "\b",
      e: "\x1B",
      f: "\f",
      n: "\n",
      r: "\r",
      t: "	",
      v: "\v",
      N: "",
      _: " ",
      L: "\u2028",
      P: "\u2029",
      " ": " ",
      '"': '"',
      "/": "/",
      "\\": "\\",
      "	": "	"
    };
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/compose/compose-scalar.js
function composeScalar2(ctx2, token, tagToken, onError) {
  const { value: value2, type, comment: comment2, range: range2 } = token.type === "block-scalar" ? resolveBlockScalar2(token, ctx2.options.strict, onError) : resolveFlowScalar2(token, ctx2.options.strict, onError);
  const tagName = tagToken ? ctx2.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
  const tag = tagToken && tagName ? findScalarTagByName2(ctx2.schema, value2, tagName, tagToken, onError) : token.type === "scalar" ? findScalarTagByTest2(ctx2, value2, token, onError) : ctx2.schema[SCALAR2];
  let scalar;
  try {
    const res = tag.resolve(value2, (msg) => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx2.options);
    scalar = isScalar2(res) ? res : new Scalar2(res);
  } catch (error3) {
    const msg = error3 instanceof Error ? error3.message : String(error3);
    onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
    scalar = new Scalar2(value2);
  }
  scalar.range = range2;
  scalar.source = value2;
  if (type)
    scalar.type = type;
  if (tagName)
    scalar.tag = tagName;
  if (tag.format)
    scalar.format = tag.format;
  if (comment2)
    scalar.comment = comment2;
  return scalar;
}
function findScalarTagByName2(schema5, value2, tagName, tagToken, onError) {
  var _a;
  if (tagName === "!")
    return schema5[SCALAR2];
  const matchWithTest = [];
  for (const tag of schema5.tags) {
    if (!tag.collection && tag.tag === tagName) {
      if (tag.default && tag.test)
        matchWithTest.push(tag);
      else
        return tag;
    }
  }
  for (const tag of matchWithTest)
    if ((_a = tag.test) == null ? void 0 : _a.test(value2))
      return tag;
  const kt = schema5.knownTags[tagName];
  if (kt && !kt.collection) {
    schema5.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
    return kt;
  }
  onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
  return schema5[SCALAR2];
}
function findScalarTagByTest2({ directives, schema: schema5 }, value2, token, onError) {
  const tag = schema5.tags.find((tag2) => {
    var _a;
    return tag2.default && ((_a = tag2.test) == null ? void 0 : _a.test(value2));
  }) || schema5[SCALAR2];
  if (schema5.compat) {
    const compat = schema5.compat.find((tag2) => {
      var _a;
      return tag2.default && ((_a = tag2.test) == null ? void 0 : _a.test(value2));
    }) ?? schema5[SCALAR2];
    if (tag.tag !== compat.tag) {
      const ts = directives.tagString(tag.tag);
      const cs = directives.tagString(compat.tag);
      const msg = `Value may be parsed as either ${ts} or ${cs}`;
      onError(token, "TAG_RESOLVE_FAILED", msg, true);
    }
  }
  return tag;
}
var init_compose_scalar = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/compose/compose-scalar.js"() {
    init_Node();
    init_Scalar();
    init_resolve_block_scalar();
    init_resolve_flow_scalar();
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/compose/util-empty-scalar-position.js
function emptyScalarPosition2(offset3, before, pos) {
  if (before) {
    if (pos === null)
      pos = before.length;
    for (let i2 = pos - 1; i2 >= 0; --i2) {
      let st = before[i2];
      switch (st.type) {
        case "space":
        case "comment":
        case "newline":
          offset3 -= st.source.length;
          continue;
      }
      st = before[++i2];
      while ((st == null ? void 0 : st.type) === "space") {
        offset3 += st.source.length;
        st = before[++i2];
      }
      break;
    }
  }
  return offset3;
}
var init_util_empty_scalar_position = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/compose/util-empty-scalar-position.js"() {
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/compose/compose-node.js
function composeNode2(ctx2, token, props, onError) {
  const { spaceBefore, comment: comment2, anchor, tag } = props;
  let node3;
  let isSrcToken = true;
  switch (token.type) {
    case "alias":
      node3 = composeAlias2(ctx2, token, onError);
      if (anchor || tag)
        onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      node3 = composeScalar2(ctx2, token, tag, onError);
      if (anchor)
        node3.anchor = anchor.source.substring(1);
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      node3 = composeCollection2(CN2, ctx2, token, tag, onError);
      if (anchor)
        node3.anchor = anchor.source.substring(1);
      break;
    default: {
      const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
      onError(token, "UNEXPECTED_TOKEN", message);
      node3 = composeEmptyNode2(ctx2, token.offset, void 0, null, props, onError);
      isSrcToken = false;
    }
  }
  if (anchor && node3.anchor === "")
    onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  if (spaceBefore)
    node3.spaceBefore = true;
  if (comment2) {
    if (token.type === "scalar" && token.source === "")
      node3.comment = comment2;
    else
      node3.commentBefore = comment2;
  }
  if (ctx2.options.keepSourceTokens && isSrcToken)
    node3.srcToken = token;
  return node3;
}
function composeEmptyNode2(ctx2, offset3, before, pos, { spaceBefore, comment: comment2, anchor, tag, end }, onError) {
  const token = {
    type: "scalar",
    offset: emptyScalarPosition2(offset3, before, pos),
    indent: -1,
    source: ""
  };
  const node3 = composeScalar2(ctx2, token, tag, onError);
  if (anchor) {
    node3.anchor = anchor.source.substring(1);
    if (node3.anchor === "")
      onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  }
  if (spaceBefore)
    node3.spaceBefore = true;
  if (comment2) {
    node3.comment = comment2;
    node3.range[2] = end;
  }
  return node3;
}
function composeAlias2({ options: options3 }, { offset: offset3, source, end }, onError) {
  const alias2 = new Alias2(source.substring(1));
  if (alias2.source === "")
    onError(offset3, "BAD_ALIAS", "Alias cannot be an empty string");
  if (alias2.source.endsWith(":"))
    onError(offset3 + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
  const valueEnd = offset3 + source.length;
  const re = resolveEnd2(end, valueEnd, options3.strict, onError);
  alias2.range = [offset3, valueEnd, re.offset];
  if (re.comment)
    alias2.comment = re.comment;
  return alias2;
}
var CN2;
var init_compose_node = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/compose/compose-node.js"() {
    init_Alias();
    init_compose_collection();
    init_compose_scalar();
    init_resolve_end();
    init_util_empty_scalar_position();
    CN2 = { composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 };
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/compose/compose-doc.js
function composeDoc2(options3, directives, { offset: offset3, start, value: value2, end }, onError) {
  const opts = Object.assign({ _directives: directives }, options3);
  const doc = new Document2(void 0, opts);
  const ctx2 = {
    atRoot: true,
    directives: doc.directives,
    options: doc.options,
    schema: doc.schema
  };
  const props = resolveProps2(start, {
    indicator: "doc-start",
    next: value2 ?? (end == null ? void 0 : end[0]),
    offset: offset3,
    onError,
    startOnNewline: true
  });
  if (props.found) {
    doc.directives.docStart = true;
    if (value2 && (value2.type === "block-map" || value2.type === "block-seq") && !props.hasNewline)
      onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
  }
  doc.contents = value2 ? composeNode2(ctx2, value2, props, onError) : composeEmptyNode2(ctx2, props.end, start, null, props, onError);
  const contentEnd = doc.contents.range[2];
  const re = resolveEnd2(end, contentEnd, false, onError);
  if (re.comment)
    doc.comment = re.comment;
  doc.range = [offset3, contentEnd, re.offset];
  return doc;
}
var init_compose_doc = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/compose/compose-doc.js"() {
    init_Document();
    init_compose_node();
    init_resolve_end();
    init_resolve_props();
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/compose/composer.js
function getErrorPos2(src3) {
  if (typeof src3 === "number")
    return [src3, src3 + 1];
  if (Array.isArray(src3))
    return src3.length === 2 ? src3 : [src3[0], src3[1]];
  const { offset: offset3, source } = src3;
  return [offset3, offset3 + (typeof source === "string" ? source.length : 1)];
}
function parsePrelude2(prelude) {
  var _a;
  let comment2 = "";
  let atComment = false;
  let afterEmptyLine = false;
  for (let i2 = 0; i2 < prelude.length; ++i2) {
    const source = prelude[i2];
    switch (source[0]) {
      case "#":
        comment2 += (comment2 === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
        atComment = true;
        afterEmptyLine = false;
        break;
      case "%":
        if (((_a = prelude[i2 + 1]) == null ? void 0 : _a[0]) !== "#")
          i2 += 1;
        atComment = false;
        break;
      default:
        if (!atComment)
          afterEmptyLine = true;
        atComment = false;
    }
  }
  return { comment: comment2, afterEmptyLine };
}
var Composer2;
var init_composer = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/compose/composer.js"() {
    init_directives();
    init_Document();
    init_errors();
    init_Node();
    init_compose_doc();
    init_resolve_end();
    Composer2 = class {
      constructor(options3 = {}) {
        this.doc = null;
        this.atDirectives = false;
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
        this.onError = (source, code, message, warning) => {
          const pos = getErrorPos2(source);
          if (warning)
            this.warnings.push(new YAMLWarning2(pos, code, message));
          else
            this.errors.push(new YAMLParseError2(pos, code, message));
        };
        this.directives = new Directives2({ version: options3.version || "1.2" });
        this.options = options3;
      }
      decorate(doc, afterDoc) {
        const { comment: comment2, afterEmptyLine } = parsePrelude2(this.prelude);
        if (comment2) {
          const dc = doc.contents;
          if (afterDoc) {
            doc.comment = doc.comment ? `${doc.comment}
${comment2}` : comment2;
          } else if (afterEmptyLine || doc.directives.docStart || !dc) {
            doc.commentBefore = comment2;
          } else if (isCollection2(dc) && !dc.flow && dc.items.length > 0) {
            let it = dc.items[0];
            if (isPair2(it))
              it = it.key;
            const cb = it.commentBefore;
            it.commentBefore = cb ? `${comment2}
${cb}` : comment2;
          } else {
            const cb = dc.commentBefore;
            dc.commentBefore = cb ? `${comment2}
${cb}` : comment2;
          }
        }
        if (afterDoc) {
          Array.prototype.push.apply(doc.errors, this.errors);
          Array.prototype.push.apply(doc.warnings, this.warnings);
        } else {
          doc.errors = this.errors;
          doc.warnings = this.warnings;
        }
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
      }
      /**
       * Current stream status information.
       *
       * Mostly useful at the end of input for an empty stream.
       */
      streamInfo() {
        return {
          comment: parsePrelude2(this.prelude).comment,
          directives: this.directives,
          errors: this.errors,
          warnings: this.warnings
        };
      }
      /**
       * Compose tokens into documents.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *compose(tokens, forceDoc = false, endOffset = -1) {
        for (const token of tokens)
          yield* this.next(token);
        yield* this.end(forceDoc, endOffset);
      }
      /** Advance the composer by one CST token. */
      *next(token) {
        switch (token.type) {
          case "directive":
            this.directives.add(token.source, (offset3, message, warning) => {
              const pos = getErrorPos2(token);
              pos[0] += offset3;
              this.onError(pos, "BAD_DIRECTIVE", message, warning);
            });
            this.prelude.push(token.source);
            this.atDirectives = true;
            break;
          case "document": {
            const doc = composeDoc2(this.options, this.directives, token, this.onError);
            if (this.atDirectives && !doc.directives.docStart)
              this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
            this.decorate(doc, false);
            if (this.doc)
              yield this.doc;
            this.doc = doc;
            this.atDirectives = false;
            break;
          }
          case "byte-order-mark":
          case "space":
            break;
          case "comment":
          case "newline":
            this.prelude.push(token.source);
            break;
          case "error": {
            const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
            const error3 = new YAMLParseError2(getErrorPos2(token), "UNEXPECTED_TOKEN", msg);
            if (this.atDirectives || !this.doc)
              this.errors.push(error3);
            else
              this.doc.errors.push(error3);
            break;
          }
          case "doc-end": {
            if (!this.doc) {
              const msg = "Unexpected doc-end without preceding document";
              this.errors.push(new YAMLParseError2(getErrorPos2(token), "UNEXPECTED_TOKEN", msg));
              break;
            }
            this.doc.directives.docEnd = true;
            const end = resolveEnd2(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
            this.decorate(this.doc, true);
            if (end.comment) {
              const dc = this.doc.comment;
              this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
            }
            this.doc.range[2] = end.offset;
            break;
          }
          default:
            this.errors.push(new YAMLParseError2(getErrorPos2(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
        }
      }
      /**
       * Call at end of input to yield any remaining document.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *end(forceDoc = false, endOffset = -1) {
        if (this.doc) {
          this.decorate(this.doc, true);
          yield this.doc;
          this.doc = null;
        } else if (forceDoc) {
          const opts = Object.assign({ _directives: this.directives }, this.options);
          const doc = new Document2(void 0, opts);
          if (this.atDirectives)
            this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
          doc.range = [0, endOffset, endOffset];
          this.decorate(doc, false);
          yield doc;
        }
      }
    };
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/parse/cst-scalar.js
function resolveAsScalar2(token, strict = true, onError) {
  if (token) {
    const _onError = (pos, code, message) => {
      const offset3 = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
      if (onError)
        onError(offset3, code, message);
      else
        throw new YAMLParseError2([offset3, offset3 + 1], code, message);
    };
    switch (token.type) {
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return resolveFlowScalar2(token, strict, _onError);
      case "block-scalar":
        return resolveBlockScalar2(token, strict, _onError);
    }
  }
  return null;
}
function createScalarToken2(value2, context) {
  const { implicitKey = false, indent, inFlow = false, offset: offset3 = -1, type = "PLAIN" } = context;
  const source = stringifyString2({ type, value: value2 }, {
    implicitKey,
    indent: indent > 0 ? " ".repeat(indent) : "",
    inFlow,
    options: { blockQuote: true, lineWidth: -1 }
  });
  const end = context.end ?? [
    { type: "newline", offset: -1, indent, source: "\n" }
  ];
  switch (source[0]) {
    case "|":
    case ">": {
      const he = source.indexOf("\n");
      const head = source.substring(0, he);
      const body = source.substring(he + 1) + "\n";
      const props = [
        { type: "block-scalar-header", offset: offset3, indent, source: head }
      ];
      if (!addEndtoBlockProps2(props, end))
        props.push({ type: "newline", offset: -1, indent, source: "\n" });
      return { type: "block-scalar", offset: offset3, indent, props, source: body };
    }
    case '"':
      return { type: "double-quoted-scalar", offset: offset3, indent, source, end };
    case "'":
      return { type: "single-quoted-scalar", offset: offset3, indent, source, end };
    default:
      return { type: "scalar", offset: offset3, indent, source, end };
  }
}
function setScalarValue2(token, value2, context = {}) {
  let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
  let indent = "indent" in token ? token.indent : null;
  if (afterKey && typeof indent === "number")
    indent += 2;
  if (!type)
    switch (token.type) {
      case "single-quoted-scalar":
        type = "QUOTE_SINGLE";
        break;
      case "double-quoted-scalar":
        type = "QUOTE_DOUBLE";
        break;
      case "block-scalar": {
        const header = token.props[0];
        if (header.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
        break;
      }
      default:
        type = "PLAIN";
    }
  const source = stringifyString2({ type, value: value2 }, {
    implicitKey: implicitKey || indent === null,
    indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
    inFlow,
    options: { blockQuote: true, lineWidth: -1 }
  });
  switch (source[0]) {
    case "|":
    case ">":
      setBlockScalarValue2(token, source);
      break;
    case '"':
      setFlowScalarValue2(token, source, "double-quoted-scalar");
      break;
    case "'":
      setFlowScalarValue2(token, source, "single-quoted-scalar");
      break;
    default:
      setFlowScalarValue2(token, source, "scalar");
  }
}
function setBlockScalarValue2(token, source) {
  const he = source.indexOf("\n");
  const head = source.substring(0, he);
  const body = source.substring(he + 1) + "\n";
  if (token.type === "block-scalar") {
    const header = token.props[0];
    if (header.type !== "block-scalar-header")
      throw new Error("Invalid block scalar header");
    header.source = head;
    token.source = body;
  } else {
    const { offset: offset3 } = token;
    const indent = "indent" in token ? token.indent : -1;
    const props = [
      { type: "block-scalar-header", offset: offset3, indent, source: head }
    ];
    if (!addEndtoBlockProps2(props, "end" in token ? token.end : void 0))
      props.push({ type: "newline", offset: -1, indent, source: "\n" });
    for (const key of Object.keys(token))
      if (key !== "type" && key !== "offset")
        delete token[key];
    Object.assign(token, { type: "block-scalar", indent, props, source: body });
  }
}
function addEndtoBlockProps2(props, end) {
  if (end)
    for (const st of end)
      switch (st.type) {
        case "space":
        case "comment":
          props.push(st);
          break;
        case "newline":
          props.push(st);
          return true;
      }
  return false;
}
function setFlowScalarValue2(token, source, type) {
  switch (token.type) {
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      token.type = type;
      token.source = source;
      break;
    case "block-scalar": {
      const end = token.props.slice(1);
      let oa = source.length;
      if (token.props[0].type === "block-scalar-header")
        oa -= token.props[0].source.length;
      for (const tok of end)
        tok.offset += oa;
      delete token.props;
      Object.assign(token, { type, source, end });
      break;
    }
    case "block-map":
    case "block-seq": {
      const offset3 = token.offset + source.length;
      const nl = { type: "newline", offset: offset3, indent: token.indent, source: "\n" };
      delete token.items;
      Object.assign(token, { type, source, end: [nl] });
      break;
    }
    default: {
      const indent = "indent" in token ? token.indent : -1;
      const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
      for (const key of Object.keys(token))
        if (key !== "type" && key !== "offset")
          delete token[key];
      Object.assign(token, { type, indent, source, end });
    }
  }
}
var init_cst_scalar = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/parse/cst-scalar.js"() {
    init_resolve_block_scalar();
    init_resolve_flow_scalar();
    init_errors();
    init_stringifyString();
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/parse/cst-stringify.js
function stringifyToken2(token) {
  switch (token.type) {
    case "block-scalar": {
      let res = "";
      for (const tok of token.props)
        res += stringifyToken2(tok);
      return res + token.source;
    }
    case "block-map":
    case "block-seq": {
      let res = "";
      for (const item of token.items)
        res += stringifyItem2(item);
      return res;
    }
    case "flow-collection": {
      let res = token.start.source;
      for (const item of token.items)
        res += stringifyItem2(item);
      for (const st of token.end)
        res += st.source;
      return res;
    }
    case "document": {
      let res = stringifyItem2(token);
      if (token.end)
        for (const st of token.end)
          res += st.source;
      return res;
    }
    default: {
      let res = token.source;
      if ("end" in token && token.end)
        for (const st of token.end)
          res += st.source;
      return res;
    }
  }
}
function stringifyItem2({ start, key, sep: sep2, value: value2 }) {
  let res = "";
  for (const st of start)
    res += st.source;
  if (key)
    res += stringifyToken2(key);
  if (sep2)
    for (const st of sep2)
      res += st.source;
  if (value2)
    res += stringifyToken2(value2);
  return res;
}
var stringify3;
var init_cst_stringify = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/parse/cst-stringify.js"() {
    stringify3 = (cst2) => "type" in cst2 ? stringifyToken2(cst2) : stringifyItem2(cst2);
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/parse/cst-visit.js
function visit3(cst2, visitor) {
  if ("type" in cst2 && cst2.type === "document")
    cst2 = { start: cst2.start, value: cst2.value };
  _visit2(Object.freeze([]), cst2, visitor);
}
function _visit2(path8, item, visitor) {
  let ctrl = visitor(item, path8);
  if (typeof ctrl === "symbol")
    return ctrl;
  for (const field of ["key", "value"]) {
    const token = item[field];
    if (token && "items" in token) {
      for (let i2 = 0; i2 < token.items.length; ++i2) {
        const ci = _visit2(Object.freeze(path8.concat([[field, i2]])), token.items[i2], visitor);
        if (typeof ci === "number")
          i2 = ci - 1;
        else if (ci === BREAK3)
          return BREAK3;
        else if (ci === REMOVE3) {
          token.items.splice(i2, 1);
          i2 -= 1;
        }
      }
      if (typeof ctrl === "function" && field === "key")
        ctrl = ctrl(item, path8);
    }
  }
  return typeof ctrl === "function" ? ctrl(item, path8) : ctrl;
}
var BREAK3, SKIP3, REMOVE3;
var init_cst_visit = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/parse/cst-visit.js"() {
    BREAK3 = Symbol("break visit");
    SKIP3 = Symbol("skip children");
    REMOVE3 = Symbol("remove item");
    visit3.BREAK = BREAK3;
    visit3.SKIP = SKIP3;
    visit3.REMOVE = REMOVE3;
    visit3.itemAtPath = (cst2, path8) => {
      let item = cst2;
      for (const [field, index2] of path8) {
        const tok = item == null ? void 0 : item[field];
        if (tok && "items" in tok) {
          item = tok.items[index2];
        } else
          return void 0;
      }
      return item;
    };
    visit3.parentCollection = (cst2, path8) => {
      const parent = visit3.itemAtPath(cst2, path8.slice(0, -1));
      const field = path8[path8.length - 1][0];
      const coll = parent == null ? void 0 : parent[field];
      if (coll && "items" in coll)
        return coll;
      throw new Error("Parent collection not found");
    };
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/parse/cst.js
var cst_exports = {};
__export(cst_exports, {
  BOM: () => BOM2,
  DOCUMENT: () => DOCUMENT2,
  FLOW_END: () => FLOW_END2,
  SCALAR: () => SCALAR3,
  createScalarToken: () => createScalarToken2,
  isCollection: () => isCollection3,
  isScalar: () => isScalar3,
  prettyToken: () => prettyToken2,
  resolveAsScalar: () => resolveAsScalar2,
  setScalarValue: () => setScalarValue2,
  stringify: () => stringify3,
  tokenType: () => tokenType2,
  visit: () => visit3
});
function prettyToken2(token) {
  switch (token) {
    case BOM2:
      return "<BOM>";
    case DOCUMENT2:
      return "<DOC>";
    case FLOW_END2:
      return "<FLOW_END>";
    case SCALAR3:
      return "<SCALAR>";
    default:
      return JSON.stringify(token);
  }
}
function tokenType2(source) {
  switch (source) {
    case BOM2:
      return "byte-order-mark";
    case DOCUMENT2:
      return "doc-mode";
    case FLOW_END2:
      return "flow-error-end";
    case SCALAR3:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case "\n":
    case "\r\n":
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (source[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}
var BOM2, DOCUMENT2, FLOW_END2, SCALAR3, isCollection3, isScalar3;
var init_cst = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/parse/cst.js"() {
    init_cst_scalar();
    init_cst_stringify();
    init_cst_visit();
    BOM2 = "\uFEFF";
    DOCUMENT2 = "";
    FLOW_END2 = "";
    SCALAR3 = "";
    isCollection3 = (token) => !!token && "items" in token;
    isScalar3 = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/parse/lexer.js
function isEmpty2(ch) {
  switch (ch) {
    case void 0:
    case " ":
    case "\n":
    case "\r":
    case "	":
      return true;
    default:
      return false;
  }
}
var hexDigits2, tagChars2, invalidFlowScalarChars2, invalidAnchorChars2, isNotAnchorChar2, Lexer2;
var init_lexer = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/parse/lexer.js"() {
    init_cst();
    hexDigits2 = "0123456789ABCDEFabcdef".split("");
    tagChars2 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split("");
    invalidFlowScalarChars2 = ",[]{}".split("");
    invalidAnchorChars2 = " ,[]{}\n\r	".split("");
    isNotAnchorChar2 = (ch) => !ch || invalidAnchorChars2.includes(ch);
    Lexer2 = class {
      constructor() {
        this.atEnd = false;
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        this.buffer = "";
        this.flowKey = false;
        this.flowLevel = 0;
        this.indentNext = 0;
        this.indentValue = 0;
        this.lineEndPos = null;
        this.next = null;
        this.pos = 0;
      }
      /**
       * Generate YAML tokens from the `source` string. If `incomplete`,
       * a part of the last line may be left as a buffer for the next call.
       *
       * @returns A generator of lexical tokens
       */
      *lex(source, incomplete = false) {
        if (source) {
          this.buffer = this.buffer ? this.buffer + source : source;
          this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next = this.next ?? "stream";
        while (next && (incomplete || this.hasChars(1)))
          next = yield* this.parseNext(next);
      }
      atLineEnd() {
        let i2 = this.pos;
        let ch = this.buffer[i2];
        while (ch === " " || ch === "	")
          ch = this.buffer[++i2];
        if (!ch || ch === "#" || ch === "\n")
          return true;
        if (ch === "\r")
          return this.buffer[i2 + 1] === "\n";
        return false;
      }
      charAt(n3) {
        return this.buffer[this.pos + n3];
      }
      continueScalar(offset3) {
        let ch = this.buffer[offset3];
        if (this.indentNext > 0) {
          let indent = 0;
          while (ch === " ")
            ch = this.buffer[++indent + offset3];
          if (ch === "\r") {
            const next = this.buffer[indent + offset3 + 1];
            if (next === "\n" || !next && !this.atEnd)
              return offset3 + indent + 1;
          }
          return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset3 + indent : -1;
        }
        if (ch === "-" || ch === ".") {
          const dt = this.buffer.substr(offset3, 3);
          if ((dt === "---" || dt === "...") && isEmpty2(this.buffer[offset3 + 3]))
            return -1;
        }
        return offset3;
      }
      getLine() {
        let end = this.lineEndPos;
        if (typeof end !== "number" || end !== -1 && end < this.pos) {
          end = this.buffer.indexOf("\n", this.pos);
          this.lineEndPos = end;
        }
        if (end === -1)
          return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === "\r")
          end -= 1;
        return this.buffer.substring(this.pos, end);
      }
      hasChars(n3) {
        return this.pos + n3 <= this.buffer.length;
      }
      setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state;
        return null;
      }
      peek(n3) {
        return this.buffer.substr(this.pos, n3);
      }
      *parseNext(next) {
        switch (next) {
          case "stream":
            return yield* this.parseStream();
          case "line-start":
            return yield* this.parseLineStart();
          case "block-start":
            return yield* this.parseBlockStart();
          case "doc":
            return yield* this.parseDocument();
          case "flow":
            return yield* this.parseFlowCollection();
          case "quoted-scalar":
            return yield* this.parseQuotedScalar();
          case "block-scalar":
            return yield* this.parseBlockScalar();
          case "plain-scalar":
            return yield* this.parsePlainScalar();
        }
      }
      *parseStream() {
        let line = this.getLine();
        if (line === null)
          return this.setNext("stream");
        if (line[0] === BOM2) {
          yield* this.pushCount(1);
          line = line.substring(1);
        }
        if (line[0] === "%") {
          let dirEnd = line.length;
          const cs = line.indexOf("#");
          if (cs !== -1) {
            const ch = line[cs - 1];
            if (ch === " " || ch === "	")
              dirEnd = cs - 1;
          }
          while (true) {
            const ch = line[dirEnd - 1];
            if (ch === " " || ch === "	")
              dirEnd -= 1;
            else
              break;
          }
          const n3 = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
          yield* this.pushCount(line.length - n3);
          this.pushNewline();
          return "stream";
        }
        if (this.atLineEnd()) {
          const sp = yield* this.pushSpaces(true);
          yield* this.pushCount(line.length - sp);
          yield* this.pushNewline();
          return "stream";
        }
        yield DOCUMENT2;
        return yield* this.parseLineStart();
      }
      *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd)
          return this.setNext("line-start");
        if (ch === "-" || ch === ".") {
          if (!this.atEnd && !this.hasChars(4))
            return this.setNext("line-start");
          const s2 = this.peek(3);
          if (s2 === "---" && isEmpty2(this.charAt(3))) {
            yield* this.pushCount(3);
            this.indentValue = 0;
            this.indentNext = 0;
            return "doc";
          } else if (s2 === "..." && isEmpty2(this.charAt(3))) {
            yield* this.pushCount(3);
            return "stream";
          }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !isEmpty2(this.charAt(1)))
          this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
      }
      *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd)
          return this.setNext("block-start");
        if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty2(ch1)) {
          const n3 = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
          this.indentNext = this.indentValue + 1;
          this.indentValue += n3;
          return yield* this.parseBlockStart();
        }
        return "doc";
      }
      *parseDocument() {
        yield* this.pushSpaces(true);
        const line = this.getLine();
        if (line === null)
          return this.setNext("doc");
        let n3 = yield* this.pushIndicators();
        switch (line[n3]) {
          case "#":
            yield* this.pushCount(line.length - n3);
          case void 0:
            yield* this.pushNewline();
            return yield* this.parseLineStart();
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel = 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            return "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar2);
            return "doc";
          case '"':
          case "'":
            return yield* this.parseQuotedScalar();
          case "|":
          case ">":
            n3 += yield* this.parseBlockScalarHeader();
            n3 += yield* this.pushSpaces(true);
            yield* this.pushCount(line.length - n3);
            yield* this.pushNewline();
            return yield* this.parseBlockScalar();
          default:
            return yield* this.parsePlainScalar();
        }
      }
      *parseFlowCollection() {
        let nl, sp;
        let indent = -1;
        do {
          nl = yield* this.pushNewline();
          if (nl > 0) {
            sp = yield* this.pushSpaces(false);
            this.indentValue = indent = sp;
          } else {
            sp = 0;
          }
          sp += yield* this.pushSpaces(true);
        } while (nl + sp > 0);
        const line = this.getLine();
        if (line === null)
          return this.setNext("flow");
        if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty2(line[3])) {
          const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
          if (!atFlowEndMarker) {
            this.flowLevel = 0;
            yield FLOW_END2;
            return yield* this.parseLineStart();
          }
        }
        let n3 = 0;
        while (line[n3] === ",") {
          n3 += yield* this.pushCount(1);
          n3 += yield* this.pushSpaces(true);
          this.flowKey = false;
        }
        n3 += yield* this.pushIndicators();
        switch (line[n3]) {
          case void 0:
            return "flow";
          case "#":
            yield* this.pushCount(line.length - n3);
            return "flow";
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel += 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            this.flowKey = true;
            this.flowLevel -= 1;
            return this.flowLevel ? "flow" : "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar2);
            return "flow";
          case '"':
          case "'":
            this.flowKey = true;
            return yield* this.parseQuotedScalar();
          case ":": {
            const next = this.charAt(1);
            if (this.flowKey || isEmpty2(next) || next === ",") {
              this.flowKey = false;
              yield* this.pushCount(1);
              yield* this.pushSpaces(true);
              return "flow";
            }
          }
          default:
            this.flowKey = false;
            return yield* this.parsePlainScalar();
        }
      }
      *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") {
          while (end !== -1 && this.buffer[end + 1] === "'")
            end = this.buffer.indexOf("'", end + 2);
        } else {
          while (end !== -1) {
            let n3 = 0;
            while (this.buffer[end - 1 - n3] === "\\")
              n3 += 1;
            if (n3 % 2 === 0)
              break;
            end = this.buffer.indexOf('"', end + 1);
          }
        }
        const qb = this.buffer.substring(0, end);
        let nl = qb.indexOf("\n", this.pos);
        if (nl !== -1) {
          while (nl !== -1) {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = qb.indexOf("\n", cs);
          }
          if (nl !== -1) {
            end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
          }
        }
        if (end === -1) {
          if (!this.atEnd)
            return this.setNext("quoted-scalar");
          end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? "flow" : "doc";
      }
      *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i2 = this.pos;
        while (true) {
          const ch = this.buffer[++i2];
          if (ch === "+")
            this.blockScalarKeep = true;
          else if (ch > "0" && ch <= "9")
            this.blockScalarIndent = Number(ch) - 1;
          else if (ch !== "-")
            break;
        }
        return yield* this.pushUntil((ch) => isEmpty2(ch) || ch === "#");
      }
      *parseBlockScalar() {
        let nl = this.pos - 1;
        let indent = 0;
        let ch;
        loop:
          for (let i2 = this.pos; ch = this.buffer[i2]; ++i2) {
            switch (ch) {
              case " ":
                indent += 1;
                break;
              case "\n":
                nl = i2;
                indent = 0;
                break;
              case "\r": {
                const next = this.buffer[i2 + 1];
                if (!next && !this.atEnd)
                  return this.setNext("block-scalar");
                if (next === "\n")
                  break;
              }
              default:
                break loop;
            }
          }
        if (!ch && !this.atEnd)
          return this.setNext("block-scalar");
        if (indent >= this.indentNext) {
          if (this.blockScalarIndent === -1)
            this.indentNext = indent;
          else
            this.indentNext += this.blockScalarIndent;
          do {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = this.buffer.indexOf("\n", cs);
          } while (nl !== -1);
          if (nl === -1) {
            if (!this.atEnd)
              return this.setNext("block-scalar");
            nl = this.buffer.length;
          }
        }
        if (!this.blockScalarKeep) {
          do {
            let i2 = nl - 1;
            let ch2 = this.buffer[i2];
            if (ch2 === "\r")
              ch2 = this.buffer[--i2];
            const lastChar = i2;
            while (ch2 === " " || ch2 === "	")
              ch2 = this.buffer[--i2];
            if (ch2 === "\n" && i2 >= this.pos && i2 + 1 + indent > lastChar)
              nl = i2;
            else
              break;
          } while (true);
        }
        yield SCALAR3;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
      }
      *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end = this.pos - 1;
        let i2 = this.pos - 1;
        let ch;
        while (ch = this.buffer[++i2]) {
          if (ch === ":") {
            const next = this.buffer[i2 + 1];
            if (isEmpty2(next) || inFlow && next === ",")
              break;
            end = i2;
          } else if (isEmpty2(ch)) {
            let next = this.buffer[i2 + 1];
            if (ch === "\r") {
              if (next === "\n") {
                i2 += 1;
                ch = "\n";
                next = this.buffer[i2 + 1];
              } else
                end = i2;
            }
            if (next === "#" || inFlow && invalidFlowScalarChars2.includes(next))
              break;
            if (ch === "\n") {
              const cs = this.continueScalar(i2 + 1);
              if (cs === -1)
                break;
              i2 = Math.max(i2, cs - 2);
            }
          } else {
            if (inFlow && invalidFlowScalarChars2.includes(ch))
              break;
            end = i2;
          }
        }
        if (!ch && !this.atEnd)
          return this.setNext("plain-scalar");
        yield SCALAR3;
        yield* this.pushToIndex(end + 1, true);
        return inFlow ? "flow" : "doc";
      }
      *pushCount(n3) {
        if (n3 > 0) {
          yield this.buffer.substr(this.pos, n3);
          this.pos += n3;
          return n3;
        }
        return 0;
      }
      *pushToIndex(i2, allowEmpty) {
        const s2 = this.buffer.slice(this.pos, i2);
        if (s2) {
          yield s2;
          this.pos += s2.length;
          return s2.length;
        } else if (allowEmpty)
          yield "";
        return 0;
      }
      *pushIndicators() {
        switch (this.charAt(0)) {
          case "!":
            return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "&":
            return (yield* this.pushUntil(isNotAnchorChar2)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "-":
          case "?":
          case ":": {
            const inFlow = this.flowLevel > 0;
            const ch1 = this.charAt(1);
            if (isEmpty2(ch1) || inFlow && invalidFlowScalarChars2.includes(ch1)) {
              if (!inFlow)
                this.indentNext = this.indentValue + 1;
              else if (this.flowKey)
                this.flowKey = false;
              return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
            }
          }
        }
        return 0;
      }
      *pushTag() {
        if (this.charAt(1) === "<") {
          let i2 = this.pos + 2;
          let ch = this.buffer[i2];
          while (!isEmpty2(ch) && ch !== ">")
            ch = this.buffer[++i2];
          return yield* this.pushToIndex(ch === ">" ? i2 + 1 : i2, false);
        } else {
          let i2 = this.pos + 1;
          let ch = this.buffer[i2];
          while (ch) {
            if (tagChars2.includes(ch))
              ch = this.buffer[++i2];
            else if (ch === "%" && hexDigits2.includes(this.buffer[i2 + 1]) && hexDigits2.includes(this.buffer[i2 + 2])) {
              ch = this.buffer[i2 += 3];
            } else
              break;
          }
          return yield* this.pushToIndex(i2, false);
        }
      }
      *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === "\n")
          return yield* this.pushCount(1);
        else if (ch === "\r" && this.charAt(1) === "\n")
          return yield* this.pushCount(2);
        else
          return 0;
      }
      *pushSpaces(allowTabs) {
        let i2 = this.pos - 1;
        let ch;
        do {
          ch = this.buffer[++i2];
        } while (ch === " " || allowTabs && ch === "	");
        const n3 = i2 - this.pos;
        if (n3 > 0) {
          yield this.buffer.substr(this.pos, n3);
          this.pos = i2;
        }
        return n3;
      }
      *pushUntil(test) {
        let i2 = this.pos;
        let ch = this.buffer[i2];
        while (!test(ch))
          ch = this.buffer[++i2];
        return yield* this.pushToIndex(i2, false);
      }
    };
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/parse/line-counter.js
var LineCounter2;
var init_line_counter = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/parse/line-counter.js"() {
    LineCounter2 = class {
      constructor() {
        this.lineStarts = [];
        this.addNewLine = (offset3) => this.lineStarts.push(offset3);
        this.linePos = (offset3) => {
          let low = 0;
          let high = this.lineStarts.length;
          while (low < high) {
            const mid = low + high >> 1;
            if (this.lineStarts[mid] < offset3)
              low = mid + 1;
            else
              high = mid;
          }
          if (this.lineStarts[low] === offset3)
            return { line: low + 1, col: 1 };
          if (low === 0)
            return { line: 0, col: offset3 };
          const start = this.lineStarts[low - 1];
          return { line: low, col: offset3 - start + 1 };
        };
      }
    };
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/parse/parser.js
function includesToken2(list, type) {
  for (let i2 = 0; i2 < list.length; ++i2)
    if (list[i2].type === type)
      return true;
  return false;
}
function findNonEmptyIndex2(list) {
  for (let i2 = 0; i2 < list.length; ++i2) {
    switch (list[i2].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return i2;
    }
  }
  return -1;
}
function isFlowToken2(token) {
  switch (token == null ? void 0 : token.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return true;
    default:
      return false;
  }
}
function getPrevProps2(parent) {
  switch (parent.type) {
    case "document":
      return parent.start;
    case "block-map": {
      const it = parent.items[parent.items.length - 1];
      return it.sep ?? it.start;
    }
    case "block-seq":
      return parent.items[parent.items.length - 1].start;
    default:
      return [];
  }
}
function getFirstKeyStartProps2(prev) {
  var _a;
  if (prev.length === 0)
    return [];
  let i2 = prev.length;
  loop:
    while (--i2 >= 0) {
      switch (prev[i2].type) {
        case "doc-start":
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
        case "newline":
          break loop;
      }
    }
  while (((_a = prev[++i2]) == null ? void 0 : _a.type) === "space") {
  }
  return prev.splice(i2, prev.length);
}
function fixFlowSeqItems2(fc) {
  if (fc.start.type === "flow-seq-start") {
    for (const it of fc.items) {
      if (it.sep && !it.value && !includesToken2(it.start, "explicit-key-ind") && !includesToken2(it.sep, "map-value-ind")) {
        if (it.key)
          it.value = it.key;
        delete it.key;
        if (isFlowToken2(it.value)) {
          if (it.value.end)
            Array.prototype.push.apply(it.value.end, it.sep);
          else
            it.value.end = it.sep;
        } else
          Array.prototype.push.apply(it.start, it.sep);
        delete it.sep;
      }
    }
  }
}
var Parser3;
var init_parser = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/parse/parser.js"() {
    init_cst();
    init_lexer();
    Parser3 = class {
      /**
       * @param onNewLine - If defined, called separately with the start position of
       *   each new line (in `parse()`, including the start of input).
       */
      constructor(onNewLine) {
        this.atNewLine = true;
        this.atScalar = false;
        this.indent = 0;
        this.offset = 0;
        this.onKeyLine = false;
        this.stack = [];
        this.source = "";
        this.type = "";
        this.lexer = new Lexer2();
        this.onNewLine = onNewLine;
      }
      /**
       * Parse `source` as a YAML stream.
       * If `incomplete`, a part of the last line may be left as a buffer for the next call.
       *
       * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
       *
       * @returns A generator of tokens representing each directive, document, and other structure.
       */
      *parse(source, incomplete = false) {
        if (this.onNewLine && this.offset === 0)
          this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source, incomplete))
          yield* this.next(lexeme);
        if (!incomplete)
          yield* this.end();
      }
      /**
       * Advance the parser by the `source` of one lexical token.
       */
      *next(source) {
        this.source = source;
        if (this.atScalar) {
          this.atScalar = false;
          yield* this.step();
          this.offset += source.length;
          return;
        }
        const type = tokenType2(source);
        if (!type) {
          const message = `Not a YAML token: ${source}`;
          yield* this.pop({ type: "error", offset: this.offset, message, source });
          this.offset += source.length;
        } else if (type === "scalar") {
          this.atNewLine = false;
          this.atScalar = true;
          this.type = "scalar";
        } else {
          this.type = type;
          yield* this.step();
          switch (type) {
            case "newline":
              this.atNewLine = true;
              this.indent = 0;
              if (this.onNewLine)
                this.onNewLine(this.offset + source.length);
              break;
            case "space":
              if (this.atNewLine && source[0] === " ")
                this.indent += source.length;
              break;
            case "explicit-key-ind":
            case "map-value-ind":
            case "seq-item-ind":
              if (this.atNewLine)
                this.indent += source.length;
              break;
            case "doc-mode":
            case "flow-error-end":
              return;
            default:
              this.atNewLine = false;
          }
          this.offset += source.length;
        }
      }
      /** Call at end of input to push out any remaining constructions */
      *end() {
        while (this.stack.length > 0)
          yield* this.pop();
      }
      get sourceToken() {
        const st = {
          type: this.type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
        return st;
      }
      *step() {
        const top = this.peek(1);
        if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
          while (this.stack.length > 0)
            yield* this.pop();
          this.stack.push({
            type: "doc-end",
            offset: this.offset,
            source: this.source
          });
          return;
        }
        if (!top)
          return yield* this.stream();
        switch (top.type) {
          case "document":
            return yield* this.document(top);
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return yield* this.scalar(top);
          case "block-scalar":
            return yield* this.blockScalar(top);
          case "block-map":
            return yield* this.blockMap(top);
          case "block-seq":
            return yield* this.blockSequence(top);
          case "flow-collection":
            return yield* this.flowCollection(top);
          case "doc-end":
            return yield* this.documentEnd(top);
        }
        yield* this.pop();
      }
      peek(n3) {
        return this.stack[this.stack.length - n3];
      }
      *pop(error3) {
        const token = error3 ?? this.stack.pop();
        if (!token) {
          const message = "Tried to pop an empty stack";
          yield { type: "error", offset: this.offset, source: "", message };
        } else if (this.stack.length === 0) {
          yield token;
        } else {
          const top = this.peek(1);
          if (token.type === "block-scalar") {
            token.indent = "indent" in top ? top.indent : 0;
          } else if (token.type === "flow-collection" && top.type === "document") {
            token.indent = 0;
          }
          if (token.type === "flow-collection")
            fixFlowSeqItems2(token);
          switch (top.type) {
            case "document":
              top.value = token;
              break;
            case "block-scalar":
              top.props.push(token);
              break;
            case "block-map": {
              const it = top.items[top.items.length - 1];
              if (it.value) {
                top.items.push({ start: [], key: token, sep: [] });
                this.onKeyLine = true;
                return;
              } else if (it.sep) {
                it.value = token;
              } else {
                Object.assign(it, { key: token, sep: [] });
                this.onKeyLine = !includesToken2(it.start, "explicit-key-ind");
                return;
              }
              break;
            }
            case "block-seq": {
              const it = top.items[top.items.length - 1];
              if (it.value)
                top.items.push({ start: [], value: token });
              else
                it.value = token;
              break;
            }
            case "flow-collection": {
              const it = top.items[top.items.length - 1];
              if (!it || it.value)
                top.items.push({ start: [], key: token, sep: [] });
              else if (it.sep)
                it.value = token;
              else
                Object.assign(it, { key: token, sep: [] });
              return;
            }
            default:
              yield* this.pop();
              yield* this.pop(token);
          }
          if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
            const last = token.items[token.items.length - 1];
            if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex2(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
              if (top.type === "document")
                top.end = last.start;
              else
                top.items.push({ start: last.start });
              token.items.splice(-1, 1);
            }
          }
        }
      }
      *stream() {
        switch (this.type) {
          case "directive-line":
            yield { type: "directive", offset: this.offset, source: this.source };
            return;
          case "byte-order-mark":
          case "space":
          case "comment":
          case "newline":
            yield this.sourceToken;
            return;
          case "doc-mode":
          case "doc-start": {
            const doc = {
              type: "document",
              offset: this.offset,
              start: []
            };
            if (this.type === "doc-start")
              doc.start.push(this.sourceToken);
            this.stack.push(doc);
            return;
          }
        }
        yield {
          type: "error",
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML stream`,
          source: this.source
        };
      }
      *document(doc) {
        if (doc.value)
          return yield* this.lineEnd(doc);
        switch (this.type) {
          case "doc-start": {
            if (findNonEmptyIndex2(doc.start) !== -1) {
              yield* this.pop();
              yield* this.step();
            } else
              doc.start.push(this.sourceToken);
            return;
          }
          case "anchor":
          case "tag":
          case "space":
          case "comment":
          case "newline":
            doc.start.push(this.sourceToken);
            return;
        }
        const bv = this.startBlockValue(doc);
        if (bv)
          this.stack.push(bv);
        else {
          yield {
            type: "error",
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML document`,
            source: this.source
          };
        }
      }
      *scalar(scalar) {
        if (this.type === "map-value-ind") {
          const prev = getPrevProps2(this.peek(2));
          const start = getFirstKeyStartProps2(prev);
          let sep2;
          if (scalar.end) {
            sep2 = scalar.end;
            sep2.push(this.sourceToken);
            delete scalar.end;
          } else
            sep2 = [this.sourceToken];
          const map3 = {
            type: "block-map",
            offset: scalar.offset,
            indent: scalar.indent,
            items: [{ start, key: scalar, sep: sep2 }]
          };
          this.onKeyLine = true;
          this.stack[this.stack.length - 1] = map3;
        } else
          yield* this.lineEnd(scalar);
      }
      *blockScalar(scalar) {
        switch (this.type) {
          case "space":
          case "comment":
          case "newline":
            scalar.props.push(this.sourceToken);
            return;
          case "scalar":
            scalar.source = this.source;
            this.atNewLine = true;
            this.indent = 0;
            if (this.onNewLine) {
              let nl = this.source.indexOf("\n") + 1;
              while (nl !== 0) {
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf("\n", nl) + 1;
              }
            }
            yield* this.pop();
            break;
          default:
            yield* this.pop();
            yield* this.step();
        }
      }
      *blockMap(map3) {
        var _a;
        const it = map3.items[map3.items.length - 1];
        switch (this.type) {
          case "newline":
            this.onKeyLine = false;
            if (it.value) {
              const end = "end" in it.value ? it.value.end : void 0;
              const last = Array.isArray(end) ? end[end.length - 1] : void 0;
              if ((last == null ? void 0 : last.type) === "comment")
                end == null ? void 0 : end.push(this.sourceToken);
              else
                map3.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              it.start.push(this.sourceToken);
            }
            return;
          case "space":
          case "comment":
            if (it.value) {
              map3.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              if (this.atIndentedComment(it.start, map3.indent)) {
                const prev = map3.items[map3.items.length - 2];
                const end = (_a = prev == null ? void 0 : prev.value) == null ? void 0 : _a.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  map3.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
        }
        if (this.indent >= map3.indent) {
          const atNextItem = !this.onKeyLine && this.indent === map3.indent && it.sep;
          let start = [];
          if (atNextItem && it.sep && !it.value) {
            const nl = [];
            for (let i2 = 0; i2 < it.sep.length; ++i2) {
              const st = it.sep[i2];
              switch (st.type) {
                case "newline":
                  nl.push(i2);
                  break;
                case "space":
                  break;
                case "comment":
                  if (st.indent > map3.indent)
                    nl.length = 0;
                  break;
                default:
                  nl.length = 0;
              }
            }
            if (nl.length >= 2)
              start = it.sep.splice(nl[1]);
          }
          switch (this.type) {
            case "anchor":
            case "tag":
              if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map3.items.push({ start });
                this.onKeyLine = true;
              } else if (it.sep) {
                it.sep.push(this.sourceToken);
              } else {
                it.start.push(this.sourceToken);
              }
              return;
            case "explicit-key-ind":
              if (!it.sep && !includesToken2(it.start, "explicit-key-ind")) {
                it.start.push(this.sourceToken);
              } else if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map3.items.push({ start });
              } else {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [this.sourceToken] }]
                });
              }
              this.onKeyLine = true;
              return;
            case "map-value-ind":
              if (includesToken2(it.start, "explicit-key-ind")) {
                if (!it.sep) {
                  if (includesToken2(it.start, "newline")) {
                    Object.assign(it, { key: null, sep: [this.sourceToken] });
                  } else {
                    const start2 = getFirstKeyStartProps2(it.start);
                    this.stack.push({
                      type: "block-map",
                      offset: this.offset,
                      indent: this.indent,
                      items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                    });
                  }
                } else if (it.value) {
                  map3.items.push({ start: [], key: null, sep: [this.sourceToken] });
                } else if (includesToken2(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, key: null, sep: [this.sourceToken] }]
                  });
                } else if (isFlowToken2(it.key) && !includesToken2(it.sep, "newline")) {
                  const start2 = getFirstKeyStartProps2(it.start);
                  const key = it.key;
                  const sep2 = it.sep;
                  sep2.push(this.sourceToken);
                  delete it.key, delete it.sep;
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: start2, key, sep: sep2 }]
                  });
                } else if (start.length > 0) {
                  it.sep = it.sep.concat(start, this.sourceToken);
                } else {
                  it.sep.push(this.sourceToken);
                }
              } else {
                if (!it.sep) {
                  Object.assign(it, { key: null, sep: [this.sourceToken] });
                } else if (it.value || atNextItem) {
                  map3.items.push({ start, key: null, sep: [this.sourceToken] });
                } else if (includesToken2(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: [], key: null, sep: [this.sourceToken] }]
                  });
                } else {
                  it.sep.push(this.sourceToken);
                }
              }
              this.onKeyLine = true;
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs6 = this.flowScalar(this.type);
              if (atNextItem || it.value) {
                map3.items.push({ start, key: fs6, sep: [] });
                this.onKeyLine = true;
              } else if (it.sep) {
                this.stack.push(fs6);
              } else {
                Object.assign(it, { key: fs6, sep: [] });
                this.onKeyLine = true;
              }
              return;
            }
            default: {
              const bv = this.startBlockValue(map3);
              if (bv) {
                if (atNextItem && bv.type !== "block-seq" && includesToken2(it.start, "explicit-key-ind")) {
                  map3.items.push({ start });
                }
                this.stack.push(bv);
                return;
              }
            }
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *blockSequence(seq3) {
        var _a;
        const it = seq3.items[seq3.items.length - 1];
        switch (this.type) {
          case "newline":
            if (it.value) {
              const end = "end" in it.value ? it.value.end : void 0;
              const last = Array.isArray(end) ? end[end.length - 1] : void 0;
              if ((last == null ? void 0 : last.type) === "comment")
                end == null ? void 0 : end.push(this.sourceToken);
              else
                seq3.items.push({ start: [this.sourceToken] });
            } else
              it.start.push(this.sourceToken);
            return;
          case "space":
          case "comment":
            if (it.value)
              seq3.items.push({ start: [this.sourceToken] });
            else {
              if (this.atIndentedComment(it.start, seq3.indent)) {
                const prev = seq3.items[seq3.items.length - 2];
                const end = (_a = prev == null ? void 0 : prev.value) == null ? void 0 : _a.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  seq3.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
          case "anchor":
          case "tag":
            if (it.value || this.indent <= seq3.indent)
              break;
            it.start.push(this.sourceToken);
            return;
          case "seq-item-ind":
            if (this.indent !== seq3.indent)
              break;
            if (it.value || includesToken2(it.start, "seq-item-ind"))
              seq3.items.push({ start: [this.sourceToken] });
            else
              it.start.push(this.sourceToken);
            return;
        }
        if (this.indent > seq3.indent) {
          const bv = this.startBlockValue(seq3);
          if (bv) {
            this.stack.push(bv);
            return;
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *flowCollection(fc) {
        const it = fc.items[fc.items.length - 1];
        if (this.type === "flow-error-end") {
          let top;
          do {
            yield* this.pop();
            top = this.peek(1);
          } while (top && top.type === "flow-collection");
        } else if (fc.end.length === 0) {
          switch (this.type) {
            case "comma":
            case "explicit-key-ind":
              if (!it || it.sep)
                fc.items.push({ start: [this.sourceToken] });
              else
                it.start.push(this.sourceToken);
              return;
            case "map-value-ind":
              if (!it || it.value)
                fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              return;
            case "space":
            case "comment":
            case "newline":
            case "anchor":
            case "tag":
              if (!it || it.value)
                fc.items.push({ start: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                it.start.push(this.sourceToken);
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs6 = this.flowScalar(this.type);
              if (!it || it.value)
                fc.items.push({ start: [], key: fs6, sep: [] });
              else if (it.sep)
                this.stack.push(fs6);
              else
                Object.assign(it, { key: fs6, sep: [] });
              return;
            }
            case "flow-map-end":
            case "flow-seq-end":
              fc.end.push(this.sourceToken);
              return;
          }
          const bv = this.startBlockValue(fc);
          if (bv)
            this.stack.push(bv);
          else {
            yield* this.pop();
            yield* this.step();
          }
        } else {
          const parent = this.peek(2);
          if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
            yield* this.pop();
            yield* this.step();
          } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
            const prev = getPrevProps2(parent);
            const start = getFirstKeyStartProps2(prev);
            fixFlowSeqItems2(fc);
            const sep2 = fc.end.splice(1, fc.end.length);
            sep2.push(this.sourceToken);
            const map3 = {
              type: "block-map",
              offset: fc.offset,
              indent: fc.indent,
              items: [{ start, key: fc, sep: sep2 }]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map3;
          } else {
            yield* this.lineEnd(fc);
          }
        }
      }
      flowScalar(type) {
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        return {
          type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
      }
      startBlockValue(parent) {
        switch (this.type) {
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return this.flowScalar(this.type);
          case "block-scalar-header":
            return {
              type: "block-scalar",
              offset: this.offset,
              indent: this.indent,
              props: [this.sourceToken],
              source: ""
            };
          case "flow-map-start":
          case "flow-seq-start":
            return {
              type: "flow-collection",
              offset: this.offset,
              indent: this.indent,
              start: this.sourceToken,
              items: [],
              end: []
            };
          case "seq-item-ind":
            return {
              type: "block-seq",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken] }]
            };
          case "explicit-key-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps2(parent);
            const start = getFirstKeyStartProps2(prev);
            start.push(this.sourceToken);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start }]
            };
          }
          case "map-value-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps2(parent);
            const start = getFirstKeyStartProps2(prev);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, key: null, sep: [this.sourceToken] }]
            };
          }
        }
        return null;
      }
      atIndentedComment(start, indent) {
        if (this.type !== "comment")
          return false;
        if (this.indent <= indent)
          return false;
        return start.every((st) => st.type === "newline" || st.type === "space");
      }
      *documentEnd(docEnd) {
        if (this.type !== "doc-mode") {
          if (docEnd.end)
            docEnd.end.push(this.sourceToken);
          else
            docEnd.end = [this.sourceToken];
          if (this.type === "newline")
            yield* this.pop();
        }
      }
      *lineEnd(token) {
        switch (this.type) {
          case "comma":
          case "doc-start":
          case "doc-end":
          case "flow-seq-end":
          case "flow-map-end":
          case "map-value-ind":
            yield* this.pop();
            yield* this.step();
            break;
          case "newline":
            this.onKeyLine = false;
          case "space":
          case "comment":
          default:
            if (token.end)
              token.end.push(this.sourceToken);
            else
              token.end = [this.sourceToken];
            if (this.type === "newline")
              yield* this.pop();
        }
      }
    };
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/public-api.js
function parseOptions2(options3) {
  const prettyErrors = options3.prettyErrors !== false;
  const lineCounter = options3.lineCounter || prettyErrors && new LineCounter2() || null;
  return { lineCounter, prettyErrors };
}
function parseAllDocuments2(source, options3 = {}) {
  const { lineCounter, prettyErrors } = parseOptions2(options3);
  const parser2 = new Parser3(lineCounter == null ? void 0 : lineCounter.addNewLine);
  const composer = new Composer2(options3);
  const docs = Array.from(composer.compose(parser2.parse(source)));
  if (prettyErrors && lineCounter)
    for (const doc of docs) {
      doc.errors.forEach(prettifyError2(source, lineCounter));
      doc.warnings.forEach(prettifyError2(source, lineCounter));
    }
  if (docs.length > 0)
    return docs;
  return Object.assign([], { empty: true }, composer.streamInfo());
}
function parseDocument2(source, options3 = {}) {
  const { lineCounter, prettyErrors } = parseOptions2(options3);
  const parser2 = new Parser3(lineCounter == null ? void 0 : lineCounter.addNewLine);
  const composer = new Composer2(options3);
  let doc = null;
  for (const _doc of composer.compose(parser2.parse(source), true, source.length)) {
    if (!doc)
      doc = _doc;
    else if (doc.options.logLevel !== "silent") {
      doc.errors.push(new YAMLParseError2(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  }
  if (prettyErrors && lineCounter) {
    doc.errors.forEach(prettifyError2(source, lineCounter));
    doc.warnings.forEach(prettifyError2(source, lineCounter));
  }
  return doc;
}
function parse6(src3, reviver, options3) {
  let _reviver = void 0;
  if (typeof reviver === "function") {
    _reviver = reviver;
  } else if (options3 === void 0 && reviver && typeof reviver === "object") {
    options3 = reviver;
  }
  const doc = parseDocument2(src3, options3);
  if (!doc)
    return null;
  doc.warnings.forEach((warning) => warn3(doc.options.logLevel, warning));
  if (doc.errors.length > 0) {
    if (doc.options.logLevel !== "silent")
      throw doc.errors[0];
    else
      doc.errors = [];
  }
  return doc.toJS(Object.assign({ reviver: _reviver }, options3));
}
function stringify4(value2, replacer, options3) {
  let _replacer = null;
  if (typeof replacer === "function" || Array.isArray(replacer)) {
    _replacer = replacer;
  } else if (options3 === void 0 && replacer) {
    options3 = replacer;
  }
  if (typeof options3 === "string")
    options3 = options3.length;
  if (typeof options3 === "number") {
    const indent = Math.round(options3);
    options3 = indent < 1 ? void 0 : indent > 8 ? { indent: 8 } : { indent };
  }
  if (value2 === void 0) {
    const { keepUndefined } = options3 ?? replacer ?? {};
    if (!keepUndefined)
      return void 0;
  }
  return new Document2(value2, _replacer, options3).toString(options3);
}
var init_public_api = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/public-api.js"() {
    init_composer();
    init_Document();
    init_errors();
    init_log();
    init_line_counter();
    init_parser();
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/index.js
var dist_exports = {};
__export(dist_exports, {
  Alias: () => Alias2,
  CST: () => cst_exports,
  Composer: () => Composer2,
  Document: () => Document2,
  Lexer: () => Lexer2,
  LineCounter: () => LineCounter2,
  Pair: () => Pair2,
  Parser: () => Parser3,
  Scalar: () => Scalar2,
  Schema: () => Schema2,
  YAMLError: () => YAMLError2,
  YAMLMap: () => YAMLMap2,
  YAMLParseError: () => YAMLParseError2,
  YAMLSeq: () => YAMLSeq2,
  YAMLWarning: () => YAMLWarning2,
  isAlias: () => isAlias2,
  isCollection: () => isCollection2,
  isDocument: () => isDocument2,
  isMap: () => isMap2,
  isNode: () => isNode2,
  isPair: () => isPair2,
  isScalar: () => isScalar2,
  isSeq: () => isSeq2,
  parse: () => parse6,
  parseAllDocuments: () => parseAllDocuments2,
  parseDocument: () => parseDocument2,
  stringify: () => stringify4,
  visit: () => visit2,
  visitAsync: () => visitAsync2
});
var init_dist = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/dist/index.js"() {
    init_composer();
    init_Document();
    init_Schema();
    init_errors();
    init_Alias();
    init_Node();
    init_Pair();
    init_Scalar();
    init_YAMLMap();
    init_YAMLSeq();
    init_cst();
    init_lexer();
    init_line_counter();
    init_parser();
    init_public_api();
    init_visit();
  }
});

// node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/index.js
var browser_exports = {};
__export(browser_exports, {
  Alias: () => Alias2,
  CST: () => cst_exports,
  Composer: () => Composer2,
  Document: () => Document2,
  Lexer: () => Lexer2,
  LineCounter: () => LineCounter2,
  Pair: () => Pair2,
  Parser: () => Parser3,
  Scalar: () => Scalar2,
  Schema: () => Schema2,
  YAMLError: () => YAMLError2,
  YAMLMap: () => YAMLMap2,
  YAMLParseError: () => YAMLParseError2,
  YAMLSeq: () => YAMLSeq2,
  YAMLWarning: () => YAMLWarning2,
  default: () => browser_default3,
  isAlias: () => isAlias2,
  isCollection: () => isCollection2,
  isDocument: () => isDocument2,
  isMap: () => isMap2,
  isNode: () => isNode2,
  isPair: () => isPair2,
  isScalar: () => isScalar2,
  isSeq: () => isSeq2,
  parse: () => parse6,
  parseAllDocuments: () => parseAllDocuments2,
  parseDocument: () => parseDocument2,
  stringify: () => stringify4,
  visit: () => visit2,
  visitAsync: () => visitAsync2
});
var browser_default3;
var init_browser = __esm({
  "node_modules/.pnpm/yaml@2.2.2/node_modules/yaml/browser/index.js"() {
    init_dist();
    init_dist();
    browser_default3 = dist_exports;
  }
});

// node_modules/.pnpm/postcss-load-config@4.0.1_postcss@8.4.23/node_modules/postcss-load-config/src/req.js
var require_req = __commonJS({
  "node_modules/.pnpm/postcss-load-config@4.0.1_postcss@8.4.23/node_modules/postcss-load-config/src/req.js"(exports3, module2) {
    var { createRequire: createRequire6, createRequireFromPath: createRequireFromPath2 } = require_module();
    function req2(name2, rootFile) {
      const create = createRequire6 || createRequireFromPath2;
      const require5 = create(rootFile);
      return require5(name2);
    }
    module2.exports = req2;
  }
});

// node_modules/.pnpm/postcss-load-config@4.0.1_postcss@8.4.23/node_modules/postcss-load-config/src/options.js
var require_options = __commonJS({
  "node_modules/.pnpm/postcss-load-config@4.0.1_postcss@8.4.23/node_modules/postcss-load-config/src/options.js"(exports3, module2) {
    "use strict";
    var req2 = require_req();
    var options3 = (config2, file) => {
      if (config2.parser && typeof config2.parser === "string") {
        try {
          config2.parser = req2(config2.parser, file);
        } catch (err2) {
          throw new Error(`Loading PostCSS Parser failed: ${err2.message}

(@${file})`);
        }
      }
      if (config2.syntax && typeof config2.syntax === "string") {
        try {
          config2.syntax = req2(config2.syntax, file);
        } catch (err2) {
          throw new Error(`Loading PostCSS Syntax failed: ${err2.message}

(@${file})`);
        }
      }
      if (config2.stringifier && typeof config2.stringifier === "string") {
        try {
          config2.stringifier = req2(config2.stringifier, file);
        } catch (err2) {
          throw new Error(`Loading PostCSS Stringifier failed: ${err2.message}

(@${file})`);
        }
      }
      if (config2.plugins) {
        delete config2.plugins;
      }
      return config2;
    };
    module2.exports = options3;
  }
});

// node_modules/.pnpm/postcss-load-config@4.0.1_postcss@8.4.23/node_modules/postcss-load-config/src/plugins.js
var require_plugins = __commonJS({
  "node_modules/.pnpm/postcss-load-config@4.0.1_postcss@8.4.23/node_modules/postcss-load-config/src/plugins.js"(exports3, module2) {
    "use strict";
    var req2 = require_req();
    var load2 = (plugin, options3, file) => {
      try {
        if (options3 === null || options3 === void 0 || Object.keys(options3).length === 0) {
          return req2(plugin, file);
        } else {
          return req2(plugin, file)(options3);
        }
      } catch (err2) {
        throw new Error(`Loading PostCSS Plugin failed: ${err2.message}

(@${file})`);
      }
    };
    var plugins2 = (config2, file) => {
      let plugins3 = [];
      if (Array.isArray(config2.plugins)) {
        plugins3 = config2.plugins.filter(Boolean);
      } else {
        plugins3 = Object.keys(config2.plugins).filter((plugin) => {
          return config2.plugins[plugin] !== false ? plugin : "";
        }).map((plugin) => {
          return load2(plugin, config2.plugins[plugin], file);
        });
      }
      if (plugins3.length && plugins3.length > 0) {
        plugins3.forEach((plugin, i2) => {
          if (plugin.default) {
            plugin = plugin.default;
          }
          if (plugin.postcss === true) {
            plugin = plugin();
          } else if (plugin.postcss) {
            plugin = plugin.postcss;
          }
          if (
            // eslint-disable-next-line
            !(typeof plugin === "object" && Array.isArray(plugin.plugins) || typeof plugin === "object" && plugin.postcssPlugin || typeof plugin === "function")
          ) {
            throw new TypeError(`Invalid PostCSS Plugin found at: plugins[${i2}]

(@${file})`);
          }
        });
      }
      return plugins3;
    };
    module2.exports = plugins2;
  }
});

// optional-peer-dep:__vite-optional-peer-dep:ts-node:postcss-load-config
var require_vite_optional_peer_dep_ts_node_postcss_load_config = __commonJS({
  "optional-peer-dep:__vite-optional-peer-dep:ts-node:postcss-load-config"() {
    throw new Error(`Could not resolve "ts-node" imported by "postcss-load-config". Is it installed?`);
  }
});

// node_modules/.pnpm/postcss-load-config@4.0.1_postcss@8.4.23/node_modules/postcss-load-config/src/index.js
var require_src = __commonJS({
  "node_modules/.pnpm/postcss-load-config@4.0.1_postcss@8.4.23/node_modules/postcss-load-config/src/index.js"(exports3, module2) {
    "use strict";
    var resolve4 = require_path().resolve;
    var url2 = require_url();
    var config2 = require_dist();
    var yaml3 = (init_browser(), __toCommonJS(browser_exports));
    var loadOptions2 = require_options();
    var loadPlugins2 = require_plugins();
    var interopRequireDefault2 = (obj) => obj && obj.__esModule ? obj : { default: obj };
    var processResult2 = (ctx2, result) => {
      const file = result.filepath || "";
      let config3 = interopRequireDefault2(result.config).default || {};
      if (typeof config3 === "function") {
        config3 = config3(ctx2);
      } else {
        config3 = Object.assign({}, config3, ctx2);
      }
      if (!config3.plugins) {
        config3.plugins = [];
      }
      return {
        plugins: loadPlugins2(config3, file),
        options: loadOptions2(config3, file),
        file
      };
    };
    var createContext2 = (ctx2) => {
      ctx2 = Object.assign({
        cwd: process.cwd(),
        env: "development"
      }, ctx2);
      if (!ctx2.env) {
        process.env.NODE_ENV = "development";
      }
      return ctx2;
    };
    var importDefault2 = async (filepath) => {
      const module3 = await import(url2.pathToFileURL(filepath).href);
      return module3.default;
    };
    var addTypeScriptLoader2 = (options3 = {}, loader) => {
      const moduleName = "postcss";
      return {
        ...options3,
        searchPlaces: [
          ...options3.searchPlaces || [],
          "package.json",
          `.${moduleName}rc`,
          `.${moduleName}rc.json`,
          `.${moduleName}rc.yaml`,
          `.${moduleName}rc.yml`,
          `.${moduleName}rc.ts`,
          `.${moduleName}rc.js`,
          `.${moduleName}rc.cjs`,
          `.${moduleName}rc.mjs`,
          `${moduleName}.config.ts`,
          `${moduleName}.config.js`,
          `${moduleName}.config.cjs`,
          `${moduleName}.config.mjs`
        ],
        loaders: {
          ...options3.loaders,
          ".yaml": (filepath, content) => yaml3.parse(content),
          ".yml": (filepath, content) => yaml3.parse(content),
          ".js": importDefault2,
          ".cjs": importDefault2,
          ".mjs": importDefault2,
          ".ts": loader
        }
      };
    };
    var withTypeScriptLoader2 = (rcFunc2) => {
      return (ctx2, path8, options3) => {
        return rcFunc2(ctx2, path8, addTypeScriptLoader2(options3, (configFile2) => {
          let registerer2 = { enabled() {
          } };
          try {
            registerer2 = require_vite_optional_peer_dep_ts_node_postcss_load_config().register();
            return __require(configFile2);
          } catch (err2) {
            if (err2.code === "MODULE_NOT_FOUND") {
              throw new Error(
                `'ts-node' is required for the TypeScript configuration files. Make sure it is installed
Error: ${err2.message}`
              );
            }
            throw err2;
          } finally {
            registerer2.enabled(false);
          }
        }));
      };
    };
    var rc2 = withTypeScriptLoader2((ctx2, path8, options3) => {
      ctx2 = createContext2(ctx2);
      path8 = path8 ? resolve4(path8) : process.cwd();
      return config2.lilconfig("postcss", options3).search(path8).then((result) => {
        if (!result) {
          throw new Error(`No PostCSS Config found in: ${path8}`);
        }
        return processResult2(ctx2, result);
      });
    });
    module2.exports = rc2;
  }
});

// node_modules/.pnpm/entities@3.0.1/node_modules/entities/lib/maps/entities.json
var require_entities = __commonJS({
  "node_modules/.pnpm/entities@3.0.1/node_modules/entities/lib/maps/entities.json"(exports3, module2) {
    module2.exports = { Aacute: "Á", aacute: "á", Abreve: "Ă", abreve: "ă", ac: "∾", acd: "∿", acE: "∾̳", Acirc: "Â", acirc: "â", acute: "´", Acy: "А", acy: "а", AElig: "Æ", aelig: "æ", af: "⁡", Afr: "𝔄", afr: "𝔞", Agrave: "À", agrave: "à", alefsym: "ℵ", aleph: "ℵ", Alpha: "Α", alpha: "α", Amacr: "Ā", amacr: "ā", amalg: "⨿", amp: "&", AMP: "&", andand: "⩕", And: "⩓", and: "∧", andd: "⩜", andslope: "⩘", andv: "⩚", ang: "∠", ange: "⦤", angle: "∠", angmsdaa: "⦨", angmsdab: "⦩", angmsdac: "⦪", angmsdad: "⦫", angmsdae: "⦬", angmsdaf: "⦭", angmsdag: "⦮", angmsdah: "⦯", angmsd: "∡", angrt: "∟", angrtvb: "⊾", angrtvbd: "⦝", angsph: "∢", angst: "Å", angzarr: "⍼", Aogon: "Ą", aogon: "ą", Aopf: "𝔸", aopf: "𝕒", apacir: "⩯", ap: "≈", apE: "⩰", ape: "≊", apid: "≋", apos: "'", ApplyFunction: "⁡", approx: "≈", approxeq: "≊", Aring: "Å", aring: "å", Ascr: "𝒜", ascr: "𝒶", Assign: "≔", ast: "*", asymp: "≈", asympeq: "≍", Atilde: "Ã", atilde: "ã", Auml: "Ä", auml: "ä", awconint: "∳", awint: "⨑", backcong: "≌", backepsilon: "϶", backprime: "‵", backsim: "∽", backsimeq: "⋍", Backslash: "∖", Barv: "⫧", barvee: "⊽", barwed: "⌅", Barwed: "⌆", barwedge: "⌅", bbrk: "⎵", bbrktbrk: "⎶", bcong: "≌", Bcy: "Б", bcy: "б", bdquo: "„", becaus: "∵", because: "∵", Because: "∵", bemptyv: "⦰", bepsi: "϶", bernou: "ℬ", Bernoullis: "ℬ", Beta: "Β", beta: "β", beth: "ℶ", between: "≬", Bfr: "𝔅", bfr: "𝔟", bigcap: "⋂", bigcirc: "◯", bigcup: "⋃", bigodot: "⨀", bigoplus: "⨁", bigotimes: "⨂", bigsqcup: "⨆", bigstar: "★", bigtriangledown: "▽", bigtriangleup: "△", biguplus: "⨄", bigvee: "⋁", bigwedge: "⋀", bkarow: "⤍", blacklozenge: "⧫", blacksquare: "▪", blacktriangle: "▴", blacktriangledown: "▾", blacktriangleleft: "◂", blacktriangleright: "▸", blank: "␣", blk12: "▒", blk14: "░", blk34: "▓", block: "█", bne: "=⃥", bnequiv: "≡⃥", bNot: "⫭", bnot: "⌐", Bopf: "𝔹", bopf: "𝕓", bot: "⊥", bottom: "⊥", bowtie: "⋈", boxbox: "⧉", boxdl: "┐", boxdL: "╕", boxDl: "╖", boxDL: "╗", boxdr: "┌", boxdR: "╒", boxDr: "╓", boxDR: "╔", boxh: "─", boxH: "═", boxhd: "┬", boxHd: "╤", boxhD: "╥", boxHD: "╦", boxhu: "┴", boxHu: "╧", boxhU: "╨", boxHU: "╩", boxminus: "⊟", boxplus: "⊞", boxtimes: "⊠", boxul: "┘", boxuL: "╛", boxUl: "╜", boxUL: "╝", boxur: "└", boxuR: "╘", boxUr: "╙", boxUR: "╚", boxv: "│", boxV: "║", boxvh: "┼", boxvH: "╪", boxVh: "╫", boxVH: "╬", boxvl: "┤", boxvL: "╡", boxVl: "╢", boxVL: "╣", boxvr: "├", boxvR: "╞", boxVr: "╟", boxVR: "╠", bprime: "‵", breve: "˘", Breve: "˘", brvbar: "¦", bscr: "𝒷", Bscr: "ℬ", bsemi: "⁏", bsim: "∽", bsime: "⋍", bsolb: "⧅", bsol: "\\", bsolhsub: "⟈", bull: "•", bullet: "•", bump: "≎", bumpE: "⪮", bumpe: "≏", Bumpeq: "≎", bumpeq: "≏", Cacute: "Ć", cacute: "ć", capand: "⩄", capbrcup: "⩉", capcap: "⩋", cap: "∩", Cap: "⋒", capcup: "⩇", capdot: "⩀", CapitalDifferentialD: "ⅅ", caps: "∩︀", caret: "⁁", caron: "ˇ", Cayleys: "ℭ", ccaps: "⩍", Ccaron: "Č", ccaron: "č", Ccedil: "Ç", ccedil: "ç", Ccirc: "Ĉ", ccirc: "ĉ", Cconint: "∰", ccups: "⩌", ccupssm: "⩐", Cdot: "Ċ", cdot: "ċ", cedil: "¸", Cedilla: "¸", cemptyv: "⦲", cent: "¢", centerdot: "·", CenterDot: "·", cfr: "𝔠", Cfr: "ℭ", CHcy: "Ч", chcy: "ч", check: "✓", checkmark: "✓", Chi: "Χ", chi: "χ", circ: "ˆ", circeq: "≗", circlearrowleft: "↺", circlearrowright: "↻", circledast: "⊛", circledcirc: "⊚", circleddash: "⊝", CircleDot: "⊙", circledR: "®", circledS: "Ⓢ", CircleMinus: "⊖", CirclePlus: "⊕", CircleTimes: "⊗", cir: "○", cirE: "⧃", cire: "≗", cirfnint: "⨐", cirmid: "⫯", cirscir: "⧂", ClockwiseContourIntegral: "∲", CloseCurlyDoubleQuote: "”", CloseCurlyQuote: "’", clubs: "♣", clubsuit: "♣", colon: ":", Colon: "∷", Colone: "⩴", colone: "≔", coloneq: "≔", comma: ",", commat: "@", comp: "∁", compfn: "∘", complement: "∁", complexes: "ℂ", cong: "≅", congdot: "⩭", Congruent: "≡", conint: "∮", Conint: "∯", ContourIntegral: "∮", copf: "𝕔", Copf: "ℂ", coprod: "∐", Coproduct: "∐", copy: "©", COPY: "©", copysr: "℗", CounterClockwiseContourIntegral: "∳", crarr: "↵", cross: "✗", Cross: "⨯", Cscr: "𝒞", cscr: "𝒸", csub: "⫏", csube: "⫑", csup: "⫐", csupe: "⫒", ctdot: "⋯", cudarrl: "⤸", cudarrr: "⤵", cuepr: "⋞", cuesc: "⋟", cularr: "↶", cularrp: "⤽", cupbrcap: "⩈", cupcap: "⩆", CupCap: "≍", cup: "∪", Cup: "⋓", cupcup: "⩊", cupdot: "⊍", cupor: "⩅", cups: "∪︀", curarr: "↷", curarrm: "⤼", curlyeqprec: "⋞", curlyeqsucc: "⋟", curlyvee: "⋎", curlywedge: "⋏", curren: "¤", curvearrowleft: "↶", curvearrowright: "↷", cuvee: "⋎", cuwed: "⋏", cwconint: "∲", cwint: "∱", cylcty: "⌭", dagger: "†", Dagger: "‡", daleth: "ℸ", darr: "↓", Darr: "↡", dArr: "⇓", dash: "‐", Dashv: "⫤", dashv: "⊣", dbkarow: "⤏", dblac: "˝", Dcaron: "Ď", dcaron: "ď", Dcy: "Д", dcy: "д", ddagger: "‡", ddarr: "⇊", DD: "ⅅ", dd: "ⅆ", DDotrahd: "⤑", ddotseq: "⩷", deg: "°", Del: "∇", Delta: "Δ", delta: "δ", demptyv: "⦱", dfisht: "⥿", Dfr: "𝔇", dfr: "𝔡", dHar: "⥥", dharl: "⇃", dharr: "⇂", DiacriticalAcute: "´", DiacriticalDot: "˙", DiacriticalDoubleAcute: "˝", DiacriticalGrave: "`", DiacriticalTilde: "˜", diam: "⋄", diamond: "⋄", Diamond: "⋄", diamondsuit: "♦", diams: "♦", die: "¨", DifferentialD: "ⅆ", digamma: "ϝ", disin: "⋲", div: "÷", divide: "÷", divideontimes: "⋇", divonx: "⋇", DJcy: "Ђ", djcy: "ђ", dlcorn: "⌞", dlcrop: "⌍", dollar: "$", Dopf: "𝔻", dopf: "𝕕", Dot: "¨", dot: "˙", DotDot: "⃜", doteq: "≐", doteqdot: "≑", DotEqual: "≐", dotminus: "∸", dotplus: "∔", dotsquare: "⊡", doublebarwedge: "⌆", DoubleContourIntegral: "∯", DoubleDot: "¨", DoubleDownArrow: "⇓", DoubleLeftArrow: "⇐", DoubleLeftRightArrow: "⇔", DoubleLeftTee: "⫤", DoubleLongLeftArrow: "⟸", DoubleLongLeftRightArrow: "⟺", DoubleLongRightArrow: "⟹", DoubleRightArrow: "⇒", DoubleRightTee: "⊨", DoubleUpArrow: "⇑", DoubleUpDownArrow: "⇕", DoubleVerticalBar: "∥", DownArrowBar: "⤓", downarrow: "↓", DownArrow: "↓", Downarrow: "⇓", DownArrowUpArrow: "⇵", DownBreve: "̑", downdownarrows: "⇊", downharpoonleft: "⇃", downharpoonright: "⇂", DownLeftRightVector: "⥐", DownLeftTeeVector: "⥞", DownLeftVectorBar: "⥖", DownLeftVector: "↽", DownRightTeeVector: "⥟", DownRightVectorBar: "⥗", DownRightVector: "⇁", DownTeeArrow: "↧", DownTee: "⊤", drbkarow: "⤐", drcorn: "⌟", drcrop: "⌌", Dscr: "𝒟", dscr: "𝒹", DScy: "Ѕ", dscy: "ѕ", dsol: "⧶", Dstrok: "Đ", dstrok: "đ", dtdot: "⋱", dtri: "▿", dtrif: "▾", duarr: "⇵", duhar: "⥯", dwangle: "⦦", DZcy: "Џ", dzcy: "џ", dzigrarr: "⟿", Eacute: "É", eacute: "é", easter: "⩮", Ecaron: "Ě", ecaron: "ě", Ecirc: "Ê", ecirc: "ê", ecir: "≖", ecolon: "≕", Ecy: "Э", ecy: "э", eDDot: "⩷", Edot: "Ė", edot: "ė", eDot: "≑", ee: "ⅇ", efDot: "≒", Efr: "𝔈", efr: "𝔢", eg: "⪚", Egrave: "È", egrave: "è", egs: "⪖", egsdot: "⪘", el: "⪙", Element: "∈", elinters: "⏧", ell: "ℓ", els: "⪕", elsdot: "⪗", Emacr: "Ē", emacr: "ē", empty: "∅", emptyset: "∅", EmptySmallSquare: "◻", emptyv: "∅", EmptyVerySmallSquare: "▫", emsp13: " ", emsp14: " ", emsp: " ", ENG: "Ŋ", eng: "ŋ", ensp: " ", Eogon: "Ę", eogon: "ę", Eopf: "𝔼", eopf: "𝕖", epar: "⋕", eparsl: "⧣", eplus: "⩱", epsi: "ε", Epsilon: "Ε", epsilon: "ε", epsiv: "ϵ", eqcirc: "≖", eqcolon: "≕", eqsim: "≂", eqslantgtr: "⪖", eqslantless: "⪕", Equal: "⩵", equals: "=", EqualTilde: "≂", equest: "≟", Equilibrium: "⇌", equiv: "≡", equivDD: "⩸", eqvparsl: "⧥", erarr: "⥱", erDot: "≓", escr: "ℯ", Escr: "ℰ", esdot: "≐", Esim: "⩳", esim: "≂", Eta: "Η", eta: "η", ETH: "Ð", eth: "ð", Euml: "Ë", euml: "ë", euro: "€", excl: "!", exist: "∃", Exists: "∃", expectation: "ℰ", exponentiale: "ⅇ", ExponentialE: "ⅇ", fallingdotseq: "≒", Fcy: "Ф", fcy: "ф", female: "♀", ffilig: "ﬃ", fflig: "ﬀ", ffllig: "ﬄ", Ffr: "𝔉", ffr: "𝔣", filig: "ﬁ", FilledSmallSquare: "◼", FilledVerySmallSquare: "▪", fjlig: "fj", flat: "♭", fllig: "ﬂ", fltns: "▱", fnof: "ƒ", Fopf: "𝔽", fopf: "𝕗", forall: "∀", ForAll: "∀", fork: "⋔", forkv: "⫙", Fouriertrf: "ℱ", fpartint: "⨍", frac12: "½", frac13: "⅓", frac14: "¼", frac15: "⅕", frac16: "⅙", frac18: "⅛", frac23: "⅔", frac25: "⅖", frac34: "¾", frac35: "⅗", frac38: "⅜", frac45: "⅘", frac56: "⅚", frac58: "⅝", frac78: "⅞", frasl: "⁄", frown: "⌢", fscr: "𝒻", Fscr: "ℱ", gacute: "ǵ", Gamma: "Γ", gamma: "γ", Gammad: "Ϝ", gammad: "ϝ", gap: "⪆", Gbreve: "Ğ", gbreve: "ğ", Gcedil: "Ģ", Gcirc: "Ĝ", gcirc: "ĝ", Gcy: "Г", gcy: "г", Gdot: "Ġ", gdot: "ġ", ge: "≥", gE: "≧", gEl: "⪌", gel: "⋛", geq: "≥", geqq: "≧", geqslant: "⩾", gescc: "⪩", ges: "⩾", gesdot: "⪀", gesdoto: "⪂", gesdotol: "⪄", gesl: "⋛︀", gesles: "⪔", Gfr: "𝔊", gfr: "𝔤", gg: "≫", Gg: "⋙", ggg: "⋙", gimel: "ℷ", GJcy: "Ѓ", gjcy: "ѓ", gla: "⪥", gl: "≷", glE: "⪒", glj: "⪤", gnap: "⪊", gnapprox: "⪊", gne: "⪈", gnE: "≩", gneq: "⪈", gneqq: "≩", gnsim: "⋧", Gopf: "𝔾", gopf: "𝕘", grave: "`", GreaterEqual: "≥", GreaterEqualLess: "⋛", GreaterFullEqual: "≧", GreaterGreater: "⪢", GreaterLess: "≷", GreaterSlantEqual: "⩾", GreaterTilde: "≳", Gscr: "𝒢", gscr: "ℊ", gsim: "≳", gsime: "⪎", gsiml: "⪐", gtcc: "⪧", gtcir: "⩺", gt: ">", GT: ">", Gt: "≫", gtdot: "⋗", gtlPar: "⦕", gtquest: "⩼", gtrapprox: "⪆", gtrarr: "⥸", gtrdot: "⋗", gtreqless: "⋛", gtreqqless: "⪌", gtrless: "≷", gtrsim: "≳", gvertneqq: "≩︀", gvnE: "≩︀", Hacek: "ˇ", hairsp: " ", half: "½", hamilt: "ℋ", HARDcy: "Ъ", hardcy: "ъ", harrcir: "⥈", harr: "↔", hArr: "⇔", harrw: "↭", Hat: "^", hbar: "ℏ", Hcirc: "Ĥ", hcirc: "ĥ", hearts: "♥", heartsuit: "♥", hellip: "…", hercon: "⊹", hfr: "𝔥", Hfr: "ℌ", HilbertSpace: "ℋ", hksearow: "⤥", hkswarow: "⤦", hoarr: "⇿", homtht: "∻", hookleftarrow: "↩", hookrightarrow: "↪", hopf: "𝕙", Hopf: "ℍ", horbar: "―", HorizontalLine: "─", hscr: "𝒽", Hscr: "ℋ", hslash: "ℏ", Hstrok: "Ħ", hstrok: "ħ", HumpDownHump: "≎", HumpEqual: "≏", hybull: "⁃", hyphen: "‐", Iacute: "Í", iacute: "í", ic: "⁣", Icirc: "Î", icirc: "î", Icy: "И", icy: "и", Idot: "İ", IEcy: "Е", iecy: "е", iexcl: "¡", iff: "⇔", ifr: "𝔦", Ifr: "ℑ", Igrave: "Ì", igrave: "ì", ii: "ⅈ", iiiint: "⨌", iiint: "∭", iinfin: "⧜", iiota: "℩", IJlig: "Ĳ", ijlig: "ĳ", Imacr: "Ī", imacr: "ī", image: "ℑ", ImaginaryI: "ⅈ", imagline: "ℐ", imagpart: "ℑ", imath: "ı", Im: "ℑ", imof: "⊷", imped: "Ƶ", Implies: "⇒", incare: "℅", in: "∈", infin: "∞", infintie: "⧝", inodot: "ı", intcal: "⊺", int: "∫", Int: "∬", integers: "ℤ", Integral: "∫", intercal: "⊺", Intersection: "⋂", intlarhk: "⨗", intprod: "⨼", InvisibleComma: "⁣", InvisibleTimes: "⁢", IOcy: "Ё", iocy: "ё", Iogon: "Į", iogon: "į", Iopf: "𝕀", iopf: "𝕚", Iota: "Ι", iota: "ι", iprod: "⨼", iquest: "¿", iscr: "𝒾", Iscr: "ℐ", isin: "∈", isindot: "⋵", isinE: "⋹", isins: "⋴", isinsv: "⋳", isinv: "∈", it: "⁢", Itilde: "Ĩ", itilde: "ĩ", Iukcy: "І", iukcy: "і", Iuml: "Ï", iuml: "ï", Jcirc: "Ĵ", jcirc: "ĵ", Jcy: "Й", jcy: "й", Jfr: "𝔍", jfr: "𝔧", jmath: "ȷ", Jopf: "𝕁", jopf: "𝕛", Jscr: "𝒥", jscr: "𝒿", Jsercy: "Ј", jsercy: "ј", Jukcy: "Є", jukcy: "є", Kappa: "Κ", kappa: "κ", kappav: "ϰ", Kcedil: "Ķ", kcedil: "ķ", Kcy: "К", kcy: "к", Kfr: "𝔎", kfr: "𝔨", kgreen: "ĸ", KHcy: "Х", khcy: "х", KJcy: "Ќ", kjcy: "ќ", Kopf: "𝕂", kopf: "𝕜", Kscr: "𝒦", kscr: "𝓀", lAarr: "⇚", Lacute: "Ĺ", lacute: "ĺ", laemptyv: "⦴", lagran: "ℒ", Lambda: "Λ", lambda: "λ", lang: "⟨", Lang: "⟪", langd: "⦑", langle: "⟨", lap: "⪅", Laplacetrf: "ℒ", laquo: "«", larrb: "⇤", larrbfs: "⤟", larr: "←", Larr: "↞", lArr: "⇐", larrfs: "⤝", larrhk: "↩", larrlp: "↫", larrpl: "⤹", larrsim: "⥳", larrtl: "↢", latail: "⤙", lAtail: "⤛", lat: "⪫", late: "⪭", lates: "⪭︀", lbarr: "⤌", lBarr: "⤎", lbbrk: "❲", lbrace: "{", lbrack: "[", lbrke: "⦋", lbrksld: "⦏", lbrkslu: "⦍", Lcaron: "Ľ", lcaron: "ľ", Lcedil: "Ļ", lcedil: "ļ", lceil: "⌈", lcub: "{", Lcy: "Л", lcy: "л", ldca: "⤶", ldquo: "“", ldquor: "„", ldrdhar: "⥧", ldrushar: "⥋", ldsh: "↲", le: "≤", lE: "≦", LeftAngleBracket: "⟨", LeftArrowBar: "⇤", leftarrow: "←", LeftArrow: "←", Leftarrow: "⇐", LeftArrowRightArrow: "⇆", leftarrowtail: "↢", LeftCeiling: "⌈", LeftDoubleBracket: "⟦", LeftDownTeeVector: "⥡", LeftDownVectorBar: "⥙", LeftDownVector: "⇃", LeftFloor: "⌊", leftharpoondown: "↽", leftharpoonup: "↼", leftleftarrows: "⇇", leftrightarrow: "↔", LeftRightArrow: "↔", Leftrightarrow: "⇔", leftrightarrows: "⇆", leftrightharpoons: "⇋", leftrightsquigarrow: "↭", LeftRightVector: "⥎", LeftTeeArrow: "↤", LeftTee: "⊣", LeftTeeVector: "⥚", leftthreetimes: "⋋", LeftTriangleBar: "⧏", LeftTriangle: "⊲", LeftTriangleEqual: "⊴", LeftUpDownVector: "⥑", LeftUpTeeVector: "⥠", LeftUpVectorBar: "⥘", LeftUpVector: "↿", LeftVectorBar: "⥒", LeftVector: "↼", lEg: "⪋", leg: "⋚", leq: "≤", leqq: "≦", leqslant: "⩽", lescc: "⪨", les: "⩽", lesdot: "⩿", lesdoto: "⪁", lesdotor: "⪃", lesg: "⋚︀", lesges: "⪓", lessapprox: "⪅", lessdot: "⋖", lesseqgtr: "⋚", lesseqqgtr: "⪋", LessEqualGreater: "⋚", LessFullEqual: "≦", LessGreater: "≶", lessgtr: "≶", LessLess: "⪡", lesssim: "≲", LessSlantEqual: "⩽", LessTilde: "≲", lfisht: "⥼", lfloor: "⌊", Lfr: "𝔏", lfr: "𝔩", lg: "≶", lgE: "⪑", lHar: "⥢", lhard: "↽", lharu: "↼", lharul: "⥪", lhblk: "▄", LJcy: "Љ", ljcy: "љ", llarr: "⇇", ll: "≪", Ll: "⋘", llcorner: "⌞", Lleftarrow: "⇚", llhard: "⥫", lltri: "◺", Lmidot: "Ŀ", lmidot: "ŀ", lmoustache: "⎰", lmoust: "⎰", lnap: "⪉", lnapprox: "⪉", lne: "⪇", lnE: "≨", lneq: "⪇", lneqq: "≨", lnsim: "⋦", loang: "⟬", loarr: "⇽", lobrk: "⟦", longleftarrow: "⟵", LongLeftArrow: "⟵", Longleftarrow: "⟸", longleftrightarrow: "⟷", LongLeftRightArrow: "⟷", Longleftrightarrow: "⟺", longmapsto: "⟼", longrightarrow: "⟶", LongRightArrow: "⟶", Longrightarrow: "⟹", looparrowleft: "↫", looparrowright: "↬", lopar: "⦅", Lopf: "𝕃", lopf: "𝕝", loplus: "⨭", lotimes: "⨴", lowast: "∗", lowbar: "_", LowerLeftArrow: "↙", LowerRightArrow: "↘", loz: "◊", lozenge: "◊", lozf: "⧫", lpar: "(", lparlt: "⦓", lrarr: "⇆", lrcorner: "⌟", lrhar: "⇋", lrhard: "⥭", lrm: "‎", lrtri: "⊿", lsaquo: "‹", lscr: "𝓁", Lscr: "ℒ", lsh: "↰", Lsh: "↰", lsim: "≲", lsime: "⪍", lsimg: "⪏", lsqb: "[", lsquo: "‘", lsquor: "‚", Lstrok: "Ł", lstrok: "ł", ltcc: "⪦", ltcir: "⩹", lt: "<", LT: "<", Lt: "≪", ltdot: "⋖", lthree: "⋋", ltimes: "⋉", ltlarr: "⥶", ltquest: "⩻", ltri: "◃", ltrie: "⊴", ltrif: "◂", ltrPar: "⦖", lurdshar: "⥊", luruhar: "⥦", lvertneqq: "≨︀", lvnE: "≨︀", macr: "¯", male: "♂", malt: "✠", maltese: "✠", Map: "⤅", map: "↦", mapsto: "↦", mapstodown: "↧", mapstoleft: "↤", mapstoup: "↥", marker: "▮", mcomma: "⨩", Mcy: "М", mcy: "м", mdash: "—", mDDot: "∺", measuredangle: "∡", MediumSpace: " ", Mellintrf: "ℳ", Mfr: "𝔐", mfr: "𝔪", mho: "℧", micro: "µ", midast: "*", midcir: "⫰", mid: "∣", middot: "·", minusb: "⊟", minus: "−", minusd: "∸", minusdu: "⨪", MinusPlus: "∓", mlcp: "⫛", mldr: "…", mnplus: "∓", models: "⊧", Mopf: "𝕄", mopf: "𝕞", mp: "∓", mscr: "𝓂", Mscr: "ℳ", mstpos: "∾", Mu: "Μ", mu: "μ", multimap: "⊸", mumap: "⊸", nabla: "∇", Nacute: "Ń", nacute: "ń", nang: "∠⃒", nap: "≉", napE: "⩰̸", napid: "≋̸", napos: "ŉ", napprox: "≉", natural: "♮", naturals: "ℕ", natur: "♮", nbsp: " ", nbump: "≎̸", nbumpe: "≏̸", ncap: "⩃", Ncaron: "Ň", ncaron: "ň", Ncedil: "Ņ", ncedil: "ņ", ncong: "≇", ncongdot: "⩭̸", ncup: "⩂", Ncy: "Н", ncy: "н", ndash: "–", nearhk: "⤤", nearr: "↗", neArr: "⇗", nearrow: "↗", ne: "≠", nedot: "≐̸", NegativeMediumSpace: "​", NegativeThickSpace: "​", NegativeThinSpace: "​", NegativeVeryThinSpace: "​", nequiv: "≢", nesear: "⤨", nesim: "≂̸", NestedGreaterGreater: "≫", NestedLessLess: "≪", NewLine: "\n", nexist: "∄", nexists: "∄", Nfr: "𝔑", nfr: "𝔫", ngE: "≧̸", nge: "≱", ngeq: "≱", ngeqq: "≧̸", ngeqslant: "⩾̸", nges: "⩾̸", nGg: "⋙̸", ngsim: "≵", nGt: "≫⃒", ngt: "≯", ngtr: "≯", nGtv: "≫̸", nharr: "↮", nhArr: "⇎", nhpar: "⫲", ni: "∋", nis: "⋼", nisd: "⋺", niv: "∋", NJcy: "Њ", njcy: "њ", nlarr: "↚", nlArr: "⇍", nldr: "‥", nlE: "≦̸", nle: "≰", nleftarrow: "↚", nLeftarrow: "⇍", nleftrightarrow: "↮", nLeftrightarrow: "⇎", nleq: "≰", nleqq: "≦̸", nleqslant: "⩽̸", nles: "⩽̸", nless: "≮", nLl: "⋘̸", nlsim: "≴", nLt: "≪⃒", nlt: "≮", nltri: "⋪", nltrie: "⋬", nLtv: "≪̸", nmid: "∤", NoBreak: "⁠", NonBreakingSpace: " ", nopf: "𝕟", Nopf: "ℕ", Not: "⫬", not: "¬", NotCongruent: "≢", NotCupCap: "≭", NotDoubleVerticalBar: "∦", NotElement: "∉", NotEqual: "≠", NotEqualTilde: "≂̸", NotExists: "∄", NotGreater: "≯", NotGreaterEqual: "≱", NotGreaterFullEqual: "≧̸", NotGreaterGreater: "≫̸", NotGreaterLess: "≹", NotGreaterSlantEqual: "⩾̸", NotGreaterTilde: "≵", NotHumpDownHump: "≎̸", NotHumpEqual: "≏̸", notin: "∉", notindot: "⋵̸", notinE: "⋹̸", notinva: "∉", notinvb: "⋷", notinvc: "⋶", NotLeftTriangleBar: "⧏̸", NotLeftTriangle: "⋪", NotLeftTriangleEqual: "⋬", NotLess: "≮", NotLessEqual: "≰", NotLessGreater: "≸", NotLessLess: "≪̸", NotLessSlantEqual: "⩽̸", NotLessTilde: "≴", NotNestedGreaterGreater: "⪢̸", NotNestedLessLess: "⪡̸", notni: "∌", notniva: "∌", notnivb: "⋾", notnivc: "⋽", NotPrecedes: "⊀", NotPrecedesEqual: "⪯̸", NotPrecedesSlantEqual: "⋠", NotReverseElement: "∌", NotRightTriangleBar: "⧐̸", NotRightTriangle: "⋫", NotRightTriangleEqual: "⋭", NotSquareSubset: "⊏̸", NotSquareSubsetEqual: "⋢", NotSquareSuperset: "⊐̸", NotSquareSupersetEqual: "⋣", NotSubset: "⊂⃒", NotSubsetEqual: "⊈", NotSucceeds: "⊁", NotSucceedsEqual: "⪰̸", NotSucceedsSlantEqual: "⋡", NotSucceedsTilde: "≿̸", NotSuperset: "⊃⃒", NotSupersetEqual: "⊉", NotTilde: "≁", NotTildeEqual: "≄", NotTildeFullEqual: "≇", NotTildeTilde: "≉", NotVerticalBar: "∤", nparallel: "∦", npar: "∦", nparsl: "⫽⃥", npart: "∂̸", npolint: "⨔", npr: "⊀", nprcue: "⋠", nprec: "⊀", npreceq: "⪯̸", npre: "⪯̸", nrarrc: "⤳̸", nrarr: "↛", nrArr: "⇏", nrarrw: "↝̸", nrightarrow: "↛", nRightarrow: "⇏", nrtri: "⋫", nrtrie: "⋭", nsc: "⊁", nsccue: "⋡", nsce: "⪰̸", Nscr: "𝒩", nscr: "𝓃", nshortmid: "∤", nshortparallel: "∦", nsim: "≁", nsime: "≄", nsimeq: "≄", nsmid: "∤", nspar: "∦", nsqsube: "⋢", nsqsupe: "⋣", nsub: "⊄", nsubE: "⫅̸", nsube: "⊈", nsubset: "⊂⃒", nsubseteq: "⊈", nsubseteqq: "⫅̸", nsucc: "⊁", nsucceq: "⪰̸", nsup: "⊅", nsupE: "⫆̸", nsupe: "⊉", nsupset: "⊃⃒", nsupseteq: "⊉", nsupseteqq: "⫆̸", ntgl: "≹", Ntilde: "Ñ", ntilde: "ñ", ntlg: "≸", ntriangleleft: "⋪", ntrianglelefteq: "⋬", ntriangleright: "⋫", ntrianglerighteq: "⋭", Nu: "Ν", nu: "ν", num: "#", numero: "№", numsp: " ", nvap: "≍⃒", nvdash: "⊬", nvDash: "⊭", nVdash: "⊮", nVDash: "⊯", nvge: "≥⃒", nvgt: ">⃒", nvHarr: "⤄", nvinfin: "⧞", nvlArr: "⤂", nvle: "≤⃒", nvlt: "<⃒", nvltrie: "⊴⃒", nvrArr: "⤃", nvrtrie: "⊵⃒", nvsim: "∼⃒", nwarhk: "⤣", nwarr: "↖", nwArr: "⇖", nwarrow: "↖", nwnear: "⤧", Oacute: "Ó", oacute: "ó", oast: "⊛", Ocirc: "Ô", ocirc: "ô", ocir: "⊚", Ocy: "О", ocy: "о", odash: "⊝", Odblac: "Ő", odblac: "ő", odiv: "⨸", odot: "⊙", odsold: "⦼", OElig: "Œ", oelig: "œ", ofcir: "⦿", Ofr: "𝔒", ofr: "𝔬", ogon: "˛", Ograve: "Ò", ograve: "ò", ogt: "⧁", ohbar: "⦵", ohm: "Ω", oint: "∮", olarr: "↺", olcir: "⦾", olcross: "⦻", oline: "‾", olt: "⧀", Omacr: "Ō", omacr: "ō", Omega: "Ω", omega: "ω", Omicron: "Ο", omicron: "ο", omid: "⦶", ominus: "⊖", Oopf: "𝕆", oopf: "𝕠", opar: "⦷", OpenCurlyDoubleQuote: "“", OpenCurlyQuote: "‘", operp: "⦹", oplus: "⊕", orarr: "↻", Or: "⩔", or: "∨", ord: "⩝", order: "ℴ", orderof: "ℴ", ordf: "ª", ordm: "º", origof: "⊶", oror: "⩖", orslope: "⩗", orv: "⩛", oS: "Ⓢ", Oscr: "𝒪", oscr: "ℴ", Oslash: "Ø", oslash: "ø", osol: "⊘", Otilde: "Õ", otilde: "õ", otimesas: "⨶", Otimes: "⨷", otimes: "⊗", Ouml: "Ö", ouml: "ö", ovbar: "⌽", OverBar: "‾", OverBrace: "⏞", OverBracket: "⎴", OverParenthesis: "⏜", para: "¶", parallel: "∥", par: "∥", parsim: "⫳", parsl: "⫽", part: "∂", PartialD: "∂", Pcy: "П", pcy: "п", percnt: "%", period: ".", permil: "‰", perp: "⊥", pertenk: "‱", Pfr: "𝔓", pfr: "𝔭", Phi: "Φ", phi: "φ", phiv: "ϕ", phmmat: "ℳ", phone: "☎", Pi: "Π", pi: "π", pitchfork: "⋔", piv: "ϖ", planck: "ℏ", planckh: "ℎ", plankv: "ℏ", plusacir: "⨣", plusb: "⊞", pluscir: "⨢", plus: "+", plusdo: "∔", plusdu: "⨥", pluse: "⩲", PlusMinus: "±", plusmn: "±", plussim: "⨦", plustwo: "⨧", pm: "±", Poincareplane: "ℌ", pointint: "⨕", popf: "𝕡", Popf: "ℙ", pound: "£", prap: "⪷", Pr: "⪻", pr: "≺", prcue: "≼", precapprox: "⪷", prec: "≺", preccurlyeq: "≼", Precedes: "≺", PrecedesEqual: "⪯", PrecedesSlantEqual: "≼", PrecedesTilde: "≾", preceq: "⪯", precnapprox: "⪹", precneqq: "⪵", precnsim: "⋨", pre: "⪯", prE: "⪳", precsim: "≾", prime: "′", Prime: "″", primes: "ℙ", prnap: "⪹", prnE: "⪵", prnsim: "⋨", prod: "∏", Product: "∏", profalar: "⌮", profline: "⌒", profsurf: "⌓", prop: "∝", Proportional: "∝", Proportion: "∷", propto: "∝", prsim: "≾", prurel: "⊰", Pscr: "𝒫", pscr: "𝓅", Psi: "Ψ", psi: "ψ", puncsp: " ", Qfr: "𝔔", qfr: "𝔮", qint: "⨌", qopf: "𝕢", Qopf: "ℚ", qprime: "⁗", Qscr: "𝒬", qscr: "𝓆", quaternions: "ℍ", quatint: "⨖", quest: "?", questeq: "≟", quot: '"', QUOT: '"', rAarr: "⇛", race: "∽̱", Racute: "Ŕ", racute: "ŕ", radic: "√", raemptyv: "⦳", rang: "⟩", Rang: "⟫", rangd: "⦒", range: "⦥", rangle: "⟩", raquo: "»", rarrap: "⥵", rarrb: "⇥", rarrbfs: "⤠", rarrc: "⤳", rarr: "→", Rarr: "↠", rArr: "⇒", rarrfs: "⤞", rarrhk: "↪", rarrlp: "↬", rarrpl: "⥅", rarrsim: "⥴", Rarrtl: "⤖", rarrtl: "↣", rarrw: "↝", ratail: "⤚", rAtail: "⤜", ratio: "∶", rationals: "ℚ", rbarr: "⤍", rBarr: "⤏", RBarr: "⤐", rbbrk: "❳", rbrace: "}", rbrack: "]", rbrke: "⦌", rbrksld: "⦎", rbrkslu: "⦐", Rcaron: "Ř", rcaron: "ř", Rcedil: "Ŗ", rcedil: "ŗ", rceil: "⌉", rcub: "}", Rcy: "Р", rcy: "р", rdca: "⤷", rdldhar: "⥩", rdquo: "”", rdquor: "”", rdsh: "↳", real: "ℜ", realine: "ℛ", realpart: "ℜ", reals: "ℝ", Re: "ℜ", rect: "▭", reg: "®", REG: "®", ReverseElement: "∋", ReverseEquilibrium: "⇋", ReverseUpEquilibrium: "⥯", rfisht: "⥽", rfloor: "⌋", rfr: "𝔯", Rfr: "ℜ", rHar: "⥤", rhard: "⇁", rharu: "⇀", rharul: "⥬", Rho: "Ρ", rho: "ρ", rhov: "ϱ", RightAngleBracket: "⟩", RightArrowBar: "⇥", rightarrow: "→", RightArrow: "→", Rightarrow: "⇒", RightArrowLeftArrow: "⇄", rightarrowtail: "↣", RightCeiling: "⌉", RightDoubleBracket: "⟧", RightDownTeeVector: "⥝", RightDownVectorBar: "⥕", RightDownVector: "⇂", RightFloor: "⌋", rightharpoondown: "⇁", rightharpoonup: "⇀", rightleftarrows: "⇄", rightleftharpoons: "⇌", rightrightarrows: "⇉", rightsquigarrow: "↝", RightTeeArrow: "↦", RightTee: "⊢", RightTeeVector: "⥛", rightthreetimes: "⋌", RightTriangleBar: "⧐", RightTriangle: "⊳", RightTriangleEqual: "⊵", RightUpDownVector: "⥏", RightUpTeeVector: "⥜", RightUpVectorBar: "⥔", RightUpVector: "↾", RightVectorBar: "⥓", RightVector: "⇀", ring: "˚", risingdotseq: "≓", rlarr: "⇄", rlhar: "⇌", rlm: "‏", rmoustache: "⎱", rmoust: "⎱", rnmid: "⫮", roang: "⟭", roarr: "⇾", robrk: "⟧", ropar: "⦆", ropf: "𝕣", Ropf: "ℝ", roplus: "⨮", rotimes: "⨵", RoundImplies: "⥰", rpar: ")", rpargt: "⦔", rppolint: "⨒", rrarr: "⇉", Rrightarrow: "⇛", rsaquo: "›", rscr: "𝓇", Rscr: "ℛ", rsh: "↱", Rsh: "↱", rsqb: "]", rsquo: "’", rsquor: "’", rthree: "⋌", rtimes: "⋊", rtri: "▹", rtrie: "⊵", rtrif: "▸", rtriltri: "⧎", RuleDelayed: "⧴", ruluhar: "⥨", rx: "℞", Sacute: "Ś", sacute: "ś", sbquo: "‚", scap: "⪸", Scaron: "Š", scaron: "š", Sc: "⪼", sc: "≻", sccue: "≽", sce: "⪰", scE: "⪴", Scedil: "Ş", scedil: "ş", Scirc: "Ŝ", scirc: "ŝ", scnap: "⪺", scnE: "⪶", scnsim: "⋩", scpolint: "⨓", scsim: "≿", Scy: "С", scy: "с", sdotb: "⊡", sdot: "⋅", sdote: "⩦", searhk: "⤥", searr: "↘", seArr: "⇘", searrow: "↘", sect: "§", semi: ";", seswar: "⤩", setminus: "∖", setmn: "∖", sext: "✶", Sfr: "𝔖", sfr: "𝔰", sfrown: "⌢", sharp: "♯", SHCHcy: "Щ", shchcy: "щ", SHcy: "Ш", shcy: "ш", ShortDownArrow: "↓", ShortLeftArrow: "←", shortmid: "∣", shortparallel: "∥", ShortRightArrow: "→", ShortUpArrow: "↑", shy: "­", Sigma: "Σ", sigma: "σ", sigmaf: "ς", sigmav: "ς", sim: "∼", simdot: "⩪", sime: "≃", simeq: "≃", simg: "⪞", simgE: "⪠", siml: "⪝", simlE: "⪟", simne: "≆", simplus: "⨤", simrarr: "⥲", slarr: "←", SmallCircle: "∘", smallsetminus: "∖", smashp: "⨳", smeparsl: "⧤", smid: "∣", smile: "⌣", smt: "⪪", smte: "⪬", smtes: "⪬︀", SOFTcy: "Ь", softcy: "ь", solbar: "⌿", solb: "⧄", sol: "/", Sopf: "𝕊", sopf: "𝕤", spades: "♠", spadesuit: "♠", spar: "∥", sqcap: "⊓", sqcaps: "⊓︀", sqcup: "⊔", sqcups: "⊔︀", Sqrt: "√", sqsub: "⊏", sqsube: "⊑", sqsubset: "⊏", sqsubseteq: "⊑", sqsup: "⊐", sqsupe: "⊒", sqsupset: "⊐", sqsupseteq: "⊒", square: "□", Square: "□", SquareIntersection: "⊓", SquareSubset: "⊏", SquareSubsetEqual: "⊑", SquareSuperset: "⊐", SquareSupersetEqual: "⊒", SquareUnion: "⊔", squarf: "▪", squ: "□", squf: "▪", srarr: "→", Sscr: "𝒮", sscr: "𝓈", ssetmn: "∖", ssmile: "⌣", sstarf: "⋆", Star: "⋆", star: "☆", starf: "★", straightepsilon: "ϵ", straightphi: "ϕ", strns: "¯", sub: "⊂", Sub: "⋐", subdot: "⪽", subE: "⫅", sube: "⊆", subedot: "⫃", submult: "⫁", subnE: "⫋", subne: "⊊", subplus: "⪿", subrarr: "⥹", subset: "⊂", Subset: "⋐", subseteq: "⊆", subseteqq: "⫅", SubsetEqual: "⊆", subsetneq: "⊊", subsetneqq: "⫋", subsim: "⫇", subsub: "⫕", subsup: "⫓", succapprox: "⪸", succ: "≻", succcurlyeq: "≽", Succeeds: "≻", SucceedsEqual: "⪰", SucceedsSlantEqual: "≽", SucceedsTilde: "≿", succeq: "⪰", succnapprox: "⪺", succneqq: "⪶", succnsim: "⋩", succsim: "≿", SuchThat: "∋", sum: "∑", Sum: "∑", sung: "♪", sup1: "¹", sup2: "²", sup3: "³", sup: "⊃", Sup: "⋑", supdot: "⪾", supdsub: "⫘", supE: "⫆", supe: "⊇", supedot: "⫄", Superset: "⊃", SupersetEqual: "⊇", suphsol: "⟉", suphsub: "⫗", suplarr: "⥻", supmult: "⫂", supnE: "⫌", supne: "⊋", supplus: "⫀", supset: "⊃", Supset: "⋑", supseteq: "⊇", supseteqq: "⫆", supsetneq: "⊋", supsetneqq: "⫌", supsim: "⫈", supsub: "⫔", supsup: "⫖", swarhk: "⤦", swarr: "↙", swArr: "⇙", swarrow: "↙", swnwar: "⤪", szlig: "ß", Tab: "	", target: "⌖", Tau: "Τ", tau: "τ", tbrk: "⎴", Tcaron: "Ť", tcaron: "ť", Tcedil: "Ţ", tcedil: "ţ", Tcy: "Т", tcy: "т", tdot: "⃛", telrec: "⌕", Tfr: "𝔗", tfr: "𝔱", there4: "∴", therefore: "∴", Therefore: "∴", Theta: "Θ", theta: "θ", thetasym: "ϑ", thetav: "ϑ", thickapprox: "≈", thicksim: "∼", ThickSpace: "  ", ThinSpace: " ", thinsp: " ", thkap: "≈", thksim: "∼", THORN: "Þ", thorn: "þ", tilde: "˜", Tilde: "∼", TildeEqual: "≃", TildeFullEqual: "≅", TildeTilde: "≈", timesbar: "⨱", timesb: "⊠", times: "×", timesd: "⨰", tint: "∭", toea: "⤨", topbot: "⌶", topcir: "⫱", top: "⊤", Topf: "𝕋", topf: "𝕥", topfork: "⫚", tosa: "⤩", tprime: "‴", trade: "™", TRADE: "™", triangle: "▵", triangledown: "▿", triangleleft: "◃", trianglelefteq: "⊴", triangleq: "≜", triangleright: "▹", trianglerighteq: "⊵", tridot: "◬", trie: "≜", triminus: "⨺", TripleDot: "⃛", triplus: "⨹", trisb: "⧍", tritime: "⨻", trpezium: "⏢", Tscr: "𝒯", tscr: "𝓉", TScy: "Ц", tscy: "ц", TSHcy: "Ћ", tshcy: "ћ", Tstrok: "Ŧ", tstrok: "ŧ", twixt: "≬", twoheadleftarrow: "↞", twoheadrightarrow: "↠", Uacute: "Ú", uacute: "ú", uarr: "↑", Uarr: "↟", uArr: "⇑", Uarrocir: "⥉", Ubrcy: "Ў", ubrcy: "ў", Ubreve: "Ŭ", ubreve: "ŭ", Ucirc: "Û", ucirc: "û", Ucy: "У", ucy: "у", udarr: "⇅", Udblac: "Ű", udblac: "ű", udhar: "⥮", ufisht: "⥾", Ufr: "𝔘", ufr: "𝔲", Ugrave: "Ù", ugrave: "ù", uHar: "⥣", uharl: "↿", uharr: "↾", uhblk: "▀", ulcorn: "⌜", ulcorner: "⌜", ulcrop: "⌏", ultri: "◸", Umacr: "Ū", umacr: "ū", uml: "¨", UnderBar: "_", UnderBrace: "⏟", UnderBracket: "⎵", UnderParenthesis: "⏝", Union: "⋃", UnionPlus: "⊎", Uogon: "Ų", uogon: "ų", Uopf: "𝕌", uopf: "𝕦", UpArrowBar: "⤒", uparrow: "↑", UpArrow: "↑", Uparrow: "⇑", UpArrowDownArrow: "⇅", updownarrow: "↕", UpDownArrow: "↕", Updownarrow: "⇕", UpEquilibrium: "⥮", upharpoonleft: "↿", upharpoonright: "↾", uplus: "⊎", UpperLeftArrow: "↖", UpperRightArrow: "↗", upsi: "υ", Upsi: "ϒ", upsih: "ϒ", Upsilon: "Υ", upsilon: "υ", UpTeeArrow: "↥", UpTee: "⊥", upuparrows: "⇈", urcorn: "⌝", urcorner: "⌝", urcrop: "⌎", Uring: "Ů", uring: "ů", urtri: "◹", Uscr: "𝒰", uscr: "𝓊", utdot: "⋰", Utilde: "Ũ", utilde: "ũ", utri: "▵", utrif: "▴", uuarr: "⇈", Uuml: "Ü", uuml: "ü", uwangle: "⦧", vangrt: "⦜", varepsilon: "ϵ", varkappa: "ϰ", varnothing: "∅", varphi: "ϕ", varpi: "ϖ", varpropto: "∝", varr: "↕", vArr: "⇕", varrho: "ϱ", varsigma: "ς", varsubsetneq: "⊊︀", varsubsetneqq: "⫋︀", varsupsetneq: "⊋︀", varsupsetneqq: "⫌︀", vartheta: "ϑ", vartriangleleft: "⊲", vartriangleright: "⊳", vBar: "⫨", Vbar: "⫫", vBarv: "⫩", Vcy: "В", vcy: "в", vdash: "⊢", vDash: "⊨", Vdash: "⊩", VDash: "⊫", Vdashl: "⫦", veebar: "⊻", vee: "∨", Vee: "⋁", veeeq: "≚", vellip: "⋮", verbar: "|", Verbar: "‖", vert: "|", Vert: "‖", VerticalBar: "∣", VerticalLine: "|", VerticalSeparator: "❘", VerticalTilde: "≀", VeryThinSpace: " ", Vfr: "𝔙", vfr: "𝔳", vltri: "⊲", vnsub: "⊂⃒", vnsup: "⊃⃒", Vopf: "𝕍", vopf: "𝕧", vprop: "∝", vrtri: "⊳", Vscr: "𝒱", vscr: "𝓋", vsubnE: "⫋︀", vsubne: "⊊︀", vsupnE: "⫌︀", vsupne: "⊋︀", Vvdash: "⊪", vzigzag: "⦚", Wcirc: "Ŵ", wcirc: "ŵ", wedbar: "⩟", wedge: "∧", Wedge: "⋀", wedgeq: "≙", weierp: "℘", Wfr: "𝔚", wfr: "𝔴", Wopf: "𝕎", wopf: "𝕨", wp: "℘", wr: "≀", wreath: "≀", Wscr: "𝒲", wscr: "𝓌", xcap: "⋂", xcirc: "◯", xcup: "⋃", xdtri: "▽", Xfr: "𝔛", xfr: "𝔵", xharr: "⟷", xhArr: "⟺", Xi: "Ξ", xi: "ξ", xlarr: "⟵", xlArr: "⟸", xmap: "⟼", xnis: "⋻", xodot: "⨀", Xopf: "𝕏", xopf: "𝕩", xoplus: "⨁", xotime: "⨂", xrarr: "⟶", xrArr: "⟹", Xscr: "𝒳", xscr: "𝓍", xsqcup: "⨆", xuplus: "⨄", xutri: "△", xvee: "⋁", xwedge: "⋀", Yacute: "Ý", yacute: "ý", YAcy: "Я", yacy: "я", Ycirc: "Ŷ", ycirc: "ŷ", Ycy: "Ы", ycy: "ы", yen: "¥", Yfr: "𝔜", yfr: "𝔶", YIcy: "Ї", yicy: "ї", Yopf: "𝕐", yopf: "𝕪", Yscr: "𝒴", yscr: "𝓎", YUcy: "Ю", yucy: "ю", yuml: "ÿ", Yuml: "Ÿ", Zacute: "Ź", zacute: "ź", Zcaron: "Ž", zcaron: "ž", Zcy: "З", zcy: "з", Zdot: "Ż", zdot: "ż", zeetrf: "ℨ", ZeroWidthSpace: "​", Zeta: "Ζ", zeta: "ζ", zfr: "𝔷", Zfr: "ℨ", ZHcy: "Ж", zhcy: "ж", zigrarr: "⇝", zopf: "𝕫", Zopf: "ℤ", Zscr: "𝒵", zscr: "𝓏", zwj: "‍", zwnj: "‌" };
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/common/entities.js
var require_entities2 = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/common/entities.js"(exports3, module2) {
    "use strict";
    module2.exports = require_entities();
  }
});

// node_modules/.pnpm/uc.micro@1.0.6/node_modules/uc.micro/categories/P/regex.js
var require_regex = __commonJS({
  "node_modules/.pnpm/uc.micro@1.0.6/node_modules/uc.micro/categories/P/regex.js"(exports3, module2) {
    module2.exports = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
  }
});

// node_modules/.pnpm/mdurl@1.0.1/node_modules/mdurl/encode.js
var require_encode = __commonJS({
  "node_modules/.pnpm/mdurl@1.0.1/node_modules/mdurl/encode.js"(exports3, module2) {
    "use strict";
    var encodeCache = {};
    function getEncodeCache(exclude) {
      var i2, ch, cache2 = encodeCache[exclude];
      if (cache2) {
        return cache2;
      }
      cache2 = encodeCache[exclude] = [];
      for (i2 = 0; i2 < 128; i2++) {
        ch = String.fromCharCode(i2);
        if (/^[0-9a-z]$/i.test(ch)) {
          cache2.push(ch);
        } else {
          cache2.push("%" + ("0" + i2.toString(16).toUpperCase()).slice(-2));
        }
      }
      for (i2 = 0; i2 < exclude.length; i2++) {
        cache2[exclude.charCodeAt(i2)] = exclude[i2];
      }
      return cache2;
    }
    function encode3(string3, exclude, keepEscaped) {
      var i2, l2, code, nextCode, cache2, result = "";
      if (typeof exclude !== "string") {
        keepEscaped = exclude;
        exclude = encode3.defaultChars;
      }
      if (typeof keepEscaped === "undefined") {
        keepEscaped = true;
      }
      cache2 = getEncodeCache(exclude);
      for (i2 = 0, l2 = string3.length; i2 < l2; i2++) {
        code = string3.charCodeAt(i2);
        if (keepEscaped && code === 37 && i2 + 2 < l2) {
          if (/^[0-9a-f]{2}$/i.test(string3.slice(i2 + 1, i2 + 3))) {
            result += string3.slice(i2, i2 + 3);
            i2 += 2;
            continue;
          }
        }
        if (code < 128) {
          result += cache2[code];
          continue;
        }
        if (code >= 55296 && code <= 57343) {
          if (code >= 55296 && code <= 56319 && i2 + 1 < l2) {
            nextCode = string3.charCodeAt(i2 + 1);
            if (nextCode >= 56320 && nextCode <= 57343) {
              result += encodeURIComponent(string3[i2] + string3[i2 + 1]);
              i2++;
              continue;
            }
          }
          result += "%EF%BF%BD";
          continue;
        }
        result += encodeURIComponent(string3[i2]);
      }
      return result;
    }
    encode3.defaultChars = ";/?:@&=+$,-_.!~*'()#";
    encode3.componentChars = "-_.!~*'()";
    module2.exports = encode3;
  }
});

// node_modules/.pnpm/mdurl@1.0.1/node_modules/mdurl/decode.js
var require_decode = __commonJS({
  "node_modules/.pnpm/mdurl@1.0.1/node_modules/mdurl/decode.js"(exports3, module2) {
    "use strict";
    var decodeCache = {};
    function getDecodeCache(exclude) {
      var i2, ch, cache2 = decodeCache[exclude];
      if (cache2) {
        return cache2;
      }
      cache2 = decodeCache[exclude] = [];
      for (i2 = 0; i2 < 128; i2++) {
        ch = String.fromCharCode(i2);
        cache2.push(ch);
      }
      for (i2 = 0; i2 < exclude.length; i2++) {
        ch = exclude.charCodeAt(i2);
        cache2[ch] = "%" + ("0" + ch.toString(16).toUpperCase()).slice(-2);
      }
      return cache2;
    }
    function decode4(string3, exclude) {
      var cache2;
      if (typeof exclude !== "string") {
        exclude = decode4.defaultChars;
      }
      cache2 = getDecodeCache(exclude);
      return string3.replace(/(%[a-f0-9]{2})+/gi, function(seq3) {
        var i2, l2, b1, b2, b3, b4, chr, result = "";
        for (i2 = 0, l2 = seq3.length; i2 < l2; i2 += 3) {
          b1 = parseInt(seq3.slice(i2 + 1, i2 + 3), 16);
          if (b1 < 128) {
            result += cache2[b1];
            continue;
          }
          if ((b1 & 224) === 192 && i2 + 3 < l2) {
            b2 = parseInt(seq3.slice(i2 + 4, i2 + 6), 16);
            if ((b2 & 192) === 128) {
              chr = b1 << 6 & 1984 | b2 & 63;
              if (chr < 128) {
                result += "��";
              } else {
                result += String.fromCharCode(chr);
              }
              i2 += 3;
              continue;
            }
          }
          if ((b1 & 240) === 224 && i2 + 6 < l2) {
            b2 = parseInt(seq3.slice(i2 + 4, i2 + 6), 16);
            b3 = parseInt(seq3.slice(i2 + 7, i2 + 9), 16);
            if ((b2 & 192) === 128 && (b3 & 192) === 128) {
              chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;
              if (chr < 2048 || chr >= 55296 && chr <= 57343) {
                result += "���";
              } else {
                result += String.fromCharCode(chr);
              }
              i2 += 6;
              continue;
            }
          }
          if ((b1 & 248) === 240 && i2 + 9 < l2) {
            b2 = parseInt(seq3.slice(i2 + 4, i2 + 6), 16);
            b3 = parseInt(seq3.slice(i2 + 7, i2 + 9), 16);
            b4 = parseInt(seq3.slice(i2 + 10, i2 + 12), 16);
            if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
              chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;
              if (chr < 65536 || chr > 1114111) {
                result += "����";
              } else {
                chr -= 65536;
                result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));
              }
              i2 += 9;
              continue;
            }
          }
          result += "�";
        }
        return result;
      });
    }
    decode4.defaultChars = ";/?:@&=+$,#";
    decode4.componentChars = "";
    module2.exports = decode4;
  }
});

// node_modules/.pnpm/mdurl@1.0.1/node_modules/mdurl/format.js
var require_format = __commonJS({
  "node_modules/.pnpm/mdurl@1.0.1/node_modules/mdurl/format.js"(exports3, module2) {
    "use strict";
    module2.exports = function format2(url2) {
      var result = "";
      result += url2.protocol || "";
      result += url2.slashes ? "//" : "";
      result += url2.auth ? url2.auth + "@" : "";
      if (url2.hostname && url2.hostname.indexOf(":") !== -1) {
        result += "[" + url2.hostname + "]";
      } else {
        result += url2.hostname || "";
      }
      result += url2.port ? ":" + url2.port : "";
      result += url2.pathname || "";
      result += url2.search || "";
      result += url2.hash || "";
      return result;
    };
  }
});

// node_modules/.pnpm/mdurl@1.0.1/node_modules/mdurl/parse.js
var require_parse5 = __commonJS({
  "node_modules/.pnpm/mdurl@1.0.1/node_modules/mdurl/parse.js"(exports3, module2) {
    "use strict";
    function Url2() {
      this.protocol = null;
      this.slashes = null;
      this.auth = null;
      this.port = null;
      this.hostname = null;
      this.hash = null;
      this.search = null;
      this.pathname = null;
    }
    var protocolPattern = /^([a-z0-9.+-]+:)/i;
    var portPattern = /:[0-9]*$/;
    var simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
    var delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
    var unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
    var autoEscape = ["'"].concat(unwise);
    var nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
    var hostEndingChars = ["/", "?", "#"];
    var hostnameMaxLen = 255;
    var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
    var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
    var hostlessProtocol = {
      "javascript": true,
      "javascript:": true
    };
    var slashedProtocol = {
      "http": true,
      "https": true,
      "ftp": true,
      "gopher": true,
      "file": true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    };
    function urlParse(url2, slashesDenoteHost) {
      if (url2 && url2 instanceof Url2) {
        return url2;
      }
      var u2 = new Url2();
      u2.parse(url2, slashesDenoteHost);
      return u2;
    }
    Url2.prototype.parse = function(url2, slashesDenoteHost) {
      var i2, l2, lowerProto, hec, slashes, rest = url2;
      rest = rest.trim();
      if (!slashesDenoteHost && url2.split("#").length === 1) {
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
          this.pathname = simplePath[1];
          if (simplePath[2]) {
            this.search = simplePath[2];
          }
          return this;
        }
      }
      var proto3 = protocolPattern.exec(rest);
      if (proto3) {
        proto3 = proto3[0];
        lowerProto = proto3.toLowerCase();
        this.protocol = proto3;
        rest = rest.substr(proto3.length);
      }
      if (slashesDenoteHost || proto3 || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        slashes = rest.substr(0, 2) === "//";
        if (slashes && !(proto3 && hostlessProtocol[proto3])) {
          rest = rest.substr(2);
          this.slashes = true;
        }
      }
      if (!hostlessProtocol[proto3] && (slashes || proto3 && !slashedProtocol[proto3])) {
        var hostEnd = -1;
        for (i2 = 0; i2 < hostEndingChars.length; i2++) {
          hec = rest.indexOf(hostEndingChars[i2]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        var auth, atSign;
        if (hostEnd === -1) {
          atSign = rest.lastIndexOf("@");
        } else {
          atSign = rest.lastIndexOf("@", hostEnd);
        }
        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          this.auth = auth;
        }
        hostEnd = -1;
        for (i2 = 0; i2 < nonHostChars.length; i2++) {
          hec = rest.indexOf(nonHostChars[i2]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        if (hostEnd === -1) {
          hostEnd = rest.length;
        }
        if (rest[hostEnd - 1] === ":") {
          hostEnd--;
        }
        var host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);
        this.parseHost(host);
        this.hostname = this.hostname || "";
        var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);
          for (i2 = 0, l2 = hostparts.length; i2 < l2; i2++) {
            var part = hostparts[i2];
            if (!part) {
              continue;
            }
            if (!part.match(hostnamePartPattern)) {
              var newpart = "";
              for (var j = 0, k = part.length; j < k; j++) {
                if (part.charCodeAt(j) > 127) {
                  newpart += "x";
                } else {
                  newpart += part[j];
                }
              }
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i2);
                var notHost = hostparts.slice(i2 + 1);
                var bit = part.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = notHost.join(".") + rest;
                }
                this.hostname = validParts.join(".");
                break;
              }
            }
          }
        }
        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = "";
        }
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
        }
      }
      var hash2 = rest.indexOf("#");
      if (hash2 !== -1) {
        this.hash = rest.substr(hash2);
        rest = rest.slice(0, hash2);
      }
      var qm = rest.indexOf("?");
      if (qm !== -1) {
        this.search = rest.substr(qm);
        rest = rest.slice(0, qm);
      }
      if (rest) {
        this.pathname = rest;
      }
      if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = "";
      }
      return this;
    };
    Url2.prototype.parseHost = function(host) {
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ":") {
          this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host) {
        this.hostname = host;
      }
    };
    module2.exports = urlParse;
  }
});

// node_modules/.pnpm/mdurl@1.0.1/node_modules/mdurl/index.js
var require_mdurl = __commonJS({
  "node_modules/.pnpm/mdurl@1.0.1/node_modules/mdurl/index.js"(exports3, module2) {
    "use strict";
    module2.exports.encode = require_encode();
    module2.exports.decode = require_decode();
    module2.exports.format = require_format();
    module2.exports.parse = require_parse5();
  }
});

// node_modules/.pnpm/uc.micro@1.0.6/node_modules/uc.micro/properties/Any/regex.js
var require_regex2 = __commonJS({
  "node_modules/.pnpm/uc.micro@1.0.6/node_modules/uc.micro/properties/Any/regex.js"(exports3, module2) {
    module2.exports = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  }
});

// node_modules/.pnpm/uc.micro@1.0.6/node_modules/uc.micro/categories/Cc/regex.js
var require_regex3 = __commonJS({
  "node_modules/.pnpm/uc.micro@1.0.6/node_modules/uc.micro/categories/Cc/regex.js"(exports3, module2) {
    module2.exports = /[\0-\x1F\x7F-\x9F]/;
  }
});

// node_modules/.pnpm/uc.micro@1.0.6/node_modules/uc.micro/categories/Cf/regex.js
var require_regex4 = __commonJS({
  "node_modules/.pnpm/uc.micro@1.0.6/node_modules/uc.micro/categories/Cf/regex.js"(exports3, module2) {
    module2.exports = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;
  }
});

// node_modules/.pnpm/uc.micro@1.0.6/node_modules/uc.micro/categories/Z/regex.js
var require_regex5 = __commonJS({
  "node_modules/.pnpm/uc.micro@1.0.6/node_modules/uc.micro/categories/Z/regex.js"(exports3, module2) {
    module2.exports = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
  }
});

// node_modules/.pnpm/uc.micro@1.0.6/node_modules/uc.micro/index.js
var require_uc = __commonJS({
  "node_modules/.pnpm/uc.micro@1.0.6/node_modules/uc.micro/index.js"(exports3) {
    "use strict";
    exports3.Any = require_regex2();
    exports3.Cc = require_regex3();
    exports3.Cf = require_regex4();
    exports3.P = require_regex();
    exports3.Z = require_regex5();
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/common/utils.js
var require_utils8 = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/common/utils.js"(exports3) {
    "use strict";
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isString3(obj) {
      return _class(obj) === "[object String]";
    }
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    function has(object, key) {
      return _hasOwnProperty.call(object, key);
    }
    function assign(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      sources.forEach(function(source) {
        if (!source) {
          return;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be object");
        }
        Object.keys(source).forEach(function(key) {
          obj[key] = source[key];
        });
      });
      return obj;
    }
    function arrayReplaceAt(src3, pos, newElements) {
      return [].concat(src3.slice(0, pos), newElements, src3.slice(pos + 1));
    }
    function isValidEntityCode(c2) {
      if (c2 >= 55296 && c2 <= 57343) {
        return false;
      }
      if (c2 >= 64976 && c2 <= 65007) {
        return false;
      }
      if ((c2 & 65535) === 65535 || (c2 & 65535) === 65534) {
        return false;
      }
      if (c2 >= 0 && c2 <= 8) {
        return false;
      }
      if (c2 === 11) {
        return false;
      }
      if (c2 >= 14 && c2 <= 31) {
        return false;
      }
      if (c2 >= 127 && c2 <= 159) {
        return false;
      }
      if (c2 > 1114111) {
        return false;
      }
      return true;
    }
    function fromCodePoint(c2) {
      if (c2 > 65535) {
        c2 -= 65536;
        var surrogate1 = 55296 + (c2 >> 10), surrogate2 = 56320 + (c2 & 1023);
        return String.fromCharCode(surrogate1, surrogate2);
      }
      return String.fromCharCode(c2);
    }
    var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
    var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
    var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + "|" + ENTITY_RE.source, "gi");
    var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;
    var entities = require_entities2();
    function replaceEntityPattern(match, name2) {
      var code = 0;
      if (has(entities, name2)) {
        return entities[name2];
      }
      if (name2.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name2)) {
        code = name2[1].toLowerCase() === "x" ? parseInt(name2.slice(2), 16) : parseInt(name2.slice(1), 10);
        if (isValidEntityCode(code)) {
          return fromCodePoint(code);
        }
      }
      return match;
    }
    function unescapeMd(str2) {
      if (str2.indexOf("\\") < 0) {
        return str2;
      }
      return str2.replace(UNESCAPE_MD_RE, "$1");
    }
    function unescapeAll(str2) {
      if (str2.indexOf("\\") < 0 && str2.indexOf("&") < 0) {
        return str2;
      }
      return str2.replace(UNESCAPE_ALL_RE, function(match, escaped2, entity) {
        if (escaped2) {
          return escaped2;
        }
        return replaceEntityPattern(match, entity);
      });
    }
    var HTML_ESCAPE_TEST_RE = /[&<>"]/;
    var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
    var HTML_REPLACEMENTS = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;"
    };
    function replaceUnsafeChar(ch) {
      return HTML_REPLACEMENTS[ch];
    }
    function escapeHtml2(str2) {
      if (HTML_ESCAPE_TEST_RE.test(str2)) {
        return str2.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
      }
      return str2;
    }
    var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
    function escapeRE(str2) {
      return str2.replace(REGEXP_ESCAPE_RE, "\\$&");
    }
    function isSpace(code) {
      switch (code) {
        case 9:
        case 32:
          return true;
      }
      return false;
    }
    function isWhiteSpace(code) {
      if (code >= 8192 && code <= 8202) {
        return true;
      }
      switch (code) {
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 32:
        case 160:
        case 5760:
        case 8239:
        case 8287:
        case 12288:
          return true;
      }
      return false;
    }
    var UNICODE_PUNCT_RE = require_regex();
    function isPunctChar(ch) {
      return UNICODE_PUNCT_RE.test(ch);
    }
    function isMdAsciiPunct(ch) {
      switch (ch) {
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 123:
        case 124:
        case 125:
        case 126:
          return true;
        default:
          return false;
      }
    }
    function normalizeReference(str2) {
      str2 = str2.trim().replace(/\s+/g, " ");
      if ("ẞ".toLowerCase() === "Ṿ") {
        str2 = str2.replace(/ẞ/g, "ß");
      }
      return str2.toLowerCase().toUpperCase();
    }
    exports3.lib = {};
    exports3.lib.mdurl = require_mdurl();
    exports3.lib.ucmicro = require_uc();
    exports3.assign = assign;
    exports3.isString = isString3;
    exports3.has = has;
    exports3.unescapeMd = unescapeMd;
    exports3.unescapeAll = unescapeAll;
    exports3.isValidEntityCode = isValidEntityCode;
    exports3.fromCodePoint = fromCodePoint;
    exports3.escapeHtml = escapeHtml2;
    exports3.arrayReplaceAt = arrayReplaceAt;
    exports3.isSpace = isSpace;
    exports3.isWhiteSpace = isWhiteSpace;
    exports3.isMdAsciiPunct = isMdAsciiPunct;
    exports3.isPunctChar = isPunctChar;
    exports3.escapeRE = escapeRE;
    exports3.normalizeReference = normalizeReference;
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/helpers/parse_link_label.js
var require_parse_link_label = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/helpers/parse_link_label.js"(exports3, module2) {
    "use strict";
    module2.exports = function parseLinkLabel(state, start, disableNested) {
      var level3, found2, marker, prevPos, labelEnd = -1, max = state.posMax, oldPos = state.pos;
      state.pos = start + 1;
      level3 = 1;
      while (state.pos < max) {
        marker = state.src.charCodeAt(state.pos);
        if (marker === 93) {
          level3--;
          if (level3 === 0) {
            found2 = true;
            break;
          }
        }
        prevPos = state.pos;
        state.md.inline.skipToken(state);
        if (marker === 91) {
          if (prevPos === state.pos - 1) {
            level3++;
          } else if (disableNested) {
            state.pos = oldPos;
            return -1;
          }
        }
      }
      if (found2) {
        labelEnd = state.pos;
      }
      state.pos = oldPos;
      return labelEnd;
    };
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/helpers/parse_link_destination.js
var require_parse_link_destination = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/helpers/parse_link_destination.js"(exports3, module2) {
    "use strict";
    var unescapeAll = require_utils8().unescapeAll;
    module2.exports = function parseLinkDestination(str2, pos, max) {
      var code, level3, lines = 0, start = pos, result = {
        ok: false,
        pos: 0,
        lines: 0,
        str: ""
      };
      if (str2.charCodeAt(pos) === 60) {
        pos++;
        while (pos < max) {
          code = str2.charCodeAt(pos);
          if (code === 10) {
            return result;
          }
          if (code === 60) {
            return result;
          }
          if (code === 62) {
            result.pos = pos + 1;
            result.str = unescapeAll(str2.slice(start + 1, pos));
            result.ok = true;
            return result;
          }
          if (code === 92 && pos + 1 < max) {
            pos += 2;
            continue;
          }
          pos++;
        }
        return result;
      }
      level3 = 0;
      while (pos < max) {
        code = str2.charCodeAt(pos);
        if (code === 32) {
          break;
        }
        if (code < 32 || code === 127) {
          break;
        }
        if (code === 92 && pos + 1 < max) {
          if (str2.charCodeAt(pos + 1) === 32) {
            break;
          }
          pos += 2;
          continue;
        }
        if (code === 40) {
          level3++;
          if (level3 > 32) {
            return result;
          }
        }
        if (code === 41) {
          if (level3 === 0) {
            break;
          }
          level3--;
        }
        pos++;
      }
      if (start === pos) {
        return result;
      }
      if (level3 !== 0) {
        return result;
      }
      result.str = unescapeAll(str2.slice(start, pos));
      result.lines = lines;
      result.pos = pos;
      result.ok = true;
      return result;
    };
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/helpers/parse_link_title.js
var require_parse_link_title = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/helpers/parse_link_title.js"(exports3, module2) {
    "use strict";
    var unescapeAll = require_utils8().unescapeAll;
    module2.exports = function parseLinkTitle(str2, pos, max) {
      var code, marker, lines = 0, start = pos, result = {
        ok: false,
        pos: 0,
        lines: 0,
        str: ""
      };
      if (pos >= max) {
        return result;
      }
      marker = str2.charCodeAt(pos);
      if (marker !== 34 && marker !== 39 && marker !== 40) {
        return result;
      }
      pos++;
      if (marker === 40) {
        marker = 41;
      }
      while (pos < max) {
        code = str2.charCodeAt(pos);
        if (code === marker) {
          result.pos = pos + 1;
          result.lines = lines;
          result.str = unescapeAll(str2.slice(start + 1, pos));
          result.ok = true;
          return result;
        } else if (code === 40 && marker === 41) {
          return result;
        } else if (code === 10) {
          lines++;
        } else if (code === 92 && pos + 1 < max) {
          pos++;
          if (str2.charCodeAt(pos) === 10) {
            lines++;
          }
        }
        pos++;
      }
      return result;
    };
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/helpers/index.js
var require_helpers = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/helpers/index.js"(exports3) {
    "use strict";
    exports3.parseLinkLabel = require_parse_link_label();
    exports3.parseLinkDestination = require_parse_link_destination();
    exports3.parseLinkTitle = require_parse_link_title();
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/renderer.js
var require_renderer = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/renderer.js"(exports3, module2) {
    "use strict";
    var assign = require_utils8().assign;
    var unescapeAll = require_utils8().unescapeAll;
    var escapeHtml2 = require_utils8().escapeHtml;
    var default_rules = {};
    default_rules.code_inline = function(tokens, idx, options3, env2, slf) {
      var token = tokens[idx];
      return "<code" + slf.renderAttrs(token) + ">" + escapeHtml2(tokens[idx].content) + "</code>";
    };
    default_rules.code_block = function(tokens, idx, options3, env2, slf) {
      var token = tokens[idx];
      return "<pre" + slf.renderAttrs(token) + "><code>" + escapeHtml2(tokens[idx].content) + "</code></pre>\n";
    };
    default_rules.fence = function(tokens, idx, options3, env2, slf) {
      var token = tokens[idx], info3 = token.info ? unescapeAll(token.info).trim() : "", langName = "", langAttrs = "", highlighted, i2, arr, tmpAttrs, tmpToken;
      if (info3) {
        arr = info3.split(/(\s+)/g);
        langName = arr[0];
        langAttrs = arr.slice(2).join("");
      }
      if (options3.highlight) {
        highlighted = options3.highlight(token.content, langName, langAttrs) || escapeHtml2(token.content);
      } else {
        highlighted = escapeHtml2(token.content);
      }
      if (highlighted.indexOf("<pre") === 0) {
        return highlighted + "\n";
      }
      if (info3) {
        i2 = token.attrIndex("class");
        tmpAttrs = token.attrs ? token.attrs.slice() : [];
        if (i2 < 0) {
          tmpAttrs.push(["class", options3.langPrefix + langName]);
        } else {
          tmpAttrs[i2] = tmpAttrs[i2].slice();
          tmpAttrs[i2][1] += " " + options3.langPrefix + langName;
        }
        tmpToken = {
          attrs: tmpAttrs
        };
        return "<pre><code" + slf.renderAttrs(tmpToken) + ">" + highlighted + "</code></pre>\n";
      }
      return "<pre><code" + slf.renderAttrs(token) + ">" + highlighted + "</code></pre>\n";
    };
    default_rules.image = function(tokens, idx, options3, env2, slf) {
      var token = tokens[idx];
      token.attrs[token.attrIndex("alt")][1] = slf.renderInlineAsText(token.children, options3, env2);
      return slf.renderToken(tokens, idx, options3);
    };
    default_rules.hardbreak = function(tokens, idx, options3) {
      return options3.xhtmlOut ? "<br />\n" : "<br>\n";
    };
    default_rules.softbreak = function(tokens, idx, options3) {
      return options3.breaks ? options3.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
    };
    default_rules.text = function(tokens, idx) {
      return escapeHtml2(tokens[idx].content);
    };
    default_rules.html_block = function(tokens, idx) {
      return tokens[idx].content;
    };
    default_rules.html_inline = function(tokens, idx) {
      return tokens[idx].content;
    };
    function Renderer() {
      this.rules = assign({}, default_rules);
    }
    Renderer.prototype.renderAttrs = function renderAttrs(token) {
      var i2, l2, result;
      if (!token.attrs) {
        return "";
      }
      result = "";
      for (i2 = 0, l2 = token.attrs.length; i2 < l2; i2++) {
        result += " " + escapeHtml2(token.attrs[i2][0]) + '="' + escapeHtml2(token.attrs[i2][1]) + '"';
      }
      return result;
    };
    Renderer.prototype.renderToken = function renderToken(tokens, idx, options3) {
      var nextToken, result = "", needLf = false, token = tokens[idx];
      if (token.hidden) {
        return "";
      }
      if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
        result += "\n";
      }
      result += (token.nesting === -1 ? "</" : "<") + token.tag;
      result += this.renderAttrs(token);
      if (token.nesting === 0 && options3.xhtmlOut) {
        result += " /";
      }
      if (token.block) {
        needLf = true;
        if (token.nesting === 1) {
          if (idx + 1 < tokens.length) {
            nextToken = tokens[idx + 1];
            if (nextToken.type === "inline" || nextToken.hidden) {
              needLf = false;
            } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
              needLf = false;
            }
          }
        }
      }
      result += needLf ? ">\n" : ">";
      return result;
    };
    Renderer.prototype.renderInline = function(tokens, options3, env2) {
      var type, result = "", rules = this.rules;
      for (var i2 = 0, len = tokens.length; i2 < len; i2++) {
        type = tokens[i2].type;
        if (typeof rules[type] !== "undefined") {
          result += rules[type](tokens, i2, options3, env2, this);
        } else {
          result += this.renderToken(tokens, i2, options3);
        }
      }
      return result;
    };
    Renderer.prototype.renderInlineAsText = function(tokens, options3, env2) {
      var result = "";
      for (var i2 = 0, len = tokens.length; i2 < len; i2++) {
        if (tokens[i2].type === "text") {
          result += tokens[i2].content;
        } else if (tokens[i2].type === "image") {
          result += this.renderInlineAsText(tokens[i2].children, options3, env2);
        } else if (tokens[i2].type === "softbreak") {
          result += "\n";
        }
      }
      return result;
    };
    Renderer.prototype.render = function(tokens, options3, env2) {
      var i2, len, type, result = "", rules = this.rules;
      for (i2 = 0, len = tokens.length; i2 < len; i2++) {
        type = tokens[i2].type;
        if (type === "inline") {
          result += this.renderInline(tokens[i2].children, options3, env2);
        } else if (typeof rules[type] !== "undefined") {
          result += rules[tokens[i2].type](tokens, i2, options3, env2, this);
        } else {
          result += this.renderToken(tokens, i2, options3, env2);
        }
      }
      return result;
    };
    module2.exports = Renderer;
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/ruler.js
var require_ruler = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/ruler.js"(exports3, module2) {
    "use strict";
    function Ruler() {
      this.__rules__ = [];
      this.__cache__ = null;
    }
    Ruler.prototype.__find__ = function(name2) {
      for (var i2 = 0; i2 < this.__rules__.length; i2++) {
        if (this.__rules__[i2].name === name2) {
          return i2;
        }
      }
      return -1;
    };
    Ruler.prototype.__compile__ = function() {
      var self2 = this;
      var chains = [""];
      self2.__rules__.forEach(function(rule) {
        if (!rule.enabled) {
          return;
        }
        rule.alt.forEach(function(altName) {
          if (chains.indexOf(altName) < 0) {
            chains.push(altName);
          }
        });
      });
      self2.__cache__ = {};
      chains.forEach(function(chain) {
        self2.__cache__[chain] = [];
        self2.__rules__.forEach(function(rule) {
          if (!rule.enabled) {
            return;
          }
          if (chain && rule.alt.indexOf(chain) < 0) {
            return;
          }
          self2.__cache__[chain].push(rule.fn);
        });
      });
    };
    Ruler.prototype.at = function(name2, fn, options3) {
      var index2 = this.__find__(name2);
      var opt = options3 || {};
      if (index2 === -1) {
        throw new Error("Parser rule not found: " + name2);
      }
      this.__rules__[index2].fn = fn;
      this.__rules__[index2].alt = opt.alt || [];
      this.__cache__ = null;
    };
    Ruler.prototype.before = function(beforeName, ruleName, fn, options3) {
      var index2 = this.__find__(beforeName);
      var opt = options3 || {};
      if (index2 === -1) {
        throw new Error("Parser rule not found: " + beforeName);
      }
      this.__rules__.splice(index2, 0, {
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.after = function(afterName, ruleName, fn, options3) {
      var index2 = this.__find__(afterName);
      var opt = options3 || {};
      if (index2 === -1) {
        throw new Error("Parser rule not found: " + afterName);
      }
      this.__rules__.splice(index2 + 1, 0, {
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.push = function(ruleName, fn, options3) {
      var opt = options3 || {};
      this.__rules__.push({
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.enable = function(list, ignoreInvalid) {
      if (!Array.isArray(list)) {
        list = [list];
      }
      var result = [];
      list.forEach(function(name2) {
        var idx = this.__find__(name2);
        if (idx < 0) {
          if (ignoreInvalid) {
            return;
          }
          throw new Error("Rules manager: invalid rule name " + name2);
        }
        this.__rules__[idx].enabled = true;
        result.push(name2);
      }, this);
      this.__cache__ = null;
      return result;
    };
    Ruler.prototype.enableOnly = function(list, ignoreInvalid) {
      if (!Array.isArray(list)) {
        list = [list];
      }
      this.__rules__.forEach(function(rule) {
        rule.enabled = false;
      });
      this.enable(list, ignoreInvalid);
    };
    Ruler.prototype.disable = function(list, ignoreInvalid) {
      if (!Array.isArray(list)) {
        list = [list];
      }
      var result = [];
      list.forEach(function(name2) {
        var idx = this.__find__(name2);
        if (idx < 0) {
          if (ignoreInvalid) {
            return;
          }
          throw new Error("Rules manager: invalid rule name " + name2);
        }
        this.__rules__[idx].enabled = false;
        result.push(name2);
      }, this);
      this.__cache__ = null;
      return result;
    };
    Ruler.prototype.getRules = function(chainName) {
      if (this.__cache__ === null) {
        this.__compile__();
      }
      return this.__cache__[chainName] || [];
    };
    module2.exports = Ruler;
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_core/normalize.js
var require_normalize = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_core/normalize.js"(exports3, module2) {
    "use strict";
    var NEWLINES_RE = /\r\n?|\n/g;
    var NULL_RE = /\0/g;
    module2.exports = function normalize2(state) {
      var str2;
      str2 = state.src.replace(NEWLINES_RE, "\n");
      str2 = str2.replace(NULL_RE, "�");
      state.src = str2;
    };
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_core/block.js
var require_block = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_core/block.js"(exports3, module2) {
    "use strict";
    module2.exports = function block(state) {
      var token;
      if (state.inlineMode) {
        token = new state.Token("inline", "", 0);
        token.content = state.src;
        token.map = [0, 1];
        token.children = [];
        state.tokens.push(token);
      } else {
        state.md.block.parse(state.src, state.md, state.env, state.tokens);
      }
    };
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_core/inline.js
var require_inline = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_core/inline.js"(exports3, module2) {
    "use strict";
    module2.exports = function inline(state) {
      var tokens = state.tokens, tok, i2, l2;
      for (i2 = 0, l2 = tokens.length; i2 < l2; i2++) {
        tok = tokens[i2];
        if (tok.type === "inline") {
          state.md.inline.parse(tok.content, state.md, state.env, tok.children);
        }
      }
    };
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_core/linkify.js
var require_linkify = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_core/linkify.js"(exports3, module2) {
    "use strict";
    var arrayReplaceAt = require_utils8().arrayReplaceAt;
    function isLinkOpen(str2) {
      return /^<a[>\s]/i.test(str2);
    }
    function isLinkClose(str2) {
      return /^<\/a\s*>/i.test(str2);
    }
    module2.exports = function linkify(state) {
      var i2, j, l2, tokens, token, currentToken, nodes, ln, text, pos, lastPos, level3, htmlLinkLevel, url2, fullUrl, urlText, blockTokens = state.tokens, links;
      if (!state.md.options.linkify) {
        return;
      }
      for (j = 0, l2 = blockTokens.length; j < l2; j++) {
        if (blockTokens[j].type !== "inline" || !state.md.linkify.pretest(blockTokens[j].content)) {
          continue;
        }
        tokens = blockTokens[j].children;
        htmlLinkLevel = 0;
        for (i2 = tokens.length - 1; i2 >= 0; i2--) {
          currentToken = tokens[i2];
          if (currentToken.type === "link_close") {
            i2--;
            while (tokens[i2].level !== currentToken.level && tokens[i2].type !== "link_open") {
              i2--;
            }
            continue;
          }
          if (currentToken.type === "html_inline") {
            if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
              htmlLinkLevel--;
            }
            if (isLinkClose(currentToken.content)) {
              htmlLinkLevel++;
            }
          }
          if (htmlLinkLevel > 0) {
            continue;
          }
          if (currentToken.type === "text" && state.md.linkify.test(currentToken.content)) {
            text = currentToken.content;
            links = state.md.linkify.match(text);
            nodes = [];
            level3 = currentToken.level;
            lastPos = 0;
            if (links.length > 0 && links[0].index === 0 && i2 > 0 && tokens[i2 - 1].type === "text_special") {
              links = links.slice(1);
            }
            for (ln = 0; ln < links.length; ln++) {
              url2 = links[ln].url;
              fullUrl = state.md.normalizeLink(url2);
              if (!state.md.validateLink(fullUrl)) {
                continue;
              }
              urlText = links[ln].text;
              if (!links[ln].schema) {
                urlText = state.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
              } else if (links[ln].schema === "mailto:" && !/^mailto:/i.test(urlText)) {
                urlText = state.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
              } else {
                urlText = state.md.normalizeLinkText(urlText);
              }
              pos = links[ln].index;
              if (pos > lastPos) {
                token = new state.Token("text", "", 0);
                token.content = text.slice(lastPos, pos);
                token.level = level3;
                nodes.push(token);
              }
              token = new state.Token("link_open", "a", 1);
              token.attrs = [["href", fullUrl]];
              token.level = level3++;
              token.markup = "linkify";
              token.info = "auto";
              nodes.push(token);
              token = new state.Token("text", "", 0);
              token.content = urlText;
              token.level = level3;
              nodes.push(token);
              token = new state.Token("link_close", "a", -1);
              token.level = --level3;
              token.markup = "linkify";
              token.info = "auto";
              nodes.push(token);
              lastPos = links[ln].lastIndex;
            }
            if (lastPos < text.length) {
              token = new state.Token("text", "", 0);
              token.content = text.slice(lastPos);
              token.level = level3;
              nodes.push(token);
            }
            blockTokens[j].children = tokens = arrayReplaceAt(tokens, i2, nodes);
          }
        }
      }
    };
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_core/replacements.js
var require_replacements = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_core/replacements.js"(exports3, module2) {
    "use strict";
    var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
    var SCOPED_ABBR_TEST_RE = /\((c|tm|r)\)/i;
    var SCOPED_ABBR_RE = /\((c|tm|r)\)/ig;
    var SCOPED_ABBR = {
      c: "©",
      r: "®",
      tm: "™"
    };
    function replaceFn(match, name2) {
      return SCOPED_ABBR[name2.toLowerCase()];
    }
    function replace_scoped(inlineTokens) {
      var i2, token, inside_autolink = 0;
      for (i2 = inlineTokens.length - 1; i2 >= 0; i2--) {
        token = inlineTokens[i2];
        if (token.type === "text" && !inside_autolink) {
          token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
        }
        if (token.type === "link_open" && token.info === "auto") {
          inside_autolink--;
        }
        if (token.type === "link_close" && token.info === "auto") {
          inside_autolink++;
        }
      }
    }
    function replace_rare(inlineTokens) {
      var i2, token, inside_autolink = 0;
      for (i2 = inlineTokens.length - 1; i2 >= 0; i2--) {
        token = inlineTokens[i2];
        if (token.type === "text" && !inside_autolink) {
          if (RARE_RE.test(token.content)) {
            token.content = token.content.replace(/\+-/g, "±").replace(/\.{2,}/g, "…").replace(/([?!])…/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1—").replace(/(^|\s)--(?=\s|$)/mg, "$1–").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1–");
          }
        }
        if (token.type === "link_open" && token.info === "auto") {
          inside_autolink--;
        }
        if (token.type === "link_close" && token.info === "auto") {
          inside_autolink++;
        }
      }
    }
    module2.exports = function replace(state) {
      var blkIdx;
      if (!state.md.options.typographer) {
        return;
      }
      for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
        if (state.tokens[blkIdx].type !== "inline") {
          continue;
        }
        if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
          replace_scoped(state.tokens[blkIdx].children);
        }
        if (RARE_RE.test(state.tokens[blkIdx].content)) {
          replace_rare(state.tokens[blkIdx].children);
        }
      }
    };
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_core/smartquotes.js
var require_smartquotes = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_core/smartquotes.js"(exports3, module2) {
    "use strict";
    var isWhiteSpace = require_utils8().isWhiteSpace;
    var isPunctChar = require_utils8().isPunctChar;
    var isMdAsciiPunct = require_utils8().isMdAsciiPunct;
    var QUOTE_TEST_RE = /['"]/;
    var QUOTE_RE = /['"]/g;
    var APOSTROPHE = "’";
    function replaceAt(str2, index2, ch) {
      return str2.slice(0, index2) + ch + str2.slice(index2 + 1);
    }
    function process_inlines(tokens, state) {
      var i2, token, text, t3, pos, max, thisLevel, item, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;
      stack = [];
      for (i2 = 0; i2 < tokens.length; i2++) {
        token = tokens[i2];
        thisLevel = tokens[i2].level;
        for (j = stack.length - 1; j >= 0; j--) {
          if (stack[j].level <= thisLevel) {
            break;
          }
        }
        stack.length = j + 1;
        if (token.type !== "text") {
          continue;
        }
        text = token.content;
        pos = 0;
        max = text.length;
        OUTER:
          while (pos < max) {
            QUOTE_RE.lastIndex = pos;
            t3 = QUOTE_RE.exec(text);
            if (!t3) {
              break;
            }
            canOpen = canClose = true;
            pos = t3.index + 1;
            isSingle = t3[0] === "'";
            lastChar = 32;
            if (t3.index - 1 >= 0) {
              lastChar = text.charCodeAt(t3.index - 1);
            } else {
              for (j = i2 - 1; j >= 0; j--) {
                if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
                  break;
                if (!tokens[j].content)
                  continue;
                lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
                break;
              }
            }
            nextChar = 32;
            if (pos < max) {
              nextChar = text.charCodeAt(pos);
            } else {
              for (j = i2 + 1; j < tokens.length; j++) {
                if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
                  break;
                if (!tokens[j].content)
                  continue;
                nextChar = tokens[j].content.charCodeAt(0);
                break;
              }
            }
            isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
            isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
            isLastWhiteSpace = isWhiteSpace(lastChar);
            isNextWhiteSpace = isWhiteSpace(nextChar);
            if (isNextWhiteSpace) {
              canOpen = false;
            } else if (isNextPunctChar) {
              if (!(isLastWhiteSpace || isLastPunctChar)) {
                canOpen = false;
              }
            }
            if (isLastWhiteSpace) {
              canClose = false;
            } else if (isLastPunctChar) {
              if (!(isNextWhiteSpace || isNextPunctChar)) {
                canClose = false;
              }
            }
            if (nextChar === 34 && t3[0] === '"') {
              if (lastChar >= 48 && lastChar <= 57) {
                canClose = canOpen = false;
              }
            }
            if (canOpen && canClose) {
              canOpen = isLastPunctChar;
              canClose = isNextPunctChar;
            }
            if (!canOpen && !canClose) {
              if (isSingle) {
                token.content = replaceAt(token.content, t3.index, APOSTROPHE);
              }
              continue;
            }
            if (canClose) {
              for (j = stack.length - 1; j >= 0; j--) {
                item = stack[j];
                if (stack[j].level < thisLevel) {
                  break;
                }
                if (item.single === isSingle && stack[j].level === thisLevel) {
                  item = stack[j];
                  if (isSingle) {
                    openQuote = state.md.options.quotes[2];
                    closeQuote = state.md.options.quotes[3];
                  } else {
                    openQuote = state.md.options.quotes[0];
                    closeQuote = state.md.options.quotes[1];
                  }
                  token.content = replaceAt(token.content, t3.index, closeQuote);
                  tokens[item.token].content = replaceAt(
                    tokens[item.token].content,
                    item.pos,
                    openQuote
                  );
                  pos += closeQuote.length - 1;
                  if (item.token === i2) {
                    pos += openQuote.length - 1;
                  }
                  text = token.content;
                  max = text.length;
                  stack.length = j;
                  continue OUTER;
                }
              }
            }
            if (canOpen) {
              stack.push({
                token: i2,
                pos: t3.index,
                single: isSingle,
                level: thisLevel
              });
            } else if (canClose && isSingle) {
              token.content = replaceAt(token.content, t3.index, APOSTROPHE);
            }
          }
      }
    }
    module2.exports = function smartquotes(state) {
      var blkIdx;
      if (!state.md.options.typographer) {
        return;
      }
      for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
        if (state.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
          continue;
        }
        process_inlines(state.tokens[blkIdx].children, state);
      }
    };
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_core/text_join.js
var require_text_join = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_core/text_join.js"(exports3, module2) {
    "use strict";
    module2.exports = function text_join(state) {
      var j, l2, tokens, curr, max, last, blockTokens = state.tokens;
      for (j = 0, l2 = blockTokens.length; j < l2; j++) {
        if (blockTokens[j].type !== "inline")
          continue;
        tokens = blockTokens[j].children;
        max = tokens.length;
        for (curr = 0; curr < max; curr++) {
          if (tokens[curr].type === "text_special") {
            tokens[curr].type = "text";
          }
        }
        for (curr = last = 0; curr < max; curr++) {
          if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
            tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
          } else {
            if (curr !== last) {
              tokens[last] = tokens[curr];
            }
            last++;
          }
        }
        if (curr !== last) {
          tokens.length = last;
        }
      }
    };
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/token.js
var require_token = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/token.js"(exports3, module2) {
    "use strict";
    function Token3(type, tag, nesting) {
      this.type = type;
      this.tag = tag;
      this.attrs = null;
      this.map = null;
      this.nesting = nesting;
      this.level = 0;
      this.children = null;
      this.content = "";
      this.markup = "";
      this.info = "";
      this.meta = null;
      this.block = false;
      this.hidden = false;
    }
    Token3.prototype.attrIndex = function attrIndex(name2) {
      var attrs, i2, len;
      if (!this.attrs) {
        return -1;
      }
      attrs = this.attrs;
      for (i2 = 0, len = attrs.length; i2 < len; i2++) {
        if (attrs[i2][0] === name2) {
          return i2;
        }
      }
      return -1;
    };
    Token3.prototype.attrPush = function attrPush(attrData) {
      if (this.attrs) {
        this.attrs.push(attrData);
      } else {
        this.attrs = [attrData];
      }
    };
    Token3.prototype.attrSet = function attrSet(name2, value2) {
      var idx = this.attrIndex(name2), attrData = [name2, value2];
      if (idx < 0) {
        this.attrPush(attrData);
      } else {
        this.attrs[idx] = attrData;
      }
    };
    Token3.prototype.attrGet = function attrGet(name2) {
      var idx = this.attrIndex(name2), value2 = null;
      if (idx >= 0) {
        value2 = this.attrs[idx][1];
      }
      return value2;
    };
    Token3.prototype.attrJoin = function attrJoin(name2, value2) {
      var idx = this.attrIndex(name2);
      if (idx < 0) {
        this.attrPush([name2, value2]);
      } else {
        this.attrs[idx][1] = this.attrs[idx][1] + " " + value2;
      }
    };
    module2.exports = Token3;
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_core/state_core.js
var require_state_core = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_core/state_core.js"(exports3, module2) {
    "use strict";
    var Token3 = require_token();
    function StateCore(src3, md, env2) {
      this.src = src3;
      this.env = env2;
      this.tokens = [];
      this.inlineMode = false;
      this.md = md;
    }
    StateCore.prototype.Token = Token3;
    module2.exports = StateCore;
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/parser_core.js
var require_parser_core = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/parser_core.js"(exports3, module2) {
    "use strict";
    var Ruler = require_ruler();
    var _rules = [
      ["normalize", require_normalize()],
      ["block", require_block()],
      ["inline", require_inline()],
      ["linkify", require_linkify()],
      ["replacements", require_replacements()],
      ["smartquotes", require_smartquotes()],
      // `text_join` finds `text_special` tokens (for escape sequences)
      // and joins them with the rest of the text
      ["text_join", require_text_join()]
    ];
    function Core() {
      this.ruler = new Ruler();
      for (var i2 = 0; i2 < _rules.length; i2++) {
        this.ruler.push(_rules[i2][0], _rules[i2][1]);
      }
    }
    Core.prototype.process = function(state) {
      var i2, l2, rules;
      rules = this.ruler.getRules("");
      for (i2 = 0, l2 = rules.length; i2 < l2; i2++) {
        rules[i2](state);
      }
    };
    Core.prototype.State = require_state_core();
    module2.exports = Core;
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_block/table.js
var require_table = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_block/table.js"(exports3, module2) {
    "use strict";
    var isSpace = require_utils8().isSpace;
    function getLine3(state, line) {
      var pos = state.bMarks[line] + state.tShift[line], max = state.eMarks[line];
      return state.src.slice(pos, max);
    }
    function escapedSplit(str2) {
      var result = [], pos = 0, max = str2.length, ch, isEscaped2 = false, lastPos = 0, current2 = "";
      ch = str2.charCodeAt(pos);
      while (pos < max) {
        if (ch === 124) {
          if (!isEscaped2) {
            result.push(current2 + str2.substring(lastPos, pos));
            current2 = "";
            lastPos = pos + 1;
          } else {
            current2 += str2.substring(lastPos, pos - 1);
            lastPos = pos;
          }
        }
        isEscaped2 = ch === 92;
        pos++;
        ch = str2.charCodeAt(pos);
      }
      result.push(current2 + str2.substring(lastPos));
      return result;
    }
    module2.exports = function table(state, startLine, endLine, silent) {
      var ch, lineText, pos, i2, l2, nextLine, columns, columnCount, token, aligns, t3, tableLines, tbodyLines, oldParentType, terminate, terminatorRules, firstCh, secondCh;
      if (startLine + 2 > endLine) {
        return false;
      }
      nextLine = startLine + 1;
      if (state.sCount[nextLine] < state.blkIndent) {
        return false;
      }
      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        return false;
      }
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      if (pos >= state.eMarks[nextLine]) {
        return false;
      }
      firstCh = state.src.charCodeAt(pos++);
      if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) {
        return false;
      }
      if (pos >= state.eMarks[nextLine]) {
        return false;
      }
      secondCh = state.src.charCodeAt(pos++);
      if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace(secondCh)) {
        return false;
      }
      if (firstCh === 45 && isSpace(secondCh)) {
        return false;
      }
      while (pos < state.eMarks[nextLine]) {
        ch = state.src.charCodeAt(pos);
        if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace(ch)) {
          return false;
        }
        pos++;
      }
      lineText = getLine3(state, startLine + 1);
      columns = lineText.split("|");
      aligns = [];
      for (i2 = 0; i2 < columns.length; i2++) {
        t3 = columns[i2].trim();
        if (!t3) {
          if (i2 === 0 || i2 === columns.length - 1) {
            continue;
          } else {
            return false;
          }
        }
        if (!/^:?-+:?$/.test(t3)) {
          return false;
        }
        if (t3.charCodeAt(t3.length - 1) === 58) {
          aligns.push(t3.charCodeAt(0) === 58 ? "center" : "right");
        } else if (t3.charCodeAt(0) === 58) {
          aligns.push("left");
        } else {
          aligns.push("");
        }
      }
      lineText = getLine3(state, startLine).trim();
      if (lineText.indexOf("|") === -1) {
        return false;
      }
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      columns = escapedSplit(lineText);
      if (columns.length && columns[0] === "")
        columns.shift();
      if (columns.length && columns[columns.length - 1] === "")
        columns.pop();
      columnCount = columns.length;
      if (columnCount === 0 || columnCount !== aligns.length) {
        return false;
      }
      if (silent) {
        return true;
      }
      oldParentType = state.parentType;
      state.parentType = "table";
      terminatorRules = state.md.block.ruler.getRules("blockquote");
      token = state.push("table_open", "table", 1);
      token.map = tableLines = [startLine, 0];
      token = state.push("thead_open", "thead", 1);
      token.map = [startLine, startLine + 1];
      token = state.push("tr_open", "tr", 1);
      token.map = [startLine, startLine + 1];
      for (i2 = 0; i2 < columns.length; i2++) {
        token = state.push("th_open", "th", 1);
        if (aligns[i2]) {
          token.attrs = [["style", "text-align:" + aligns[i2]]];
        }
        token = state.push("inline", "", 0);
        token.content = columns[i2].trim();
        token.children = [];
        token = state.push("th_close", "th", -1);
      }
      token = state.push("tr_close", "tr", -1);
      token = state.push("thead_close", "thead", -1);
      for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        terminate = false;
        for (i2 = 0, l2 = terminatorRules.length; i2 < l2; i2++) {
          if (terminatorRules[i2](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
        lineText = getLine3(state, nextLine).trim();
        if (!lineText) {
          break;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          break;
        }
        columns = escapedSplit(lineText);
        if (columns.length && columns[0] === "")
          columns.shift();
        if (columns.length && columns[columns.length - 1] === "")
          columns.pop();
        if (nextLine === startLine + 2) {
          token = state.push("tbody_open", "tbody", 1);
          token.map = tbodyLines = [startLine + 2, 0];
        }
        token = state.push("tr_open", "tr", 1);
        token.map = [nextLine, nextLine + 1];
        for (i2 = 0; i2 < columnCount; i2++) {
          token = state.push("td_open", "td", 1);
          if (aligns[i2]) {
            token.attrs = [["style", "text-align:" + aligns[i2]]];
          }
          token = state.push("inline", "", 0);
          token.content = columns[i2] ? columns[i2].trim() : "";
          token.children = [];
          token = state.push("td_close", "td", -1);
        }
        token = state.push("tr_close", "tr", -1);
      }
      if (tbodyLines) {
        token = state.push("tbody_close", "tbody", -1);
        tbodyLines[1] = nextLine;
      }
      token = state.push("table_close", "table", -1);
      tableLines[1] = nextLine;
      state.parentType = oldParentType;
      state.line = nextLine;
      return true;
    };
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_block/code.js
var require_code = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_block/code.js"(exports3, module2) {
    "use strict";
    module2.exports = function code(state, startLine, endLine) {
      var nextLine, last, token;
      if (state.sCount[startLine] - state.blkIndent < 4) {
        return false;
      }
      last = nextLine = startLine + 1;
      while (nextLine < endLine) {
        if (state.isEmpty(nextLine)) {
          nextLine++;
          continue;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          nextLine++;
          last = nextLine;
          continue;
        }
        break;
      }
      state.line = last;
      token = state.push("code_block", "code", 0);
      token.content = state.getLines(startLine, last, 4 + state.blkIndent, false) + "\n";
      token.map = [startLine, state.line];
      return true;
    };
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_block/fence.js
var require_fence = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_block/fence.js"(exports3, module2) {
    "use strict";
    module2.exports = function fence(state, startLine, endLine, silent) {
      var marker, len, params, nextLine, mem, token, markup, haveEndMarker = false, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (pos + 3 > max) {
        return false;
      }
      marker = state.src.charCodeAt(pos);
      if (marker !== 126 && marker !== 96) {
        return false;
      }
      mem = pos;
      pos = state.skipChars(pos, marker);
      len = pos - mem;
      if (len < 3) {
        return false;
      }
      markup = state.src.slice(mem, pos);
      params = state.src.slice(pos, max);
      if (marker === 96) {
        if (params.indexOf(String.fromCharCode(marker)) >= 0) {
          return false;
        }
      }
      if (silent) {
        return true;
      }
      nextLine = startLine;
      for (; ; ) {
        nextLine++;
        if (nextLine >= endLine) {
          break;
        }
        pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];
        if (pos < max && state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        if (state.src.charCodeAt(pos) !== marker) {
          continue;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          continue;
        }
        pos = state.skipChars(pos, marker);
        if (pos - mem < len) {
          continue;
        }
        pos = state.skipSpaces(pos);
        if (pos < max) {
          continue;
        }
        haveEndMarker = true;
        break;
      }
      len = state.sCount[startLine];
      state.line = nextLine + (haveEndMarker ? 1 : 0);
      token = state.push("fence", "code", 0);
      token.info = params;
      token.content = state.getLines(startLine + 1, nextLine, len, true);
      token.markup = markup;
      token.map = [startLine, state.line];
      return true;
    };
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_block/blockquote.js
var require_blockquote = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_block/blockquote.js"(exports3, module2) {
    "use strict";
    var isSpace = require_utils8().isSpace;
    module2.exports = function blockquote(state, startLine, endLine, silent) {
      var adjustTab, ch, i2, initial, l2, lastLineEmpty, lines, nextLine, offset3, oldBMarks, oldBSCount, oldIndent, oldParentType, oldSCount, oldTShift, spaceAfterMarker, terminate, terminatorRules, token, isOutdented, oldLineMax = state.lineMax, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.src.charCodeAt(pos++) !== 62) {
        return false;
      }
      if (silent) {
        return true;
      }
      initial = offset3 = state.sCount[startLine] + 1;
      if (state.src.charCodeAt(pos) === 32) {
        pos++;
        initial++;
        offset3++;
        adjustTab = false;
        spaceAfterMarker = true;
      } else if (state.src.charCodeAt(pos) === 9) {
        spaceAfterMarker = true;
        if ((state.bsCount[startLine] + offset3) % 4 === 3) {
          pos++;
          initial++;
          offset3++;
          adjustTab = false;
        } else {
          adjustTab = true;
        }
      } else {
        spaceAfterMarker = false;
      }
      oldBMarks = [state.bMarks[startLine]];
      state.bMarks[startLine] = pos;
      while (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (isSpace(ch)) {
          if (ch === 9) {
            offset3 += 4 - (offset3 + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset3++;
          }
        } else {
          break;
        }
        pos++;
      }
      oldBSCount = [state.bsCount[startLine]];
      state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);
      lastLineEmpty = pos >= max;
      oldSCount = [state.sCount[startLine]];
      state.sCount[startLine] = offset3 - initial;
      oldTShift = [state.tShift[startLine]];
      state.tShift[startLine] = pos - state.bMarks[startLine];
      terminatorRules = state.md.block.ruler.getRules("blockquote");
      oldParentType = state.parentType;
      state.parentType = "blockquote";
      for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
        isOutdented = state.sCount[nextLine] < state.blkIndent;
        pos = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];
        if (pos >= max) {
          break;
        }
        if (state.src.charCodeAt(pos++) === 62 && !isOutdented) {
          initial = offset3 = state.sCount[nextLine] + 1;
          if (state.src.charCodeAt(pos) === 32) {
            pos++;
            initial++;
            offset3++;
            adjustTab = false;
            spaceAfterMarker = true;
          } else if (state.src.charCodeAt(pos) === 9) {
            spaceAfterMarker = true;
            if ((state.bsCount[nextLine] + offset3) % 4 === 3) {
              pos++;
              initial++;
              offset3++;
              adjustTab = false;
            } else {
              adjustTab = true;
            }
          } else {
            spaceAfterMarker = false;
          }
          oldBMarks.push(state.bMarks[nextLine]);
          state.bMarks[nextLine] = pos;
          while (pos < max) {
            ch = state.src.charCodeAt(pos);
            if (isSpace(ch)) {
              if (ch === 9) {
                offset3 += 4 - (offset3 + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
              } else {
                offset3++;
              }
            } else {
              break;
            }
            pos++;
          }
          lastLineEmpty = pos >= max;
          oldBSCount.push(state.bsCount[nextLine]);
          state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
          oldSCount.push(state.sCount[nextLine]);
          state.sCount[nextLine] = offset3 - initial;
          oldTShift.push(state.tShift[nextLine]);
          state.tShift[nextLine] = pos - state.bMarks[nextLine];
          continue;
        }
        if (lastLineEmpty) {
          break;
        }
        terminate = false;
        for (i2 = 0, l2 = terminatorRules.length; i2 < l2; i2++) {
          if (terminatorRules[i2](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          state.lineMax = nextLine;
          if (state.blkIndent !== 0) {
            oldBMarks.push(state.bMarks[nextLine]);
            oldBSCount.push(state.bsCount[nextLine]);
            oldTShift.push(state.tShift[nextLine]);
            oldSCount.push(state.sCount[nextLine]);
            state.sCount[nextLine] -= state.blkIndent;
          }
          break;
        }
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] = -1;
      }
      oldIndent = state.blkIndent;
      state.blkIndent = 0;
      token = state.push("blockquote_open", "blockquote", 1);
      token.markup = ">";
      token.map = lines = [startLine, 0];
      state.md.block.tokenize(state, startLine, nextLine);
      token = state.push("blockquote_close", "blockquote", -1);
      token.markup = ">";
      state.lineMax = oldLineMax;
      state.parentType = oldParentType;
      lines[1] = state.line;
      for (i2 = 0; i2 < oldTShift.length; i2++) {
        state.bMarks[i2 + startLine] = oldBMarks[i2];
        state.tShift[i2 + startLine] = oldTShift[i2];
        state.sCount[i2 + startLine] = oldSCount[i2];
        state.bsCount[i2 + startLine] = oldBSCount[i2];
      }
      state.blkIndent = oldIndent;
      return true;
    };
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_block/hr.js
var require_hr = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_block/hr.js"(exports3, module2) {
    "use strict";
    var isSpace = require_utils8().isSpace;
    module2.exports = function hr(state, startLine, endLine, silent) {
      var marker, cnt, ch, token, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      marker = state.src.charCodeAt(pos++);
      if (marker !== 42 && marker !== 45 && marker !== 95) {
        return false;
      }
      cnt = 1;
      while (pos < max) {
        ch = state.src.charCodeAt(pos++);
        if (ch !== marker && !isSpace(ch)) {
          return false;
        }
        if (ch === marker) {
          cnt++;
        }
      }
      if (cnt < 3) {
        return false;
      }
      if (silent) {
        return true;
      }
      state.line = startLine + 1;
      token = state.push("hr", "hr", 0);
      token.map = [startLine, state.line];
      token.markup = Array(cnt + 1).join(String.fromCharCode(marker));
      return true;
    };
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_block/list.js
var require_list = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_block/list.js"(exports3, module2) {
    "use strict";
    var isSpace = require_utils8().isSpace;
    function skipBulletListMarker(state, startLine) {
      var marker, pos, max, ch;
      pos = state.bMarks[startLine] + state.tShift[startLine];
      max = state.eMarks[startLine];
      marker = state.src.charCodeAt(pos++);
      if (marker !== 42 && marker !== 45 && marker !== 43) {
        return -1;
      }
      if (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          return -1;
        }
      }
      return pos;
    }
    function skipOrderedListMarker(state, startLine) {
      var ch, start = state.bMarks[startLine] + state.tShift[startLine], pos = start, max = state.eMarks[startLine];
      if (pos + 1 >= max) {
        return -1;
      }
      ch = state.src.charCodeAt(pos++);
      if (ch < 48 || ch > 57) {
        return -1;
      }
      for (; ; ) {
        if (pos >= max) {
          return -1;
        }
        ch = state.src.charCodeAt(pos++);
        if (ch >= 48 && ch <= 57) {
          if (pos - start >= 10) {
            return -1;
          }
          continue;
        }
        if (ch === 41 || ch === 46) {
          break;
        }
        return -1;
      }
      if (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          return -1;
        }
      }
      return pos;
    }
    function markTightParagraphs(state, idx) {
      var i2, l2, level3 = state.level + 2;
      for (i2 = idx + 2, l2 = state.tokens.length - 2; i2 < l2; i2++) {
        if (state.tokens[i2].level === level3 && state.tokens[i2].type === "paragraph_open") {
          state.tokens[i2 + 2].hidden = true;
          state.tokens[i2].hidden = true;
          i2 += 2;
        }
      }
    }
    module2.exports = function list(state, startLine, endLine, silent) {
      var ch, contentStart, i2, indent, indentAfterMarker, initial, isOrdered, itemLines, l2, listLines, listTokIdx, markerCharCode, markerValue, max, nextLine, offset3, oldListIndent, oldParentType, oldSCount, oldTShift, oldTight, pos, posAfterMarker, prevEmptyEnd, start, terminate, terminatorRules, token, isTerminatingParagraph = false, tight = true;
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.listIndent >= 0 && state.sCount[startLine] - state.listIndent >= 4 && state.sCount[startLine] < state.blkIndent) {
        return false;
      }
      if (silent && state.parentType === "paragraph") {
        if (state.sCount[startLine] >= state.blkIndent) {
          isTerminatingParagraph = true;
        }
      }
      if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
        isOrdered = true;
        start = state.bMarks[startLine] + state.tShift[startLine];
        markerValue = Number(state.src.slice(start, posAfterMarker - 1));
        if (isTerminatingParagraph && markerValue !== 1)
          return false;
      } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
        isOrdered = false;
      } else {
        return false;
      }
      if (isTerminatingParagraph) {
        if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine])
          return false;
      }
      markerCharCode = state.src.charCodeAt(posAfterMarker - 1);
      if (silent) {
        return true;
      }
      listTokIdx = state.tokens.length;
      if (isOrdered) {
        token = state.push("ordered_list_open", "ol", 1);
        if (markerValue !== 1) {
          token.attrs = [["start", markerValue]];
        }
      } else {
        token = state.push("bullet_list_open", "ul", 1);
      }
      token.map = listLines = [startLine, 0];
      token.markup = String.fromCharCode(markerCharCode);
      nextLine = startLine;
      prevEmptyEnd = false;
      terminatorRules = state.md.block.ruler.getRules("list");
      oldParentType = state.parentType;
      state.parentType = "list";
      while (nextLine < endLine) {
        pos = posAfterMarker;
        max = state.eMarks[nextLine];
        initial = offset3 = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);
        while (pos < max) {
          ch = state.src.charCodeAt(pos);
          if (ch === 9) {
            offset3 += 4 - (offset3 + state.bsCount[nextLine]) % 4;
          } else if (ch === 32) {
            offset3++;
          } else {
            break;
          }
          pos++;
        }
        contentStart = pos;
        if (contentStart >= max) {
          indentAfterMarker = 1;
        } else {
          indentAfterMarker = offset3 - initial;
        }
        if (indentAfterMarker > 4) {
          indentAfterMarker = 1;
        }
        indent = initial + indentAfterMarker;
        token = state.push("list_item_open", "li", 1);
        token.markup = String.fromCharCode(markerCharCode);
        token.map = itemLines = [startLine, 0];
        if (isOrdered) {
          token.info = state.src.slice(start, posAfterMarker - 1);
        }
        oldTight = state.tight;
        oldTShift = state.tShift[startLine];
        oldSCount = state.sCount[startLine];
        oldListIndent = state.listIndent;
        state.listIndent = state.blkIndent;
        state.blkIndent = indent;
        state.tight = true;
        state.tShift[startLine] = contentStart - state.bMarks[startLine];
        state.sCount[startLine] = offset3;
        if (contentStart >= max && state.isEmpty(startLine + 1)) {
          state.line = Math.min(state.line + 2, endLine);
        } else {
          state.md.block.tokenize(state, startLine, endLine, true);
        }
        if (!state.tight || prevEmptyEnd) {
          tight = false;
        }
        prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);
        state.blkIndent = state.listIndent;
        state.listIndent = oldListIndent;
        state.tShift[startLine] = oldTShift;
        state.sCount[startLine] = oldSCount;
        state.tight = oldTight;
        token = state.push("list_item_close", "li", -1);
        token.markup = String.fromCharCode(markerCharCode);
        nextLine = startLine = state.line;
        itemLines[1] = nextLine;
        contentStart = state.bMarks[startLine];
        if (nextLine >= endLine) {
          break;
        }
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        if (state.sCount[startLine] - state.blkIndent >= 4) {
          break;
        }
        terminate = false;
        for (i2 = 0, l2 = terminatorRules.length; i2 < l2; i2++) {
          if (terminatorRules[i2](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
        if (isOrdered) {
          posAfterMarker = skipOrderedListMarker(state, nextLine);
          if (posAfterMarker < 0) {
            break;
          }
          start = state.bMarks[nextLine] + state.tShift[nextLine];
        } else {
          posAfterMarker = skipBulletListMarker(state, nextLine);
          if (posAfterMarker < 0) {
            break;
          }
        }
        if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
          break;
        }
      }
      if (isOrdered) {
        token = state.push("ordered_list_close", "ol", -1);
      } else {
        token = state.push("bullet_list_close", "ul", -1);
      }
      token.markup = String.fromCharCode(markerCharCode);
      listLines[1] = nextLine;
      state.line = nextLine;
      state.parentType = oldParentType;
      if (tight) {
        markTightParagraphs(state, listTokIdx);
      }
      return true;
    };
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_block/reference.js
var require_reference = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_block/reference.js"(exports3, module2) {
    "use strict";
    var normalizeReference = require_utils8().normalizeReference;
    var isSpace = require_utils8().isSpace;
    module2.exports = function reference(state, startLine, _endLine, silent) {
      var ch, destEndPos, destEndLineNo, endLine, href, i2, l2, label, labelEnd, oldParentType, res, start, str2, terminate, terminatorRules, title, lines = 0, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine], nextLine = startLine + 1;
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.src.charCodeAt(pos) !== 91) {
        return false;
      }
      while (++pos < max) {
        if (state.src.charCodeAt(pos) === 93 && state.src.charCodeAt(pos - 1) !== 92) {
          if (pos + 1 === max) {
            return false;
          }
          if (state.src.charCodeAt(pos + 1) !== 58) {
            return false;
          }
          break;
        }
      }
      endLine = state.lineMax;
      terminatorRules = state.md.block.ruler.getRules("reference");
      oldParentType = state.parentType;
      state.parentType = "reference";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i2 = 0, l2 = terminatorRules.length; i2 < l2; i2++) {
          if (terminatorRules[i2](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      str2 = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      max = str2.length;
      for (pos = 1; pos < max; pos++) {
        ch = str2.charCodeAt(pos);
        if (ch === 91) {
          return false;
        } else if (ch === 93) {
          labelEnd = pos;
          break;
        } else if (ch === 10) {
          lines++;
        } else if (ch === 92) {
          pos++;
          if (pos < max && str2.charCodeAt(pos) === 10) {
            lines++;
          }
        }
      }
      if (labelEnd < 0 || str2.charCodeAt(labelEnd + 1) !== 58) {
        return false;
      }
      for (pos = labelEnd + 2; pos < max; pos++) {
        ch = str2.charCodeAt(pos);
        if (ch === 10) {
          lines++;
        } else if (isSpace(ch)) {
        } else {
          break;
        }
      }
      res = state.md.helpers.parseLinkDestination(str2, pos, max);
      if (!res.ok) {
        return false;
      }
      href = state.md.normalizeLink(res.str);
      if (!state.md.validateLink(href)) {
        return false;
      }
      pos = res.pos;
      lines += res.lines;
      destEndPos = pos;
      destEndLineNo = lines;
      start = pos;
      for (; pos < max; pos++) {
        ch = str2.charCodeAt(pos);
        if (ch === 10) {
          lines++;
        } else if (isSpace(ch)) {
        } else {
          break;
        }
      }
      res = state.md.helpers.parseLinkTitle(str2, pos, max);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;
        lines += res.lines;
      } else {
        title = "";
        pos = destEndPos;
        lines = destEndLineNo;
      }
      while (pos < max) {
        ch = str2.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }
      if (pos < max && str2.charCodeAt(pos) !== 10) {
        if (title) {
          title = "";
          pos = destEndPos;
          lines = destEndLineNo;
          while (pos < max) {
            ch = str2.charCodeAt(pos);
            if (!isSpace(ch)) {
              break;
            }
            pos++;
          }
        }
      }
      if (pos < max && str2.charCodeAt(pos) !== 10) {
        return false;
      }
      label = normalizeReference(str2.slice(1, labelEnd));
      if (!label) {
        return false;
      }
      if (silent) {
        return true;
      }
      if (typeof state.env.references === "undefined") {
        state.env.references = {};
      }
      if (typeof state.env.references[label] === "undefined") {
        state.env.references[label] = { title, href };
      }
      state.parentType = oldParentType;
      state.line = startLine + lines + 1;
      return true;
    };
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/common/html_blocks.js
var require_html_blocks = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/common/html_blocks.js"(exports3, module2) {
    "use strict";
    module2.exports = [
      "address",
      "article",
      "aside",
      "base",
      "basefont",
      "blockquote",
      "body",
      "caption",
      "center",
      "col",
      "colgroup",
      "dd",
      "details",
      "dialog",
      "dir",
      "div",
      "dl",
      "dt",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "frame",
      "frameset",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hr",
      "html",
      "iframe",
      "legend",
      "li",
      "link",
      "main",
      "menu",
      "menuitem",
      "nav",
      "noframes",
      "ol",
      "optgroup",
      "option",
      "p",
      "param",
      "section",
      "source",
      "summary",
      "table",
      "tbody",
      "td",
      "tfoot",
      "th",
      "thead",
      "title",
      "tr",
      "track",
      "ul"
    ];
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/common/html_re.js
var require_html_re = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/common/html_re.js"(exports3, module2) {
    "use strict";
    var attr_name2 = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
    var unquoted2 = "[^\"'=<>`\\x00-\\x20]+";
    var single_quoted2 = "'[^']*'";
    var double_quoted2 = '"[^"]*"';
    var attr_value2 = "(?:" + unquoted2 + "|" + single_quoted2 + "|" + double_quoted2 + ")";
    var attribute2 = "(?:\\s+" + attr_name2 + "(?:\\s*=\\s*" + attr_value2 + ")?)";
    var open_tag2 = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute2 + "*\\s*\\/?>";
    var close_tag2 = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
    var comment2 = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
    var processing2 = "<[?][\\s\\S]*?[?]>";
    var declaration2 = "<![A-Z]+\\s+[^>]*>";
    var cdata2 = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
    var HTML_TAG_RE2 = new RegExp("^(?:" + open_tag2 + "|" + close_tag2 + "|" + comment2 + "|" + processing2 + "|" + declaration2 + "|" + cdata2 + ")");
    var HTML_OPEN_CLOSE_TAG_RE2 = new RegExp("^(?:" + open_tag2 + "|" + close_tag2 + ")");
    module2.exports.HTML_TAG_RE = HTML_TAG_RE2;
    module2.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE2;
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_block/html_block.js
var require_html_block = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_block/html_block.js"(exports3, module2) {
    "use strict";
    var block_names = require_html_blocks();
    var HTML_OPEN_CLOSE_TAG_RE2 = require_html_re().HTML_OPEN_CLOSE_TAG_RE;
    var HTML_SEQUENCES = [
      [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true],
      [/^<!--/, /-->/, true],
      [/^<\?/, /\?>/, true],
      [/^<![A-Z]/, />/, true],
      [/^<!\[CDATA\[/, /\]\]>/, true],
      [new RegExp("^</?(" + block_names.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true],
      [new RegExp(HTML_OPEN_CLOSE_TAG_RE2.source + "\\s*$"), /^$/, false]
    ];
    module2.exports = function html_block(state, startLine, endLine, silent) {
      var i2, nextLine, token, lineText, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (!state.md.options.html) {
        return false;
      }
      if (state.src.charCodeAt(pos) !== 60) {
        return false;
      }
      lineText = state.src.slice(pos, max);
      for (i2 = 0; i2 < HTML_SEQUENCES.length; i2++) {
        if (HTML_SEQUENCES[i2][0].test(lineText)) {
          break;
        }
      }
      if (i2 === HTML_SEQUENCES.length) {
        return false;
      }
      if (silent) {
        return HTML_SEQUENCES[i2][2];
      }
      nextLine = startLine + 1;
      if (!HTML_SEQUENCES[i2][1].test(lineText)) {
        for (; nextLine < endLine; nextLine++) {
          if (state.sCount[nextLine] < state.blkIndent) {
            break;
          }
          pos = state.bMarks[nextLine] + state.tShift[nextLine];
          max = state.eMarks[nextLine];
          lineText = state.src.slice(pos, max);
          if (HTML_SEQUENCES[i2][1].test(lineText)) {
            if (lineText.length !== 0) {
              nextLine++;
            }
            break;
          }
        }
      }
      state.line = nextLine;
      token = state.push("html_block", "", 0);
      token.map = [startLine, nextLine];
      token.content = state.getLines(startLine, nextLine, state.blkIndent, true);
      return true;
    };
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_block/heading.js
var require_heading = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_block/heading.js"(exports3, module2) {
    "use strict";
    var isSpace = require_utils8().isSpace;
    module2.exports = function heading(state, startLine, endLine, silent) {
      var ch, level3, tmp, token, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      ch = state.src.charCodeAt(pos);
      if (ch !== 35 || pos >= max) {
        return false;
      }
      level3 = 1;
      ch = state.src.charCodeAt(++pos);
      while (ch === 35 && pos < max && level3 <= 6) {
        level3++;
        ch = state.src.charCodeAt(++pos);
      }
      if (level3 > 6 || pos < max && !isSpace(ch)) {
        return false;
      }
      if (silent) {
        return true;
      }
      max = state.skipSpacesBack(max, pos);
      tmp = state.skipCharsBack(max, 35, pos);
      if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
        max = tmp;
      }
      state.line = startLine + 1;
      token = state.push("heading_open", "h" + String(level3), 1);
      token.markup = "########".slice(0, level3);
      token.map = [startLine, state.line];
      token = state.push("inline", "", 0);
      token.content = state.src.slice(pos, max).trim();
      token.map = [startLine, state.line];
      token.children = [];
      token = state.push("heading_close", "h" + String(level3), -1);
      token.markup = "########".slice(0, level3);
      return true;
    };
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_block/lheading.js
var require_lheading = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_block/lheading.js"(exports3, module2) {
    "use strict";
    module2.exports = function lheading(state, startLine, endLine) {
      var content, terminate, i2, l2, token, pos, max, level3, marker, nextLine = startLine + 1, oldParentType, terminatorRules = state.md.block.ruler.getRules("paragraph");
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      oldParentType = state.parentType;
      state.parentType = "paragraph";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] >= state.blkIndent) {
          pos = state.bMarks[nextLine] + state.tShift[nextLine];
          max = state.eMarks[nextLine];
          if (pos < max) {
            marker = state.src.charCodeAt(pos);
            if (marker === 45 || marker === 61) {
              pos = state.skipChars(pos, marker);
              pos = state.skipSpaces(pos);
              if (pos >= max) {
                level3 = marker === 61 ? 1 : 2;
                break;
              }
            }
          }
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i2 = 0, l2 = terminatorRules.length; i2 < l2; i2++) {
          if (terminatorRules[i2](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      if (!level3) {
        return false;
      }
      content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      state.line = nextLine + 1;
      token = state.push("heading_open", "h" + String(level3), 1);
      token.markup = String.fromCharCode(marker);
      token.map = [startLine, state.line];
      token = state.push("inline", "", 0);
      token.content = content;
      token.map = [startLine, state.line - 1];
      token.children = [];
      token = state.push("heading_close", "h" + String(level3), -1);
      token.markup = String.fromCharCode(marker);
      state.parentType = oldParentType;
      return true;
    };
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_block/paragraph.js
var require_paragraph = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_block/paragraph.js"(exports3, module2) {
    "use strict";
    module2.exports = function paragraph(state, startLine) {
      var content, terminate, i2, l2, token, oldParentType, nextLine = startLine + 1, terminatorRules = state.md.block.ruler.getRules("paragraph"), endLine = state.lineMax;
      oldParentType = state.parentType;
      state.parentType = "paragraph";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i2 = 0, l2 = terminatorRules.length; i2 < l2; i2++) {
          if (terminatorRules[i2](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      state.line = nextLine;
      token = state.push("paragraph_open", "p", 1);
      token.map = [startLine, state.line];
      token = state.push("inline", "", 0);
      token.content = content;
      token.map = [startLine, state.line];
      token.children = [];
      token = state.push("paragraph_close", "p", -1);
      state.parentType = oldParentType;
      return true;
    };
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_block/state_block.js
var require_state_block = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_block/state_block.js"(exports3, module2) {
    "use strict";
    var Token3 = require_token();
    var isSpace = require_utils8().isSpace;
    function StateBlock(src3, md, env2, tokens) {
      var ch, s2, start, pos, len, indent, offset3, indent_found;
      this.src = src3;
      this.md = md;
      this.env = env2;
      this.tokens = tokens;
      this.bMarks = [];
      this.eMarks = [];
      this.tShift = [];
      this.sCount = [];
      this.bsCount = [];
      this.blkIndent = 0;
      this.line = 0;
      this.lineMax = 0;
      this.tight = false;
      this.ddIndent = -1;
      this.listIndent = -1;
      this.parentType = "root";
      this.level = 0;
      this.result = "";
      s2 = this.src;
      indent_found = false;
      for (start = pos = indent = offset3 = 0, len = s2.length; pos < len; pos++) {
        ch = s2.charCodeAt(pos);
        if (!indent_found) {
          if (isSpace(ch)) {
            indent++;
            if (ch === 9) {
              offset3 += 4 - offset3 % 4;
            } else {
              offset3++;
            }
            continue;
          } else {
            indent_found = true;
          }
        }
        if (ch === 10 || pos === len - 1) {
          if (ch !== 10) {
            pos++;
          }
          this.bMarks.push(start);
          this.eMarks.push(pos);
          this.tShift.push(indent);
          this.sCount.push(offset3);
          this.bsCount.push(0);
          indent_found = false;
          indent = 0;
          offset3 = 0;
          start = pos + 1;
        }
      }
      this.bMarks.push(s2.length);
      this.eMarks.push(s2.length);
      this.tShift.push(0);
      this.sCount.push(0);
      this.bsCount.push(0);
      this.lineMax = this.bMarks.length - 1;
    }
    StateBlock.prototype.push = function(type, tag, nesting) {
      var token = new Token3(type, tag, nesting);
      token.block = true;
      if (nesting < 0)
        this.level--;
      token.level = this.level;
      if (nesting > 0)
        this.level++;
      this.tokens.push(token);
      return token;
    };
    StateBlock.prototype.isEmpty = function isEmpty3(line) {
      return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
    };
    StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
      for (var max = this.lineMax; from < max; from++) {
        if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
          break;
        }
      }
      return from;
    };
    StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
      var ch;
      for (var max = this.src.length; pos < max; pos++) {
        ch = this.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min2) {
      if (pos <= min2) {
        return pos;
      }
      while (pos > min2) {
        if (!isSpace(this.src.charCodeAt(--pos))) {
          return pos + 1;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipChars = function skipChars(pos, code) {
      for (var max = this.src.length; pos < max; pos++) {
        if (this.src.charCodeAt(pos) !== code) {
          break;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min2) {
      if (pos <= min2) {
        return pos;
      }
      while (pos > min2) {
        if (code !== this.src.charCodeAt(--pos)) {
          return pos + 1;
        }
      }
      return pos;
    };
    StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
      var i2, lineIndent, ch, first2, last, queue2, lineStart, line = begin;
      if (begin >= end) {
        return "";
      }
      queue2 = new Array(end - begin);
      for (i2 = 0; line < end; line++, i2++) {
        lineIndent = 0;
        lineStart = first2 = this.bMarks[line];
        if (line + 1 < end || keepLastLF) {
          last = this.eMarks[line] + 1;
        } else {
          last = this.eMarks[line];
        }
        while (first2 < last && lineIndent < indent) {
          ch = this.src.charCodeAt(first2);
          if (isSpace(ch)) {
            if (ch === 9) {
              lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
            } else {
              lineIndent++;
            }
          } else if (first2 - lineStart < this.tShift[line]) {
            lineIndent++;
          } else {
            break;
          }
          first2++;
        }
        if (lineIndent > indent) {
          queue2[i2] = new Array(lineIndent - indent + 1).join(" ") + this.src.slice(first2, last);
        } else {
          queue2[i2] = this.src.slice(first2, last);
        }
      }
      return queue2.join("");
    };
    StateBlock.prototype.Token = Token3;
    module2.exports = StateBlock;
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/parser_block.js
var require_parser_block = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/parser_block.js"(exports3, module2) {
    "use strict";
    var Ruler = require_ruler();
    var _rules = [
      // First 2 params - rule name & source. Secondary array - list of rules,
      // which can be terminated by this one.
      ["table", require_table(), ["paragraph", "reference"]],
      ["code", require_code()],
      ["fence", require_fence(), ["paragraph", "reference", "blockquote", "list"]],
      ["blockquote", require_blockquote(), ["paragraph", "reference", "blockquote", "list"]],
      ["hr", require_hr(), ["paragraph", "reference", "blockquote", "list"]],
      ["list", require_list(), ["paragraph", "reference", "blockquote"]],
      ["reference", require_reference()],
      ["html_block", require_html_block(), ["paragraph", "reference", "blockquote"]],
      ["heading", require_heading(), ["paragraph", "reference", "blockquote"]],
      ["lheading", require_lheading()],
      ["paragraph", require_paragraph()]
    ];
    function ParserBlock() {
      this.ruler = new Ruler();
      for (var i2 = 0; i2 < _rules.length; i2++) {
        this.ruler.push(_rules[i2][0], _rules[i2][1], { alt: (_rules[i2][2] || []).slice() });
      }
    }
    ParserBlock.prototype.tokenize = function(state, startLine, endLine) {
      var ok2, i2, rules = this.ruler.getRules(""), len = rules.length, line = startLine, hasEmptyLines = false, maxNesting = state.md.options.maxNesting;
      while (line < endLine) {
        state.line = line = state.skipEmptyLines(line);
        if (line >= endLine) {
          break;
        }
        if (state.sCount[line] < state.blkIndent) {
          break;
        }
        if (state.level >= maxNesting) {
          state.line = endLine;
          break;
        }
        for (i2 = 0; i2 < len; i2++) {
          ok2 = rules[i2](state, line, endLine, false);
          if (ok2) {
            break;
          }
        }
        state.tight = !hasEmptyLines;
        if (state.isEmpty(state.line - 1)) {
          hasEmptyLines = true;
        }
        line = state.line;
        if (line < endLine && state.isEmpty(line)) {
          hasEmptyLines = true;
          line++;
          state.line = line;
        }
      }
    };
    ParserBlock.prototype.parse = function(src3, md, env2, outTokens) {
      var state;
      if (!src3) {
        return;
      }
      state = new this.State(src3, md, env2, outTokens);
      this.tokenize(state, state.line, state.lineMax);
    };
    ParserBlock.prototype.State = require_state_block();
    module2.exports = ParserBlock;
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_inline/text.js
var require_text = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_inline/text.js"(exports3, module2) {
    "use strict";
    function isTerminatorChar(ch) {
      switch (ch) {
        case 10:
        case 33:
        case 35:
        case 36:
        case 37:
        case 38:
        case 42:
        case 43:
        case 45:
        case 58:
        case 60:
        case 61:
        case 62:
        case 64:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 123:
        case 125:
        case 126:
          return true;
        default:
          return false;
      }
    }
    module2.exports = function text(state, silent) {
      var pos = state.pos;
      while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
        pos++;
      }
      if (pos === state.pos) {
        return false;
      }
      if (!silent) {
        state.pending += state.src.slice(state.pos, pos);
      }
      state.pos = pos;
      return true;
    };
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_inline/linkify.js
var require_linkify2 = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_inline/linkify.js"(exports3, module2) {
    "use strict";
    var SCHEME_RE = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
    module2.exports = function linkify(state, silent) {
      var pos, max, match, proto3, link, url2, fullUrl, token;
      if (!state.md.options.linkify)
        return false;
      if (state.linkLevel > 0)
        return false;
      pos = state.pos;
      max = state.posMax;
      if (pos + 3 > max)
        return false;
      if (state.src.charCodeAt(pos) !== 58)
        return false;
      if (state.src.charCodeAt(pos + 1) !== 47)
        return false;
      if (state.src.charCodeAt(pos + 2) !== 47)
        return false;
      match = state.pending.match(SCHEME_RE);
      if (!match)
        return false;
      proto3 = match[1];
      link = state.md.linkify.matchAtStart(state.src.slice(pos - proto3.length));
      if (!link)
        return false;
      url2 = link.url;
      url2 = url2.replace(/\*+$/, "");
      fullUrl = state.md.normalizeLink(url2);
      if (!state.md.validateLink(fullUrl))
        return false;
      if (!silent) {
        state.pending = state.pending.slice(0, -proto3.length);
        token = state.push("link_open", "a", 1);
        token.attrs = [["href", fullUrl]];
        token.markup = "linkify";
        token.info = "auto";
        token = state.push("text", "", 0);
        token.content = state.md.normalizeLinkText(url2);
        token = state.push("link_close", "a", -1);
        token.markup = "linkify";
        token.info = "auto";
      }
      state.pos += url2.length - proto3.length;
      return true;
    };
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_inline/newline.js
var require_newline = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_inline/newline.js"(exports3, module2) {
    "use strict";
    var isSpace = require_utils8().isSpace;
    module2.exports = function newline(state, silent) {
      var pmax, max, ws, pos = state.pos;
      if (state.src.charCodeAt(pos) !== 10) {
        return false;
      }
      pmax = state.pending.length - 1;
      max = state.posMax;
      if (!silent) {
        if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {
          if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {
            ws = pmax - 1;
            while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 32)
              ws--;
            state.pending = state.pending.slice(0, ws);
            state.push("hardbreak", "br", 0);
          } else {
            state.pending = state.pending.slice(0, -1);
            state.push("softbreak", "br", 0);
          }
        } else {
          state.push("softbreak", "br", 0);
        }
      }
      pos++;
      while (pos < max && isSpace(state.src.charCodeAt(pos))) {
        pos++;
      }
      state.pos = pos;
      return true;
    };
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_inline/escape.js
var require_escape = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_inline/escape.js"(exports3, module2) {
    "use strict";
    var isSpace = require_utils8().isSpace;
    var ESCAPED = [];
    for (i2 = 0; i2 < 256; i2++) {
      ESCAPED.push(0);
    }
    var i2;
    "\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch) {
      ESCAPED[ch.charCodeAt(0)] = 1;
    });
    module2.exports = function escape2(state, silent) {
      var ch1, ch2, origStr, escapedStr, token, pos = state.pos, max = state.posMax;
      if (state.src.charCodeAt(pos) !== 92)
        return false;
      pos++;
      if (pos >= max)
        return false;
      ch1 = state.src.charCodeAt(pos);
      if (ch1 === 10) {
        if (!silent) {
          state.push("hardbreak", "br", 0);
        }
        pos++;
        while (pos < max) {
          ch1 = state.src.charCodeAt(pos);
          if (!isSpace(ch1))
            break;
          pos++;
        }
        state.pos = pos;
        return true;
      }
      escapedStr = state.src[pos];
      if (ch1 >= 55296 && ch1 <= 56319 && pos + 1 < max) {
        ch2 = state.src.charCodeAt(pos + 1);
        if (ch2 >= 56320 && ch2 <= 57343) {
          escapedStr += state.src[pos + 1];
          pos++;
        }
      }
      origStr = "\\" + escapedStr;
      if (!silent) {
        token = state.push("text_special", "", 0);
        if (ch1 < 256 && ESCAPED[ch1] !== 0) {
          token.content = escapedStr;
        } else {
          token.content = origStr;
        }
        token.markup = origStr;
        token.info = "escape";
      }
      state.pos = pos + 1;
      return true;
    };
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_inline/backticks.js
var require_backticks = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_inline/backticks.js"(exports3, module2) {
    "use strict";
    module2.exports = function backtick(state, silent) {
      var start, max, marker, token, matchStart, matchEnd, openerLength, closerLength, pos = state.pos, ch = state.src.charCodeAt(pos);
      if (ch !== 96) {
        return false;
      }
      start = pos;
      pos++;
      max = state.posMax;
      while (pos < max && state.src.charCodeAt(pos) === 96) {
        pos++;
      }
      marker = state.src.slice(start, pos);
      openerLength = marker.length;
      if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {
        if (!silent)
          state.pending += marker;
        state.pos += openerLength;
        return true;
      }
      matchStart = matchEnd = pos;
      while ((matchStart = state.src.indexOf("`", matchEnd)) !== -1) {
        matchEnd = matchStart + 1;
        while (matchEnd < max && state.src.charCodeAt(matchEnd) === 96) {
          matchEnd++;
        }
        closerLength = matchEnd - matchStart;
        if (closerLength === openerLength) {
          if (!silent) {
            token = state.push("code_inline", "code", 0);
            token.markup = marker;
            token.content = state.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
          }
          state.pos = matchEnd;
          return true;
        }
        state.backticks[closerLength] = matchStart;
      }
      state.backticksScanned = true;
      if (!silent)
        state.pending += marker;
      state.pos += openerLength;
      return true;
    };
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_inline/strikethrough.js
var require_strikethrough = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_inline/strikethrough.js"(exports3, module2) {
    "use strict";
    module2.exports.tokenize = function strikethrough(state, silent) {
      var i2, scanned, token, len, ch, start = state.pos, marker = state.src.charCodeAt(start);
      if (silent) {
        return false;
      }
      if (marker !== 126) {
        return false;
      }
      scanned = state.scanDelims(state.pos, true);
      len = scanned.length;
      ch = String.fromCharCode(marker);
      if (len < 2) {
        return false;
      }
      if (len % 2) {
        token = state.push("text", "", 0);
        token.content = ch;
        len--;
      }
      for (i2 = 0; i2 < len; i2 += 2) {
        token = state.push("text", "", 0);
        token.content = ch + ch;
        state.delimiters.push({
          marker,
          length: 0,
          // disable "rule of 3" length checks meant for emphasis
          token: state.tokens.length - 1,
          end: -1,
          open: scanned.can_open,
          close: scanned.can_close
        });
      }
      state.pos += scanned.length;
      return true;
    };
    function postProcess(state, delimiters) {
      var i2, j, startDelim, endDelim, token, loneMarkers = [], max = delimiters.length;
      for (i2 = 0; i2 < max; i2++) {
        startDelim = delimiters[i2];
        if (startDelim.marker !== 126) {
          continue;
        }
        if (startDelim.end === -1) {
          continue;
        }
        endDelim = delimiters[startDelim.end];
        token = state.tokens[startDelim.token];
        token.type = "s_open";
        token.tag = "s";
        token.nesting = 1;
        token.markup = "~~";
        token.content = "";
        token = state.tokens[endDelim.token];
        token.type = "s_close";
        token.tag = "s";
        token.nesting = -1;
        token.markup = "~~";
        token.content = "";
        if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "~") {
          loneMarkers.push(endDelim.token - 1);
        }
      }
      while (loneMarkers.length) {
        i2 = loneMarkers.pop();
        j = i2 + 1;
        while (j < state.tokens.length && state.tokens[j].type === "s_close") {
          j++;
        }
        j--;
        if (i2 !== j) {
          token = state.tokens[j];
          state.tokens[j] = state.tokens[i2];
          state.tokens[i2] = token;
        }
      }
    }
    module2.exports.postProcess = function strikethrough(state) {
      var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
      postProcess(state, state.delimiters);
      for (curr = 0; curr < max; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          postProcess(state, tokens_meta[curr].delimiters);
        }
      }
    };
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_inline/emphasis.js
var require_emphasis = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_inline/emphasis.js"(exports3, module2) {
    "use strict";
    module2.exports.tokenize = function emphasis(state, silent) {
      var i2, scanned, token, start = state.pos, marker = state.src.charCodeAt(start);
      if (silent) {
        return false;
      }
      if (marker !== 95 && marker !== 42) {
        return false;
      }
      scanned = state.scanDelims(state.pos, marker === 42);
      for (i2 = 0; i2 < scanned.length; i2++) {
        token = state.push("text", "", 0);
        token.content = String.fromCharCode(marker);
        state.delimiters.push({
          // Char code of the starting marker (number).
          //
          marker,
          // Total length of these series of delimiters.
          //
          length: scanned.length,
          // A position of the token this delimiter corresponds to.
          //
          token: state.tokens.length - 1,
          // If this delimiter is matched as a valid opener, `end` will be
          // equal to its position, otherwise it's `-1`.
          //
          end: -1,
          // Boolean flags that determine if this delimiter could open or close
          // an emphasis.
          //
          open: scanned.can_open,
          close: scanned.can_close
        });
      }
      state.pos += scanned.length;
      return true;
    };
    function postProcess(state, delimiters) {
      var i2, startDelim, endDelim, token, ch, isStrong, max = delimiters.length;
      for (i2 = max - 1; i2 >= 0; i2--) {
        startDelim = delimiters[i2];
        if (startDelim.marker !== 95 && startDelim.marker !== 42) {
          continue;
        }
        if (startDelim.end === -1) {
          continue;
        }
        endDelim = delimiters[startDelim.end];
        isStrong = i2 > 0 && delimiters[i2 - 1].end === startDelim.end + 1 && // check that first two markers match and adjacent
        delimiters[i2 - 1].marker === startDelim.marker && delimiters[i2 - 1].token === startDelim.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
        delimiters[startDelim.end + 1].token === endDelim.token + 1;
        ch = String.fromCharCode(startDelim.marker);
        token = state.tokens[startDelim.token];
        token.type = isStrong ? "strong_open" : "em_open";
        token.tag = isStrong ? "strong" : "em";
        token.nesting = 1;
        token.markup = isStrong ? ch + ch : ch;
        token.content = "";
        token = state.tokens[endDelim.token];
        token.type = isStrong ? "strong_close" : "em_close";
        token.tag = isStrong ? "strong" : "em";
        token.nesting = -1;
        token.markup = isStrong ? ch + ch : ch;
        token.content = "";
        if (isStrong) {
          state.tokens[delimiters[i2 - 1].token].content = "";
          state.tokens[delimiters[startDelim.end + 1].token].content = "";
          i2--;
        }
      }
    }
    module2.exports.postProcess = function emphasis(state) {
      var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
      postProcess(state, state.delimiters);
      for (curr = 0; curr < max; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          postProcess(state, tokens_meta[curr].delimiters);
        }
      }
    };
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_inline/link.js
var require_link2 = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_inline/link.js"(exports3, module2) {
    "use strict";
    var normalizeReference = require_utils8().normalizeReference;
    var isSpace = require_utils8().isSpace;
    module2.exports = function link(state, silent) {
      var attrs, code, label, labelEnd, labelStart, pos, res, ref2, token, href = "", title = "", oldPos = state.pos, max = state.posMax, start = state.pos, parseReference = true;
      if (state.src.charCodeAt(state.pos) !== 91) {
        return false;
      }
      labelStart = state.pos + 1;
      labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);
      if (labelEnd < 0) {
        return false;
      }
      pos = labelEnd + 1;
      if (pos < max && state.src.charCodeAt(pos) === 40) {
        parseReference = false;
        pos++;
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 10) {
            break;
          }
        }
        if (pos >= max) {
          return false;
        }
        start = pos;
        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
        if (res.ok) {
          href = state.md.normalizeLink(res.str);
          if (state.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = "";
          }
          start = pos;
          for (; pos < max; pos++) {
            code = state.src.charCodeAt(pos);
            if (!isSpace(code) && code !== 10) {
              break;
            }
          }
          res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
          if (pos < max && start !== pos && res.ok) {
            title = res.str;
            pos = res.pos;
            for (; pos < max; pos++) {
              code = state.src.charCodeAt(pos);
              if (!isSpace(code) && code !== 10) {
                break;
              }
            }
          }
        }
        if (pos >= max || state.src.charCodeAt(pos) !== 41) {
          parseReference = true;
        }
        pos++;
      }
      if (parseReference) {
        if (typeof state.env.references === "undefined") {
          return false;
        }
        if (pos < max && state.src.charCodeAt(pos) === 91) {
          start = pos + 1;
          pos = state.md.helpers.parseLinkLabel(state, pos);
          if (pos >= 0) {
            label = state.src.slice(start, pos++);
          } else {
            pos = labelEnd + 1;
          }
        } else {
          pos = labelEnd + 1;
        }
        if (!label) {
          label = state.src.slice(labelStart, labelEnd);
        }
        ref2 = state.env.references[normalizeReference(label)];
        if (!ref2) {
          state.pos = oldPos;
          return false;
        }
        href = ref2.href;
        title = ref2.title;
      }
      if (!silent) {
        state.pos = labelStart;
        state.posMax = labelEnd;
        token = state.push("link_open", "a", 1);
        token.attrs = attrs = [["href", href]];
        if (title) {
          attrs.push(["title", title]);
        }
        state.linkLevel++;
        state.md.inline.tokenize(state);
        state.linkLevel--;
        token = state.push("link_close", "a", -1);
      }
      state.pos = pos;
      state.posMax = max;
      return true;
    };
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_inline/image.js
var require_image = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_inline/image.js"(exports3, module2) {
    "use strict";
    var normalizeReference = require_utils8().normalizeReference;
    var isSpace = require_utils8().isSpace;
    module2.exports = function image(state, silent) {
      var attrs, code, content, label, labelEnd, labelStart, pos, ref2, res, title, token, tokens, start, href = "", oldPos = state.pos, max = state.posMax;
      if (state.src.charCodeAt(state.pos) !== 33) {
        return false;
      }
      if (state.src.charCodeAt(state.pos + 1) !== 91) {
        return false;
      }
      labelStart = state.pos + 2;
      labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);
      if (labelEnd < 0) {
        return false;
      }
      pos = labelEnd + 1;
      if (pos < max && state.src.charCodeAt(pos) === 40) {
        pos++;
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 10) {
            break;
          }
        }
        if (pos >= max) {
          return false;
        }
        start = pos;
        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
        if (res.ok) {
          href = state.md.normalizeLink(res.str);
          if (state.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = "";
          }
        }
        start = pos;
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 10) {
            break;
          }
        }
        res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
        if (pos < max && start !== pos && res.ok) {
          title = res.str;
          pos = res.pos;
          for (; pos < max; pos++) {
            code = state.src.charCodeAt(pos);
            if (!isSpace(code) && code !== 10) {
              break;
            }
          }
        } else {
          title = "";
        }
        if (pos >= max || state.src.charCodeAt(pos) !== 41) {
          state.pos = oldPos;
          return false;
        }
        pos++;
      } else {
        if (typeof state.env.references === "undefined") {
          return false;
        }
        if (pos < max && state.src.charCodeAt(pos) === 91) {
          start = pos + 1;
          pos = state.md.helpers.parseLinkLabel(state, pos);
          if (pos >= 0) {
            label = state.src.slice(start, pos++);
          } else {
            pos = labelEnd + 1;
          }
        } else {
          pos = labelEnd + 1;
        }
        if (!label) {
          label = state.src.slice(labelStart, labelEnd);
        }
        ref2 = state.env.references[normalizeReference(label)];
        if (!ref2) {
          state.pos = oldPos;
          return false;
        }
        href = ref2.href;
        title = ref2.title;
      }
      if (!silent) {
        content = state.src.slice(labelStart, labelEnd);
        state.md.inline.parse(
          content,
          state.md,
          state.env,
          tokens = []
        );
        token = state.push("image", "img", 0);
        token.attrs = attrs = [["src", href], ["alt", ""]];
        token.children = tokens;
        token.content = content;
        if (title) {
          attrs.push(["title", title]);
        }
      }
      state.pos = pos;
      state.posMax = max;
      return true;
    };
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_inline/autolink.js
var require_autolink = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_inline/autolink.js"(exports3, module2) {
    "use strict";
    var EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
    var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/;
    module2.exports = function autolink(state, silent) {
      var url2, fullUrl, token, ch, start, max, pos = state.pos;
      if (state.src.charCodeAt(pos) !== 60) {
        return false;
      }
      start = state.pos;
      max = state.posMax;
      for (; ; ) {
        if (++pos >= max)
          return false;
        ch = state.src.charCodeAt(pos);
        if (ch === 60)
          return false;
        if (ch === 62)
          break;
      }
      url2 = state.src.slice(start + 1, pos);
      if (AUTOLINK_RE.test(url2)) {
        fullUrl = state.md.normalizeLink(url2);
        if (!state.md.validateLink(fullUrl)) {
          return false;
        }
        if (!silent) {
          token = state.push("link_open", "a", 1);
          token.attrs = [["href", fullUrl]];
          token.markup = "autolink";
          token.info = "auto";
          token = state.push("text", "", 0);
          token.content = state.md.normalizeLinkText(url2);
          token = state.push("link_close", "a", -1);
          token.markup = "autolink";
          token.info = "auto";
        }
        state.pos += url2.length + 2;
        return true;
      }
      if (EMAIL_RE.test(url2)) {
        fullUrl = state.md.normalizeLink("mailto:" + url2);
        if (!state.md.validateLink(fullUrl)) {
          return false;
        }
        if (!silent) {
          token = state.push("link_open", "a", 1);
          token.attrs = [["href", fullUrl]];
          token.markup = "autolink";
          token.info = "auto";
          token = state.push("text", "", 0);
          token.content = state.md.normalizeLinkText(url2);
          token = state.push("link_close", "a", -1);
          token.markup = "autolink";
          token.info = "auto";
        }
        state.pos += url2.length + 2;
        return true;
      }
      return false;
    };
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_inline/html_inline.js
var require_html_inline = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_inline/html_inline.js"(exports3, module2) {
    "use strict";
    var HTML_TAG_RE2 = require_html_re().HTML_TAG_RE;
    function isLinkOpen(str2) {
      return /^<a[>\s]/i.test(str2);
    }
    function isLinkClose(str2) {
      return /^<\/a\s*>/i.test(str2);
    }
    function isLetter2(ch) {
      var lc = ch | 32;
      return lc >= 97 && lc <= 122;
    }
    module2.exports = function html_inline(state, silent) {
      var ch, match, max, token, pos = state.pos;
      if (!state.md.options.html) {
        return false;
      }
      max = state.posMax;
      if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max) {
        return false;
      }
      ch = state.src.charCodeAt(pos + 1);
      if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter2(ch)) {
        return false;
      }
      match = state.src.slice(pos).match(HTML_TAG_RE2);
      if (!match) {
        return false;
      }
      if (!silent) {
        token = state.push("html_inline", "", 0);
        token.content = state.src.slice(pos, pos + match[0].length);
        if (isLinkOpen(token.content))
          state.linkLevel++;
        if (isLinkClose(token.content))
          state.linkLevel--;
      }
      state.pos += match[0].length;
      return true;
    };
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_inline/entity.js
var require_entity = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_inline/entity.js"(exports3, module2) {
    "use strict";
    var entities = require_entities2();
    var has = require_utils8().has;
    var isValidEntityCode = require_utils8().isValidEntityCode;
    var fromCodePoint = require_utils8().fromCodePoint;
    var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
    var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
    module2.exports = function entity(state, silent) {
      var ch, code, match, token, pos = state.pos, max = state.posMax;
      if (state.src.charCodeAt(pos) !== 38)
        return false;
      if (pos + 1 >= max)
        return false;
      ch = state.src.charCodeAt(pos + 1);
      if (ch === 35) {
        match = state.src.slice(pos).match(DIGITAL_RE);
        if (match) {
          if (!silent) {
            code = match[1][0].toLowerCase() === "x" ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
            token = state.push("text_special", "", 0);
            token.content = isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(65533);
            token.markup = match[0];
            token.info = "entity";
          }
          state.pos += match[0].length;
          return true;
        }
      } else {
        match = state.src.slice(pos).match(NAMED_RE);
        if (match) {
          if (has(entities, match[1])) {
            if (!silent) {
              token = state.push("text_special", "", 0);
              token.content = entities[match[1]];
              token.markup = match[0];
              token.info = "entity";
            }
            state.pos += match[0].length;
            return true;
          }
        }
      }
      return false;
    };
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_inline/balance_pairs.js
var require_balance_pairs = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_inline/balance_pairs.js"(exports3, module2) {
    "use strict";
    function processDelimiters(state, delimiters) {
      var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx, isOddMatch, lastJump, openersBottom = {}, max = delimiters.length;
      if (!max)
        return;
      var headerIdx = 0;
      var lastTokenIdx = -2;
      var jumps = [];
      for (closerIdx = 0; closerIdx < max; closerIdx++) {
        closer = delimiters[closerIdx];
        jumps.push(0);
        if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
          headerIdx = closerIdx;
        }
        lastTokenIdx = closer.token;
        closer.length = closer.length || 0;
        if (!closer.close)
          continue;
        if (!openersBottom.hasOwnProperty(closer.marker)) {
          openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];
        }
        minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];
        openerIdx = headerIdx - jumps[headerIdx] - 1;
        newMinOpenerIdx = openerIdx;
        for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
          opener = delimiters[openerIdx];
          if (opener.marker !== closer.marker)
            continue;
          if (opener.open && opener.end < 0) {
            isOddMatch = false;
            if (opener.close || closer.open) {
              if ((opener.length + closer.length) % 3 === 0) {
                if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
                  isOddMatch = true;
                }
              }
            }
            if (!isOddMatch) {
              lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;
              jumps[closerIdx] = closerIdx - openerIdx + lastJump;
              jumps[openerIdx] = lastJump;
              closer.open = false;
              opener.end = closerIdx;
              opener.close = false;
              newMinOpenerIdx = -1;
              lastTokenIdx = -2;
              break;
            }
          }
        }
        if (newMinOpenerIdx !== -1) {
          openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;
        }
      }
    }
    module2.exports = function link_pairs(state) {
      var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
      processDelimiters(state, state.delimiters);
      for (curr = 0; curr < max; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          processDelimiters(state, tokens_meta[curr].delimiters);
        }
      }
    };
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_inline/fragments_join.js
var require_fragments_join = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_inline/fragments_join.js"(exports3, module2) {
    "use strict";
    module2.exports = function fragments_join(state) {
      var curr, last, level3 = 0, tokens = state.tokens, max = state.tokens.length;
      for (curr = last = 0; curr < max; curr++) {
        if (tokens[curr].nesting < 0)
          level3--;
        tokens[curr].level = level3;
        if (tokens[curr].nesting > 0)
          level3++;
        if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
          tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
        } else {
          if (curr !== last) {
            tokens[last] = tokens[curr];
          }
          last++;
        }
      }
      if (curr !== last) {
        tokens.length = last;
      }
    };
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_inline/state_inline.js
var require_state_inline = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/rules_inline/state_inline.js"(exports3, module2) {
    "use strict";
    var Token3 = require_token();
    var isWhiteSpace = require_utils8().isWhiteSpace;
    var isPunctChar = require_utils8().isPunctChar;
    var isMdAsciiPunct = require_utils8().isMdAsciiPunct;
    function StateInline(src3, md, env2, outTokens) {
      this.src = src3;
      this.env = env2;
      this.md = md;
      this.tokens = outTokens;
      this.tokens_meta = Array(outTokens.length);
      this.pos = 0;
      this.posMax = this.src.length;
      this.level = 0;
      this.pending = "";
      this.pendingLevel = 0;
      this.cache = {};
      this.delimiters = [];
      this._prev_delimiters = [];
      this.backticks = {};
      this.backticksScanned = false;
      this.linkLevel = 0;
    }
    StateInline.prototype.pushPending = function() {
      var token = new Token3("text", "", 0);
      token.content = this.pending;
      token.level = this.pendingLevel;
      this.tokens.push(token);
      this.pending = "";
      return token;
    };
    StateInline.prototype.push = function(type, tag, nesting) {
      if (this.pending) {
        this.pushPending();
      }
      var token = new Token3(type, tag, nesting);
      var token_meta = null;
      if (nesting < 0) {
        this.level--;
        this.delimiters = this._prev_delimiters.pop();
      }
      token.level = this.level;
      if (nesting > 0) {
        this.level++;
        this._prev_delimiters.push(this.delimiters);
        this.delimiters = [];
        token_meta = { delimiters: this.delimiters };
      }
      this.pendingLevel = this.level;
      this.tokens.push(token);
      this.tokens_meta.push(token_meta);
      return token;
    };
    StateInline.prototype.scanDelims = function(start, canSplitWord) {
      var pos = start, lastChar, nextChar, count, can_open, can_close, isLastWhiteSpace, isLastPunctChar, isNextWhiteSpace, isNextPunctChar, left_flanking = true, right_flanking = true, max = this.posMax, marker = this.src.charCodeAt(start);
      lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 32;
      while (pos < max && this.src.charCodeAt(pos) === marker) {
        pos++;
      }
      count = pos - start;
      nextChar = pos < max ? this.src.charCodeAt(pos) : 32;
      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
      isLastWhiteSpace = isWhiteSpace(lastChar);
      isNextWhiteSpace = isWhiteSpace(nextChar);
      if (isNextWhiteSpace) {
        left_flanking = false;
      } else if (isNextPunctChar) {
        if (!(isLastWhiteSpace || isLastPunctChar)) {
          left_flanking = false;
        }
      }
      if (isLastWhiteSpace) {
        right_flanking = false;
      } else if (isLastPunctChar) {
        if (!(isNextWhiteSpace || isNextPunctChar)) {
          right_flanking = false;
        }
      }
      if (!canSplitWord) {
        can_open = left_flanking && (!right_flanking || isLastPunctChar);
        can_close = right_flanking && (!left_flanking || isNextPunctChar);
      } else {
        can_open = left_flanking;
        can_close = right_flanking;
      }
      return {
        can_open,
        can_close,
        length: count
      };
    };
    StateInline.prototype.Token = Token3;
    module2.exports = StateInline;
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/parser_inline.js
var require_parser_inline = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/parser_inline.js"(exports3, module2) {
    "use strict";
    var Ruler = require_ruler();
    var _rules = [
      ["text", require_text()],
      ["linkify", require_linkify2()],
      ["newline", require_newline()],
      ["escape", require_escape()],
      ["backticks", require_backticks()],
      ["strikethrough", require_strikethrough().tokenize],
      ["emphasis", require_emphasis().tokenize],
      ["link", require_link2()],
      ["image", require_image()],
      ["autolink", require_autolink()],
      ["html_inline", require_html_inline()],
      ["entity", require_entity()]
    ];
    var _rules2 = [
      ["balance_pairs", require_balance_pairs()],
      ["strikethrough", require_strikethrough().postProcess],
      ["emphasis", require_emphasis().postProcess],
      // rules for pairs separate '**' into its own text tokens, which may be left unused,
      // rule below merges unused segments back with the rest of the text
      ["fragments_join", require_fragments_join()]
    ];
    function ParserInline() {
      var i2;
      this.ruler = new Ruler();
      for (i2 = 0; i2 < _rules.length; i2++) {
        this.ruler.push(_rules[i2][0], _rules[i2][1]);
      }
      this.ruler2 = new Ruler();
      for (i2 = 0; i2 < _rules2.length; i2++) {
        this.ruler2.push(_rules2[i2][0], _rules2[i2][1]);
      }
    }
    ParserInline.prototype.skipToken = function(state) {
      var ok2, i2, pos = state.pos, rules = this.ruler.getRules(""), len = rules.length, maxNesting = state.md.options.maxNesting, cache2 = state.cache;
      if (typeof cache2[pos] !== "undefined") {
        state.pos = cache2[pos];
        return;
      }
      if (state.level < maxNesting) {
        for (i2 = 0; i2 < len; i2++) {
          state.level++;
          ok2 = rules[i2](state, true);
          state.level--;
          if (ok2) {
            break;
          }
        }
      } else {
        state.pos = state.posMax;
      }
      if (!ok2) {
        state.pos++;
      }
      cache2[pos] = state.pos;
    };
    ParserInline.prototype.tokenize = function(state) {
      var ok2, i2, rules = this.ruler.getRules(""), len = rules.length, end = state.posMax, maxNesting = state.md.options.maxNesting;
      while (state.pos < end) {
        if (state.level < maxNesting) {
          for (i2 = 0; i2 < len; i2++) {
            ok2 = rules[i2](state, false);
            if (ok2) {
              break;
            }
          }
        }
        if (ok2) {
          if (state.pos >= end) {
            break;
          }
          continue;
        }
        state.pending += state.src[state.pos++];
      }
      if (state.pending) {
        state.pushPending();
      }
    };
    ParserInline.prototype.parse = function(str2, md, env2, outTokens) {
      var i2, rules, len;
      var state = new this.State(str2, md, env2, outTokens);
      this.tokenize(state);
      rules = this.ruler2.getRules("");
      len = rules.length;
      for (i2 = 0; i2 < len; i2++) {
        rules[i2](state);
      }
    };
    ParserInline.prototype.State = require_state_inline();
    module2.exports = ParserInline;
  }
});

// node_modules/.pnpm/linkify-it@4.0.1/node_modules/linkify-it/lib/re.js
var require_re = __commonJS({
  "node_modules/.pnpm/linkify-it@4.0.1/node_modules/linkify-it/lib/re.js"(exports3, module2) {
    "use strict";
    module2.exports = function(opts) {
      var re = {};
      opts = opts || {};
      re.src_Any = require_regex2().source;
      re.src_Cc = require_regex3().source;
      re.src_Z = require_regex5().source;
      re.src_P = require_regex().source;
      re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join("|");
      re.src_ZCc = [re.src_Z, re.src_Cc].join("|");
      var text_separators = "[><｜]";
      re.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re.src_ZPCc + ")" + re.src_Any + ")";
      re.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
      re.src_auth = "(?:(?:(?!" + re.src_ZCc + "|[@/\\[\\]()]).)+@)?";
      re.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
      re.src_host_terminator = "(?=$|" + text_separators + "|" + re.src_ZPCc + ")(?!" + (opts["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + re.src_ZPCc + "))";
      re.src_path = "(?:[/?#](?:(?!" + re.src_ZCc + "|" + text_separators + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + re.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + re.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + re.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + re.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + re.src_ZCc + "|[']).)+\\'|\\'(?=" + re.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + re.src_ZCc + "|[.]|$)|" + (opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + re.src_ZCc + "|$)|;(?!" + re.src_ZCc + "|$)|\\!+(?!" + re.src_ZCc + "|[!]|$)|\\?(?!" + re.src_ZCc + "|[?]|$))+|\\/)?";
      re.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
      re.src_xn = "xn--[a-z0-9\\-]{1,59}";
      re.src_domain_root = // Allow letters & digits (http://test1)
      "(?:" + re.src_xn + "|" + re.src_pseudo_letter + "{1,63})";
      re.src_domain = "(?:" + re.src_xn + "|(?:" + re.src_pseudo_letter + ")|(?:" + re.src_pseudo_letter + "(?:-|" + re.src_pseudo_letter + "){0,61}" + re.src_pseudo_letter + "))";
      re.src_host = "(?:(?:(?:(?:" + re.src_domain + ")\\.)*" + re.src_domain + "))";
      re.tpl_host_fuzzy = "(?:" + re.src_ip4 + "|(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%)))";
      re.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%))";
      re.src_host_strict = re.src_host + re.src_host_terminator;
      re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;
      re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;
      re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;
      re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;
      re.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re.src_ZPCc + "|>|$))";
      re.tpl_email_fuzzy = "(^|" + text_separators + '|"|\\(|' + re.src_ZCc + ")(" + re.src_email_name + "@" + re.tpl_host_fuzzy_strict + ")";
      re.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
      // but can start with > (markdown blockquote)
      "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + re.src_ZPCc + "))((?![$+<=>^`|｜])" + re.tpl_host_port_fuzzy_strict + re.src_path + ")";
      re.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
      // but can start with > (markdown blockquote)
      "(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|" + re.src_ZPCc + "))((?![$+<=>^`|｜])" + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ")";
      return re;
    };
  }
});

// node_modules/.pnpm/linkify-it@4.0.1/node_modules/linkify-it/index.js
var require_linkify_it = __commonJS({
  "node_modules/.pnpm/linkify-it@4.0.1/node_modules/linkify-it/index.js"(exports3, module2) {
    "use strict";
    function assign(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      sources.forEach(function(source) {
        if (!source) {
          return;
        }
        Object.keys(source).forEach(function(key) {
          obj[key] = source[key];
        });
      });
      return obj;
    }
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isString3(obj) {
      return _class(obj) === "[object String]";
    }
    function isObject2(obj) {
      return _class(obj) === "[object Object]";
    }
    function isRegExp(obj) {
      return _class(obj) === "[object RegExp]";
    }
    function isFunction3(obj) {
      return _class(obj) === "[object Function]";
    }
    function escapeRE(str2) {
      return str2.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
    }
    var defaultOptions2 = {
      fuzzyLink: true,
      fuzzyEmail: true,
      fuzzyIP: false
    };
    function isOptionsObj(obj) {
      return Object.keys(obj || {}).reduce(function(acc, k) {
        return acc || defaultOptions2.hasOwnProperty(k);
      }, false);
    }
    var defaultSchemas = {
      "http:": {
        validate: function(text, pos, self2) {
          var tail = text.slice(pos);
          if (!self2.re.http) {
            self2.re.http = new RegExp(
              "^\\/\\/" + self2.re.src_auth + self2.re.src_host_port_strict + self2.re.src_path,
              "i"
            );
          }
          if (self2.re.http.test(tail)) {
            return tail.match(self2.re.http)[0].length;
          }
          return 0;
        }
      },
      "https:": "http:",
      "ftp:": "http:",
      "//": {
        validate: function(text, pos, self2) {
          var tail = text.slice(pos);
          if (!self2.re.no_http) {
            self2.re.no_http = new RegExp(
              "^" + self2.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
              // with code comments
              "(?:localhost|(?:(?:" + self2.re.src_domain + ")\\.)+" + self2.re.src_domain_root + ")" + self2.re.src_port + self2.re.src_host_terminator + self2.re.src_path,
              "i"
            );
          }
          if (self2.re.no_http.test(tail)) {
            if (pos >= 3 && text[pos - 3] === ":") {
              return 0;
            }
            if (pos >= 3 && text[pos - 3] === "/") {
              return 0;
            }
            return tail.match(self2.re.no_http)[0].length;
          }
          return 0;
        }
      },
      "mailto:": {
        validate: function(text, pos, self2) {
          var tail = text.slice(pos);
          if (!self2.re.mailto) {
            self2.re.mailto = new RegExp(
              "^" + self2.re.src_email_name + "@" + self2.re.src_host_strict,
              "i"
            );
          }
          if (self2.re.mailto.test(tail)) {
            return tail.match(self2.re.mailto)[0].length;
          }
          return 0;
        }
      }
    };
    var tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
    var tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф".split("|");
    function resetScanCache(self2) {
      self2.__index__ = -1;
      self2.__text_cache__ = "";
    }
    function createValidator(re) {
      return function(text, pos) {
        var tail = text.slice(pos);
        if (re.test(tail)) {
          return tail.match(re)[0].length;
        }
        return 0;
      };
    }
    function createNormalizer() {
      return function(match, self2) {
        self2.normalize(match);
      };
    }
    function compile3(self2) {
      var re = self2.re = require_re()(self2.__opts__);
      var tlds = self2.__tlds__.slice();
      self2.onCompile();
      if (!self2.__tlds_replaced__) {
        tlds.push(tlds_2ch_src_re);
      }
      tlds.push(re.src_xn);
      re.src_tlds = tlds.join("|");
      function untpl(tpl) {
        return tpl.replace("%TLDS%", re.src_tlds);
      }
      re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), "i");
      re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), "i");
      re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), "i");
      re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), "i");
      var aliases = [];
      self2.__compiled__ = {};
      function schemaError(name2, val) {
        throw new Error('(LinkifyIt) Invalid schema "' + name2 + '": ' + val);
      }
      Object.keys(self2.__schemas__).forEach(function(name2) {
        var val = self2.__schemas__[name2];
        if (val === null) {
          return;
        }
        var compiled = { validate: null, link: null };
        self2.__compiled__[name2] = compiled;
        if (isObject2(val)) {
          if (isRegExp(val.validate)) {
            compiled.validate = createValidator(val.validate);
          } else if (isFunction3(val.validate)) {
            compiled.validate = val.validate;
          } else {
            schemaError(name2, val);
          }
          if (isFunction3(val.normalize)) {
            compiled.normalize = val.normalize;
          } else if (!val.normalize) {
            compiled.normalize = createNormalizer();
          } else {
            schemaError(name2, val);
          }
          return;
        }
        if (isString3(val)) {
          aliases.push(name2);
          return;
        }
        schemaError(name2, val);
      });
      aliases.forEach(function(alias2) {
        if (!self2.__compiled__[self2.__schemas__[alias2]]) {
          return;
        }
        self2.__compiled__[alias2].validate = self2.__compiled__[self2.__schemas__[alias2]].validate;
        self2.__compiled__[alias2].normalize = self2.__compiled__[self2.__schemas__[alias2]].normalize;
      });
      self2.__compiled__[""] = { validate: null, normalize: createNormalizer() };
      var slist = Object.keys(self2.__compiled__).filter(function(name2) {
        return name2.length > 0 && self2.__compiled__[name2];
      }).map(escapeRE).join("|");
      self2.re.schema_test = RegExp("(^|(?!_)(?:[><｜]|" + re.src_ZPCc + "))(" + slist + ")", "i");
      self2.re.schema_search = RegExp("(^|(?!_)(?:[><｜]|" + re.src_ZPCc + "))(" + slist + ")", "ig");
      self2.re.schema_at_start = RegExp("^" + self2.re.schema_search.source, "i");
      self2.re.pretest = RegExp(
        "(" + self2.re.schema_test.source + ")|(" + self2.re.host_fuzzy_test.source + ")|@",
        "i"
      );
      resetScanCache(self2);
    }
    function Match(self2, shift) {
      var start = self2.__index__, end = self2.__last_index__, text = self2.__text_cache__.slice(start, end);
      this.schema = self2.__schema__.toLowerCase();
      this.index = start + shift;
      this.lastIndex = end + shift;
      this.raw = text;
      this.text = text;
      this.url = text;
    }
    function createMatch(self2, shift) {
      var match = new Match(self2, shift);
      self2.__compiled__[match.schema].normalize(match, self2);
      return match;
    }
    function LinkifyIt(schemas3, options3) {
      if (!(this instanceof LinkifyIt)) {
        return new LinkifyIt(schemas3, options3);
      }
      if (!options3) {
        if (isOptionsObj(schemas3)) {
          options3 = schemas3;
          schemas3 = {};
        }
      }
      this.__opts__ = assign({}, defaultOptions2, options3);
      this.__index__ = -1;
      this.__last_index__ = -1;
      this.__schema__ = "";
      this.__text_cache__ = "";
      this.__schemas__ = assign({}, defaultSchemas, schemas3);
      this.__compiled__ = {};
      this.__tlds__ = tlds_default;
      this.__tlds_replaced__ = false;
      this.re = {};
      compile3(this);
    }
    LinkifyIt.prototype.add = function add(schema5, definition) {
      this.__schemas__[schema5] = definition;
      compile3(this);
      return this;
    };
    LinkifyIt.prototype.set = function set3(options3) {
      this.__opts__ = assign(this.__opts__, options3);
      return this;
    };
    LinkifyIt.prototype.test = function test(text) {
      this.__text_cache__ = text;
      this.__index__ = -1;
      if (!text.length) {
        return false;
      }
      var m, ml, me, len, shift, next, re, tld_pos, at_pos;
      if (this.re.schema_test.test(text)) {
        re = this.re.schema_search;
        re.lastIndex = 0;
        while ((m = re.exec(text)) !== null) {
          len = this.testSchemaAt(text, m[2], re.lastIndex);
          if (len) {
            this.__schema__ = m[2];
            this.__index__ = m.index + m[1].length;
            this.__last_index__ = m.index + m[0].length + len;
            break;
          }
        }
      }
      if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
        tld_pos = text.search(this.re.host_fuzzy_test);
        if (tld_pos >= 0) {
          if (this.__index__ < 0 || tld_pos < this.__index__) {
            if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
              shift = ml.index + ml[1].length;
              if (this.__index__ < 0 || shift < this.__index__) {
                this.__schema__ = "";
                this.__index__ = shift;
                this.__last_index__ = ml.index + ml[0].length;
              }
            }
          }
        }
      }
      if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
        at_pos = text.indexOf("@");
        if (at_pos >= 0) {
          if ((me = text.match(this.re.email_fuzzy)) !== null) {
            shift = me.index + me[1].length;
            next = me.index + me[0].length;
            if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
              this.__schema__ = "mailto:";
              this.__index__ = shift;
              this.__last_index__ = next;
            }
          }
        }
      }
      return this.__index__ >= 0;
    };
    LinkifyIt.prototype.pretest = function pretest(text) {
      return this.re.pretest.test(text);
    };
    LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema5, pos) {
      if (!this.__compiled__[schema5.toLowerCase()]) {
        return 0;
      }
      return this.__compiled__[schema5.toLowerCase()].validate(text, pos, this);
    };
    LinkifyIt.prototype.match = function match(text) {
      var shift = 0, result = [];
      if (this.__index__ >= 0 && this.__text_cache__ === text) {
        result.push(createMatch(this, shift));
        shift = this.__last_index__;
      }
      var tail = shift ? text.slice(shift) : text;
      while (this.test(tail)) {
        result.push(createMatch(this, shift));
        tail = tail.slice(this.__last_index__);
        shift += this.__last_index__;
      }
      if (result.length) {
        return result;
      }
      return null;
    };
    LinkifyIt.prototype.matchAtStart = function matchAtStart(text) {
      this.__text_cache__ = text;
      this.__index__ = -1;
      if (!text.length)
        return null;
      var m = this.re.schema_at_start.exec(text);
      if (!m)
        return null;
      var len = this.testSchemaAt(text, m[2], m[0].length);
      if (!len)
        return null;
      this.__schema__ = m[2];
      this.__index__ = m.index + m[1].length;
      this.__last_index__ = m.index + m[0].length + len;
      return createMatch(this, 0);
    };
    LinkifyIt.prototype.tlds = function tlds(list, keepOld) {
      list = Array.isArray(list) ? list : [list];
      if (!keepOld) {
        this.__tlds__ = list.slice();
        this.__tlds_replaced__ = true;
        compile3(this);
        return this;
      }
      this.__tlds__ = this.__tlds__.concat(list).sort().filter(function(el, idx, arr) {
        return el !== arr[idx - 1];
      }).reverse();
      compile3(this);
      return this;
    };
    LinkifyIt.prototype.normalize = function normalize2(match) {
      if (!match.schema) {
        match.url = "http://" + match.url;
      }
      if (match.schema === "mailto:" && !/^mailto:/i.test(match.url)) {
        match.url = "mailto:" + match.url;
      }
    };
    LinkifyIt.prototype.onCompile = function onCompile() {
    };
    module2.exports = LinkifyIt;
  }
});

// browser-external:punycode
var require_punycode = __commonJS({
  "browser-external:punycode"(exports3, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "punycode" has been externalized for browser compatibility. Cannot access "punycode.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/presets/default.js
var require_default = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/presets/default.js"(exports3, module2) {
    "use strict";
    module2.exports = {
      options: {
        html: false,
        // Enable HTML tags in source
        xhtmlOut: false,
        // Use '/' to close single tags (<br />)
        breaks: false,
        // Convert '\n' in paragraphs into <br>
        langPrefix: "language-",
        // CSS language prefix for fenced blocks
        linkify: false,
        // autoconvert URL-like texts to links
        // Enable some language-neutral replacements + quotes beautification
        typographer: false,
        // Double + single quotes replacement pairs, when typographer enabled,
        // and smartquotes on. Could be either a String or an Array.
        //
        // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
        // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
        quotes: "“”‘’",
        /* “”‘’ */
        // Highlighter function. Should return escaped HTML,
        // or '' if the source string is not changed and should be escaped externaly.
        // If result starts with <pre... internal wrapper is skipped.
        //
        // function (/*str, lang*/) { return ''; }
        //
        highlight: null,
        maxNesting: 100
        // Internal protection, recursion limit
      },
      components: {
        core: {},
        block: {},
        inline: {}
      }
    };
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/presets/zero.js
var require_zero = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/presets/zero.js"(exports3, module2) {
    "use strict";
    module2.exports = {
      options: {
        html: false,
        // Enable HTML tags in source
        xhtmlOut: false,
        // Use '/' to close single tags (<br />)
        breaks: false,
        // Convert '\n' in paragraphs into <br>
        langPrefix: "language-",
        // CSS language prefix for fenced blocks
        linkify: false,
        // autoconvert URL-like texts to links
        // Enable some language-neutral replacements + quotes beautification
        typographer: false,
        // Double + single quotes replacement pairs, when typographer enabled,
        // and smartquotes on. Could be either a String or an Array.
        //
        // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
        // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
        quotes: "“”‘’",
        /* “”‘’ */
        // Highlighter function. Should return escaped HTML,
        // or '' if the source string is not changed and should be escaped externaly.
        // If result starts with <pre... internal wrapper is skipped.
        //
        // function (/*str, lang*/) { return ''; }
        //
        highlight: null,
        maxNesting: 20
        // Internal protection, recursion limit
      },
      components: {
        core: {
          rules: [
            "normalize",
            "block",
            "inline",
            "text_join"
          ]
        },
        block: {
          rules: [
            "paragraph"
          ]
        },
        inline: {
          rules: [
            "text"
          ],
          rules2: [
            "balance_pairs",
            "fragments_join"
          ]
        }
      }
    };
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/presets/commonmark.js
var require_commonmark = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/presets/commonmark.js"(exports3, module2) {
    "use strict";
    module2.exports = {
      options: {
        html: true,
        // Enable HTML tags in source
        xhtmlOut: true,
        // Use '/' to close single tags (<br />)
        breaks: false,
        // Convert '\n' in paragraphs into <br>
        langPrefix: "language-",
        // CSS language prefix for fenced blocks
        linkify: false,
        // autoconvert URL-like texts to links
        // Enable some language-neutral replacements + quotes beautification
        typographer: false,
        // Double + single quotes replacement pairs, when typographer enabled,
        // and smartquotes on. Could be either a String or an Array.
        //
        // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
        // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
        quotes: "“”‘’",
        /* “”‘’ */
        // Highlighter function. Should return escaped HTML,
        // or '' if the source string is not changed and should be escaped externaly.
        // If result starts with <pre... internal wrapper is skipped.
        //
        // function (/*str, lang*/) { return ''; }
        //
        highlight: null,
        maxNesting: 20
        // Internal protection, recursion limit
      },
      components: {
        core: {
          rules: [
            "normalize",
            "block",
            "inline",
            "text_join"
          ]
        },
        block: {
          rules: [
            "blockquote",
            "code",
            "fence",
            "heading",
            "hr",
            "html_block",
            "lheading",
            "list",
            "reference",
            "paragraph"
          ]
        },
        inline: {
          rules: [
            "autolink",
            "backticks",
            "emphasis",
            "entity",
            "escape",
            "html_inline",
            "image",
            "link",
            "newline",
            "text"
          ],
          rules2: [
            "balance_pairs",
            "emphasis",
            "fragments_join"
          ]
        }
      }
    };
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/lib/index.js"(exports3, module2) {
    "use strict";
    var utils2 = require_utils8();
    var helpers = require_helpers();
    var Renderer = require_renderer();
    var ParserCore = require_parser_core();
    var ParserBlock = require_parser_block();
    var ParserInline = require_parser_inline();
    var LinkifyIt = require_linkify_it();
    var mdurl = require_mdurl();
    var punycode = require_punycode();
    var config2 = {
      default: require_default(),
      zero: require_zero(),
      commonmark: require_commonmark()
    };
    var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
    var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
    function validateLink(url2) {
      var str2 = url2.trim().toLowerCase();
      return BAD_PROTO_RE.test(str2) ? GOOD_DATA_RE.test(str2) ? true : false : true;
    }
    var RECODE_HOSTNAME_FOR = ["http:", "https:", "mailto:"];
    function normalizeLink(url2) {
      var parsed = mdurl.parse(url2, true);
      if (parsed.hostname) {
        if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
          try {
            parsed.hostname = punycode.toASCII(parsed.hostname);
          } catch (er) {
          }
        }
      }
      return mdurl.encode(mdurl.format(parsed));
    }
    function normalizeLinkText(url2) {
      var parsed = mdurl.parse(url2, true);
      if (parsed.hostname) {
        if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
          try {
            parsed.hostname = punycode.toUnicode(parsed.hostname);
          } catch (er) {
          }
        }
      }
      return mdurl.decode(mdurl.format(parsed), mdurl.decode.defaultChars + "%");
    }
    function MarkdownIt2(presetName, options3) {
      if (!(this instanceof MarkdownIt2)) {
        return new MarkdownIt2(presetName, options3);
      }
      if (!options3) {
        if (!utils2.isString(presetName)) {
          options3 = presetName || {};
          presetName = "default";
        }
      }
      this.inline = new ParserInline();
      this.block = new ParserBlock();
      this.core = new ParserCore();
      this.renderer = new Renderer();
      this.linkify = new LinkifyIt();
      this.validateLink = validateLink;
      this.normalizeLink = normalizeLink;
      this.normalizeLinkText = normalizeLinkText;
      this.utils = utils2;
      this.helpers = utils2.assign({}, helpers);
      this.options = {};
      this.configure(presetName);
      if (options3) {
        this.set(options3);
      }
    }
    MarkdownIt2.prototype.set = function(options3) {
      utils2.assign(this.options, options3);
      return this;
    };
    MarkdownIt2.prototype.configure = function(presets) {
      var self2 = this, presetName;
      if (utils2.isString(presets)) {
        presetName = presets;
        presets = config2[presetName];
        if (!presets) {
          throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
        }
      }
      if (!presets) {
        throw new Error("Wrong `markdown-it` preset, can't be empty");
      }
      if (presets.options) {
        self2.set(presets.options);
      }
      if (presets.components) {
        Object.keys(presets.components).forEach(function(name2) {
          if (presets.components[name2].rules) {
            self2[name2].ruler.enableOnly(presets.components[name2].rules);
          }
          if (presets.components[name2].rules2) {
            self2[name2].ruler2.enableOnly(presets.components[name2].rules2);
          }
        });
      }
      return this;
    };
    MarkdownIt2.prototype.enable = function(list, ignoreInvalid) {
      var result = [];
      if (!Array.isArray(list)) {
        list = [list];
      }
      ["core", "block", "inline"].forEach(function(chain) {
        result = result.concat(this[chain].ruler.enable(list, true));
      }, this);
      result = result.concat(this.inline.ruler2.enable(list, true));
      var missed = list.filter(function(name2) {
        return result.indexOf(name2) < 0;
      });
      if (missed.length && !ignoreInvalid) {
        throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed);
      }
      return this;
    };
    MarkdownIt2.prototype.disable = function(list, ignoreInvalid) {
      var result = [];
      if (!Array.isArray(list)) {
        list = [list];
      }
      ["core", "block", "inline"].forEach(function(chain) {
        result = result.concat(this[chain].ruler.disable(list, true));
      }, this);
      result = result.concat(this.inline.ruler2.disable(list, true));
      var missed = list.filter(function(name2) {
        return result.indexOf(name2) < 0;
      });
      if (missed.length && !ignoreInvalid) {
        throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed);
      }
      return this;
    };
    MarkdownIt2.prototype.use = function(plugin) {
      var args = [this].concat(Array.prototype.slice.call(arguments, 1));
      plugin.apply(plugin, args);
      return this;
    };
    MarkdownIt2.prototype.parse = function(src3, env2) {
      if (typeof src3 !== "string") {
        throw new Error("Input data should be a String");
      }
      var state = new this.core.State(src3, this, env2);
      this.core.process(state);
      return state.tokens;
    };
    MarkdownIt2.prototype.render = function(src3, env2) {
      env2 = env2 || {};
      return this.renderer.render(this.parse(src3, env2), this.options, env2);
    };
    MarkdownIt2.prototype.parseInline = function(src3, env2) {
      var state = new this.core.State(src3, this, env2);
      state.inlineMode = true;
      this.core.process(state);
      return state.tokens;
    };
    MarkdownIt2.prototype.renderInline = function(src3, env2) {
      env2 = env2 || {};
      return this.renderer.render(this.parseInline(src3, env2), this.options, env2);
    };
    module2.exports = MarkdownIt2;
  }
});

// node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/index.js
var require_markdown_it = __commonJS({
  "node_modules/.pnpm/markdown-it@13.0.1/node_modules/markdown-it/index.js"(exports3, module2) {
    "use strict";
    module2.exports = require_lib4();
  }
});

// node_modules/.pnpm/kind-of@6.0.3/node_modules/kind-of/index.js
var require_kind_of = __commonJS({
  "node_modules/.pnpm/kind-of@6.0.3/node_modules/kind-of/index.js"(exports3, module2) {
    var toString2 = Object.prototype.toString;
    module2.exports = function kindOf(val) {
      if (val === void 0)
        return "undefined";
      if (val === null)
        return "null";
      var type = typeof val;
      if (type === "boolean")
        return "boolean";
      if (type === "string")
        return "string";
      if (type === "number")
        return "number";
      if (type === "symbol")
        return "symbol";
      if (type === "function") {
        return isGeneratorFn(val) ? "generatorfunction" : "function";
      }
      if (isArray2(val))
        return "array";
      if (isBuffer(val))
        return "buffer";
      if (isArguments(val))
        return "arguments";
      if (isDate(val))
        return "date";
      if (isError(val))
        return "error";
      if (isRegexp(val))
        return "regexp";
      switch (ctorName(val)) {
        case "Symbol":
          return "symbol";
        case "Promise":
          return "promise";
        case "WeakMap":
          return "weakmap";
        case "WeakSet":
          return "weakset";
        case "Map":
          return "map";
        case "Set":
          return "set";
        case "Int8Array":
          return "int8array";
        case "Uint8Array":
          return "uint8array";
        case "Uint8ClampedArray":
          return "uint8clampedarray";
        case "Int16Array":
          return "int16array";
        case "Uint16Array":
          return "uint16array";
        case "Int32Array":
          return "int32array";
        case "Uint32Array":
          return "uint32array";
        case "Float32Array":
          return "float32array";
        case "Float64Array":
          return "float64array";
      }
      if (isGeneratorObj(val)) {
        return "generator";
      }
      type = toString2.call(val);
      switch (type) {
        case "[object Object]":
          return "object";
        case "[object Map Iterator]":
          return "mapiterator";
        case "[object Set Iterator]":
          return "setiterator";
        case "[object String Iterator]":
          return "stringiterator";
        case "[object Array Iterator]":
          return "arrayiterator";
      }
      return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
    };
    function ctorName(val) {
      return typeof val.constructor === "function" ? val.constructor.name : null;
    }
    function isArray2(val) {
      if (Array.isArray)
        return Array.isArray(val);
      return val instanceof Array;
    }
    function isError(val) {
      return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
    }
    function isDate(val) {
      if (val instanceof Date)
        return true;
      return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
    }
    function isRegexp(val) {
      if (val instanceof RegExp)
        return true;
      return typeof val.flags === "string" && typeof val.ignoreCase === "boolean" && typeof val.multiline === "boolean" && typeof val.global === "boolean";
    }
    function isGeneratorFn(name2, val) {
      return ctorName(name2) === "GeneratorFunction";
    }
    function isGeneratorObj(val) {
      return typeof val.throw === "function" && typeof val.return === "function" && typeof val.next === "function";
    }
    function isArguments(val) {
      try {
        if (typeof val.length === "number" && typeof val.callee === "function") {
          return true;
        }
      } catch (err2) {
        if (err2.message.indexOf("callee") !== -1) {
          return true;
        }
      }
      return false;
    }
    function isBuffer(val) {
      if (val.constructor && typeof val.constructor.isBuffer === "function") {
        return val.constructor.isBuffer(val);
      }
      return false;
    }
  }
});

// node_modules/.pnpm/is-extendable@0.1.1/node_modules/is-extendable/index.js
var require_is_extendable = __commonJS({
  "node_modules/.pnpm/is-extendable@0.1.1/node_modules/is-extendable/index.js"(exports3, module2) {
    "use strict";
    module2.exports = function isExtendable(val) {
      return typeof val !== "undefined" && val !== null && (typeof val === "object" || typeof val === "function");
    };
  }
});

// node_modules/.pnpm/extend-shallow@2.0.1/node_modules/extend-shallow/index.js
var require_extend_shallow = __commonJS({
  "node_modules/.pnpm/extend-shallow@2.0.1/node_modules/extend-shallow/index.js"(exports3, module2) {
    "use strict";
    var isObject2 = require_is_extendable();
    module2.exports = function extend2(o3) {
      if (!isObject2(o3)) {
        o3 = {};
      }
      var len = arguments.length;
      for (var i2 = 1; i2 < len; i2++) {
        var obj = arguments[i2];
        if (isObject2(obj)) {
          assign(o3, obj);
        }
      }
      return o3;
    };
    function assign(a2, b) {
      for (var key in b) {
        if (hasOwn2(b, key)) {
          a2[key] = b[key];
        }
      }
    }
    function hasOwn2(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
  }
});

// node_modules/.pnpm/section-matter@1.0.0/node_modules/section-matter/index.js
var require_section_matter = __commonJS({
  "node_modules/.pnpm/section-matter@1.0.0/node_modules/section-matter/index.js"(exports3, module2) {
    "use strict";
    var typeOf = require_kind_of();
    var extend2 = require_extend_shallow();
    module2.exports = function(input, options3) {
      if (typeof options3 === "function") {
        options3 = { parse: options3 };
      }
      var file = toObject2(input);
      var defaults = { section_delimiter: "---", parse: identity };
      var opts = extend2({}, defaults, options3);
      var delim = opts.section_delimiter;
      var lines = file.content.split(/\r?\n/);
      var sections = null;
      var section = createSection();
      var content = [];
      var stack = [];
      function initSections(val) {
        file.content = val;
        sections = [];
        content = [];
      }
      function closeSection(val) {
        if (stack.length) {
          section.key = getKey(stack[0], delim);
          section.content = val;
          opts.parse(section, sections);
          sections.push(section);
          section = createSection();
          content = [];
          stack = [];
        }
      }
      for (var i2 = 0; i2 < lines.length; i2++) {
        var line = lines[i2];
        var len = stack.length;
        var ln = line.trim();
        if (isDelimiter(ln, delim)) {
          if (ln.length === 3 && i2 !== 0) {
            if (len === 0 || len === 2) {
              content.push(line);
              continue;
            }
            stack.push(ln);
            section.data = content.join("\n");
            content = [];
            continue;
          }
          if (sections === null) {
            initSections(content.join("\n"));
          }
          if (len === 2) {
            closeSection(content.join("\n"));
          }
          stack.push(ln);
          continue;
        }
        content.push(line);
      }
      if (sections === null) {
        initSections(content.join("\n"));
      } else {
        closeSection(content.join("\n"));
      }
      file.sections = sections;
      return file;
    };
    function isDelimiter(line, delim) {
      if (line.slice(0, delim.length) !== delim) {
        return false;
      }
      if (line.charAt(delim.length + 1) === delim.slice(-1)) {
        return false;
      }
      return true;
    }
    function toObject2(input) {
      if (typeOf(input) !== "object") {
        input = { content: input };
      }
      if (typeof input.content !== "string" && !isBuffer(input.content)) {
        throw new TypeError("expected a buffer or string");
      }
      input.content = input.content.toString();
      input.sections = [];
      return input;
    }
    function getKey(val, delim) {
      return val ? val.slice(delim.length).trim() : "";
    }
    function createSection() {
      return { key: "", data: "", content: "" };
    }
    function identity(val) {
      return val;
    }
    function isBuffer(val) {
      if (val && val.constructor && typeof val.constructor.isBuffer === "function") {
        return val.constructor.isBuffer(val);
      }
      return false;
    }
  }
});

// node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/common.js
var require_common4 = __commonJS({
  "node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/common.js"(exports3, module2) {
    "use strict";
    function isNothing(subject) {
      return typeof subject === "undefined" || subject === null;
    }
    function isObject2(subject) {
      return typeof subject === "object" && subject !== null;
    }
    function toArray(sequence) {
      if (Array.isArray(sequence))
        return sequence;
      else if (isNothing(sequence))
        return [];
      return [sequence];
    }
    function extend2(target, source) {
      var index2, length, key, sourceKeys;
      if (source) {
        sourceKeys = Object.keys(source);
        for (index2 = 0, length = sourceKeys.length; index2 < length; index2 += 1) {
          key = sourceKeys[index2];
          target[key] = source[key];
        }
      }
      return target;
    }
    function repeat(string3, count) {
      var result = "", cycle;
      for (cycle = 0; cycle < count; cycle += 1) {
        result += string3;
      }
      return result;
    }
    function isNegativeZero(number) {
      return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
    }
    module2.exports.isNothing = isNothing;
    module2.exports.isObject = isObject2;
    module2.exports.toArray = toArray;
    module2.exports.repeat = repeat;
    module2.exports.isNegativeZero = isNegativeZero;
    module2.exports.extend = extend2;
  }
});

// node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/exception.js
var require_exception = __commonJS({
  "node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/exception.js"(exports3, module2) {
    "use strict";
    function YAMLException(reason, mark2) {
      Error.call(this);
      this.name = "YAMLException";
      this.reason = reason;
      this.mark = mark2;
      this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : "");
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack || "";
      }
    }
    YAMLException.prototype = Object.create(Error.prototype);
    YAMLException.prototype.constructor = YAMLException;
    YAMLException.prototype.toString = function toString2(compact) {
      var result = this.name + ": ";
      result += this.reason || "(unknown reason)";
      if (!compact && this.mark) {
        result += " " + this.mark.toString();
      }
      return result;
    };
    module2.exports = YAMLException;
  }
});

// node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/mark.js
var require_mark = __commonJS({
  "node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/mark.js"(exports3, module2) {
    "use strict";
    var common3 = require_common4();
    function Mark(name2, buffer, position, line, column) {
      this.name = name2;
      this.buffer = buffer;
      this.position = position;
      this.line = line;
      this.column = column;
    }
    Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
      var head, start, tail, end, snippet;
      if (!this.buffer)
        return null;
      indent = indent || 4;
      maxLength = maxLength || 75;
      head = "";
      start = this.position;
      while (start > 0 && "\0\r\n\u2028\u2029".indexOf(this.buffer.charAt(start - 1)) === -1) {
        start -= 1;
        if (this.position - start > maxLength / 2 - 1) {
          head = " ... ";
          start += 5;
          break;
        }
      }
      tail = "";
      end = this.position;
      while (end < this.buffer.length && "\0\r\n\u2028\u2029".indexOf(this.buffer.charAt(end)) === -1) {
        end += 1;
        if (end - this.position > maxLength / 2 - 1) {
          tail = " ... ";
          end -= 5;
          break;
        }
      }
      snippet = this.buffer.slice(start, end);
      return common3.repeat(" ", indent) + head + snippet + tail + "\n" + common3.repeat(" ", indent + this.position - start + head.length) + "^";
    };
    Mark.prototype.toString = function toString2(compact) {
      var snippet, where = "";
      if (this.name) {
        where += 'in "' + this.name + '" ';
      }
      where += "at line " + (this.line + 1) + ", column " + (this.column + 1);
      if (!compact) {
        snippet = this.getSnippet();
        if (snippet) {
          where += ":\n" + snippet;
        }
      }
      return where;
    };
    module2.exports = Mark;
  }
});

// node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/type.js
var require_type = __commonJS({
  "node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/type.js"(exports3, module2) {
    "use strict";
    var YAMLException = require_exception();
    var TYPE_CONSTRUCTOR_OPTIONS = [
      "kind",
      "resolve",
      "construct",
      "instanceOf",
      "predicate",
      "represent",
      "defaultStyle",
      "styleAliases"
    ];
    var YAML_NODE_KINDS = [
      "scalar",
      "sequence",
      "mapping"
    ];
    function compileStyleAliases(map3) {
      var result = {};
      if (map3 !== null) {
        Object.keys(map3).forEach(function(style) {
          map3[style].forEach(function(alias2) {
            result[String(alias2)] = style;
          });
        });
      }
      return result;
    }
    function Type(tag, options3) {
      options3 = options3 || {};
      Object.keys(options3).forEach(function(name2) {
        if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name2) === -1) {
          throw new YAMLException('Unknown option "' + name2 + '" is met in definition of "' + tag + '" YAML type.');
        }
      });
      this.tag = tag;
      this.kind = options3["kind"] || null;
      this.resolve = options3["resolve"] || function() {
        return true;
      };
      this.construct = options3["construct"] || function(data2) {
        return data2;
      };
      this.instanceOf = options3["instanceOf"] || null;
      this.predicate = options3["predicate"] || null;
      this.represent = options3["represent"] || null;
      this.defaultStyle = options3["defaultStyle"] || null;
      this.styleAliases = compileStyleAliases(options3["styleAliases"] || null);
      if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
        throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
      }
    }
    module2.exports = Type;
  }
});

// node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/schema.js
var require_schema = __commonJS({
  "node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/schema.js"(exports3, module2) {
    "use strict";
    var common3 = require_common4();
    var YAMLException = require_exception();
    var Type = require_type();
    function compileList(schema5, name2, result) {
      var exclude = [];
      schema5.include.forEach(function(includedSchema) {
        result = compileList(includedSchema, name2, result);
      });
      schema5[name2].forEach(function(currentType) {
        result.forEach(function(previousType, previousIndex) {
          if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
            exclude.push(previousIndex);
          }
        });
        result.push(currentType);
      });
      return result.filter(function(type, index2) {
        return exclude.indexOf(index2) === -1;
      });
    }
    function compileMap() {
      var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {}
      }, index2, length;
      function collectType(type) {
        result[type.kind][type.tag] = result["fallback"][type.tag] = type;
      }
      for (index2 = 0, length = arguments.length; index2 < length; index2 += 1) {
        arguments[index2].forEach(collectType);
      }
      return result;
    }
    function Schema3(definition) {
      this.include = definition.include || [];
      this.implicit = definition.implicit || [];
      this.explicit = definition.explicit || [];
      this.implicit.forEach(function(type) {
        if (type.loadKind && type.loadKind !== "scalar") {
          throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
        }
      });
      this.compiledImplicit = compileList(this, "implicit", []);
      this.compiledExplicit = compileList(this, "explicit", []);
      this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
    }
    Schema3.DEFAULT = null;
    Schema3.create = function createSchema() {
      var schemas3, types2;
      switch (arguments.length) {
        case 1:
          schemas3 = Schema3.DEFAULT;
          types2 = arguments[0];
          break;
        case 2:
          schemas3 = arguments[0];
          types2 = arguments[1];
          break;
        default:
          throw new YAMLException("Wrong number of arguments for Schema.create function");
      }
      schemas3 = common3.toArray(schemas3);
      types2 = common3.toArray(types2);
      if (!schemas3.every(function(schema5) {
        return schema5 instanceof Schema3;
      })) {
        throw new YAMLException("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
      }
      if (!types2.every(function(type) {
        return type instanceof Type;
      })) {
        throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      }
      return new Schema3({
        include: schemas3,
        explicit: types2
      });
    };
    module2.exports = Schema3;
  }
});

// node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/type/str.js
var require_str = __commonJS({
  "node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/type/str.js"(exports3, module2) {
    "use strict";
    var Type = require_type();
    module2.exports = new Type("tag:yaml.org,2002:str", {
      kind: "scalar",
      construct: function(data2) {
        return data2 !== null ? data2 : "";
      }
    });
  }
});

// node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/type/seq.js
var require_seq = __commonJS({
  "node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/type/seq.js"(exports3, module2) {
    "use strict";
    var Type = require_type();
    module2.exports = new Type("tag:yaml.org,2002:seq", {
      kind: "sequence",
      construct: function(data2) {
        return data2 !== null ? data2 : [];
      }
    });
  }
});

// node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/type/map.js
var require_map = __commonJS({
  "node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/type/map.js"(exports3, module2) {
    "use strict";
    var Type = require_type();
    module2.exports = new Type("tag:yaml.org,2002:map", {
      kind: "mapping",
      construct: function(data2) {
        return data2 !== null ? data2 : {};
      }
    });
  }
});

// node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/schema/failsafe.js
var require_failsafe = __commonJS({
  "node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/schema/failsafe.js"(exports3, module2) {
    "use strict";
    var Schema3 = require_schema();
    module2.exports = new Schema3({
      explicit: [
        require_str(),
        require_seq(),
        require_map()
      ]
    });
  }
});

// node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/type/null.js
var require_null = __commonJS({
  "node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/type/null.js"(exports3, module2) {
    "use strict";
    var Type = require_type();
    function resolveYamlNull(data2) {
      if (data2 === null)
        return true;
      var max = data2.length;
      return max === 1 && data2 === "~" || max === 4 && (data2 === "null" || data2 === "Null" || data2 === "NULL");
    }
    function constructYamlNull() {
      return null;
    }
    function isNull(object) {
      return object === null;
    }
    module2.exports = new Type("tag:yaml.org,2002:null", {
      kind: "scalar",
      resolve: resolveYamlNull,
      construct: constructYamlNull,
      predicate: isNull,
      represent: {
        canonical: function() {
          return "~";
        },
        lowercase: function() {
          return "null";
        },
        uppercase: function() {
          return "NULL";
        },
        camelcase: function() {
          return "Null";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/type/bool.js
var require_bool = __commonJS({
  "node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/type/bool.js"(exports3, module2) {
    "use strict";
    var Type = require_type();
    function resolveYamlBoolean(data2) {
      if (data2 === null)
        return false;
      var max = data2.length;
      return max === 4 && (data2 === "true" || data2 === "True" || data2 === "TRUE") || max === 5 && (data2 === "false" || data2 === "False" || data2 === "FALSE");
    }
    function constructYamlBoolean(data2) {
      return data2 === "true" || data2 === "True" || data2 === "TRUE";
    }
    function isBoolean(object) {
      return Object.prototype.toString.call(object) === "[object Boolean]";
    }
    module2.exports = new Type("tag:yaml.org,2002:bool", {
      kind: "scalar",
      resolve: resolveYamlBoolean,
      construct: constructYamlBoolean,
      predicate: isBoolean,
      represent: {
        lowercase: function(object) {
          return object ? "true" : "false";
        },
        uppercase: function(object) {
          return object ? "TRUE" : "FALSE";
        },
        camelcase: function(object) {
          return object ? "True" : "False";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/type/int.js
var require_int = __commonJS({
  "node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/type/int.js"(exports3, module2) {
    "use strict";
    var common3 = require_common4();
    var Type = require_type();
    function isHexCode(c2) {
      return 48 <= c2 && c2 <= 57 || 65 <= c2 && c2 <= 70 || 97 <= c2 && c2 <= 102;
    }
    function isOctCode(c2) {
      return 48 <= c2 && c2 <= 55;
    }
    function isDecCode(c2) {
      return 48 <= c2 && c2 <= 57;
    }
    function resolveYamlInteger(data2) {
      if (data2 === null)
        return false;
      var max = data2.length, index2 = 0, hasDigits = false, ch;
      if (!max)
        return false;
      ch = data2[index2];
      if (ch === "-" || ch === "+") {
        ch = data2[++index2];
      }
      if (ch === "0") {
        if (index2 + 1 === max)
          return true;
        ch = data2[++index2];
        if (ch === "b") {
          index2++;
          for (; index2 < max; index2++) {
            ch = data2[index2];
            if (ch === "_")
              continue;
            if (ch !== "0" && ch !== "1")
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        if (ch === "x") {
          index2++;
          for (; index2 < max; index2++) {
            ch = data2[index2];
            if (ch === "_")
              continue;
            if (!isHexCode(data2.charCodeAt(index2)))
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        for (; index2 < max; index2++) {
          ch = data2[index2];
          if (ch === "_")
            continue;
          if (!isOctCode(data2.charCodeAt(index2)))
            return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
      if (ch === "_")
        return false;
      for (; index2 < max; index2++) {
        ch = data2[index2];
        if (ch === "_")
          continue;
        if (ch === ":")
          break;
        if (!isDecCode(data2.charCodeAt(index2))) {
          return false;
        }
        hasDigits = true;
      }
      if (!hasDigits || ch === "_")
        return false;
      if (ch !== ":")
        return true;
      return /^(:[0-5]?[0-9])+$/.test(data2.slice(index2));
    }
    function constructYamlInteger(data2) {
      var value2 = data2, sign = 1, ch, base2, digits = [];
      if (value2.indexOf("_") !== -1) {
        value2 = value2.replace(/_/g, "");
      }
      ch = value2[0];
      if (ch === "-" || ch === "+") {
        if (ch === "-")
          sign = -1;
        value2 = value2.slice(1);
        ch = value2[0];
      }
      if (value2 === "0")
        return 0;
      if (ch === "0") {
        if (value2[1] === "b")
          return sign * parseInt(value2.slice(2), 2);
        if (value2[1] === "x")
          return sign * parseInt(value2, 16);
        return sign * parseInt(value2, 8);
      }
      if (value2.indexOf(":") !== -1) {
        value2.split(":").forEach(function(v) {
          digits.unshift(parseInt(v, 10));
        });
        value2 = 0;
        base2 = 1;
        digits.forEach(function(d2) {
          value2 += d2 * base2;
          base2 *= 60;
        });
        return sign * value2;
      }
      return sign * parseInt(value2, 10);
    }
    function isInteger(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common3.isNegativeZero(object));
    }
    module2.exports = new Type("tag:yaml.org,2002:int", {
      kind: "scalar",
      resolve: resolveYamlInteger,
      construct: constructYamlInteger,
      predicate: isInteger,
      represent: {
        binary: function(obj) {
          return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
        },
        octal: function(obj) {
          return obj >= 0 ? "0" + obj.toString(8) : "-0" + obj.toString(8).slice(1);
        },
        decimal: function(obj) {
          return obj.toString(10);
        },
        /* eslint-disable max-len */
        hexadecimal: function(obj) {
          return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
        }
      },
      defaultStyle: "decimal",
      styleAliases: {
        binary: [2, "bin"],
        octal: [8, "oct"],
        decimal: [10, "dec"],
        hexadecimal: [16, "hex"]
      }
    });
  }
});

// node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/type/float.js
var require_float = __commonJS({
  "node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/type/float.js"(exports3, module2) {
    "use strict";
    var common3 = require_common4();
    var Type = require_type();
    var YAML_FLOAT_PATTERN = new RegExp(
      // 2.5e4, 2.5 and integers
      "^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
    );
    function resolveYamlFloat(data2) {
      if (data2 === null)
        return false;
      if (!YAML_FLOAT_PATTERN.test(data2) || // Quick hack to not allow integers end with `_`
      // Probably should update regexp & check speed
      data2[data2.length - 1] === "_") {
        return false;
      }
      return true;
    }
    function constructYamlFloat(data2) {
      var value2, sign, base2, digits;
      value2 = data2.replace(/_/g, "").toLowerCase();
      sign = value2[0] === "-" ? -1 : 1;
      digits = [];
      if ("+-".indexOf(value2[0]) >= 0) {
        value2 = value2.slice(1);
      }
      if (value2 === ".inf") {
        return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
      } else if (value2 === ".nan") {
        return NaN;
      } else if (value2.indexOf(":") >= 0) {
        value2.split(":").forEach(function(v) {
          digits.unshift(parseFloat(v, 10));
        });
        value2 = 0;
        base2 = 1;
        digits.forEach(function(d2) {
          value2 += d2 * base2;
          base2 *= 60;
        });
        return sign * value2;
      }
      return sign * parseFloat(value2, 10);
    }
    var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
    function representYamlFloat(object, style) {
      var res;
      if (isNaN(object)) {
        switch (style) {
          case "lowercase":
            return ".nan";
          case "uppercase":
            return ".NAN";
          case "camelcase":
            return ".NaN";
        }
      } else if (Number.POSITIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return ".inf";
          case "uppercase":
            return ".INF";
          case "camelcase":
            return ".Inf";
        }
      } else if (Number.NEGATIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return "-.inf";
          case "uppercase":
            return "-.INF";
          case "camelcase":
            return "-.Inf";
        }
      } else if (common3.isNegativeZero(object)) {
        return "-0.0";
      }
      res = object.toString(10);
      return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
    }
    function isFloat(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common3.isNegativeZero(object));
    }
    module2.exports = new Type("tag:yaml.org,2002:float", {
      kind: "scalar",
      resolve: resolveYamlFloat,
      construct: constructYamlFloat,
      predicate: isFloat,
      represent: representYamlFloat,
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/schema/json.js
var require_json2 = __commonJS({
  "node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/schema/json.js"(exports3, module2) {
    "use strict";
    var Schema3 = require_schema();
    module2.exports = new Schema3({
      include: [
        require_failsafe()
      ],
      implicit: [
        require_null(),
        require_bool(),
        require_int(),
        require_float()
      ]
    });
  }
});

// node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/schema/core.js
var require_core = __commonJS({
  "node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/schema/core.js"(exports3, module2) {
    "use strict";
    var Schema3 = require_schema();
    module2.exports = new Schema3({
      include: [
        require_json2()
      ]
    });
  }
});

// node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/type/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/type/timestamp.js"(exports3, module2) {
    "use strict";
    var Type = require_type();
    var YAML_DATE_REGEXP = new RegExp(
      "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
    );
    var YAML_TIMESTAMP_REGEXP = new RegExp(
      "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
    );
    function resolveYamlTimestamp(data2) {
      if (data2 === null)
        return false;
      if (YAML_DATE_REGEXP.exec(data2) !== null)
        return true;
      if (YAML_TIMESTAMP_REGEXP.exec(data2) !== null)
        return true;
      return false;
    }
    function constructYamlTimestamp(data2) {
      var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
      match = YAML_DATE_REGEXP.exec(data2);
      if (match === null)
        match = YAML_TIMESTAMP_REGEXP.exec(data2);
      if (match === null)
        throw new Error("Date resolve error");
      year = +match[1];
      month = +match[2] - 1;
      day = +match[3];
      if (!match[4]) {
        return new Date(Date.UTC(year, month, day));
      }
      hour = +match[4];
      minute = +match[5];
      second = +match[6];
      if (match[7]) {
        fraction = match[7].slice(0, 3);
        while (fraction.length < 3) {
          fraction += "0";
        }
        fraction = +fraction;
      }
      if (match[9]) {
        tz_hour = +match[10];
        tz_minute = +(match[11] || 0);
        delta = (tz_hour * 60 + tz_minute) * 6e4;
        if (match[9] === "-")
          delta = -delta;
      }
      date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
      if (delta)
        date.setTime(date.getTime() - delta);
      return date;
    }
    function representYamlTimestamp(object) {
      return object.toISOString();
    }
    module2.exports = new Type("tag:yaml.org,2002:timestamp", {
      kind: "scalar",
      resolve: resolveYamlTimestamp,
      construct: constructYamlTimestamp,
      instanceOf: Date,
      represent: representYamlTimestamp
    });
  }
});

// node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/type/merge.js
var require_merge = __commonJS({
  "node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/type/merge.js"(exports3, module2) {
    "use strict";
    var Type = require_type();
    function resolveYamlMerge(data2) {
      return data2 === "<<" || data2 === null;
    }
    module2.exports = new Type("tag:yaml.org,2002:merge", {
      kind: "scalar",
      resolve: resolveYamlMerge
    });
  }
});

// node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/type/binary.js
var require_binary = __commonJS({
  "node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/type/binary.js"(exports3, module2) {
    "use strict";
    var NodeBuffer;
    try {
      _require3 = __require;
      NodeBuffer = _require3("buffer").Buffer;
    } catch (__) {
    }
    var _require3;
    var Type = require_type();
    var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
    function resolveYamlBinary(data2) {
      if (data2 === null)
        return false;
      var code, idx, bitlen = 0, max = data2.length, map3 = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        code = map3.indexOf(data2.charAt(idx));
        if (code > 64)
          continue;
        if (code < 0)
          return false;
        bitlen += 6;
      }
      return bitlen % 8 === 0;
    }
    function constructYamlBinary(data2) {
      var idx, tailbits, input = data2.replace(/[\r\n=]/g, ""), max = input.length, map3 = BASE64_MAP, bits = 0, result = [];
      for (idx = 0; idx < max; idx++) {
        if (idx % 4 === 0 && idx) {
          result.push(bits >> 16 & 255);
          result.push(bits >> 8 & 255);
          result.push(bits & 255);
        }
        bits = bits << 6 | map3.indexOf(input.charAt(idx));
      }
      tailbits = max % 4 * 6;
      if (tailbits === 0) {
        result.push(bits >> 16 & 255);
        result.push(bits >> 8 & 255);
        result.push(bits & 255);
      } else if (tailbits === 18) {
        result.push(bits >> 10 & 255);
        result.push(bits >> 2 & 255);
      } else if (tailbits === 12) {
        result.push(bits >> 4 & 255);
      }
      if (NodeBuffer) {
        return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
      }
      return result;
    }
    function representYamlBinary(object) {
      var result = "", bits = 0, idx, tail, max = object.length, map3 = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        if (idx % 3 === 0 && idx) {
          result += map3[bits >> 18 & 63];
          result += map3[bits >> 12 & 63];
          result += map3[bits >> 6 & 63];
          result += map3[bits & 63];
        }
        bits = (bits << 8) + object[idx];
      }
      tail = max % 3;
      if (tail === 0) {
        result += map3[bits >> 18 & 63];
        result += map3[bits >> 12 & 63];
        result += map3[bits >> 6 & 63];
        result += map3[bits & 63];
      } else if (tail === 2) {
        result += map3[bits >> 10 & 63];
        result += map3[bits >> 4 & 63];
        result += map3[bits << 2 & 63];
        result += map3[64];
      } else if (tail === 1) {
        result += map3[bits >> 2 & 63];
        result += map3[bits << 4 & 63];
        result += map3[64];
        result += map3[64];
      }
      return result;
    }
    function isBinary(object) {
      return NodeBuffer && NodeBuffer.isBuffer(object);
    }
    module2.exports = new Type("tag:yaml.org,2002:binary", {
      kind: "scalar",
      resolve: resolveYamlBinary,
      construct: constructYamlBinary,
      predicate: isBinary,
      represent: representYamlBinary
    });
  }
});

// node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/type/omap.js
var require_omap = __commonJS({
  "node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/type/omap.js"(exports3, module2) {
    "use strict";
    var Type = require_type();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var _toString = Object.prototype.toString;
    function resolveYamlOmap(data2) {
      if (data2 === null)
        return true;
      var objectKeys2 = [], index2, length, pair, pairKey, pairHasKey, object = data2;
      for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
        pair = object[index2];
        pairHasKey = false;
        if (_toString.call(pair) !== "[object Object]")
          return false;
        for (pairKey in pair) {
          if (_hasOwnProperty.call(pair, pairKey)) {
            if (!pairHasKey)
              pairHasKey = true;
            else
              return false;
          }
        }
        if (!pairHasKey)
          return false;
        if (objectKeys2.indexOf(pairKey) === -1)
          objectKeys2.push(pairKey);
        else
          return false;
      }
      return true;
    }
    function constructYamlOmap(data2) {
      return data2 !== null ? data2 : [];
    }
    module2.exports = new Type("tag:yaml.org,2002:omap", {
      kind: "sequence",
      resolve: resolveYamlOmap,
      construct: constructYamlOmap
    });
  }
});

// node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/type/pairs.js
var require_pairs = __commonJS({
  "node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/type/pairs.js"(exports3, module2) {
    "use strict";
    var Type = require_type();
    var _toString = Object.prototype.toString;
    function resolveYamlPairs(data2) {
      if (data2 === null)
        return true;
      var index2, length, pair, keys, result, object = data2;
      result = new Array(object.length);
      for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
        pair = object[index2];
        if (_toString.call(pair) !== "[object Object]")
          return false;
        keys = Object.keys(pair);
        if (keys.length !== 1)
          return false;
        result[index2] = [keys[0], pair[keys[0]]];
      }
      return true;
    }
    function constructYamlPairs(data2) {
      if (data2 === null)
        return [];
      var index2, length, pair, keys, result, object = data2;
      result = new Array(object.length);
      for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
        pair = object[index2];
        keys = Object.keys(pair);
        result[index2] = [keys[0], pair[keys[0]]];
      }
      return result;
    }
    module2.exports = new Type("tag:yaml.org,2002:pairs", {
      kind: "sequence",
      resolve: resolveYamlPairs,
      construct: constructYamlPairs
    });
  }
});

// node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/type/set.js
var require_set = __commonJS({
  "node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/type/set.js"(exports3, module2) {
    "use strict";
    var Type = require_type();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    function resolveYamlSet(data2) {
      if (data2 === null)
        return true;
      var key, object = data2;
      for (key in object) {
        if (_hasOwnProperty.call(object, key)) {
          if (object[key] !== null)
            return false;
        }
      }
      return true;
    }
    function constructYamlSet(data2) {
      return data2 !== null ? data2 : {};
    }
    module2.exports = new Type("tag:yaml.org,2002:set", {
      kind: "mapping",
      resolve: resolveYamlSet,
      construct: constructYamlSet
    });
  }
});

// node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/schema/default_safe.js
var require_default_safe = __commonJS({
  "node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/schema/default_safe.js"(exports3, module2) {
    "use strict";
    var Schema3 = require_schema();
    module2.exports = new Schema3({
      include: [
        require_core()
      ],
      implicit: [
        require_timestamp(),
        require_merge()
      ],
      explicit: [
        require_binary(),
        require_omap(),
        require_pairs(),
        require_set()
      ]
    });
  }
});

// node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/type/js/undefined.js
var require_undefined = __commonJS({
  "node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/type/js/undefined.js"(exports3, module2) {
    "use strict";
    var Type = require_type();
    function resolveJavascriptUndefined() {
      return true;
    }
    function constructJavascriptUndefined() {
      return void 0;
    }
    function representJavascriptUndefined() {
      return "";
    }
    function isUndefined(object) {
      return typeof object === "undefined";
    }
    module2.exports = new Type("tag:yaml.org,2002:js/undefined", {
      kind: "scalar",
      resolve: resolveJavascriptUndefined,
      construct: constructJavascriptUndefined,
      predicate: isUndefined,
      represent: representJavascriptUndefined
    });
  }
});

// node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/type/js/regexp.js
var require_regexp = __commonJS({
  "node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/type/js/regexp.js"(exports3, module2) {
    "use strict";
    var Type = require_type();
    function resolveJavascriptRegExp(data2) {
      if (data2 === null)
        return false;
      if (data2.length === 0)
        return false;
      var regexp = data2, tail = /\/([gim]*)$/.exec(data2), modifiers = "";
      if (regexp[0] === "/") {
        if (tail)
          modifiers = tail[1];
        if (modifiers.length > 3)
          return false;
        if (regexp[regexp.length - modifiers.length - 1] !== "/")
          return false;
      }
      return true;
    }
    function constructJavascriptRegExp(data2) {
      var regexp = data2, tail = /\/([gim]*)$/.exec(data2), modifiers = "";
      if (regexp[0] === "/") {
        if (tail)
          modifiers = tail[1];
        regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
      }
      return new RegExp(regexp, modifiers);
    }
    function representJavascriptRegExp(object) {
      var result = "/" + object.source + "/";
      if (object.global)
        result += "g";
      if (object.multiline)
        result += "m";
      if (object.ignoreCase)
        result += "i";
      return result;
    }
    function isRegExp(object) {
      return Object.prototype.toString.call(object) === "[object RegExp]";
    }
    module2.exports = new Type("tag:yaml.org,2002:js/regexp", {
      kind: "scalar",
      resolve: resolveJavascriptRegExp,
      construct: constructJavascriptRegExp,
      predicate: isRegExp,
      represent: representJavascriptRegExp
    });
  }
});

// node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/type/js/function.js
var require_function = __commonJS({
  "node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/type/js/function.js"(exports3, module2) {
    "use strict";
    var esprima;
    try {
      _require3 = __require;
      esprima = _require3("esprima");
    } catch (_) {
      if (typeof window !== "undefined")
        esprima = window.esprima;
    }
    var _require3;
    var Type = require_type();
    function resolveJavascriptFunction(data2) {
      if (data2 === null)
        return false;
      try {
        var source = "(" + data2 + ")", ast = esprima.parse(source, { range: true });
        if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") {
          return false;
        }
        return true;
      } catch (err2) {
        return false;
      }
    }
    function constructJavascriptFunction(data2) {
      var source = "(" + data2 + ")", ast = esprima.parse(source, { range: true }), params = [], body;
      if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") {
        throw new Error("Failed to resolve function");
      }
      ast.body[0].expression.params.forEach(function(param) {
        params.push(param.name);
      });
      body = ast.body[0].expression.body.range;
      if (ast.body[0].expression.body.type === "BlockStatement") {
        return new Function(params, source.slice(body[0] + 1, body[1] - 1));
      }
      return new Function(params, "return " + source.slice(body[0], body[1]));
    }
    function representJavascriptFunction(object) {
      return object.toString();
    }
    function isFunction3(object) {
      return Object.prototype.toString.call(object) === "[object Function]";
    }
    module2.exports = new Type("tag:yaml.org,2002:js/function", {
      kind: "scalar",
      resolve: resolveJavascriptFunction,
      construct: constructJavascriptFunction,
      predicate: isFunction3,
      represent: representJavascriptFunction
    });
  }
});

// node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/schema/default_full.js
var require_default_full = __commonJS({
  "node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/schema/default_full.js"(exports3, module2) {
    "use strict";
    var Schema3 = require_schema();
    module2.exports = Schema3.DEFAULT = new Schema3({
      include: [
        require_default_safe()
      ],
      explicit: [
        require_undefined(),
        require_regexp(),
        require_function()
      ]
    });
  }
});

// node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/loader.js
var require_loader = __commonJS({
  "node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/loader.js"(exports3, module2) {
    "use strict";
    var common3 = require_common4();
    var YAMLException = require_exception();
    var Mark = require_mark();
    var DEFAULT_SAFE_SCHEMA = require_default_safe();
    var DEFAULT_FULL_SCHEMA = require_default_full();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CONTEXT_FLOW_IN = 1;
    var CONTEXT_FLOW_OUT = 2;
    var CONTEXT_BLOCK_IN = 3;
    var CONTEXT_BLOCK_OUT = 4;
    var CHOMPING_CLIP = 1;
    var CHOMPING_STRIP = 2;
    var CHOMPING_KEEP = 3;
    var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
    var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
    var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
    var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function is_EOL(c2) {
      return c2 === 10 || c2 === 13;
    }
    function is_WHITE_SPACE(c2) {
      return c2 === 9 || c2 === 32;
    }
    function is_WS_OR_EOL(c2) {
      return c2 === 9 || c2 === 32 || c2 === 10 || c2 === 13;
    }
    function is_FLOW_INDICATOR(c2) {
      return c2 === 44 || c2 === 91 || c2 === 93 || c2 === 123 || c2 === 125;
    }
    function fromHexCode(c2) {
      var lc;
      if (48 <= c2 && c2 <= 57) {
        return c2 - 48;
      }
      lc = c2 | 32;
      if (97 <= lc && lc <= 102) {
        return lc - 97 + 10;
      }
      return -1;
    }
    function escapedHexLen(c2) {
      if (c2 === 120) {
        return 2;
      }
      if (c2 === 117) {
        return 4;
      }
      if (c2 === 85) {
        return 8;
      }
      return 0;
    }
    function fromDecimalCode(c2) {
      if (48 <= c2 && c2 <= 57) {
        return c2 - 48;
      }
      return -1;
    }
    function simpleEscapeSequence(c2) {
      return c2 === 48 ? "\0" : c2 === 97 ? "\x07" : c2 === 98 ? "\b" : c2 === 116 ? "	" : c2 === 9 ? "	" : c2 === 110 ? "\n" : c2 === 118 ? "\v" : c2 === 102 ? "\f" : c2 === 114 ? "\r" : c2 === 101 ? "\x1B" : c2 === 32 ? " " : c2 === 34 ? '"' : c2 === 47 ? "/" : c2 === 92 ? "\\" : c2 === 78 ? "" : c2 === 95 ? " " : c2 === 76 ? "\u2028" : c2 === 80 ? "\u2029" : "";
    }
    function charFromCodepoint(c2) {
      if (c2 <= 65535) {
        return String.fromCharCode(c2);
      }
      return String.fromCharCode(
        (c2 - 65536 >> 10) + 55296,
        (c2 - 65536 & 1023) + 56320
      );
    }
    var simpleEscapeCheck = new Array(256);
    var simpleEscapeMap = new Array(256);
    for (i2 = 0; i2 < 256; i2++) {
      simpleEscapeCheck[i2] = simpleEscapeSequence(i2) ? 1 : 0;
      simpleEscapeMap[i2] = simpleEscapeSequence(i2);
    }
    var i2;
    function State(input, options3) {
      this.input = input;
      this.filename = options3["filename"] || null;
      this.schema = options3["schema"] || DEFAULT_FULL_SCHEMA;
      this.onWarning = options3["onWarning"] || null;
      this.legacy = options3["legacy"] || false;
      this.json = options3["json"] || false;
      this.listener = options3["listener"] || null;
      this.implicitTypes = this.schema.compiledImplicit;
      this.typeMap = this.schema.compiledTypeMap;
      this.length = input.length;
      this.position = 0;
      this.line = 0;
      this.lineStart = 0;
      this.lineIndent = 0;
      this.documents = [];
    }
    function generateError(state, message) {
      return new YAMLException(
        message,
        new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart)
      );
    }
    function throwError(state, message) {
      throw generateError(state, message);
    }
    function throwWarning(state, message) {
      if (state.onWarning) {
        state.onWarning.call(null, generateError(state, message));
      }
    }
    var directiveHandlers = {
      YAML: function handleYamlDirective(state, name2, args) {
        var match, major, minor;
        if (state.version !== null) {
          throwError(state, "duplication of %YAML directive");
        }
        if (args.length !== 1) {
          throwError(state, "YAML directive accepts exactly one argument");
        }
        match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
        if (match === null) {
          throwError(state, "ill-formed argument of the YAML directive");
        }
        major = parseInt(match[1], 10);
        minor = parseInt(match[2], 10);
        if (major !== 1) {
          throwError(state, "unacceptable YAML version of the document");
        }
        state.version = args[0];
        state.checkLineBreaks = minor < 2;
        if (minor !== 1 && minor !== 2) {
          throwWarning(state, "unsupported YAML version of the document");
        }
      },
      TAG: function handleTagDirective(state, name2, args) {
        var handle2, prefix;
        if (args.length !== 2) {
          throwError(state, "TAG directive accepts exactly two arguments");
        }
        handle2 = args[0];
        prefix = args[1];
        if (!PATTERN_TAG_HANDLE.test(handle2)) {
          throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
        }
        if (_hasOwnProperty.call(state.tagMap, handle2)) {
          throwError(state, 'there is a previously declared suffix for "' + handle2 + '" tag handle');
        }
        if (!PATTERN_TAG_URI.test(prefix)) {
          throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
        }
        state.tagMap[handle2] = prefix;
      }
    };
    function captureSegment(state, start, end, checkJson) {
      var _position, _length, _character, _result;
      if (start < end) {
        _result = state.input.slice(start, end);
        if (checkJson) {
          for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
            _character = _result.charCodeAt(_position);
            if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
              throwError(state, "expected valid JSON character");
            }
          }
        } else if (PATTERN_NON_PRINTABLE.test(_result)) {
          throwError(state, "the stream contains non-printable characters");
        }
        state.result += _result;
      }
    }
    function mergeMappings(state, destination, source, overridableKeys) {
      var sourceKeys, key, index2, quantity;
      if (!common3.isObject(source)) {
        throwError(state, "cannot merge mappings; the provided source object is unacceptable");
      }
      sourceKeys = Object.keys(source);
      for (index2 = 0, quantity = sourceKeys.length; index2 < quantity; index2 += 1) {
        key = sourceKeys[index2];
        if (!_hasOwnProperty.call(destination, key)) {
          destination[key] = source[key];
          overridableKeys[key] = true;
        }
      }
    }
    function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
      var index2, quantity;
      if (Array.isArray(keyNode)) {
        keyNode = Array.prototype.slice.call(keyNode);
        for (index2 = 0, quantity = keyNode.length; index2 < quantity; index2 += 1) {
          if (Array.isArray(keyNode[index2])) {
            throwError(state, "nested arrays are not supported inside keys");
          }
          if (typeof keyNode === "object" && _class(keyNode[index2]) === "[object Object]") {
            keyNode[index2] = "[object Object]";
          }
        }
      }
      if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
        keyNode = "[object Object]";
      }
      keyNode = String(keyNode);
      if (_result === null) {
        _result = {};
      }
      if (keyTag === "tag:yaml.org,2002:merge") {
        if (Array.isArray(valueNode)) {
          for (index2 = 0, quantity = valueNode.length; index2 < quantity; index2 += 1) {
            mergeMappings(state, _result, valueNode[index2], overridableKeys);
          }
        } else {
          mergeMappings(state, _result, valueNode, overridableKeys);
        }
      } else {
        if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
          state.line = startLine || state.line;
          state.position = startPos || state.position;
          throwError(state, "duplicated mapping key");
        }
        _result[keyNode] = valueNode;
        delete overridableKeys[keyNode];
      }
      return _result;
    }
    function readLineBreak(state) {
      var ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 10) {
        state.position++;
      } else if (ch === 13) {
        state.position++;
        if (state.input.charCodeAt(state.position) === 10) {
          state.position++;
        }
      } else {
        throwError(state, "a line break is expected");
      }
      state.line += 1;
      state.lineStart = state.position;
    }
    function skipSeparationSpace(state, allowComments, checkIndent) {
      var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (allowComments && ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 10 && ch !== 13 && ch !== 0);
        }
        if (is_EOL(ch)) {
          readLineBreak(state);
          ch = state.input.charCodeAt(state.position);
          lineBreaks++;
          state.lineIndent = 0;
          while (ch === 32) {
            state.lineIndent++;
            ch = state.input.charCodeAt(++state.position);
          }
        } else {
          break;
        }
      }
      if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
        throwWarning(state, "deficient indentation");
      }
      return lineBreaks;
    }
    function testDocumentSeparator(state) {
      var _position = state.position, ch;
      ch = state.input.charCodeAt(_position);
      if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
        _position += 3;
        ch = state.input.charCodeAt(_position);
        if (ch === 0 || is_WS_OR_EOL(ch)) {
          return true;
        }
      }
      return false;
    }
    function writeFoldedLines(state, count) {
      if (count === 1) {
        state.result += " ";
      } else if (count > 1) {
        state.result += common3.repeat("\n", count - 1);
      }
    }
    function readPlainScalar(state, nodeIndent, withinFlowCollection) {
      var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
      ch = state.input.charCodeAt(state.position);
      if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
        return false;
      }
      if (ch === 63 || ch === 45) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          return false;
        }
      }
      state.kind = "scalar";
      state.result = "";
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
      while (ch !== 0) {
        if (ch === 58) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
            break;
          }
        } else if (ch === 35) {
          preceding = state.input.charCodeAt(state.position - 1);
          if (is_WS_OR_EOL(preceding)) {
            break;
          }
        } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
          break;
        } else if (is_EOL(ch)) {
          _line = state.line;
          _lineStart = state.lineStart;
          _lineIndent = state.lineIndent;
          skipSeparationSpace(state, false, -1);
          if (state.lineIndent >= nodeIndent) {
            hasPendingContent = true;
            ch = state.input.charCodeAt(state.position);
            continue;
          } else {
            state.position = captureEnd;
            state.line = _line;
            state.lineStart = _lineStart;
            state.lineIndent = _lineIndent;
            break;
          }
        }
        if (hasPendingContent) {
          captureSegment(state, captureStart, captureEnd, false);
          writeFoldedLines(state, state.line - _line);
          captureStart = captureEnd = state.position;
          hasPendingContent = false;
        }
        if (!is_WHITE_SPACE(ch)) {
          captureEnd = state.position + 1;
        }
        ch = state.input.charCodeAt(++state.position);
      }
      captureSegment(state, captureStart, captureEnd, false);
      if (state.result) {
        return true;
      }
      state.kind = _kind;
      state.result = _result;
      return false;
    }
    function readSingleQuotedScalar(state, nodeIndent) {
      var ch, captureStart, captureEnd;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 39) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 39) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (ch === 39) {
            captureStart = state.position;
            state.position++;
            captureEnd = state.position;
          } else {
            return true;
          }
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a single quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a single quoted scalar");
    }
    function readDoubleQuotedScalar(state, nodeIndent) {
      var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 34) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 34) {
          captureSegment(state, captureStart, state.position, true);
          state.position++;
          return true;
        } else if (ch === 92) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (is_EOL(ch)) {
            skipSeparationSpace(state, false, nodeIndent);
          } else if (ch < 256 && simpleEscapeCheck[ch]) {
            state.result += simpleEscapeMap[ch];
            state.position++;
          } else if ((tmp = escapedHexLen(ch)) > 0) {
            hexLength = tmp;
            hexResult = 0;
            for (; hexLength > 0; hexLength--) {
              ch = state.input.charCodeAt(++state.position);
              if ((tmp = fromHexCode(ch)) >= 0) {
                hexResult = (hexResult << 4) + tmp;
              } else {
                throwError(state, "expected hexadecimal character");
              }
            }
            state.result += charFromCodepoint(hexResult);
            state.position++;
          } else {
            throwError(state, "unknown escape sequence");
          }
          captureStart = captureEnd = state.position;
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a double quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a double quoted scalar");
    }
    function readFlowCollection(state, nodeIndent) {
      var readNext = true, _line, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair3, isExplicitPair, isMapping, overridableKeys = {}, keyNode, keyTag, valueNode, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 91) {
        terminator = 93;
        isMapping = false;
        _result = [];
      } else if (ch === 123) {
        terminator = 125;
        isMapping = true;
        _result = {};
      } else {
        return false;
      }
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(++state.position);
      while (ch !== 0) {
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === terminator) {
          state.position++;
          state.tag = _tag;
          state.anchor = _anchor;
          state.kind = isMapping ? "mapping" : "sequence";
          state.result = _result;
          return true;
        } else if (!readNext) {
          throwError(state, "missed comma between flow collection entries");
        }
        keyTag = keyNode = valueNode = null;
        isPair3 = isExplicitPair = false;
        if (ch === 63) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following)) {
            isPair3 = isExplicitPair = true;
            state.position++;
            skipSeparationSpace(state, true, nodeIndent);
          }
        }
        _line = state.line;
        composeNode3(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        keyTag = state.tag;
        keyNode = state.result;
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if ((isExplicitPair || state.line === _line) && ch === 58) {
          isPair3 = true;
          ch = state.input.charCodeAt(++state.position);
          skipSeparationSpace(state, true, nodeIndent);
          composeNode3(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
          valueNode = state.result;
        }
        if (isMapping) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
        } else if (isPair3) {
          _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
        } else {
          _result.push(keyNode);
        }
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === 44) {
          readNext = true;
          ch = state.input.charCodeAt(++state.position);
        } else {
          readNext = false;
        }
      }
      throwError(state, "unexpected end of the stream within a flow collection");
    }
    function readBlockScalar(state, nodeIndent) {
      var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 124) {
        folding = false;
      } else if (ch === 62) {
        folding = true;
      } else {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      while (ch !== 0) {
        ch = state.input.charCodeAt(++state.position);
        if (ch === 43 || ch === 45) {
          if (CHOMPING_CLIP === chomping) {
            chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
          } else {
            throwError(state, "repeat of a chomping mode identifier");
          }
        } else if ((tmp = fromDecimalCode(ch)) >= 0) {
          if (tmp === 0) {
            throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
          } else if (!detectedIndent) {
            textIndent = nodeIndent + tmp - 1;
            detectedIndent = true;
          } else {
            throwError(state, "repeat of an indentation width identifier");
          }
        } else {
          break;
        }
      }
      if (is_WHITE_SPACE(ch)) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (is_WHITE_SPACE(ch));
        if (ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (!is_EOL(ch) && ch !== 0);
        }
      }
      while (ch !== 0) {
        readLineBreak(state);
        state.lineIndent = 0;
        ch = state.input.charCodeAt(state.position);
        while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
        if (!detectedIndent && state.lineIndent > textIndent) {
          textIndent = state.lineIndent;
        }
        if (is_EOL(ch)) {
          emptyLines++;
          continue;
        }
        if (state.lineIndent < textIndent) {
          if (chomping === CHOMPING_KEEP) {
            state.result += common3.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (chomping === CHOMPING_CLIP) {
            if (didReadContent) {
              state.result += "\n";
            }
          }
          break;
        }
        if (folding) {
          if (is_WHITE_SPACE(ch)) {
            atMoreIndented = true;
            state.result += common3.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (atMoreIndented) {
            atMoreIndented = false;
            state.result += common3.repeat("\n", emptyLines + 1);
          } else if (emptyLines === 0) {
            if (didReadContent) {
              state.result += " ";
            }
          } else {
            state.result += common3.repeat("\n", emptyLines);
          }
        } else {
          state.result += common3.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        }
        didReadContent = true;
        detectedIndent = true;
        emptyLines = 0;
        captureStart = state.position;
        while (!is_EOL(ch) && ch !== 0) {
          ch = state.input.charCodeAt(++state.position);
        }
        captureSegment(state, captureStart, state.position, false);
      }
      return true;
    }
    function readBlockSequence(state, nodeIndent) {
      var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        if (ch !== 45) {
          break;
        }
        following = state.input.charCodeAt(state.position + 1);
        if (!is_WS_OR_EOL(following)) {
          break;
        }
        detected = true;
        state.position++;
        if (skipSeparationSpace(state, true, -1)) {
          if (state.lineIndent <= nodeIndent) {
            _result.push(null);
            ch = state.input.charCodeAt(state.position);
            continue;
          }
        }
        _line = state.line;
        composeNode3(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
        _result.push(state.result);
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
          throwError(state, "bad indentation of a sequence entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "sequence";
        state.result = _result;
        return true;
      }
      return false;
    }
    function readBlockMapping(state, nodeIndent, flowIndent) {
      var following, allowCompact, _line, _pos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = {}, keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        following = state.input.charCodeAt(state.position + 1);
        _line = state.line;
        _pos = state.position;
        if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
          if (ch === 63) {
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = true;
            allowCompact = true;
          } else if (atExplicitKey) {
            atExplicitKey = false;
            allowCompact = true;
          } else {
            throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
          }
          state.position += 1;
          ch = following;
        } else if (composeNode3(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
          if (state.line === _line) {
            ch = state.input.charCodeAt(state.position);
            while (is_WHITE_SPACE(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (ch === 58) {
              ch = state.input.charCodeAt(++state.position);
              if (!is_WS_OR_EOL(ch)) {
                throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
              }
              if (atExplicitKey) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
                keyTag = keyNode = valueNode = null;
              }
              detected = true;
              atExplicitKey = false;
              allowCompact = false;
              keyTag = state.tag;
              keyNode = state.result;
            } else if (detected) {
              throwError(state, "can not read an implicit mapping pair; a colon is missed");
            } else {
              state.tag = _tag;
              state.anchor = _anchor;
              return true;
            }
          } else if (detected) {
            throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true;
          }
        } else {
          break;
        }
        if (state.line === _line || state.lineIndent > nodeIndent) {
          if (composeNode3(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
            if (atExplicitKey) {
              keyNode = state.result;
            } else {
              valueNode = state.result;
            }
          }
          if (!atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
            keyTag = keyNode = valueNode = null;
          }
          skipSeparationSpace(state, true, -1);
          ch = state.input.charCodeAt(state.position);
        }
        if (state.lineIndent > nodeIndent && ch !== 0) {
          throwError(state, "bad indentation of a mapping entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "mapping";
        state.result = _result;
      }
      return detected;
    }
    function readTagProperty(state) {
      var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 33)
        return false;
      if (state.tag !== null) {
        throwError(state, "duplication of a tag property");
      }
      ch = state.input.charCodeAt(++state.position);
      if (ch === 60) {
        isVerbatim = true;
        ch = state.input.charCodeAt(++state.position);
      } else if (ch === 33) {
        isNamed = true;
        tagHandle = "!!";
        ch = state.input.charCodeAt(++state.position);
      } else {
        tagHandle = "!";
      }
      _position = state.position;
      if (isVerbatim) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && ch !== 62);
        if (state.position < state.length) {
          tagName = state.input.slice(_position, state.position);
          ch = state.input.charCodeAt(++state.position);
        } else {
          throwError(state, "unexpected end of the stream within a verbatim tag");
        }
      } else {
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          if (ch === 33) {
            if (!isNamed) {
              tagHandle = state.input.slice(_position - 1, state.position + 1);
              if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                throwError(state, "named tag handle cannot contain such characters");
              }
              isNamed = true;
              _position = state.position + 1;
            } else {
              throwError(state, "tag suffix cannot contain exclamation marks");
            }
          }
          ch = state.input.charCodeAt(++state.position);
        }
        tagName = state.input.slice(_position, state.position);
        if (PATTERN_FLOW_INDICATORS.test(tagName)) {
          throwError(state, "tag suffix cannot contain flow indicator characters");
        }
      }
      if (tagName && !PATTERN_TAG_URI.test(tagName)) {
        throwError(state, "tag name cannot contain such characters: " + tagName);
      }
      if (isVerbatim) {
        state.tag = tagName;
      } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
        state.tag = state.tagMap[tagHandle] + tagName;
      } else if (tagHandle === "!") {
        state.tag = "!" + tagName;
      } else if (tagHandle === "!!") {
        state.tag = "tag:yaml.org,2002:" + tagName;
      } else {
        throwError(state, 'undeclared tag handle "' + tagHandle + '"');
      }
      return true;
    }
    function readAnchorProperty(state) {
      var _position, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 38)
        return false;
      if (state.anchor !== null) {
        throwError(state, "duplication of an anchor property");
      }
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an anchor node must contain at least one character");
      }
      state.anchor = state.input.slice(_position, state.position);
      return true;
    }
    function readAlias(state) {
      var _position, alias2, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 42)
        return false;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an alias node must contain at least one character");
      }
      alias2 = state.input.slice(_position, state.position);
      if (!_hasOwnProperty.call(state.anchorMap, alias2)) {
        throwError(state, 'unidentified alias "' + alias2 + '"');
      }
      state.result = state.anchorMap[alias2];
      skipSeparationSpace(state, true, -1);
      return true;
    }
    function composeNode3(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
      var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, type, flowIndent, blockIndent;
      if (state.listener !== null) {
        state.listener("open", state);
      }
      state.tag = null;
      state.anchor = null;
      state.kind = null;
      state.result = null;
      allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
      if (allowToSeek) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        }
      }
      if (indentStatus === 1) {
        while (readTagProperty(state) || readAnchorProperty(state)) {
          if (skipSeparationSpace(state, true, -1)) {
            atNewLine = true;
            allowBlockCollections = allowBlockStyles;
            if (state.lineIndent > parentIndent) {
              indentStatus = 1;
            } else if (state.lineIndent === parentIndent) {
              indentStatus = 0;
            } else if (state.lineIndent < parentIndent) {
              indentStatus = -1;
            }
          } else {
            allowBlockCollections = false;
          }
        }
      }
      if (allowBlockCollections) {
        allowBlockCollections = atNewLine || allowCompact;
      }
      if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
        if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
          flowIndent = parentIndent;
        } else {
          flowIndent = parentIndent + 1;
        }
        blockIndent = state.position - state.lineStart;
        if (indentStatus === 1) {
          if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
            hasContent = true;
          } else {
            if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
              hasContent = true;
            } else if (readAlias(state)) {
              hasContent = true;
              if (state.tag !== null || state.anchor !== null) {
                throwError(state, "alias node should not have any properties");
              }
            } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
              hasContent = true;
              if (state.tag === null) {
                state.tag = "?";
              }
            }
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
          }
        } else if (indentStatus === 0) {
          hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
        }
      }
      if (state.tag !== null && state.tag !== "!") {
        if (state.tag === "?") {
          if (state.result !== null && state.kind !== "scalar") {
            throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
          }
          for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
            type = state.implicitTypes[typeIndex];
            if (type.resolve(state.result)) {
              state.result = type.construct(state.result);
              state.tag = type.tag;
              if (state.anchor !== null) {
                state.anchorMap[state.anchor] = state.result;
              }
              break;
            }
          }
        } else if (_hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag)) {
          type = state.typeMap[state.kind || "fallback"][state.tag];
          if (state.result !== null && type.kind !== state.kind) {
            throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
          }
          if (!type.resolve(state.result)) {
            throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
          } else {
            state.result = type.construct(state.result);
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
          }
        } else {
          throwError(state, "unknown tag !<" + state.tag + ">");
        }
      }
      if (state.listener !== null) {
        state.listener("close", state);
      }
      return state.tag !== null || state.anchor !== null || hasContent;
    }
    function readDocument(state) {
      var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
      state.version = null;
      state.checkLineBreaks = state.legacy;
      state.tagMap = {};
      state.anchorMap = {};
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if (state.lineIndent > 0 || ch !== 37) {
          break;
        }
        hasDirectives = true;
        ch = state.input.charCodeAt(++state.position);
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        directiveName = state.input.slice(_position, state.position);
        directiveArgs = [];
        if (directiveName.length < 1) {
          throwError(state, "directive name must not be less than one character in length");
        }
        while (ch !== 0) {
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (ch === 35) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (ch !== 0 && !is_EOL(ch));
            break;
          }
          if (is_EOL(ch))
            break;
          _position = state.position;
          while (ch !== 0 && !is_WS_OR_EOL(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          directiveArgs.push(state.input.slice(_position, state.position));
        }
        if (ch !== 0)
          readLineBreak(state);
        if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
          directiveHandlers[directiveName](state, directiveName, directiveArgs);
        } else {
          throwWarning(state, 'unknown document directive "' + directiveName + '"');
        }
      }
      skipSeparationSpace(state, true, -1);
      if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      } else if (hasDirectives) {
        throwError(state, "directives end mark is expected");
      }
      composeNode3(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
      skipSeparationSpace(state, true, -1);
      if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
        throwWarning(state, "non-ASCII line breaks are interpreted as content");
      }
      state.documents.push(state.result);
      if (state.position === state.lineStart && testDocumentSeparator(state)) {
        if (state.input.charCodeAt(state.position) === 46) {
          state.position += 3;
          skipSeparationSpace(state, true, -1);
        }
        return;
      }
      if (state.position < state.length - 1) {
        throwError(state, "end of the stream or a document separator is expected");
      } else {
        return;
      }
    }
    function loadDocuments(input, options3) {
      input = String(input);
      options3 = options3 || {};
      if (input.length !== 0) {
        if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
          input += "\n";
        }
        if (input.charCodeAt(0) === 65279) {
          input = input.slice(1);
        }
      }
      var state = new State(input, options3);
      var nullpos = input.indexOf("\0");
      if (nullpos !== -1) {
        state.position = nullpos;
        throwError(state, "null byte is not allowed in input");
      }
      state.input += "\0";
      while (state.input.charCodeAt(state.position) === 32) {
        state.lineIndent += 1;
        state.position += 1;
      }
      while (state.position < state.length - 1) {
        readDocument(state);
      }
      return state.documents;
    }
    function loadAll(input, iterator, options3) {
      if (iterator !== null && typeof iterator === "object" && typeof options3 === "undefined") {
        options3 = iterator;
        iterator = null;
      }
      var documents = loadDocuments(input, options3);
      if (typeof iterator !== "function") {
        return documents;
      }
      for (var index2 = 0, length = documents.length; index2 < length; index2 += 1) {
        iterator(documents[index2]);
      }
    }
    function load2(input, options3) {
      var documents = loadDocuments(input, options3);
      if (documents.length === 0) {
        return void 0;
      } else if (documents.length === 1) {
        return documents[0];
      }
      throw new YAMLException("expected a single document in the stream, but found more");
    }
    function safeLoadAll(input, iterator, options3) {
      if (typeof iterator === "object" && iterator !== null && typeof options3 === "undefined") {
        options3 = iterator;
        iterator = null;
      }
      return loadAll(input, iterator, common3.extend({ schema: DEFAULT_SAFE_SCHEMA }, options3));
    }
    function safeLoad(input, options3) {
      return load2(input, common3.extend({ schema: DEFAULT_SAFE_SCHEMA }, options3));
    }
    module2.exports.loadAll = loadAll;
    module2.exports.load = load2;
    module2.exports.safeLoadAll = safeLoadAll;
    module2.exports.safeLoad = safeLoad;
  }
});

// node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/dumper.js
var require_dumper = __commonJS({
  "node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml/dumper.js"(exports3, module2) {
    "use strict";
    var common3 = require_common4();
    var YAMLException = require_exception();
    var DEFAULT_FULL_SCHEMA = require_default_full();
    var DEFAULT_SAFE_SCHEMA = require_default_safe();
    var _toString = Object.prototype.toString;
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CHAR_TAB = 9;
    var CHAR_LINE_FEED = 10;
    var CHAR_CARRIAGE_RETURN = 13;
    var CHAR_SPACE = 32;
    var CHAR_EXCLAMATION = 33;
    var CHAR_DOUBLE_QUOTE2 = 34;
    var CHAR_SHARP = 35;
    var CHAR_PERCENT = 37;
    var CHAR_AMPERSAND = 38;
    var CHAR_SINGLE_QUOTE2 = 39;
    var CHAR_ASTERISK2 = 42;
    var CHAR_COMMA2 = 44;
    var CHAR_MINUS = 45;
    var CHAR_COLON = 58;
    var CHAR_EQUALS = 61;
    var CHAR_GREATER_THAN = 62;
    var CHAR_QUESTION = 63;
    var CHAR_COMMERCIAL_AT = 64;
    var CHAR_LEFT_SQUARE_BRACKET2 = 91;
    var CHAR_RIGHT_SQUARE_BRACKET2 = 93;
    var CHAR_GRAVE_ACCENT = 96;
    var CHAR_LEFT_CURLY_BRACKET = 123;
    var CHAR_VERTICAL_LINE = 124;
    var CHAR_RIGHT_CURLY_BRACKET = 125;
    var ESCAPE_SEQUENCES = {};
    ESCAPE_SEQUENCES[0] = "\\0";
    ESCAPE_SEQUENCES[7] = "\\a";
    ESCAPE_SEQUENCES[8] = "\\b";
    ESCAPE_SEQUENCES[9] = "\\t";
    ESCAPE_SEQUENCES[10] = "\\n";
    ESCAPE_SEQUENCES[11] = "\\v";
    ESCAPE_SEQUENCES[12] = "\\f";
    ESCAPE_SEQUENCES[13] = "\\r";
    ESCAPE_SEQUENCES[27] = "\\e";
    ESCAPE_SEQUENCES[34] = '\\"';
    ESCAPE_SEQUENCES[92] = "\\\\";
    ESCAPE_SEQUENCES[133] = "\\N";
    ESCAPE_SEQUENCES[160] = "\\_";
    ESCAPE_SEQUENCES[8232] = "\\L";
    ESCAPE_SEQUENCES[8233] = "\\P";
    var DEPRECATED_BOOLEANS_SYNTAX = [
      "y",
      "Y",
      "yes",
      "Yes",
      "YES",
      "on",
      "On",
      "ON",
      "n",
      "N",
      "no",
      "No",
      "NO",
      "off",
      "Off",
      "OFF"
    ];
    function compileStyleMap(schema5, map3) {
      var result, keys, index2, length, tag, style, type;
      if (map3 === null)
        return {};
      result = {};
      keys = Object.keys(map3);
      for (index2 = 0, length = keys.length; index2 < length; index2 += 1) {
        tag = keys[index2];
        style = String(map3[tag]);
        if (tag.slice(0, 2) === "!!") {
          tag = "tag:yaml.org,2002:" + tag.slice(2);
        }
        type = schema5.compiledTypeMap["fallback"][tag];
        if (type && _hasOwnProperty.call(type.styleAliases, style)) {
          style = type.styleAliases[style];
        }
        result[tag] = style;
      }
      return result;
    }
    function encodeHex(character) {
      var string3, handle2, length;
      string3 = character.toString(16).toUpperCase();
      if (character <= 255) {
        handle2 = "x";
        length = 2;
      } else if (character <= 65535) {
        handle2 = "u";
        length = 4;
      } else if (character <= 4294967295) {
        handle2 = "U";
        length = 8;
      } else {
        throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
      }
      return "\\" + handle2 + common3.repeat("0", length - string3.length) + string3;
    }
    function State(options3) {
      this.schema = options3["schema"] || DEFAULT_FULL_SCHEMA;
      this.indent = Math.max(1, options3["indent"] || 2);
      this.noArrayIndent = options3["noArrayIndent"] || false;
      this.skipInvalid = options3["skipInvalid"] || false;
      this.flowLevel = common3.isNothing(options3["flowLevel"]) ? -1 : options3["flowLevel"];
      this.styleMap = compileStyleMap(this.schema, options3["styles"] || null);
      this.sortKeys = options3["sortKeys"] || false;
      this.lineWidth = options3["lineWidth"] || 80;
      this.noRefs = options3["noRefs"] || false;
      this.noCompatMode = options3["noCompatMode"] || false;
      this.condenseFlow = options3["condenseFlow"] || false;
      this.implicitTypes = this.schema.compiledImplicit;
      this.explicitTypes = this.schema.compiledExplicit;
      this.tag = null;
      this.result = "";
      this.duplicates = [];
      this.usedDuplicates = null;
    }
    function indentString(string3, spaces) {
      var ind = common3.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string3.length;
      while (position < length) {
        next = string3.indexOf("\n", position);
        if (next === -1) {
          line = string3.slice(position);
          position = length;
        } else {
          line = string3.slice(position, next + 1);
          position = next + 1;
        }
        if (line.length && line !== "\n")
          result += ind;
        result += line;
      }
      return result;
    }
    function generateNextLine(state, level3) {
      return "\n" + common3.repeat(" ", state.indent * level3);
    }
    function testImplicitResolving(state, str2) {
      var index2, length, type;
      for (index2 = 0, length = state.implicitTypes.length; index2 < length; index2 += 1) {
        type = state.implicitTypes[index2];
        if (type.resolve(str2)) {
          return true;
        }
      }
      return false;
    }
    function isWhitespace(c2) {
      return c2 === CHAR_SPACE || c2 === CHAR_TAB;
    }
    function isPrintable(c2) {
      return 32 <= c2 && c2 <= 126 || 161 <= c2 && c2 <= 55295 && c2 !== 8232 && c2 !== 8233 || 57344 <= c2 && c2 <= 65533 && c2 !== 65279 || 65536 <= c2 && c2 <= 1114111;
    }
    function isNsChar(c2) {
      return isPrintable(c2) && !isWhitespace(c2) && c2 !== 65279 && c2 !== CHAR_CARRIAGE_RETURN && c2 !== CHAR_LINE_FEED;
    }
    function isPlainSafe(c2, prev) {
      return isPrintable(c2) && c2 !== 65279 && c2 !== CHAR_COMMA2 && c2 !== CHAR_LEFT_SQUARE_BRACKET2 && c2 !== CHAR_RIGHT_SQUARE_BRACKET2 && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET && c2 !== CHAR_COLON && (c2 !== CHAR_SHARP || prev && isNsChar(prev));
    }
    function isPlainSafeFirst(c2) {
      return isPrintable(c2) && c2 !== 65279 && !isWhitespace(c2) && c2 !== CHAR_MINUS && c2 !== CHAR_QUESTION && c2 !== CHAR_COLON && c2 !== CHAR_COMMA2 && c2 !== CHAR_LEFT_SQUARE_BRACKET2 && c2 !== CHAR_RIGHT_SQUARE_BRACKET2 && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET && c2 !== CHAR_SHARP && c2 !== CHAR_AMPERSAND && c2 !== CHAR_ASTERISK2 && c2 !== CHAR_EXCLAMATION && c2 !== CHAR_VERTICAL_LINE && c2 !== CHAR_EQUALS && c2 !== CHAR_GREATER_THAN && c2 !== CHAR_SINGLE_QUOTE2 && c2 !== CHAR_DOUBLE_QUOTE2 && c2 !== CHAR_PERCENT && c2 !== CHAR_COMMERCIAL_AT && c2 !== CHAR_GRAVE_ACCENT;
    }
    function needIndentIndicator(string3) {
      var leadingSpaceRe = /^\n* /;
      return leadingSpaceRe.test(string3);
    }
    var STYLE_PLAIN = 1;
    var STYLE_SINGLE = 2;
    var STYLE_LITERAL = 3;
    var STYLE_FOLDED = 4;
    var STYLE_DOUBLE = 5;
    function chooseScalarStyle(string3, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
      var i2;
      var char, prev_char;
      var hasLineBreak = false;
      var hasFoldableLine = false;
      var shouldTrackWidth = lineWidth !== -1;
      var previousLineBreak = -1;
      var plain = isPlainSafeFirst(string3.charCodeAt(0)) && !isWhitespace(string3.charCodeAt(string3.length - 1));
      if (singleLineOnly) {
        for (i2 = 0; i2 < string3.length; i2++) {
          char = string3.charCodeAt(i2);
          if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          prev_char = i2 > 0 ? string3.charCodeAt(i2 - 1) : null;
          plain = plain && isPlainSafe(char, prev_char);
        }
      } else {
        for (i2 = 0; i2 < string3.length; i2++) {
          char = string3.charCodeAt(i2);
          if (char === CHAR_LINE_FEED) {
            hasLineBreak = true;
            if (shouldTrackWidth) {
              hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
              i2 - previousLineBreak - 1 > lineWidth && string3[previousLineBreak + 1] !== " ";
              previousLineBreak = i2;
            }
          } else if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          prev_char = i2 > 0 ? string3.charCodeAt(i2 - 1) : null;
          plain = plain && isPlainSafe(char, prev_char);
        }
        hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i2 - previousLineBreak - 1 > lineWidth && string3[previousLineBreak + 1] !== " ");
      }
      if (!hasLineBreak && !hasFoldableLine) {
        return plain && !testAmbiguousType(string3) ? STYLE_PLAIN : STYLE_SINGLE;
      }
      if (indentPerLevel > 9 && needIndentIndicator(string3)) {
        return STYLE_DOUBLE;
      }
      return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
    }
    function writeScalar(state, string3, level3, iskey) {
      state.dump = function() {
        if (string3.length === 0) {
          return "''";
        }
        if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string3) !== -1) {
          return "'" + string3 + "'";
        }
        var indent = state.indent * Math.max(1, level3);
        var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
        var singleLineOnly = iskey || state.flowLevel > -1 && level3 >= state.flowLevel;
        function testAmbiguity(string4) {
          return testImplicitResolving(state, string4);
        }
        switch (chooseScalarStyle(string3, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
          case STYLE_PLAIN:
            return string3;
          case STYLE_SINGLE:
            return "'" + string3.replace(/'/g, "''") + "'";
          case STYLE_LITERAL:
            return "|" + blockHeader(string3, state.indent) + dropEndingNewline(indentString(string3, indent));
          case STYLE_FOLDED:
            return ">" + blockHeader(string3, state.indent) + dropEndingNewline(indentString(foldString(string3, lineWidth), indent));
          case STYLE_DOUBLE:
            return '"' + escapeString(string3, lineWidth) + '"';
          default:
            throw new YAMLException("impossible error: invalid scalar style");
        }
      }();
    }
    function blockHeader(string3, indentPerLevel) {
      var indentIndicator = needIndentIndicator(string3) ? String(indentPerLevel) : "";
      var clip = string3[string3.length - 1] === "\n";
      var keep = clip && (string3[string3.length - 2] === "\n" || string3 === "\n");
      var chomp = keep ? "+" : clip ? "" : "-";
      return indentIndicator + chomp + "\n";
    }
    function dropEndingNewline(string3) {
      return string3[string3.length - 1] === "\n" ? string3.slice(0, -1) : string3;
    }
    function foldString(string3, width) {
      var lineRe = /(\n+)([^\n]*)/g;
      var result = function() {
        var nextLF = string3.indexOf("\n");
        nextLF = nextLF !== -1 ? nextLF : string3.length;
        lineRe.lastIndex = nextLF;
        return foldLine(string3.slice(0, nextLF), width);
      }();
      var prevMoreIndented = string3[0] === "\n" || string3[0] === " ";
      var moreIndented;
      var match;
      while (match = lineRe.exec(string3)) {
        var prefix = match[1], line = match[2];
        moreIndented = line[0] === " ";
        result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
        prevMoreIndented = moreIndented;
      }
      return result;
    }
    function foldLine(line, width) {
      if (line === "" || line[0] === " ")
        return line;
      var breakRe = / [^ ]/g;
      var match;
      var start = 0, end, curr = 0, next = 0;
      var result = "";
      while (match = breakRe.exec(line)) {
        next = match.index;
        if (next - start > width) {
          end = curr > start ? curr : next;
          result += "\n" + line.slice(start, end);
          start = end + 1;
        }
        curr = next;
      }
      result += "\n";
      if (line.length - start > width && curr > start) {
        result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
      } else {
        result += line.slice(start);
      }
      return result.slice(1);
    }
    function escapeString(string3) {
      var result = "";
      var char, nextChar;
      var escapeSeq;
      for (var i2 = 0; i2 < string3.length; i2++) {
        char = string3.charCodeAt(i2);
        if (char >= 55296 && char <= 56319) {
          nextChar = string3.charCodeAt(i2 + 1);
          if (nextChar >= 56320 && nextChar <= 57343) {
            result += encodeHex((char - 55296) * 1024 + nextChar - 56320 + 65536);
            i2++;
            continue;
          }
        }
        escapeSeq = ESCAPE_SEQUENCES[char];
        result += !escapeSeq && isPrintable(char) ? string3[i2] : escapeSeq || encodeHex(char);
      }
      return result;
    }
    function writeFlowSequence(state, level3, object) {
      var _result = "", _tag = state.tag, index2, length;
      for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
        if (writeNode(state, level3, object[index2], false, false)) {
          if (index2 !== 0)
            _result += "," + (!state.condenseFlow ? " " : "");
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = "[" + _result + "]";
    }
    function writeBlockSequence(state, level3, object, compact) {
      var _result = "", _tag = state.tag, index2, length;
      for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
        if (writeNode(state, level3 + 1, object[index2], true, true)) {
          if (!compact || index2 !== 0) {
            _result += generateNextLine(state, level3);
          }
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            _result += "-";
          } else {
            _result += "- ";
          }
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = _result || "[]";
    }
    function writeFlowMapping(state, level3, object) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index2, length, objectKey, objectValue, pairBuffer;
      for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
        pairBuffer = "";
        if (index2 !== 0)
          pairBuffer += ", ";
        if (state.condenseFlow)
          pairBuffer += '"';
        objectKey = objectKeyList[index2];
        objectValue = object[objectKey];
        if (!writeNode(state, level3, objectKey, false, false)) {
          continue;
        }
        if (state.dump.length > 1024)
          pairBuffer += "? ";
        pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
        if (!writeNode(state, level3, objectValue, false, false)) {
          continue;
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = "{" + _result + "}";
    }
    function writeBlockMapping(state, level3, object, compact) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index2, length, objectKey, objectValue, explicitPair, pairBuffer;
      if (state.sortKeys === true) {
        objectKeyList.sort();
      } else if (typeof state.sortKeys === "function") {
        objectKeyList.sort(state.sortKeys);
      } else if (state.sortKeys) {
        throw new YAMLException("sortKeys must be a boolean or a function");
      }
      for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
        pairBuffer = "";
        if (!compact || index2 !== 0) {
          pairBuffer += generateNextLine(state, level3);
        }
        objectKey = objectKeyList[index2];
        objectValue = object[objectKey];
        if (!writeNode(state, level3 + 1, objectKey, true, true, true)) {
          continue;
        }
        explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
        if (explicitPair) {
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            pairBuffer += "?";
          } else {
            pairBuffer += "? ";
          }
        }
        pairBuffer += state.dump;
        if (explicitPair) {
          pairBuffer += generateNextLine(state, level3);
        }
        if (!writeNode(state, level3 + 1, objectValue, true, explicitPair)) {
          continue;
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += ":";
        } else {
          pairBuffer += ": ";
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = _result || "{}";
    }
    function detectType(state, object, explicit) {
      var _result, typeList, index2, length, type, style;
      typeList = explicit ? state.explicitTypes : state.implicitTypes;
      for (index2 = 0, length = typeList.length; index2 < length; index2 += 1) {
        type = typeList[index2];
        if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === "object" && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
          state.tag = explicit ? type.tag : "?";
          if (type.represent) {
            style = state.styleMap[type.tag] || type.defaultStyle;
            if (_toString.call(type.represent) === "[object Function]") {
              _result = type.represent(object, style);
            } else if (_hasOwnProperty.call(type.represent, style)) {
              _result = type.represent[style](object, style);
            } else {
              throw new YAMLException("!<" + type.tag + '> tag resolver accepts not "' + style + '" style');
            }
            state.dump = _result;
          }
          return true;
        }
      }
      return false;
    }
    function writeNode(state, level3, object, block, compact, iskey) {
      state.tag = null;
      state.dump = object;
      if (!detectType(state, object, false)) {
        detectType(state, object, true);
      }
      var type = _toString.call(state.dump);
      if (block) {
        block = state.flowLevel < 0 || state.flowLevel > level3;
      }
      var objectOrArray = type === "[object Object]" || type === "[object Array]", duplicateIndex, duplicate;
      if (objectOrArray) {
        duplicateIndex = state.duplicates.indexOf(object);
        duplicate = duplicateIndex !== -1;
      }
      if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level3 > 0) {
        compact = false;
      }
      if (duplicate && state.usedDuplicates[duplicateIndex]) {
        state.dump = "*ref_" + duplicateIndex;
      } else {
        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
          state.usedDuplicates[duplicateIndex] = true;
        }
        if (type === "[object Object]") {
          if (block && Object.keys(state.dump).length !== 0) {
            writeBlockMapping(state, level3, state.dump, compact);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowMapping(state, level3, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type === "[object Array]") {
          var arrayLevel = state.noArrayIndent && level3 > 0 ? level3 - 1 : level3;
          if (block && state.dump.length !== 0) {
            writeBlockSequence(state, arrayLevel, state.dump, compact);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowSequence(state, arrayLevel, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type === "[object String]") {
          if (state.tag !== "?") {
            writeScalar(state, state.dump, level3, iskey);
          }
        } else {
          if (state.skipInvalid)
            return false;
          throw new YAMLException("unacceptable kind of an object to dump " + type);
        }
        if (state.tag !== null && state.tag !== "?") {
          state.dump = "!<" + state.tag + "> " + state.dump;
        }
      }
      return true;
    }
    function getDuplicateReferences(object, state) {
      var objects = [], duplicatesIndexes = [], index2, length;
      inspectNode(object, objects, duplicatesIndexes);
      for (index2 = 0, length = duplicatesIndexes.length; index2 < length; index2 += 1) {
        state.duplicates.push(objects[duplicatesIndexes[index2]]);
      }
      state.usedDuplicates = new Array(length);
    }
    function inspectNode(object, objects, duplicatesIndexes) {
      var objectKeyList, index2, length;
      if (object !== null && typeof object === "object") {
        index2 = objects.indexOf(object);
        if (index2 !== -1) {
          if (duplicatesIndexes.indexOf(index2) === -1) {
            duplicatesIndexes.push(index2);
          }
        } else {
          objects.push(object);
          if (Array.isArray(object)) {
            for (index2 = 0, length = object.length; index2 < length; index2 += 1) {
              inspectNode(object[index2], objects, duplicatesIndexes);
            }
          } else {
            objectKeyList = Object.keys(object);
            for (index2 = 0, length = objectKeyList.length; index2 < length; index2 += 1) {
              inspectNode(object[objectKeyList[index2]], objects, duplicatesIndexes);
            }
          }
        }
      }
    }
    function dump(input, options3) {
      options3 = options3 || {};
      var state = new State(options3);
      if (!state.noRefs)
        getDuplicateReferences(input, state);
      if (writeNode(state, 0, input, true, true))
        return state.dump + "\n";
      return "";
    }
    function safeDump(input, options3) {
      return dump(input, common3.extend({ schema: DEFAULT_SAFE_SCHEMA }, options3));
    }
    module2.exports.dump = dump;
    module2.exports.safeDump = safeDump;
  }
});

// node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml.js
var require_js_yaml = __commonJS({
  "node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/lib/js-yaml.js"(exports3, module2) {
    "use strict";
    var loader = require_loader();
    var dumper = require_dumper();
    function deprecated(name2) {
      return function() {
        throw new Error("Function " + name2 + " is deprecated and cannot be used.");
      };
    }
    module2.exports.Type = require_type();
    module2.exports.Schema = require_schema();
    module2.exports.FAILSAFE_SCHEMA = require_failsafe();
    module2.exports.JSON_SCHEMA = require_json2();
    module2.exports.CORE_SCHEMA = require_core();
    module2.exports.DEFAULT_SAFE_SCHEMA = require_default_safe();
    module2.exports.DEFAULT_FULL_SCHEMA = require_default_full();
    module2.exports.load = loader.load;
    module2.exports.loadAll = loader.loadAll;
    module2.exports.safeLoad = loader.safeLoad;
    module2.exports.safeLoadAll = loader.safeLoadAll;
    module2.exports.dump = dumper.dump;
    module2.exports.safeDump = dumper.safeDump;
    module2.exports.YAMLException = require_exception();
    module2.exports.MINIMAL_SCHEMA = require_failsafe();
    module2.exports.SAFE_SCHEMA = require_default_safe();
    module2.exports.DEFAULT_SCHEMA = require_default_full();
    module2.exports.scan = deprecated("scan");
    module2.exports.parse = deprecated("parse");
    module2.exports.compose = deprecated("compose");
    module2.exports.addConstructor = deprecated("addConstructor");
  }
});

// node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/index.js
var require_js_yaml2 = __commonJS({
  "node_modules/.pnpm/js-yaml@3.14.1/node_modules/js-yaml/index.js"(exports3, module2) {
    "use strict";
    var yaml3 = require_js_yaml();
    module2.exports = yaml3;
  }
});

// node_modules/.pnpm/gray-matter@4.0.3/node_modules/gray-matter/lib/engines.js
var require_engines = __commonJS({
  "node_modules/.pnpm/gray-matter@4.0.3/node_modules/gray-matter/lib/engines.js"(exports, module) {
    "use strict";
    var yaml = require_js_yaml2();
    var engines = exports = module.exports;
    engines.yaml = {
      parse: yaml.safeLoad.bind(yaml),
      stringify: yaml.safeDump.bind(yaml)
    };
    engines.json = {
      parse: JSON.parse.bind(JSON),
      stringify: function(obj, options3) {
        const opts = Object.assign({ replacer: null, space: 2 }, options3);
        return JSON.stringify(obj, opts.replacer, opts.space);
      }
    };
    engines.javascript = {
      parse: function parse(str, options, wrap) {
        try {
          if (wrap !== false) {
            str = "(function() {\nreturn " + str.trim() + ";\n}());";
          }
          return eval(str) || {};
        } catch (err2) {
          if (wrap !== false && /(unexpected|identifier)/i.test(err2.message)) {
            return parse(str, options, false);
          }
          throw new SyntaxError(err2);
        }
      },
      stringify: function() {
        throw new Error("stringifying JavaScript is not supported");
      }
    };
  }
});

// node_modules/.pnpm/strip-bom-string@1.0.0/node_modules/strip-bom-string/index.js
var require_strip_bom_string = __commonJS({
  "node_modules/.pnpm/strip-bom-string@1.0.0/node_modules/strip-bom-string/index.js"(exports3, module2) {
    "use strict";
    module2.exports = function(str2) {
      if (typeof str2 === "string" && str2.charAt(0) === "\uFEFF") {
        return str2.slice(1);
      }
      return str2;
    };
  }
});

// node_modules/.pnpm/gray-matter@4.0.3/node_modules/gray-matter/lib/utils.js
var require_utils9 = __commonJS({
  "node_modules/.pnpm/gray-matter@4.0.3/node_modules/gray-matter/lib/utils.js"(exports3) {
    "use strict";
    var stripBom2 = require_strip_bom_string();
    var typeOf = require_kind_of();
    exports3.define = function(obj, key, val) {
      Reflect.defineProperty(obj, key, {
        enumerable: false,
        configurable: true,
        writable: true,
        value: val
      });
    };
    exports3.isBuffer = function(val) {
      return typeOf(val) === "buffer";
    };
    exports3.isObject = function(val) {
      return typeOf(val) === "object";
    };
    exports3.toBuffer = function(input) {
      return typeof input === "string" ? Buffer.from(input) : input;
    };
    exports3.toString = function(input) {
      if (exports3.isBuffer(input))
        return stripBom2(String(input));
      if (typeof input !== "string") {
        throw new TypeError("expected input to be a string or buffer");
      }
      return stripBom2(input);
    };
    exports3.arrayify = function(val) {
      return val ? Array.isArray(val) ? val : [val] : [];
    };
    exports3.startsWith = function(str2, substr, len) {
      if (typeof len !== "number")
        len = substr.length;
      return str2.slice(0, len) === substr;
    };
  }
});

// node_modules/.pnpm/gray-matter@4.0.3/node_modules/gray-matter/lib/defaults.js
var require_defaults2 = __commonJS({
  "node_modules/.pnpm/gray-matter@4.0.3/node_modules/gray-matter/lib/defaults.js"(exports3, module2) {
    "use strict";
    var engines3 = require_engines();
    var utils2 = require_utils9();
    module2.exports = function(options3) {
      const opts = Object.assign({}, options3);
      opts.delimiters = utils2.arrayify(opts.delims || opts.delimiters || "---");
      if (opts.delimiters.length === 1) {
        opts.delimiters.push(opts.delimiters[0]);
      }
      opts.language = (opts.language || opts.lang || "yaml").toLowerCase();
      opts.engines = Object.assign({}, engines3, opts.parsers, opts.engines);
      return opts;
    };
  }
});

// node_modules/.pnpm/gray-matter@4.0.3/node_modules/gray-matter/lib/engine.js
var require_engine = __commonJS({
  "node_modules/.pnpm/gray-matter@4.0.3/node_modules/gray-matter/lib/engine.js"(exports3, module2) {
    "use strict";
    module2.exports = function(name2, options3) {
      let engine = options3.engines[name2] || options3.engines[aliase(name2)];
      if (typeof engine === "undefined") {
        throw new Error('gray-matter engine "' + name2 + '" is not registered');
      }
      if (typeof engine === "function") {
        engine = { parse: engine };
      }
      return engine;
    };
    function aliase(name2) {
      switch (name2.toLowerCase()) {
        case "js":
        case "javascript":
          return "javascript";
        case "coffee":
        case "coffeescript":
        case "cson":
          return "coffee";
        case "yaml":
        case "yml":
          return "yaml";
        default: {
          return name2;
        }
      }
    }
  }
});

// node_modules/.pnpm/gray-matter@4.0.3/node_modules/gray-matter/lib/stringify.js
var require_stringify3 = __commonJS({
  "node_modules/.pnpm/gray-matter@4.0.3/node_modules/gray-matter/lib/stringify.js"(exports3, module2) {
    "use strict";
    var typeOf = require_kind_of();
    var getEngine = require_engine();
    var defaults = require_defaults2();
    module2.exports = function(file, data2, options3) {
      if (data2 == null && options3 == null) {
        switch (typeOf(file)) {
          case "object":
            data2 = file.data;
            options3 = {};
            break;
          case "string":
            return file;
          default: {
            throw new TypeError("expected file to be a string or object");
          }
        }
      }
      const str2 = file.content;
      const opts = defaults(options3);
      if (data2 == null) {
        if (!opts.data)
          return file;
        data2 = opts.data;
      }
      const language = file.language || opts.language;
      const engine = getEngine(language, opts);
      if (typeof engine.stringify !== "function") {
        throw new TypeError('expected "' + language + '.stringify" to be a function');
      }
      data2 = Object.assign({}, file.data, data2);
      const open2 = opts.delimiters[0];
      const close2 = opts.delimiters[1];
      const matter = engine.stringify(data2, options3).trim();
      let buf = "";
      if (matter !== "{}") {
        buf = newline(open2) + newline(matter) + newline(close2);
      }
      if (typeof file.excerpt === "string" && file.excerpt !== "") {
        if (str2.indexOf(file.excerpt.trim()) === -1) {
          buf += newline(file.excerpt) + newline(close2);
        }
      }
      return buf + newline(str2);
    };
    function newline(str2) {
      return str2.slice(-1) !== "\n" ? str2 + "\n" : str2;
    }
  }
});

// node_modules/.pnpm/gray-matter@4.0.3/node_modules/gray-matter/lib/excerpt.js
var require_excerpt = __commonJS({
  "node_modules/.pnpm/gray-matter@4.0.3/node_modules/gray-matter/lib/excerpt.js"(exports3, module2) {
    "use strict";
    var defaults = require_defaults2();
    module2.exports = function(file, options3) {
      const opts = defaults(options3);
      if (file.data == null) {
        file.data = {};
      }
      if (typeof opts.excerpt === "function") {
        return opts.excerpt(file, opts);
      }
      const sep2 = file.data.excerpt_separator || opts.excerpt_separator;
      if (sep2 == null && (opts.excerpt === false || opts.excerpt == null)) {
        return file;
      }
      const delimiter = typeof opts.excerpt === "string" ? opts.excerpt : sep2 || opts.delimiters[0];
      const idx = file.content.indexOf(delimiter);
      if (idx !== -1) {
        file.excerpt = file.content.slice(0, idx);
      }
      return file;
    };
  }
});

// node_modules/.pnpm/gray-matter@4.0.3/node_modules/gray-matter/lib/to-file.js
var require_to_file = __commonJS({
  "node_modules/.pnpm/gray-matter@4.0.3/node_modules/gray-matter/lib/to-file.js"(exports3, module2) {
    "use strict";
    var typeOf = require_kind_of();
    var stringify5 = require_stringify3();
    var utils2 = require_utils9();
    module2.exports = function(file) {
      if (typeOf(file) !== "object") {
        file = { content: file };
      }
      if (typeOf(file.data) !== "object") {
        file.data = {};
      }
      if (file.contents && file.content == null) {
        file.content = file.contents;
      }
      utils2.define(file, "orig", utils2.toBuffer(file.content));
      utils2.define(file, "language", file.language || "");
      utils2.define(file, "matter", file.matter || "");
      utils2.define(file, "stringify", function(data2, options3) {
        if (options3 && options3.language) {
          file.language = options3.language;
        }
        return stringify5(file, data2, options3);
      });
      file.content = utils2.toString(file.content);
      file.isEmpty = false;
      file.excerpt = "";
      return file;
    };
  }
});

// node_modules/.pnpm/gray-matter@4.0.3/node_modules/gray-matter/lib/parse.js
var require_parse6 = __commonJS({
  "node_modules/.pnpm/gray-matter@4.0.3/node_modules/gray-matter/lib/parse.js"(exports3, module2) {
    "use strict";
    var getEngine = require_engine();
    var defaults = require_defaults2();
    module2.exports = function(language, str2, options3) {
      const opts = defaults(options3);
      const engine = getEngine(language, opts);
      if (typeof engine.parse !== "function") {
        throw new TypeError('expected "' + language + '.parse" to be a function');
      }
      return engine.parse(str2, opts);
    };
  }
});

// node_modules/.pnpm/gray-matter@4.0.3/node_modules/gray-matter/index.js
var require_gray_matter = __commonJS({
  "node_modules/.pnpm/gray-matter@4.0.3/node_modules/gray-matter/index.js"(exports3, module2) {
    "use strict";
    var fs6 = require_fs();
    var sections = require_section_matter();
    var defaults = require_defaults2();
    var stringify5 = require_stringify3();
    var excerpt = require_excerpt();
    var engines3 = require_engines();
    var toFile = require_to_file();
    var parse7 = require_parse6();
    var utils2 = require_utils9();
    function matter(input, options3) {
      if (input === "") {
        return { data: {}, content: input, excerpt: "", orig: input };
      }
      let file = toFile(input);
      const cached = matter.cache[file.content];
      if (!options3) {
        if (cached) {
          file = Object.assign({}, cached);
          file.orig = cached.orig;
          return file;
        }
        matter.cache[file.content] = file;
      }
      return parseMatter(file, options3);
    }
    function parseMatter(file, options3) {
      const opts = defaults(options3);
      const open2 = opts.delimiters[0];
      const close2 = "\n" + opts.delimiters[1];
      let str2 = file.content;
      if (opts.language) {
        file.language = opts.language;
      }
      const openLen = open2.length;
      if (!utils2.startsWith(str2, open2, openLen)) {
        excerpt(file, opts);
        return file;
      }
      if (str2.charAt(openLen) === open2.slice(-1)) {
        return file;
      }
      str2 = str2.slice(openLen);
      const len = str2.length;
      const language = matter.language(str2, opts);
      if (language.name) {
        file.language = language.name;
        str2 = str2.slice(language.raw.length);
      }
      let closeIndex = str2.indexOf(close2);
      if (closeIndex === -1) {
        closeIndex = len;
      }
      file.matter = str2.slice(0, closeIndex);
      const block = file.matter.replace(/^\s*#[^\n]+/gm, "").trim();
      if (block === "") {
        file.isEmpty = true;
        file.empty = file.content;
        file.data = {};
      } else {
        file.data = parse7(file.language, file.matter, opts);
      }
      if (closeIndex === len) {
        file.content = "";
      } else {
        file.content = str2.slice(closeIndex + close2.length);
        if (file.content[0] === "\r") {
          file.content = file.content.slice(1);
        }
        if (file.content[0] === "\n") {
          file.content = file.content.slice(1);
        }
      }
      excerpt(file, opts);
      if (opts.sections === true || typeof opts.section === "function") {
        sections(file, opts.section);
      }
      return file;
    }
    matter.engines = engines3;
    matter.stringify = function(file, data2, options3) {
      if (typeof file === "string")
        file = matter(file, options3);
      return stringify5(file, data2, options3);
    };
    matter.read = function(filepath, options3) {
      const str2 = fs6.readFileSync(filepath, "utf8");
      const file = matter(str2, options3);
      file.path = filepath;
      return file;
    };
    matter.test = function(str2, options3) {
      return utils2.startsWith(str2, defaults(options3).delimiters[0]);
    };
    matter.language = function(str2, options3) {
      const opts = defaults(options3);
      const open2 = opts.delimiters[0];
      if (matter.test(str2)) {
        str2 = str2.slice(open2.length);
      }
      const language = str2.slice(0, str2.search(/\r?\n/));
      return {
        raw: language,
        name: language ? language.trim() : ""
      };
    };
    matter.cache = {};
    matter.clearCache = function() {
      matter.cache = {};
    };
    module2.exports = matter;
  }
});

// node_modules/.pnpm/markdown-it-emoji@2.0.2/node_modules/markdown-it-emoji/lib/data/full.json
var require_full = __commonJS({
  "node_modules/.pnpm/markdown-it-emoji@2.0.2/node_modules/markdown-it-emoji/lib/data/full.json"(exports3, module2) {
    module2.exports = {
      "100": "💯",
      "1234": "🔢",
      grinning: "😀",
      smiley: "😃",
      smile: "😄",
      grin: "😁",
      laughing: "😆",
      satisfied: "😆",
      sweat_smile: "😅",
      rofl: "🤣",
      joy: "😂",
      slightly_smiling_face: "🙂",
      upside_down_face: "🙃",
      wink: "😉",
      blush: "😊",
      innocent: "😇",
      smiling_face_with_three_hearts: "🥰",
      heart_eyes: "😍",
      star_struck: "🤩",
      kissing_heart: "😘",
      kissing: "😗",
      relaxed: "☺️",
      kissing_closed_eyes: "😚",
      kissing_smiling_eyes: "😙",
      smiling_face_with_tear: "🥲",
      yum: "😋",
      stuck_out_tongue: "😛",
      stuck_out_tongue_winking_eye: "😜",
      zany_face: "🤪",
      stuck_out_tongue_closed_eyes: "😝",
      money_mouth_face: "🤑",
      hugs: "🤗",
      hand_over_mouth: "🤭",
      shushing_face: "🤫",
      thinking: "🤔",
      zipper_mouth_face: "🤐",
      raised_eyebrow: "🤨",
      neutral_face: "😐",
      expressionless: "😑",
      no_mouth: "😶",
      smirk: "😏",
      unamused: "😒",
      roll_eyes: "🙄",
      grimacing: "😬",
      lying_face: "🤥",
      relieved: "😌",
      pensive: "😔",
      sleepy: "😪",
      drooling_face: "🤤",
      sleeping: "😴",
      mask: "😷",
      face_with_thermometer: "🤒",
      face_with_head_bandage: "🤕",
      nauseated_face: "🤢",
      vomiting_face: "🤮",
      sneezing_face: "🤧",
      hot_face: "🥵",
      cold_face: "🥶",
      woozy_face: "🥴",
      dizzy_face: "😵",
      exploding_head: "🤯",
      cowboy_hat_face: "🤠",
      partying_face: "🥳",
      disguised_face: "🥸",
      sunglasses: "😎",
      nerd_face: "🤓",
      monocle_face: "🧐",
      confused: "😕",
      worried: "😟",
      slightly_frowning_face: "🙁",
      frowning_face: "☹️",
      open_mouth: "😮",
      hushed: "😯",
      astonished: "😲",
      flushed: "😳",
      pleading_face: "🥺",
      frowning: "😦",
      anguished: "😧",
      fearful: "😨",
      cold_sweat: "😰",
      disappointed_relieved: "😥",
      cry: "😢",
      sob: "😭",
      scream: "😱",
      confounded: "😖",
      persevere: "😣",
      disappointed: "😞",
      sweat: "😓",
      weary: "😩",
      tired_face: "😫",
      yawning_face: "🥱",
      triumph: "😤",
      rage: "😡",
      pout: "😡",
      angry: "😠",
      cursing_face: "🤬",
      smiling_imp: "😈",
      imp: "👿",
      skull: "💀",
      skull_and_crossbones: "☠️",
      hankey: "💩",
      poop: "💩",
      shit: "💩",
      clown_face: "🤡",
      japanese_ogre: "👹",
      japanese_goblin: "👺",
      ghost: "👻",
      alien: "👽",
      space_invader: "👾",
      robot: "🤖",
      smiley_cat: "😺",
      smile_cat: "😸",
      joy_cat: "😹",
      heart_eyes_cat: "😻",
      smirk_cat: "😼",
      kissing_cat: "😽",
      scream_cat: "🙀",
      crying_cat_face: "😿",
      pouting_cat: "😾",
      see_no_evil: "🙈",
      hear_no_evil: "🙉",
      speak_no_evil: "🙊",
      kiss: "💋",
      love_letter: "💌",
      cupid: "💘",
      gift_heart: "💝",
      sparkling_heart: "💖",
      heartpulse: "💗",
      heartbeat: "💓",
      revolving_hearts: "💞",
      two_hearts: "💕",
      heart_decoration: "💟",
      heavy_heart_exclamation: "❣️",
      broken_heart: "💔",
      heart: "❤️",
      orange_heart: "🧡",
      yellow_heart: "💛",
      green_heart: "💚",
      blue_heart: "💙",
      purple_heart: "💜",
      brown_heart: "🤎",
      black_heart: "🖤",
      white_heart: "🤍",
      anger: "💢",
      boom: "💥",
      collision: "💥",
      dizzy: "💫",
      sweat_drops: "💦",
      dash: "💨",
      hole: "🕳️",
      bomb: "💣",
      speech_balloon: "💬",
      eye_speech_bubble: "👁️‍🗨️",
      left_speech_bubble: "🗨️",
      right_anger_bubble: "🗯️",
      thought_balloon: "💭",
      zzz: "💤",
      wave: "👋",
      raised_back_of_hand: "🤚",
      raised_hand_with_fingers_splayed: "🖐️",
      hand: "✋",
      raised_hand: "✋",
      vulcan_salute: "🖖",
      ok_hand: "👌",
      pinched_fingers: "🤌",
      pinching_hand: "🤏",
      v: "✌️",
      crossed_fingers: "🤞",
      love_you_gesture: "🤟",
      metal: "🤘",
      call_me_hand: "🤙",
      point_left: "👈",
      point_right: "👉",
      point_up_2: "👆",
      middle_finger: "🖕",
      fu: "🖕",
      point_down: "👇",
      point_up: "☝️",
      "+1": "👍",
      thumbsup: "👍",
      "-1": "👎",
      thumbsdown: "👎",
      fist_raised: "✊",
      fist: "✊",
      fist_oncoming: "👊",
      facepunch: "👊",
      punch: "👊",
      fist_left: "🤛",
      fist_right: "🤜",
      clap: "👏",
      raised_hands: "🙌",
      open_hands: "👐",
      palms_up_together: "🤲",
      handshake: "🤝",
      pray: "🙏",
      writing_hand: "✍️",
      nail_care: "💅",
      selfie: "🤳",
      muscle: "💪",
      mechanical_arm: "🦾",
      mechanical_leg: "🦿",
      leg: "🦵",
      foot: "🦶",
      ear: "👂",
      ear_with_hearing_aid: "🦻",
      nose: "👃",
      brain: "🧠",
      anatomical_heart: "🫀",
      lungs: "🫁",
      tooth: "🦷",
      bone: "🦴",
      eyes: "👀",
      eye: "👁️",
      tongue: "👅",
      lips: "👄",
      baby: "👶",
      child: "🧒",
      boy: "👦",
      girl: "👧",
      adult: "🧑",
      blond_haired_person: "👱",
      man: "👨",
      bearded_person: "🧔",
      red_haired_man: "👨‍🦰",
      curly_haired_man: "👨‍🦱",
      white_haired_man: "👨‍🦳",
      bald_man: "👨‍🦲",
      woman: "👩",
      red_haired_woman: "👩‍🦰",
      person_red_hair: "🧑‍🦰",
      curly_haired_woman: "👩‍🦱",
      person_curly_hair: "🧑‍🦱",
      white_haired_woman: "👩‍🦳",
      person_white_hair: "🧑‍🦳",
      bald_woman: "👩‍🦲",
      person_bald: "🧑‍🦲",
      blond_haired_woman: "👱‍♀️",
      blonde_woman: "👱‍♀️",
      blond_haired_man: "👱‍♂️",
      older_adult: "🧓",
      older_man: "👴",
      older_woman: "👵",
      frowning_person: "🙍",
      frowning_man: "🙍‍♂️",
      frowning_woman: "🙍‍♀️",
      pouting_face: "🙎",
      pouting_man: "🙎‍♂️",
      pouting_woman: "🙎‍♀️",
      no_good: "🙅",
      no_good_man: "🙅‍♂️",
      ng_man: "🙅‍♂️",
      no_good_woman: "🙅‍♀️",
      ng_woman: "🙅‍♀️",
      ok_person: "🙆",
      ok_man: "🙆‍♂️",
      ok_woman: "🙆‍♀️",
      tipping_hand_person: "💁",
      information_desk_person: "💁",
      tipping_hand_man: "💁‍♂️",
      sassy_man: "💁‍♂️",
      tipping_hand_woman: "💁‍♀️",
      sassy_woman: "💁‍♀️",
      raising_hand: "🙋",
      raising_hand_man: "🙋‍♂️",
      raising_hand_woman: "🙋‍♀️",
      deaf_person: "🧏",
      deaf_man: "🧏‍♂️",
      deaf_woman: "🧏‍♀️",
      bow: "🙇",
      bowing_man: "🙇‍♂️",
      bowing_woman: "🙇‍♀️",
      facepalm: "🤦",
      man_facepalming: "🤦‍♂️",
      woman_facepalming: "🤦‍♀️",
      shrug: "🤷",
      man_shrugging: "🤷‍♂️",
      woman_shrugging: "🤷‍♀️",
      health_worker: "🧑‍⚕️",
      man_health_worker: "👨‍⚕️",
      woman_health_worker: "👩‍⚕️",
      student: "🧑‍🎓",
      man_student: "👨‍🎓",
      woman_student: "👩‍🎓",
      teacher: "🧑‍🏫",
      man_teacher: "👨‍🏫",
      woman_teacher: "👩‍🏫",
      judge: "🧑‍⚖️",
      man_judge: "👨‍⚖️",
      woman_judge: "👩‍⚖️",
      farmer: "🧑‍🌾",
      man_farmer: "👨‍🌾",
      woman_farmer: "👩‍🌾",
      cook: "🧑‍🍳",
      man_cook: "👨‍🍳",
      woman_cook: "👩‍🍳",
      mechanic: "🧑‍🔧",
      man_mechanic: "👨‍🔧",
      woman_mechanic: "👩‍🔧",
      factory_worker: "🧑‍🏭",
      man_factory_worker: "👨‍🏭",
      woman_factory_worker: "👩‍🏭",
      office_worker: "🧑‍💼",
      man_office_worker: "👨‍💼",
      woman_office_worker: "👩‍💼",
      scientist: "🧑‍🔬",
      man_scientist: "👨‍🔬",
      woman_scientist: "👩‍🔬",
      technologist: "🧑‍💻",
      man_technologist: "👨‍💻",
      woman_technologist: "👩‍💻",
      singer: "🧑‍🎤",
      man_singer: "👨‍🎤",
      woman_singer: "👩‍🎤",
      artist: "🧑‍🎨",
      man_artist: "👨‍🎨",
      woman_artist: "👩‍🎨",
      pilot: "🧑‍✈️",
      man_pilot: "👨‍✈️",
      woman_pilot: "👩‍✈️",
      astronaut: "🧑‍🚀",
      man_astronaut: "👨‍🚀",
      woman_astronaut: "👩‍🚀",
      firefighter: "🧑‍🚒",
      man_firefighter: "👨‍🚒",
      woman_firefighter: "👩‍🚒",
      police_officer: "👮",
      cop: "👮",
      policeman: "👮‍♂️",
      policewoman: "👮‍♀️",
      detective: "🕵️",
      male_detective: "🕵️‍♂️",
      female_detective: "🕵️‍♀️",
      guard: "💂",
      guardsman: "💂‍♂️",
      guardswoman: "💂‍♀️",
      ninja: "🥷",
      construction_worker: "👷",
      construction_worker_man: "👷‍♂️",
      construction_worker_woman: "👷‍♀️",
      prince: "🤴",
      princess: "👸",
      person_with_turban: "👳",
      man_with_turban: "👳‍♂️",
      woman_with_turban: "👳‍♀️",
      man_with_gua_pi_mao: "👲",
      woman_with_headscarf: "🧕",
      person_in_tuxedo: "🤵",
      man_in_tuxedo: "🤵‍♂️",
      woman_in_tuxedo: "🤵‍♀️",
      person_with_veil: "👰",
      man_with_veil: "👰‍♂️",
      woman_with_veil: "👰‍♀️",
      bride_with_veil: "👰‍♀️",
      pregnant_woman: "🤰",
      breast_feeding: "🤱",
      woman_feeding_baby: "👩‍🍼",
      man_feeding_baby: "👨‍🍼",
      person_feeding_baby: "🧑‍🍼",
      angel: "👼",
      santa: "🎅",
      mrs_claus: "🤶",
      mx_claus: "🧑‍🎄",
      superhero: "🦸",
      superhero_man: "🦸‍♂️",
      superhero_woman: "🦸‍♀️",
      supervillain: "🦹",
      supervillain_man: "🦹‍♂️",
      supervillain_woman: "🦹‍♀️",
      mage: "🧙",
      mage_man: "🧙‍♂️",
      mage_woman: "🧙‍♀️",
      fairy: "🧚",
      fairy_man: "🧚‍♂️",
      fairy_woman: "🧚‍♀️",
      vampire: "🧛",
      vampire_man: "🧛‍♂️",
      vampire_woman: "🧛‍♀️",
      merperson: "🧜",
      merman: "🧜‍♂️",
      mermaid: "🧜‍♀️",
      elf: "🧝",
      elf_man: "🧝‍♂️",
      elf_woman: "🧝‍♀️",
      genie: "🧞",
      genie_man: "🧞‍♂️",
      genie_woman: "🧞‍♀️",
      zombie: "🧟",
      zombie_man: "🧟‍♂️",
      zombie_woman: "🧟‍♀️",
      massage: "💆",
      massage_man: "💆‍♂️",
      massage_woman: "💆‍♀️",
      haircut: "💇",
      haircut_man: "💇‍♂️",
      haircut_woman: "💇‍♀️",
      walking: "🚶",
      walking_man: "🚶‍♂️",
      walking_woman: "🚶‍♀️",
      standing_person: "🧍",
      standing_man: "🧍‍♂️",
      standing_woman: "🧍‍♀️",
      kneeling_person: "🧎",
      kneeling_man: "🧎‍♂️",
      kneeling_woman: "🧎‍♀️",
      person_with_probing_cane: "🧑‍🦯",
      man_with_probing_cane: "👨‍🦯",
      woman_with_probing_cane: "👩‍🦯",
      person_in_motorized_wheelchair: "🧑‍🦼",
      man_in_motorized_wheelchair: "👨‍🦼",
      woman_in_motorized_wheelchair: "👩‍🦼",
      person_in_manual_wheelchair: "🧑‍🦽",
      man_in_manual_wheelchair: "👨‍🦽",
      woman_in_manual_wheelchair: "👩‍🦽",
      runner: "🏃",
      running: "🏃",
      running_man: "🏃‍♂️",
      running_woman: "🏃‍♀️",
      woman_dancing: "💃",
      dancer: "💃",
      man_dancing: "🕺",
      business_suit_levitating: "🕴️",
      dancers: "👯",
      dancing_men: "👯‍♂️",
      dancing_women: "👯‍♀️",
      sauna_person: "🧖",
      sauna_man: "🧖‍♂️",
      sauna_woman: "🧖‍♀️",
      climbing: "🧗",
      climbing_man: "🧗‍♂️",
      climbing_woman: "🧗‍♀️",
      person_fencing: "🤺",
      horse_racing: "🏇",
      skier: "⛷️",
      snowboarder: "🏂",
      golfing: "🏌️",
      golfing_man: "🏌️‍♂️",
      golfing_woman: "🏌️‍♀️",
      surfer: "🏄",
      surfing_man: "🏄‍♂️",
      surfing_woman: "🏄‍♀️",
      rowboat: "🚣",
      rowing_man: "🚣‍♂️",
      rowing_woman: "🚣‍♀️",
      swimmer: "🏊",
      swimming_man: "🏊‍♂️",
      swimming_woman: "🏊‍♀️",
      bouncing_ball_person: "⛹️",
      bouncing_ball_man: "⛹️‍♂️",
      basketball_man: "⛹️‍♂️",
      bouncing_ball_woman: "⛹️‍♀️",
      basketball_woman: "⛹️‍♀️",
      weight_lifting: "🏋️",
      weight_lifting_man: "🏋️‍♂️",
      weight_lifting_woman: "🏋️‍♀️",
      bicyclist: "🚴",
      biking_man: "🚴‍♂️",
      biking_woman: "🚴‍♀️",
      mountain_bicyclist: "🚵",
      mountain_biking_man: "🚵‍♂️",
      mountain_biking_woman: "🚵‍♀️",
      cartwheeling: "🤸",
      man_cartwheeling: "🤸‍♂️",
      woman_cartwheeling: "🤸‍♀️",
      wrestling: "🤼",
      men_wrestling: "🤼‍♂️",
      women_wrestling: "🤼‍♀️",
      water_polo: "🤽",
      man_playing_water_polo: "🤽‍♂️",
      woman_playing_water_polo: "🤽‍♀️",
      handball_person: "🤾",
      man_playing_handball: "🤾‍♂️",
      woman_playing_handball: "🤾‍♀️",
      juggling_person: "🤹",
      man_juggling: "🤹‍♂️",
      woman_juggling: "🤹‍♀️",
      lotus_position: "🧘",
      lotus_position_man: "🧘‍♂️",
      lotus_position_woman: "🧘‍♀️",
      bath: "🛀",
      sleeping_bed: "🛌",
      people_holding_hands: "🧑‍🤝‍🧑",
      two_women_holding_hands: "👭",
      couple: "👫",
      two_men_holding_hands: "👬",
      couplekiss: "💏",
      couplekiss_man_woman: "👩‍❤️‍💋‍👨",
      couplekiss_man_man: "👨‍❤️‍💋‍👨",
      couplekiss_woman_woman: "👩‍❤️‍💋‍👩",
      couple_with_heart: "💑",
      couple_with_heart_woman_man: "👩‍❤️‍👨",
      couple_with_heart_man_man: "👨‍❤️‍👨",
      couple_with_heart_woman_woman: "👩‍❤️‍👩",
      family: "👪",
      family_man_woman_boy: "👨‍👩‍👦",
      family_man_woman_girl: "👨‍👩‍👧",
      family_man_woman_girl_boy: "👨‍👩‍👧‍👦",
      family_man_woman_boy_boy: "👨‍👩‍👦‍👦",
      family_man_woman_girl_girl: "👨‍👩‍👧‍👧",
      family_man_man_boy: "👨‍👨‍👦",
      family_man_man_girl: "👨‍👨‍👧",
      family_man_man_girl_boy: "👨‍👨‍👧‍👦",
      family_man_man_boy_boy: "👨‍👨‍👦‍👦",
      family_man_man_girl_girl: "👨‍👨‍👧‍👧",
      family_woman_woman_boy: "👩‍👩‍👦",
      family_woman_woman_girl: "👩‍👩‍👧",
      family_woman_woman_girl_boy: "👩‍👩‍👧‍👦",
      family_woman_woman_boy_boy: "👩‍👩‍👦‍👦",
      family_woman_woman_girl_girl: "👩‍👩‍👧‍👧",
      family_man_boy: "👨‍👦",
      family_man_boy_boy: "👨‍👦‍👦",
      family_man_girl: "👨‍👧",
      family_man_girl_boy: "👨‍👧‍👦",
      family_man_girl_girl: "👨‍👧‍👧",
      family_woman_boy: "👩‍👦",
      family_woman_boy_boy: "👩‍👦‍👦",
      family_woman_girl: "👩‍👧",
      family_woman_girl_boy: "👩‍👧‍👦",
      family_woman_girl_girl: "👩‍👧‍👧",
      speaking_head: "🗣️",
      bust_in_silhouette: "👤",
      busts_in_silhouette: "👥",
      people_hugging: "🫂",
      footprints: "👣",
      monkey_face: "🐵",
      monkey: "🐒",
      gorilla: "🦍",
      orangutan: "🦧",
      dog: "🐶",
      dog2: "🐕",
      guide_dog: "🦮",
      service_dog: "🐕‍🦺",
      poodle: "🐩",
      wolf: "🐺",
      fox_face: "🦊",
      raccoon: "🦝",
      cat: "🐱",
      cat2: "🐈",
      black_cat: "🐈‍⬛",
      lion: "🦁",
      tiger: "🐯",
      tiger2: "🐅",
      leopard: "🐆",
      horse: "🐴",
      racehorse: "🐎",
      unicorn: "🦄",
      zebra: "🦓",
      deer: "🦌",
      bison: "🦬",
      cow: "🐮",
      ox: "🐂",
      water_buffalo: "🐃",
      cow2: "🐄",
      pig: "🐷",
      pig2: "🐖",
      boar: "🐗",
      pig_nose: "🐽",
      ram: "🐏",
      sheep: "🐑",
      goat: "🐐",
      dromedary_camel: "🐪",
      camel: "🐫",
      llama: "🦙",
      giraffe: "🦒",
      elephant: "🐘",
      mammoth: "🦣",
      rhinoceros: "🦏",
      hippopotamus: "🦛",
      mouse: "🐭",
      mouse2: "🐁",
      rat: "🐀",
      hamster: "🐹",
      rabbit: "🐰",
      rabbit2: "🐇",
      chipmunk: "🐿️",
      beaver: "🦫",
      hedgehog: "🦔",
      bat: "🦇",
      bear: "🐻",
      polar_bear: "🐻‍❄️",
      koala: "🐨",
      panda_face: "🐼",
      sloth: "🦥",
      otter: "🦦",
      skunk: "🦨",
      kangaroo: "🦘",
      badger: "🦡",
      feet: "🐾",
      paw_prints: "🐾",
      turkey: "🦃",
      chicken: "🐔",
      rooster: "🐓",
      hatching_chick: "🐣",
      baby_chick: "🐤",
      hatched_chick: "🐥",
      bird: "🐦",
      penguin: "🐧",
      dove: "🕊️",
      eagle: "🦅",
      duck: "🦆",
      swan: "🦢",
      owl: "🦉",
      dodo: "🦤",
      feather: "🪶",
      flamingo: "🦩",
      peacock: "🦚",
      parrot: "🦜",
      frog: "🐸",
      crocodile: "🐊",
      turtle: "🐢",
      lizard: "🦎",
      snake: "🐍",
      dragon_face: "🐲",
      dragon: "🐉",
      sauropod: "🦕",
      "t-rex": "🦖",
      whale: "🐳",
      whale2: "🐋",
      dolphin: "🐬",
      flipper: "🐬",
      seal: "🦭",
      fish: "🐟",
      tropical_fish: "🐠",
      blowfish: "🐡",
      shark: "🦈",
      octopus: "🐙",
      shell: "🐚",
      snail: "🐌",
      butterfly: "🦋",
      bug: "🐛",
      ant: "🐜",
      bee: "🐝",
      honeybee: "🐝",
      beetle: "🪲",
      lady_beetle: "🐞",
      cricket: "🦗",
      cockroach: "🪳",
      spider: "🕷️",
      spider_web: "🕸️",
      scorpion: "🦂",
      mosquito: "🦟",
      fly: "🪰",
      worm: "🪱",
      microbe: "🦠",
      bouquet: "💐",
      cherry_blossom: "🌸",
      white_flower: "💮",
      rosette: "🏵️",
      rose: "🌹",
      wilted_flower: "🥀",
      hibiscus: "🌺",
      sunflower: "🌻",
      blossom: "🌼",
      tulip: "🌷",
      seedling: "🌱",
      potted_plant: "🪴",
      evergreen_tree: "🌲",
      deciduous_tree: "🌳",
      palm_tree: "🌴",
      cactus: "🌵",
      ear_of_rice: "🌾",
      herb: "🌿",
      shamrock: "☘️",
      four_leaf_clover: "🍀",
      maple_leaf: "🍁",
      fallen_leaf: "🍂",
      leaves: "🍃",
      grapes: "🍇",
      melon: "🍈",
      watermelon: "🍉",
      tangerine: "🍊",
      orange: "🍊",
      mandarin: "🍊",
      lemon: "🍋",
      banana: "🍌",
      pineapple: "🍍",
      mango: "🥭",
      apple: "🍎",
      green_apple: "🍏",
      pear: "🍐",
      peach: "🍑",
      cherries: "🍒",
      strawberry: "🍓",
      blueberries: "🫐",
      kiwi_fruit: "🥝",
      tomato: "🍅",
      olive: "🫒",
      coconut: "🥥",
      avocado: "🥑",
      eggplant: "🍆",
      potato: "🥔",
      carrot: "🥕",
      corn: "🌽",
      hot_pepper: "🌶️",
      bell_pepper: "🫑",
      cucumber: "🥒",
      leafy_green: "🥬",
      broccoli: "🥦",
      garlic: "🧄",
      onion: "🧅",
      mushroom: "🍄",
      peanuts: "🥜",
      chestnut: "🌰",
      bread: "🍞",
      croissant: "🥐",
      baguette_bread: "🥖",
      flatbread: "🫓",
      pretzel: "🥨",
      bagel: "🥯",
      pancakes: "🥞",
      waffle: "🧇",
      cheese: "🧀",
      meat_on_bone: "🍖",
      poultry_leg: "🍗",
      cut_of_meat: "🥩",
      bacon: "🥓",
      hamburger: "🍔",
      fries: "🍟",
      pizza: "🍕",
      hotdog: "🌭",
      sandwich: "🥪",
      taco: "🌮",
      burrito: "🌯",
      tamale: "🫔",
      stuffed_flatbread: "🥙",
      falafel: "🧆",
      egg: "🥚",
      fried_egg: "🍳",
      shallow_pan_of_food: "🥘",
      stew: "🍲",
      fondue: "🫕",
      bowl_with_spoon: "🥣",
      green_salad: "🥗",
      popcorn: "🍿",
      butter: "🧈",
      salt: "🧂",
      canned_food: "🥫",
      bento: "🍱",
      rice_cracker: "🍘",
      rice_ball: "🍙",
      rice: "🍚",
      curry: "🍛",
      ramen: "🍜",
      spaghetti: "🍝",
      sweet_potato: "🍠",
      oden: "🍢",
      sushi: "🍣",
      fried_shrimp: "🍤",
      fish_cake: "🍥",
      moon_cake: "🥮",
      dango: "🍡",
      dumpling: "🥟",
      fortune_cookie: "🥠",
      takeout_box: "🥡",
      crab: "🦀",
      lobster: "🦞",
      shrimp: "🦐",
      squid: "🦑",
      oyster: "🦪",
      icecream: "🍦",
      shaved_ice: "🍧",
      ice_cream: "🍨",
      doughnut: "🍩",
      cookie: "🍪",
      birthday: "🎂",
      cake: "🍰",
      cupcake: "🧁",
      pie: "🥧",
      chocolate_bar: "🍫",
      candy: "🍬",
      lollipop: "🍭",
      custard: "🍮",
      honey_pot: "🍯",
      baby_bottle: "🍼",
      milk_glass: "🥛",
      coffee: "☕",
      teapot: "🫖",
      tea: "🍵",
      sake: "🍶",
      champagne: "🍾",
      wine_glass: "🍷",
      cocktail: "🍸",
      tropical_drink: "🍹",
      beer: "🍺",
      beers: "🍻",
      clinking_glasses: "🥂",
      tumbler_glass: "🥃",
      cup_with_straw: "🥤",
      bubble_tea: "🧋",
      beverage_box: "🧃",
      mate: "🧉",
      ice_cube: "🧊",
      chopsticks: "🥢",
      plate_with_cutlery: "🍽️",
      fork_and_knife: "🍴",
      spoon: "🥄",
      hocho: "🔪",
      knife: "🔪",
      amphora: "🏺",
      earth_africa: "🌍",
      earth_americas: "🌎",
      earth_asia: "🌏",
      globe_with_meridians: "🌐",
      world_map: "🗺️",
      japan: "🗾",
      compass: "🧭",
      mountain_snow: "🏔️",
      mountain: "⛰️",
      volcano: "🌋",
      mount_fuji: "🗻",
      camping: "🏕️",
      beach_umbrella: "🏖️",
      desert: "🏜️",
      desert_island: "🏝️",
      national_park: "🏞️",
      stadium: "🏟️",
      classical_building: "🏛️",
      building_construction: "🏗️",
      bricks: "🧱",
      rock: "🪨",
      wood: "🪵",
      hut: "🛖",
      houses: "🏘️",
      derelict_house: "🏚️",
      house: "🏠",
      house_with_garden: "🏡",
      office: "🏢",
      post_office: "🏣",
      european_post_office: "🏤",
      hospital: "🏥",
      bank: "🏦",
      hotel: "🏨",
      love_hotel: "🏩",
      convenience_store: "🏪",
      school: "🏫",
      department_store: "🏬",
      factory: "🏭",
      japanese_castle: "🏯",
      european_castle: "🏰",
      wedding: "💒",
      tokyo_tower: "🗼",
      statue_of_liberty: "🗽",
      church: "⛪",
      mosque: "🕌",
      hindu_temple: "🛕",
      synagogue: "🕍",
      shinto_shrine: "⛩️",
      kaaba: "🕋",
      fountain: "⛲",
      tent: "⛺",
      foggy: "🌁",
      night_with_stars: "🌃",
      cityscape: "🏙️",
      sunrise_over_mountains: "🌄",
      sunrise: "🌅",
      city_sunset: "🌆",
      city_sunrise: "🌇",
      bridge_at_night: "🌉",
      hotsprings: "♨️",
      carousel_horse: "🎠",
      ferris_wheel: "🎡",
      roller_coaster: "🎢",
      barber: "💈",
      circus_tent: "🎪",
      steam_locomotive: "🚂",
      railway_car: "🚃",
      bullettrain_side: "🚄",
      bullettrain_front: "🚅",
      train2: "🚆",
      metro: "🚇",
      light_rail: "🚈",
      station: "🚉",
      tram: "🚊",
      monorail: "🚝",
      mountain_railway: "🚞",
      train: "🚋",
      bus: "🚌",
      oncoming_bus: "🚍",
      trolleybus: "🚎",
      minibus: "🚐",
      ambulance: "🚑",
      fire_engine: "🚒",
      police_car: "🚓",
      oncoming_police_car: "🚔",
      taxi: "🚕",
      oncoming_taxi: "🚖",
      car: "🚗",
      red_car: "🚗",
      oncoming_automobile: "🚘",
      blue_car: "🚙",
      pickup_truck: "🛻",
      truck: "🚚",
      articulated_lorry: "🚛",
      tractor: "🚜",
      racing_car: "🏎️",
      motorcycle: "🏍️",
      motor_scooter: "🛵",
      manual_wheelchair: "🦽",
      motorized_wheelchair: "🦼",
      auto_rickshaw: "🛺",
      bike: "🚲",
      kick_scooter: "🛴",
      skateboard: "🛹",
      roller_skate: "🛼",
      busstop: "🚏",
      motorway: "🛣️",
      railway_track: "🛤️",
      oil_drum: "🛢️",
      fuelpump: "⛽",
      rotating_light: "🚨",
      traffic_light: "🚥",
      vertical_traffic_light: "🚦",
      stop_sign: "🛑",
      construction: "🚧",
      anchor: "⚓",
      boat: "⛵",
      sailboat: "⛵",
      canoe: "🛶",
      speedboat: "🚤",
      passenger_ship: "🛳️",
      ferry: "⛴️",
      motor_boat: "🛥️",
      ship: "🚢",
      airplane: "✈️",
      small_airplane: "🛩️",
      flight_departure: "🛫",
      flight_arrival: "🛬",
      parachute: "🪂",
      seat: "💺",
      helicopter: "🚁",
      suspension_railway: "🚟",
      mountain_cableway: "🚠",
      aerial_tramway: "🚡",
      artificial_satellite: "🛰️",
      rocket: "🚀",
      flying_saucer: "🛸",
      bellhop_bell: "🛎️",
      luggage: "🧳",
      hourglass: "⌛",
      hourglass_flowing_sand: "⏳",
      watch: "⌚",
      alarm_clock: "⏰",
      stopwatch: "⏱️",
      timer_clock: "⏲️",
      mantelpiece_clock: "🕰️",
      clock12: "🕛",
      clock1230: "🕧",
      clock1: "🕐",
      clock130: "🕜",
      clock2: "🕑",
      clock230: "🕝",
      clock3: "🕒",
      clock330: "🕞",
      clock4: "🕓",
      clock430: "🕟",
      clock5: "🕔",
      clock530: "🕠",
      clock6: "🕕",
      clock630: "🕡",
      clock7: "🕖",
      clock730: "🕢",
      clock8: "🕗",
      clock830: "🕣",
      clock9: "🕘",
      clock930: "🕤",
      clock10: "🕙",
      clock1030: "🕥",
      clock11: "🕚",
      clock1130: "🕦",
      new_moon: "🌑",
      waxing_crescent_moon: "🌒",
      first_quarter_moon: "🌓",
      moon: "🌔",
      waxing_gibbous_moon: "🌔",
      full_moon: "🌕",
      waning_gibbous_moon: "🌖",
      last_quarter_moon: "🌗",
      waning_crescent_moon: "🌘",
      crescent_moon: "🌙",
      new_moon_with_face: "🌚",
      first_quarter_moon_with_face: "🌛",
      last_quarter_moon_with_face: "🌜",
      thermometer: "🌡️",
      sunny: "☀️",
      full_moon_with_face: "🌝",
      sun_with_face: "🌞",
      ringed_planet: "🪐",
      star: "⭐",
      star2: "🌟",
      stars: "🌠",
      milky_way: "🌌",
      cloud: "☁️",
      partly_sunny: "⛅",
      cloud_with_lightning_and_rain: "⛈️",
      sun_behind_small_cloud: "🌤️",
      sun_behind_large_cloud: "🌥️",
      sun_behind_rain_cloud: "🌦️",
      cloud_with_rain: "🌧️",
      cloud_with_snow: "🌨️",
      cloud_with_lightning: "🌩️",
      tornado: "🌪️",
      fog: "🌫️",
      wind_face: "🌬️",
      cyclone: "🌀",
      rainbow: "🌈",
      closed_umbrella: "🌂",
      open_umbrella: "☂️",
      umbrella: "☔",
      parasol_on_ground: "⛱️",
      zap: "⚡",
      snowflake: "❄️",
      snowman_with_snow: "☃️",
      snowman: "⛄",
      comet: "☄️",
      fire: "🔥",
      droplet: "💧",
      ocean: "🌊",
      jack_o_lantern: "🎃",
      christmas_tree: "🎄",
      fireworks: "🎆",
      sparkler: "🎇",
      firecracker: "🧨",
      sparkles: "✨",
      balloon: "🎈",
      tada: "🎉",
      confetti_ball: "🎊",
      tanabata_tree: "🎋",
      bamboo: "🎍",
      dolls: "🎎",
      flags: "🎏",
      wind_chime: "🎐",
      rice_scene: "🎑",
      red_envelope: "🧧",
      ribbon: "🎀",
      gift: "🎁",
      reminder_ribbon: "🎗️",
      tickets: "🎟️",
      ticket: "🎫",
      medal_military: "🎖️",
      trophy: "🏆",
      medal_sports: "🏅",
      "1st_place_medal": "🥇",
      "2nd_place_medal": "🥈",
      "3rd_place_medal": "🥉",
      soccer: "⚽",
      baseball: "⚾",
      softball: "🥎",
      basketball: "🏀",
      volleyball: "🏐",
      football: "🏈",
      rugby_football: "🏉",
      tennis: "🎾",
      flying_disc: "🥏",
      bowling: "🎳",
      cricket_game: "🏏",
      field_hockey: "🏑",
      ice_hockey: "🏒",
      lacrosse: "🥍",
      ping_pong: "🏓",
      badminton: "🏸",
      boxing_glove: "🥊",
      martial_arts_uniform: "🥋",
      goal_net: "🥅",
      golf: "⛳",
      ice_skate: "⛸️",
      fishing_pole_and_fish: "🎣",
      diving_mask: "🤿",
      running_shirt_with_sash: "🎽",
      ski: "🎿",
      sled: "🛷",
      curling_stone: "🥌",
      dart: "🎯",
      yo_yo: "🪀",
      kite: "🪁",
      "8ball": "🎱",
      crystal_ball: "🔮",
      magic_wand: "🪄",
      nazar_amulet: "🧿",
      video_game: "🎮",
      joystick: "🕹️",
      slot_machine: "🎰",
      game_die: "🎲",
      jigsaw: "🧩",
      teddy_bear: "🧸",
      pinata: "🪅",
      nesting_dolls: "🪆",
      spades: "♠️",
      hearts: "♥️",
      diamonds: "♦️",
      clubs: "♣️",
      chess_pawn: "♟️",
      black_joker: "🃏",
      mahjong: "🀄",
      flower_playing_cards: "🎴",
      performing_arts: "🎭",
      framed_picture: "🖼️",
      art: "🎨",
      thread: "🧵",
      sewing_needle: "🪡",
      yarn: "🧶",
      knot: "🪢",
      eyeglasses: "👓",
      dark_sunglasses: "🕶️",
      goggles: "🥽",
      lab_coat: "🥼",
      safety_vest: "🦺",
      necktie: "👔",
      shirt: "👕",
      tshirt: "👕",
      jeans: "👖",
      scarf: "🧣",
      gloves: "🧤",
      coat: "🧥",
      socks: "🧦",
      dress: "👗",
      kimono: "👘",
      sari: "🥻",
      one_piece_swimsuit: "🩱",
      swim_brief: "🩲",
      shorts: "🩳",
      bikini: "👙",
      womans_clothes: "👚",
      purse: "👛",
      handbag: "👜",
      pouch: "👝",
      shopping: "🛍️",
      school_satchel: "🎒",
      thong_sandal: "🩴",
      mans_shoe: "👞",
      shoe: "👞",
      athletic_shoe: "👟",
      hiking_boot: "🥾",
      flat_shoe: "🥿",
      high_heel: "👠",
      sandal: "👡",
      ballet_shoes: "🩰",
      boot: "👢",
      crown: "👑",
      womans_hat: "👒",
      tophat: "🎩",
      mortar_board: "🎓",
      billed_cap: "🧢",
      military_helmet: "🪖",
      rescue_worker_helmet: "⛑️",
      prayer_beads: "📿",
      lipstick: "💄",
      ring: "💍",
      gem: "💎",
      mute: "🔇",
      speaker: "🔈",
      sound: "🔉",
      loud_sound: "🔊",
      loudspeaker: "📢",
      mega: "📣",
      postal_horn: "📯",
      bell: "🔔",
      no_bell: "🔕",
      musical_score: "🎼",
      musical_note: "🎵",
      notes: "🎶",
      studio_microphone: "🎙️",
      level_slider: "🎚️",
      control_knobs: "🎛️",
      microphone: "🎤",
      headphones: "🎧",
      radio: "📻",
      saxophone: "🎷",
      accordion: "🪗",
      guitar: "🎸",
      musical_keyboard: "🎹",
      trumpet: "🎺",
      violin: "🎻",
      banjo: "🪕",
      drum: "🥁",
      long_drum: "🪘",
      iphone: "📱",
      calling: "📲",
      phone: "☎️",
      telephone: "☎️",
      telephone_receiver: "📞",
      pager: "📟",
      fax: "📠",
      battery: "🔋",
      electric_plug: "🔌",
      computer: "💻",
      desktop_computer: "🖥️",
      printer: "🖨️",
      keyboard: "⌨️",
      computer_mouse: "🖱️",
      trackball: "🖲️",
      minidisc: "💽",
      floppy_disk: "💾",
      cd: "💿",
      dvd: "📀",
      abacus: "🧮",
      movie_camera: "🎥",
      film_strip: "🎞️",
      film_projector: "📽️",
      clapper: "🎬",
      tv: "📺",
      camera: "📷",
      camera_flash: "📸",
      video_camera: "📹",
      vhs: "📼",
      mag: "🔍",
      mag_right: "🔎",
      candle: "🕯️",
      bulb: "💡",
      flashlight: "🔦",
      izakaya_lantern: "🏮",
      lantern: "🏮",
      diya_lamp: "🪔",
      notebook_with_decorative_cover: "📔",
      closed_book: "📕",
      book: "📖",
      open_book: "📖",
      green_book: "📗",
      blue_book: "📘",
      orange_book: "📙",
      books: "📚",
      notebook: "📓",
      ledger: "📒",
      page_with_curl: "📃",
      scroll: "📜",
      page_facing_up: "📄",
      newspaper: "📰",
      newspaper_roll: "🗞️",
      bookmark_tabs: "📑",
      bookmark: "🔖",
      label: "🏷️",
      moneybag: "💰",
      coin: "🪙",
      yen: "💴",
      dollar: "💵",
      euro: "💶",
      pound: "💷",
      money_with_wings: "💸",
      credit_card: "💳",
      receipt: "🧾",
      chart: "💹",
      envelope: "✉️",
      email: "📧",
      "e-mail": "📧",
      incoming_envelope: "📨",
      envelope_with_arrow: "📩",
      outbox_tray: "📤",
      inbox_tray: "📥",
      package: "📦",
      mailbox: "📫",
      mailbox_closed: "📪",
      mailbox_with_mail: "📬",
      mailbox_with_no_mail: "📭",
      postbox: "📮",
      ballot_box: "🗳️",
      pencil2: "✏️",
      black_nib: "✒️",
      fountain_pen: "🖋️",
      pen: "🖊️",
      paintbrush: "🖌️",
      crayon: "🖍️",
      memo: "📝",
      pencil: "📝",
      briefcase: "💼",
      file_folder: "📁",
      open_file_folder: "📂",
      card_index_dividers: "🗂️",
      date: "📅",
      calendar: "📆",
      spiral_notepad: "🗒️",
      spiral_calendar: "🗓️",
      card_index: "📇",
      chart_with_upwards_trend: "📈",
      chart_with_downwards_trend: "📉",
      bar_chart: "📊",
      clipboard: "📋",
      pushpin: "📌",
      round_pushpin: "📍",
      paperclip: "📎",
      paperclips: "🖇️",
      straight_ruler: "📏",
      triangular_ruler: "📐",
      scissors: "✂️",
      card_file_box: "🗃️",
      file_cabinet: "🗄️",
      wastebasket: "🗑️",
      lock: "🔒",
      unlock: "🔓",
      lock_with_ink_pen: "🔏",
      closed_lock_with_key: "🔐",
      key: "🔑",
      old_key: "🗝️",
      hammer: "🔨",
      axe: "🪓",
      pick: "⛏️",
      hammer_and_pick: "⚒️",
      hammer_and_wrench: "🛠️",
      dagger: "🗡️",
      crossed_swords: "⚔️",
      gun: "🔫",
      boomerang: "🪃",
      bow_and_arrow: "🏹",
      shield: "🛡️",
      carpentry_saw: "🪚",
      wrench: "🔧",
      screwdriver: "🪛",
      nut_and_bolt: "🔩",
      gear: "⚙️",
      clamp: "🗜️",
      balance_scale: "⚖️",
      probing_cane: "🦯",
      link: "🔗",
      chains: "⛓️",
      hook: "🪝",
      toolbox: "🧰",
      magnet: "🧲",
      ladder: "🪜",
      alembic: "⚗️",
      test_tube: "🧪",
      petri_dish: "🧫",
      dna: "🧬",
      microscope: "🔬",
      telescope: "🔭",
      satellite: "📡",
      syringe: "💉",
      drop_of_blood: "🩸",
      pill: "💊",
      adhesive_bandage: "🩹",
      stethoscope: "🩺",
      door: "🚪",
      elevator: "🛗",
      mirror: "🪞",
      window: "🪟",
      bed: "🛏️",
      couch_and_lamp: "🛋️",
      chair: "🪑",
      toilet: "🚽",
      plunger: "🪠",
      shower: "🚿",
      bathtub: "🛁",
      mouse_trap: "🪤",
      razor: "🪒",
      lotion_bottle: "🧴",
      safety_pin: "🧷",
      broom: "🧹",
      basket: "🧺",
      roll_of_paper: "🧻",
      bucket: "🪣",
      soap: "🧼",
      toothbrush: "🪥",
      sponge: "🧽",
      fire_extinguisher: "🧯",
      shopping_cart: "🛒",
      smoking: "🚬",
      coffin: "⚰️",
      headstone: "🪦",
      funeral_urn: "⚱️",
      moyai: "🗿",
      placard: "🪧",
      atm: "🏧",
      put_litter_in_its_place: "🚮",
      potable_water: "🚰",
      wheelchair: "♿",
      mens: "🚹",
      womens: "🚺",
      restroom: "🚻",
      baby_symbol: "🚼",
      wc: "🚾",
      passport_control: "🛂",
      customs: "🛃",
      baggage_claim: "🛄",
      left_luggage: "🛅",
      warning: "⚠️",
      children_crossing: "🚸",
      no_entry: "⛔",
      no_entry_sign: "🚫",
      no_bicycles: "🚳",
      no_smoking: "🚭",
      do_not_litter: "🚯",
      "non-potable_water": "🚱",
      no_pedestrians: "🚷",
      no_mobile_phones: "📵",
      underage: "🔞",
      radioactive: "☢️",
      biohazard: "☣️",
      arrow_up: "⬆️",
      arrow_upper_right: "↗️",
      arrow_right: "➡️",
      arrow_lower_right: "↘️",
      arrow_down: "⬇️",
      arrow_lower_left: "↙️",
      arrow_left: "⬅️",
      arrow_upper_left: "↖️",
      arrow_up_down: "↕️",
      left_right_arrow: "↔️",
      leftwards_arrow_with_hook: "↩️",
      arrow_right_hook: "↪️",
      arrow_heading_up: "⤴️",
      arrow_heading_down: "⤵️",
      arrows_clockwise: "🔃",
      arrows_counterclockwise: "🔄",
      back: "🔙",
      end: "🔚",
      on: "🔛",
      soon: "🔜",
      top: "🔝",
      place_of_worship: "🛐",
      atom_symbol: "⚛️",
      om: "🕉️",
      star_of_david: "✡️",
      wheel_of_dharma: "☸️",
      yin_yang: "☯️",
      latin_cross: "✝️",
      orthodox_cross: "☦️",
      star_and_crescent: "☪️",
      peace_symbol: "☮️",
      menorah: "🕎",
      six_pointed_star: "🔯",
      aries: "♈",
      taurus: "♉",
      gemini: "♊",
      cancer: "♋",
      leo: "♌",
      virgo: "♍",
      libra: "♎",
      scorpius: "♏",
      sagittarius: "♐",
      capricorn: "♑",
      aquarius: "♒",
      pisces: "♓",
      ophiuchus: "⛎",
      twisted_rightwards_arrows: "🔀",
      repeat: "🔁",
      repeat_one: "🔂",
      arrow_forward: "▶️",
      fast_forward: "⏩",
      next_track_button: "⏭️",
      play_or_pause_button: "⏯️",
      arrow_backward: "◀️",
      rewind: "⏪",
      previous_track_button: "⏮️",
      arrow_up_small: "🔼",
      arrow_double_up: "⏫",
      arrow_down_small: "🔽",
      arrow_double_down: "⏬",
      pause_button: "⏸️",
      stop_button: "⏹️",
      record_button: "⏺️",
      eject_button: "⏏️",
      cinema: "🎦",
      low_brightness: "🔅",
      high_brightness: "🔆",
      signal_strength: "📶",
      vibration_mode: "📳",
      mobile_phone_off: "📴",
      female_sign: "♀️",
      male_sign: "♂️",
      transgender_symbol: "⚧️",
      heavy_multiplication_x: "✖️",
      heavy_plus_sign: "➕",
      heavy_minus_sign: "➖",
      heavy_division_sign: "➗",
      infinity: "♾️",
      bangbang: "‼️",
      interrobang: "⁉️",
      question: "❓",
      grey_question: "❔",
      grey_exclamation: "❕",
      exclamation: "❗",
      heavy_exclamation_mark: "❗",
      wavy_dash: "〰️",
      currency_exchange: "💱",
      heavy_dollar_sign: "💲",
      medical_symbol: "⚕️",
      recycle: "♻️",
      fleur_de_lis: "⚜️",
      trident: "🔱",
      name_badge: "📛",
      beginner: "🔰",
      o: "⭕",
      white_check_mark: "✅",
      ballot_box_with_check: "☑️",
      heavy_check_mark: "✔️",
      x: "❌",
      negative_squared_cross_mark: "❎",
      curly_loop: "➰",
      loop: "➿",
      part_alternation_mark: "〽️",
      eight_spoked_asterisk: "✳️",
      eight_pointed_black_star: "✴️",
      sparkle: "❇️",
      copyright: "©️",
      registered: "®️",
      tm: "™️",
      hash: "#️⃣",
      asterisk: "*️⃣",
      zero: "0️⃣",
      one: "1️⃣",
      two: "2️⃣",
      three: "3️⃣",
      four: "4️⃣",
      five: "5️⃣",
      six: "6️⃣",
      seven: "7️⃣",
      eight: "8️⃣",
      nine: "9️⃣",
      keycap_ten: "🔟",
      capital_abcd: "🔠",
      abcd: "🔡",
      symbols: "🔣",
      abc: "🔤",
      a: "🅰️",
      ab: "🆎",
      b: "🅱️",
      cl: "🆑",
      cool: "🆒",
      free: "🆓",
      information_source: "ℹ️",
      id: "🆔",
      m: "Ⓜ️",
      new: "🆕",
      ng: "🆖",
      o2: "🅾️",
      ok: "🆗",
      parking: "🅿️",
      sos: "🆘",
      up: "🆙",
      vs: "🆚",
      koko: "🈁",
      sa: "🈂️",
      ideograph_advantage: "🉐",
      accept: "🉑",
      congratulations: "㊗️",
      secret: "㊙️",
      u6e80: "🈵",
      red_circle: "🔴",
      orange_circle: "🟠",
      yellow_circle: "🟡",
      green_circle: "🟢",
      large_blue_circle: "🔵",
      purple_circle: "🟣",
      brown_circle: "🟤",
      black_circle: "⚫",
      white_circle: "⚪",
      red_square: "🟥",
      orange_square: "🟧",
      yellow_square: "🟨",
      green_square: "🟩",
      blue_square: "🟦",
      purple_square: "🟪",
      brown_square: "🟫",
      black_large_square: "⬛",
      white_large_square: "⬜",
      black_medium_square: "◼️",
      white_medium_square: "◻️",
      black_medium_small_square: "◾",
      white_medium_small_square: "◽",
      black_small_square: "▪️",
      white_small_square: "▫️",
      large_orange_diamond: "🔶",
      large_blue_diamond: "🔷",
      small_orange_diamond: "🔸",
      small_blue_diamond: "🔹",
      small_red_triangle: "🔺",
      small_red_triangle_down: "🔻",
      diamond_shape_with_a_dot_inside: "💠",
      radio_button: "🔘",
      white_square_button: "🔳",
      black_square_button: "🔲",
      checkered_flag: "🏁",
      triangular_flag_on_post: "🚩",
      crossed_flags: "🎌",
      black_flag: "🏴",
      white_flag: "🏳️",
      rainbow_flag: "🏳️‍🌈",
      transgender_flag: "🏳️‍⚧️",
      pirate_flag: "🏴‍☠️",
      ascension_island: "🇦🇨",
      andorra: "🇦🇩",
      united_arab_emirates: "🇦🇪",
      afghanistan: "🇦🇫",
      antigua_barbuda: "🇦🇬",
      anguilla: "🇦🇮",
      albania: "🇦🇱",
      armenia: "🇦🇲",
      angola: "🇦🇴",
      antarctica: "🇦🇶",
      argentina: "🇦🇷",
      american_samoa: "🇦🇸",
      austria: "🇦🇹",
      australia: "🇦🇺",
      aruba: "🇦🇼",
      aland_islands: "🇦🇽",
      azerbaijan: "🇦🇿",
      bosnia_herzegovina: "🇧🇦",
      barbados: "🇧🇧",
      bangladesh: "🇧🇩",
      belgium: "🇧🇪",
      burkina_faso: "🇧🇫",
      bulgaria: "🇧🇬",
      bahrain: "🇧🇭",
      burundi: "🇧🇮",
      benin: "🇧🇯",
      st_barthelemy: "🇧🇱",
      bermuda: "🇧🇲",
      brunei: "🇧🇳",
      bolivia: "🇧🇴",
      caribbean_netherlands: "🇧🇶",
      brazil: "🇧🇷",
      bahamas: "🇧🇸",
      bhutan: "🇧🇹",
      bouvet_island: "🇧🇻",
      botswana: "🇧🇼",
      belarus: "🇧🇾",
      belize: "🇧🇿",
      canada: "🇨🇦",
      cocos_islands: "🇨🇨",
      congo_kinshasa: "🇨🇩",
      central_african_republic: "🇨🇫",
      congo_brazzaville: "🇨🇬",
      switzerland: "🇨🇭",
      cote_divoire: "🇨🇮",
      cook_islands: "🇨🇰",
      chile: "🇨🇱",
      cameroon: "🇨🇲",
      cn: "🇨🇳",
      colombia: "🇨🇴",
      clipperton_island: "🇨🇵",
      costa_rica: "🇨🇷",
      cuba: "🇨🇺",
      cape_verde: "🇨🇻",
      curacao: "🇨🇼",
      christmas_island: "🇨🇽",
      cyprus: "🇨🇾",
      czech_republic: "🇨🇿",
      de: "🇩🇪",
      diego_garcia: "🇩🇬",
      djibouti: "🇩🇯",
      denmark: "🇩🇰",
      dominica: "🇩🇲",
      dominican_republic: "🇩🇴",
      algeria: "🇩🇿",
      ceuta_melilla: "🇪🇦",
      ecuador: "🇪🇨",
      estonia: "🇪🇪",
      egypt: "🇪🇬",
      western_sahara: "🇪🇭",
      eritrea: "🇪🇷",
      es: "🇪🇸",
      ethiopia: "🇪🇹",
      eu: "🇪🇺",
      european_union: "🇪🇺",
      finland: "🇫🇮",
      fiji: "🇫🇯",
      falkland_islands: "🇫🇰",
      micronesia: "🇫🇲",
      faroe_islands: "🇫🇴",
      fr: "🇫🇷",
      gabon: "🇬🇦",
      gb: "🇬🇧",
      uk: "🇬🇧",
      grenada: "🇬🇩",
      georgia: "🇬🇪",
      french_guiana: "🇬🇫",
      guernsey: "🇬🇬",
      ghana: "🇬🇭",
      gibraltar: "🇬🇮",
      greenland: "🇬🇱",
      gambia: "🇬🇲",
      guinea: "🇬🇳",
      guadeloupe: "🇬🇵",
      equatorial_guinea: "🇬🇶",
      greece: "🇬🇷",
      south_georgia_south_sandwich_islands: "🇬🇸",
      guatemala: "🇬🇹",
      guam: "🇬🇺",
      guinea_bissau: "🇬🇼",
      guyana: "🇬🇾",
      hong_kong: "🇭🇰",
      heard_mcdonald_islands: "🇭🇲",
      honduras: "🇭🇳",
      croatia: "🇭🇷",
      haiti: "🇭🇹",
      hungary: "🇭🇺",
      canary_islands: "🇮🇨",
      indonesia: "🇮🇩",
      ireland: "🇮🇪",
      israel: "🇮🇱",
      isle_of_man: "🇮🇲",
      india: "🇮🇳",
      british_indian_ocean_territory: "🇮🇴",
      iraq: "🇮🇶",
      iran: "🇮🇷",
      iceland: "🇮🇸",
      it: "🇮🇹",
      jersey: "🇯🇪",
      jamaica: "🇯🇲",
      jordan: "🇯🇴",
      jp: "🇯🇵",
      kenya: "🇰🇪",
      kyrgyzstan: "🇰🇬",
      cambodia: "🇰🇭",
      kiribati: "🇰🇮",
      comoros: "🇰🇲",
      st_kitts_nevis: "🇰🇳",
      north_korea: "🇰🇵",
      kr: "🇰🇷",
      kuwait: "🇰🇼",
      cayman_islands: "🇰🇾",
      kazakhstan: "🇰🇿",
      laos: "🇱🇦",
      lebanon: "🇱🇧",
      st_lucia: "🇱🇨",
      liechtenstein: "🇱🇮",
      sri_lanka: "🇱🇰",
      liberia: "🇱🇷",
      lesotho: "🇱🇸",
      lithuania: "🇱🇹",
      luxembourg: "🇱🇺",
      latvia: "🇱🇻",
      libya: "🇱🇾",
      morocco: "🇲🇦",
      monaco: "🇲🇨",
      moldova: "🇲🇩",
      montenegro: "🇲🇪",
      st_martin: "🇲🇫",
      madagascar: "🇲🇬",
      marshall_islands: "🇲🇭",
      macedonia: "🇲🇰",
      mali: "🇲🇱",
      myanmar: "🇲🇲",
      mongolia: "🇲🇳",
      macau: "🇲🇴",
      northern_mariana_islands: "🇲🇵",
      martinique: "🇲🇶",
      mauritania: "🇲🇷",
      montserrat: "🇲🇸",
      malta: "🇲🇹",
      mauritius: "🇲🇺",
      maldives: "🇲🇻",
      malawi: "🇲🇼",
      mexico: "🇲🇽",
      malaysia: "🇲🇾",
      mozambique: "🇲🇿",
      namibia: "🇳🇦",
      new_caledonia: "🇳🇨",
      niger: "🇳🇪",
      norfolk_island: "🇳🇫",
      nigeria: "🇳🇬",
      nicaragua: "🇳🇮",
      netherlands: "🇳🇱",
      norway: "🇳🇴",
      nepal: "🇳🇵",
      nauru: "🇳🇷",
      niue: "🇳🇺",
      new_zealand: "🇳🇿",
      oman: "🇴🇲",
      panama: "🇵🇦",
      peru: "🇵🇪",
      french_polynesia: "🇵🇫",
      papua_new_guinea: "🇵🇬",
      philippines: "🇵🇭",
      pakistan: "🇵🇰",
      poland: "🇵🇱",
      st_pierre_miquelon: "🇵🇲",
      pitcairn_islands: "🇵🇳",
      puerto_rico: "🇵🇷",
      palestinian_territories: "🇵🇸",
      portugal: "🇵🇹",
      palau: "🇵🇼",
      paraguay: "🇵🇾",
      qatar: "🇶🇦",
      reunion: "🇷🇪",
      romania: "🇷🇴",
      serbia: "🇷🇸",
      ru: "🇷🇺",
      rwanda: "🇷🇼",
      saudi_arabia: "🇸🇦",
      solomon_islands: "🇸🇧",
      seychelles: "🇸🇨",
      sudan: "🇸🇩",
      sweden: "🇸🇪",
      singapore: "🇸🇬",
      st_helena: "🇸🇭",
      slovenia: "🇸🇮",
      svalbard_jan_mayen: "🇸🇯",
      slovakia: "🇸🇰",
      sierra_leone: "🇸🇱",
      san_marino: "🇸🇲",
      senegal: "🇸🇳",
      somalia: "🇸🇴",
      suriname: "🇸🇷",
      south_sudan: "🇸🇸",
      sao_tome_principe: "🇸🇹",
      el_salvador: "🇸🇻",
      sint_maarten: "🇸🇽",
      syria: "🇸🇾",
      swaziland: "🇸🇿",
      tristan_da_cunha: "🇹🇦",
      turks_caicos_islands: "🇹🇨",
      chad: "🇹🇩",
      french_southern_territories: "🇹🇫",
      togo: "🇹🇬",
      thailand: "🇹🇭",
      tajikistan: "🇹🇯",
      tokelau: "🇹🇰",
      timor_leste: "🇹🇱",
      turkmenistan: "🇹🇲",
      tunisia: "🇹🇳",
      tonga: "🇹🇴",
      tr: "🇹🇷",
      trinidad_tobago: "🇹🇹",
      tuvalu: "🇹🇻",
      taiwan: "🇹🇼",
      tanzania: "🇹🇿",
      ukraine: "🇺🇦",
      uganda: "🇺🇬",
      us_outlying_islands: "🇺🇲",
      united_nations: "🇺🇳",
      us: "🇺🇸",
      uruguay: "🇺🇾",
      uzbekistan: "🇺🇿",
      vatican_city: "🇻🇦",
      st_vincent_grenadines: "🇻🇨",
      venezuela: "🇻🇪",
      british_virgin_islands: "🇻🇬",
      us_virgin_islands: "🇻🇮",
      vietnam: "🇻🇳",
      vanuatu: "🇻🇺",
      wallis_futuna: "🇼🇫",
      samoa: "🇼🇸",
      kosovo: "🇽🇰",
      yemen: "🇾🇪",
      mayotte: "🇾🇹",
      south_africa: "🇿🇦",
      zambia: "🇿🇲",
      zimbabwe: "🇿🇼",
      england: "🏴󠁧󠁢󠁥󠁮󠁧󠁿",
      scotland: "🏴󠁧󠁢󠁳󠁣󠁴󠁿",
      wales: "🏴󠁧󠁢󠁷󠁬󠁳󠁿"
    };
  }
});

// node_modules/.pnpm/markdown-it-emoji@2.0.2/node_modules/markdown-it-emoji/lib/data/shortcuts.js
var require_shortcuts = __commonJS({
  "node_modules/.pnpm/markdown-it-emoji@2.0.2/node_modules/markdown-it-emoji/lib/data/shortcuts.js"(exports3, module2) {
    "use strict";
    module2.exports = {
      angry: [">:(", ">:-("],
      blush: [':")', ':-")'],
      broken_heart: ["</3", "<\\3"],
      // :\ and :-\ not used because of conflict with markdown escaping
      confused: [":/", ":-/"],
      // twemoji shows question
      cry: [":'(", ":'-(", ":,(", ":,-("],
      frowning: [":(", ":-("],
      heart: ["<3"],
      imp: ["]:(", "]:-("],
      innocent: ["o:)", "O:)", "o:-)", "O:-)", "0:)", "0:-)"],
      joy: [":')", ":'-)", ":,)", ":,-)", ":'D", ":'-D", ":,D", ":,-D"],
      kissing: [":*", ":-*"],
      laughing: ["x-)", "X-)"],
      neutral_face: [":|", ":-|"],
      open_mouth: [":o", ":-o", ":O", ":-O"],
      rage: [":@", ":-@"],
      smile: [":D", ":-D"],
      smiley: [":)", ":-)"],
      smiling_imp: ["]:)", "]:-)"],
      sob: [":,'(", ":,'-(", ";(", ";-("],
      stuck_out_tongue: [":P", ":-P"],
      sunglasses: ["8-)", "B-)"],
      sweat: [",:(", ",:-("],
      sweat_smile: [",:)", ",:-)"],
      unamused: [":s", ":-S", ":z", ":-Z", ":$", ":-$"],
      wink: [";)", ";-)"]
    };
  }
});

// node_modules/.pnpm/markdown-it-emoji@2.0.2/node_modules/markdown-it-emoji/lib/render.js
var require_render = __commonJS({
  "node_modules/.pnpm/markdown-it-emoji@2.0.2/node_modules/markdown-it-emoji/lib/render.js"(exports3, module2) {
    "use strict";
    module2.exports = function emoji_html(tokens, idx) {
      return tokens[idx].content;
    };
  }
});

// node_modules/.pnpm/markdown-it-emoji@2.0.2/node_modules/markdown-it-emoji/lib/replace.js
var require_replace = __commonJS({
  "node_modules/.pnpm/markdown-it-emoji@2.0.2/node_modules/markdown-it-emoji/lib/replace.js"(exports3, module2) {
    "use strict";
    module2.exports = function create_rule(md, emojies, shortcuts, scanRE, replaceRE) {
      var arrayReplaceAt = md.utils.arrayReplaceAt, ucm = md.utils.lib.ucmicro, ZPCc = new RegExp([ucm.Z.source, ucm.P.source, ucm.Cc.source].join("|"));
      function splitTextToken(text, level3, Token3) {
        var token, last_pos = 0, nodes = [];
        text.replace(replaceRE, function(match, offset3, src3) {
          var emoji_name;
          if (shortcuts.hasOwnProperty(match)) {
            emoji_name = shortcuts[match];
            if (offset3 > 0 && !ZPCc.test(src3[offset3 - 1])) {
              return;
            }
            if (offset3 + match.length < src3.length && !ZPCc.test(src3[offset3 + match.length])) {
              return;
            }
          } else {
            emoji_name = match.slice(1, -1);
          }
          if (offset3 > last_pos) {
            token = new Token3("text", "", 0);
            token.content = text.slice(last_pos, offset3);
            nodes.push(token);
          }
          token = new Token3("emoji", "", 0);
          token.markup = emoji_name;
          token.content = emojies[emoji_name];
          nodes.push(token);
          last_pos = offset3 + match.length;
        });
        if (last_pos < text.length) {
          token = new Token3("text", "", 0);
          token.content = text.slice(last_pos);
          nodes.push(token);
        }
        return nodes;
      }
      return function emoji_replace(state) {
        var i2, j, l2, tokens, token, blockTokens = state.tokens, autolinkLevel = 0;
        for (j = 0, l2 = blockTokens.length; j < l2; j++) {
          if (blockTokens[j].type !== "inline") {
            continue;
          }
          tokens = blockTokens[j].children;
          for (i2 = tokens.length - 1; i2 >= 0; i2--) {
            token = tokens[i2];
            if (token.type === "link_open" || token.type === "link_close") {
              if (token.info === "auto") {
                autolinkLevel -= token.nesting;
              }
            }
            if (token.type === "text" && autolinkLevel === 0 && scanRE.test(token.content)) {
              blockTokens[j].children = tokens = arrayReplaceAt(
                tokens,
                i2,
                splitTextToken(token.content, token.level, state.Token)
              );
            }
          }
        }
      };
    };
  }
});

// node_modules/.pnpm/markdown-it-emoji@2.0.2/node_modules/markdown-it-emoji/lib/normalize_opts.js
var require_normalize_opts = __commonJS({
  "node_modules/.pnpm/markdown-it-emoji@2.0.2/node_modules/markdown-it-emoji/lib/normalize_opts.js"(exports3, module2) {
    "use strict";
    function quoteRE(str2) {
      return str2.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
    }
    module2.exports = function normalize_opts(options3) {
      var emojies = options3.defs, shortcuts;
      if (options3.enabled.length) {
        emojies = Object.keys(emojies).reduce(function(acc, key) {
          if (options3.enabled.indexOf(key) >= 0) {
            acc[key] = emojies[key];
          }
          return acc;
        }, {});
      }
      shortcuts = Object.keys(options3.shortcuts).reduce(function(acc, key) {
        if (!emojies[key]) {
          return acc;
        }
        if (Array.isArray(options3.shortcuts[key])) {
          options3.shortcuts[key].forEach(function(alias2) {
            acc[alias2] = key;
          });
          return acc;
        }
        acc[options3.shortcuts[key]] = key;
        return acc;
      }, {});
      var keys = Object.keys(emojies), names;
      if (keys.length === 0) {
        names = "^$";
      } else {
        names = keys.map(function(name2) {
          return ":" + name2 + ":";
        }).concat(Object.keys(shortcuts)).sort().reverse().map(function(name2) {
          return quoteRE(name2);
        }).join("|");
      }
      var scanRE = RegExp(names);
      var replaceRE = RegExp(names, "g");
      return {
        defs: emojies,
        shortcuts,
        scanRE,
        replaceRE
      };
    };
  }
});

// node_modules/.pnpm/markdown-it-emoji@2.0.2/node_modules/markdown-it-emoji/bare.js
var require_bare = __commonJS({
  "node_modules/.pnpm/markdown-it-emoji@2.0.2/node_modules/markdown-it-emoji/bare.js"(exports3, module2) {
    "use strict";
    var emoji_html = require_render();
    var emoji_replace = require_replace();
    var normalize_opts = require_normalize_opts();
    module2.exports = function emoji_plugin(md, options3) {
      var defaults = {
        defs: {},
        shortcuts: {},
        enabled: []
      };
      var opts = normalize_opts(md.utils.assign({}, defaults, options3 || {}));
      md.renderer.rules.emoji = emoji_html;
      md.core.ruler.after(
        "linkify",
        "emoji",
        emoji_replace(md, opts.defs, opts.shortcuts, opts.scanRE, opts.replaceRE)
      );
    };
  }
});

// node_modules/.pnpm/markdown-it-emoji@2.0.2/node_modules/markdown-it-emoji/index.js
var require_markdown_it_emoji = __commonJS({
  "node_modules/.pnpm/markdown-it-emoji@2.0.2/node_modules/markdown-it-emoji/index.js"(exports3, module2) {
    "use strict";
    var emojies_defs = require_full();
    var emojies_shortcuts = require_shortcuts();
    var bare_emoji_plugin = require_bare();
    module2.exports = function emoji_plugin(md, options3) {
      var defaults = {
        defs: emojies_defs,
        shortcuts: emojies_shortcuts,
        enabled: []
      };
      var opts = md.utils.assign({}, defaults, options3 || {});
      bare_emoji_plugin(md, opts);
    };
  }
});

// node_modules/.pnpm/readdirp@3.6.0/node_modules/readdirp/index.js
var require_readdirp = __commonJS({
  "node_modules/.pnpm/readdirp@3.6.0/node_modules/readdirp/index.js"(exports3, module2) {
    "use strict";
    var fs6 = require_fs();
    var { Readable: Readable2 } = require_stream();
    var sysPath2 = require_path();
    var { promisify: promisify2 } = require_util();
    var picomatch2 = require_picomatch2();
    var readdir2 = promisify2(fs6.readdir);
    var stat2 = promisify2(fs6.stat);
    var lstat2 = promisify2(fs6.lstat);
    var realpath3 = promisify2(fs6.realpath);
    var BANG2 = "!";
    var RECURSIVE_ERROR_CODE2 = "READDIRP_RECURSIVE_ERROR";
    var NORMAL_FLOW_ERRORS2 = /* @__PURE__ */ new Set(["ENOENT", "EPERM", "EACCES", "ELOOP", RECURSIVE_ERROR_CODE2]);
    var FILE_TYPE2 = "files";
    var DIR_TYPE2 = "directories";
    var FILE_DIR_TYPE2 = "files_directories";
    var EVERYTHING_TYPE2 = "all";
    var ALL_TYPES2 = [FILE_TYPE2, DIR_TYPE2, FILE_DIR_TYPE2, EVERYTHING_TYPE2];
    var isNormalFlowError2 = (error3) => NORMAL_FLOW_ERRORS2.has(error3.code);
    var [maj2, min2] = process.versions.node.split(".").slice(0, 2).map((n3) => Number.parseInt(n3, 10));
    var wantBigintFsStats2 = process.platform === "win32" && (maj2 > 10 || maj2 === 10 && min2 >= 5);
    var normalizeFilter2 = (filter2) => {
      if (filter2 === void 0)
        return;
      if (typeof filter2 === "function")
        return filter2;
      if (typeof filter2 === "string") {
        const glob2 = picomatch2(filter2.trim());
        return (entry2) => glob2(entry2.basename);
      }
      if (Array.isArray(filter2)) {
        const positive = [];
        const negative = [];
        for (const item of filter2) {
          const trimmed = item.trim();
          if (trimmed.charAt(0) === BANG2) {
            negative.push(picomatch2(trimmed.slice(1)));
          } else {
            positive.push(picomatch2(trimmed));
          }
        }
        if (negative.length > 0) {
          if (positive.length > 0) {
            return (entry2) => positive.some((f2) => f2(entry2.basename)) && !negative.some((f2) => f2(entry2.basename));
          }
          return (entry2) => !negative.some((f2) => f2(entry2.basename));
        }
        return (entry2) => positive.some((f2) => f2(entry2.basename));
      }
    };
    var ReaddirpStream2 = class extends Readable2 {
      static get defaultOptions() {
        return {
          root: ".",
          /* eslint-disable no-unused-vars */
          fileFilter: (path8) => true,
          directoryFilter: (path8) => true,
          /* eslint-enable no-unused-vars */
          type: FILE_TYPE2,
          lstat: false,
          depth: 2147483648,
          alwaysStat: false
        };
      }
      constructor(options3 = {}) {
        super({
          objectMode: true,
          autoDestroy: true,
          highWaterMark: options3.highWaterMark || 4096
        });
        const opts = { ...ReaddirpStream2.defaultOptions, ...options3 };
        const { root, type } = opts;
        this._fileFilter = normalizeFilter2(opts.fileFilter);
        this._directoryFilter = normalizeFilter2(opts.directoryFilter);
        const statMethod = opts.lstat ? lstat2 : stat2;
        if (wantBigintFsStats2) {
          this._stat = (path8) => statMethod(path8, { bigint: true });
        } else {
          this._stat = statMethod;
        }
        this._maxDepth = opts.depth;
        this._wantsDir = [DIR_TYPE2, FILE_DIR_TYPE2, EVERYTHING_TYPE2].includes(type);
        this._wantsFile = [FILE_TYPE2, FILE_DIR_TYPE2, EVERYTHING_TYPE2].includes(type);
        this._wantsEverything = type === EVERYTHING_TYPE2;
        this._root = sysPath2.resolve(root);
        this._isDirent = "Dirent" in fs6 && !opts.alwaysStat;
        this._statsProp = this._isDirent ? "dirent" : "stats";
        this._rdOptions = { encoding: "utf8", withFileTypes: this._isDirent };
        this.parents = [this._exploreDir(root, 1)];
        this.reading = false;
        this.parent = void 0;
      }
      async _read(batch) {
        if (this.reading)
          return;
        this.reading = true;
        try {
          while (!this.destroyed && batch > 0) {
            const { path: path8, depth: depth2, files = [] } = this.parent || {};
            if (files.length > 0) {
              const slice2 = files.splice(0, batch).map((dirent) => this._formatEntry(dirent, path8));
              for (const entry2 of await Promise.all(slice2)) {
                if (this.destroyed)
                  return;
                const entryType = await this._getEntryType(entry2);
                if (entryType === "directory" && this._directoryFilter(entry2)) {
                  if (depth2 <= this._maxDepth) {
                    this.parents.push(this._exploreDir(entry2.fullPath, depth2 + 1));
                  }
                  if (this._wantsDir) {
                    this.push(entry2);
                    batch--;
                  }
                } else if ((entryType === "file" || this._includeAsFile(entry2)) && this._fileFilter(entry2)) {
                  if (this._wantsFile) {
                    this.push(entry2);
                    batch--;
                  }
                }
              }
            } else {
              const parent = this.parents.pop();
              if (!parent) {
                this.push(null);
                break;
              }
              this.parent = await parent;
              if (this.destroyed)
                return;
            }
          }
        } catch (error3) {
          this.destroy(error3);
        } finally {
          this.reading = false;
        }
      }
      async _exploreDir(path8, depth2) {
        let files;
        try {
          files = await readdir2(path8, this._rdOptions);
        } catch (error3) {
          this._onError(error3);
        }
        return { files, depth: depth2, path: path8 };
      }
      async _formatEntry(dirent, path8) {
        let entry2;
        try {
          const basename2 = this._isDirent ? dirent.name : dirent;
          const fullPath = sysPath2.resolve(sysPath2.join(path8, basename2));
          entry2 = { path: sysPath2.relative(this._root, fullPath), fullPath, basename: basename2 };
          entry2[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);
        } catch (err2) {
          this._onError(err2);
        }
        return entry2;
      }
      _onError(err2) {
        if (isNormalFlowError2(err2) && !this.destroyed) {
          this.emit("warn", err2);
        } else {
          this.destroy(err2);
        }
      }
      async _getEntryType(entry2) {
        const stats = entry2 && entry2[this._statsProp];
        if (!stats) {
          return;
        }
        if (stats.isFile()) {
          return "file";
        }
        if (stats.isDirectory()) {
          return "directory";
        }
        if (stats && stats.isSymbolicLink()) {
          const full = entry2.fullPath;
          try {
            const entryRealPath = await realpath3(full);
            const entryRealPathStats = await lstat2(entryRealPath);
            if (entryRealPathStats.isFile()) {
              return "file";
            }
            if (entryRealPathStats.isDirectory()) {
              const len = entryRealPath.length;
              if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath2.sep) {
                const recursiveError = new Error(
                  `Circular symlink detected: "${full}" points to "${entryRealPath}"`
                );
                recursiveError.code = RECURSIVE_ERROR_CODE2;
                return this._onError(recursiveError);
              }
              return "directory";
            }
          } catch (error3) {
            this._onError(error3);
          }
        }
      }
      _includeAsFile(entry2) {
        const stats = entry2 && entry2[this._statsProp];
        return stats && this._wantsEverything && !stats.isDirectory();
      }
    };
    var readdirp2 = (root, options3 = {}) => {
      let type = options3.entryType || options3.type;
      if (type === "both")
        type = FILE_DIR_TYPE2;
      if (type)
        options3.type = type;
      if (!root) {
        throw new Error("readdirp: root argument is required. Usage: readdirp(root, options)");
      } else if (typeof root !== "string") {
        throw new TypeError("readdirp: root argument must be a string. Usage: readdirp(root, options)");
      } else if (type && !ALL_TYPES2.includes(type)) {
        throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES2.join(", ")}`);
      }
      options3.root = root;
      return new ReaddirpStream2(options3);
    };
    var readdirpPromise2 = (root, options3 = {}) => {
      return new Promise((resolve4, reject) => {
        const files = [];
        readdirp2(root, options3).on("data", (entry2) => files.push(entry2)).on("end", () => resolve4(files)).on("error", (error3) => reject(error3));
      });
    };
    readdirp2.promise = readdirpPromise2;
    readdirp2.ReaddirpStream = ReaddirpStream2;
    readdirp2.default = readdirp2;
    module2.exports = readdirp2;
  }
});

// node_modules/.pnpm/normalize-path@3.0.0/node_modules/normalize-path/index.js
var require_normalize_path = __commonJS({
  "node_modules/.pnpm/normalize-path@3.0.0/node_modules/normalize-path/index.js"(exports3, module2) {
    module2.exports = function(path8, stripTrailing) {
      if (typeof path8 !== "string") {
        throw new TypeError("expected path to be a string");
      }
      if (path8 === "\\" || path8 === "/")
        return "/";
      var len = path8.length;
      if (len <= 1)
        return path8;
      var prefix = "";
      if (len > 4 && path8[3] === "\\") {
        var ch = path8[2];
        if ((ch === "?" || ch === ".") && path8.slice(0, 2) === "\\\\") {
          path8 = path8.slice(2);
          prefix = "//";
        }
      }
      var segs = path8.split(/[/\\]+/);
      if (stripTrailing !== false && segs[segs.length - 1] === "") {
        segs.pop();
      }
      return prefix + segs.join("/");
    };
  }
});

// node_modules/.pnpm/anymatch@3.1.3/node_modules/anymatch/index.js
var require_anymatch = __commonJS({
  "node_modules/.pnpm/anymatch@3.1.3/node_modules/anymatch/index.js"(exports3, module2) {
    "use strict";
    Object.defineProperty(exports3, "__esModule", { value: true });
    var picomatch2 = require_picomatch2();
    var normalizePath4 = require_normalize_path();
    var BANG2 = "!";
    var DEFAULT_OPTIONS2 = { returnIndex: false };
    var arrify2 = (item) => Array.isArray(item) ? item : [item];
    var createPattern2 = (matcher2, options3) => {
      if (typeof matcher2 === "function") {
        return matcher2;
      }
      if (typeof matcher2 === "string") {
        const glob2 = picomatch2(matcher2, options3);
        return (string3) => matcher2 === string3 || glob2(string3);
      }
      if (matcher2 instanceof RegExp) {
        return (string3) => matcher2.test(string3);
      }
      return (string3) => false;
    };
    var matchPatterns2 = (patterns2, negPatterns, args, returnIndex) => {
      const isList = Array.isArray(args);
      const _path = isList ? args[0] : args;
      if (!isList && typeof _path !== "string") {
        throw new TypeError("anymatch: second argument must be a string: got " + Object.prototype.toString.call(_path));
      }
      const path8 = normalizePath4(_path, false);
      for (let index2 = 0; index2 < negPatterns.length; index2++) {
        const nglob = negPatterns[index2];
        if (nglob(path8)) {
          return returnIndex ? -1 : false;
        }
      }
      const applied = isList && [path8].concat(args.slice(1));
      for (let index2 = 0; index2 < patterns2.length; index2++) {
        const pattern2 = patterns2[index2];
        if (isList ? pattern2(...applied) : pattern2(path8)) {
          return returnIndex ? index2 : true;
        }
      }
      return returnIndex ? -1 : false;
    };
    var anymatch2 = (matchers, testString, options3 = DEFAULT_OPTIONS2) => {
      if (matchers == null) {
        throw new TypeError("anymatch: specify first argument");
      }
      const opts = typeof options3 === "boolean" ? { returnIndex: options3 } : options3;
      const returnIndex = opts.returnIndex || false;
      const mtchers = arrify2(matchers);
      const negatedGlobs = mtchers.filter((item) => typeof item === "string" && item.charAt(0) === BANG2).map((item) => item.slice(1)).map((item) => picomatch2(item, opts));
      const patterns2 = mtchers.filter((item) => typeof item !== "string" || typeof item === "string" && item.charAt(0) !== BANG2).map((matcher2) => createPattern2(matcher2, opts));
      if (testString == null) {
        return (testString2, ri = false) => {
          const returnIndex2 = typeof ri === "boolean" ? ri : false;
          return matchPatterns2(patterns2, negatedGlobs, testString2, returnIndex2);
        };
      }
      return matchPatterns2(patterns2, negatedGlobs, testString, returnIndex);
    };
    anymatch2.default = anymatch2;
    module2.exports = anymatch2;
  }
});

// node_modules/.pnpm/binary-extensions@2.2.0/node_modules/binary-extensions/binary-extensions.json
var require_binary_extensions = __commonJS({
  "node_modules/.pnpm/binary-extensions@2.2.0/node_modules/binary-extensions/binary-extensions.json"(exports3, module2) {
    module2.exports = [
      "3dm",
      "3ds",
      "3g2",
      "3gp",
      "7z",
      "a",
      "aac",
      "adp",
      "ai",
      "aif",
      "aiff",
      "alz",
      "ape",
      "apk",
      "appimage",
      "ar",
      "arj",
      "asf",
      "au",
      "avi",
      "bak",
      "baml",
      "bh",
      "bin",
      "bk",
      "bmp",
      "btif",
      "bz2",
      "bzip2",
      "cab",
      "caf",
      "cgm",
      "class",
      "cmx",
      "cpio",
      "cr2",
      "cur",
      "dat",
      "dcm",
      "deb",
      "dex",
      "djvu",
      "dll",
      "dmg",
      "dng",
      "doc",
      "docm",
      "docx",
      "dot",
      "dotm",
      "dra",
      "DS_Store",
      "dsk",
      "dts",
      "dtshd",
      "dvb",
      "dwg",
      "dxf",
      "ecelp4800",
      "ecelp7470",
      "ecelp9600",
      "egg",
      "eol",
      "eot",
      "epub",
      "exe",
      "f4v",
      "fbs",
      "fh",
      "fla",
      "flac",
      "flatpak",
      "fli",
      "flv",
      "fpx",
      "fst",
      "fvt",
      "g3",
      "gh",
      "gif",
      "graffle",
      "gz",
      "gzip",
      "h261",
      "h263",
      "h264",
      "icns",
      "ico",
      "ief",
      "img",
      "ipa",
      "iso",
      "jar",
      "jpeg",
      "jpg",
      "jpgv",
      "jpm",
      "jxr",
      "key",
      "ktx",
      "lha",
      "lib",
      "lvp",
      "lz",
      "lzh",
      "lzma",
      "lzo",
      "m3u",
      "m4a",
      "m4v",
      "mar",
      "mdi",
      "mht",
      "mid",
      "midi",
      "mj2",
      "mka",
      "mkv",
      "mmr",
      "mng",
      "mobi",
      "mov",
      "movie",
      "mp3",
      "mp4",
      "mp4a",
      "mpeg",
      "mpg",
      "mpga",
      "mxu",
      "nef",
      "npx",
      "numbers",
      "nupkg",
      "o",
      "odp",
      "ods",
      "odt",
      "oga",
      "ogg",
      "ogv",
      "otf",
      "ott",
      "pages",
      "pbm",
      "pcx",
      "pdb",
      "pdf",
      "pea",
      "pgm",
      "pic",
      "png",
      "pnm",
      "pot",
      "potm",
      "potx",
      "ppa",
      "ppam",
      "ppm",
      "pps",
      "ppsm",
      "ppsx",
      "ppt",
      "pptm",
      "pptx",
      "psd",
      "pya",
      "pyc",
      "pyo",
      "pyv",
      "qt",
      "rar",
      "ras",
      "raw",
      "resources",
      "rgb",
      "rip",
      "rlc",
      "rmf",
      "rmvb",
      "rpm",
      "rtf",
      "rz",
      "s3m",
      "s7z",
      "scpt",
      "sgi",
      "shar",
      "snap",
      "sil",
      "sketch",
      "slk",
      "smv",
      "snk",
      "so",
      "stl",
      "suo",
      "sub",
      "swf",
      "tar",
      "tbz",
      "tbz2",
      "tga",
      "tgz",
      "thmx",
      "tif",
      "tiff",
      "tlz",
      "ttc",
      "ttf",
      "txz",
      "udf",
      "uvh",
      "uvi",
      "uvm",
      "uvp",
      "uvs",
      "uvu",
      "viv",
      "vob",
      "war",
      "wav",
      "wax",
      "wbmp",
      "wdp",
      "weba",
      "webm",
      "webp",
      "whl",
      "wim",
      "wm",
      "wma",
      "wmv",
      "wmx",
      "woff",
      "woff2",
      "wrm",
      "wvx",
      "xbm",
      "xif",
      "xla",
      "xlam",
      "xls",
      "xlsb",
      "xlsm",
      "xlsx",
      "xlt",
      "xltm",
      "xltx",
      "xm",
      "xmind",
      "xpi",
      "xpm",
      "xwd",
      "xz",
      "z",
      "zip",
      "zipx"
    ];
  }
});

// node_modules/.pnpm/binary-extensions@2.2.0/node_modules/binary-extensions/index.js
var require_binary_extensions2 = __commonJS({
  "node_modules/.pnpm/binary-extensions@2.2.0/node_modules/binary-extensions/index.js"(exports3, module2) {
    module2.exports = require_binary_extensions();
  }
});

// node_modules/.pnpm/is-binary-path@2.1.0/node_modules/is-binary-path/index.js
var require_is_binary_path = __commonJS({
  "node_modules/.pnpm/is-binary-path@2.1.0/node_modules/is-binary-path/index.js"(exports3, module2) {
    "use strict";
    var path8 = require_path();
    var binaryExtensions2 = require_binary_extensions2();
    var extensions2 = new Set(binaryExtensions2);
    module2.exports = (filePath) => extensions2.has(path8.extname(filePath).slice(1).toLowerCase());
  }
});

// node_modules/.pnpm/chokidar@3.5.3/node_modules/chokidar/lib/constants.js
var require_constants5 = __commonJS({
  "node_modules/.pnpm/chokidar@3.5.3/node_modules/chokidar/lib/constants.js"(exports3) {
    "use strict";
    var { sep: sep2 } = require_path();
    var { platform: platform2 } = process;
    var os2 = require_os();
    exports3.EV_ALL = "all";
    exports3.EV_READY = "ready";
    exports3.EV_ADD = "add";
    exports3.EV_CHANGE = "change";
    exports3.EV_ADD_DIR = "addDir";
    exports3.EV_UNLINK = "unlink";
    exports3.EV_UNLINK_DIR = "unlinkDir";
    exports3.EV_RAW = "raw";
    exports3.EV_ERROR = "error";
    exports3.STR_DATA = "data";
    exports3.STR_END = "end";
    exports3.STR_CLOSE = "close";
    exports3.FSEVENT_CREATED = "created";
    exports3.FSEVENT_MODIFIED = "modified";
    exports3.FSEVENT_DELETED = "deleted";
    exports3.FSEVENT_MOVED = "moved";
    exports3.FSEVENT_CLONED = "cloned";
    exports3.FSEVENT_UNKNOWN = "unknown";
    exports3.FSEVENT_TYPE_FILE = "file";
    exports3.FSEVENT_TYPE_DIRECTORY = "directory";
    exports3.FSEVENT_TYPE_SYMLINK = "symlink";
    exports3.KEY_LISTENERS = "listeners";
    exports3.KEY_ERR = "errHandlers";
    exports3.KEY_RAW = "rawEmitters";
    exports3.HANDLER_KEYS = [exports3.KEY_LISTENERS, exports3.KEY_ERR, exports3.KEY_RAW];
    exports3.DOT_SLASH = `.${sep2}`;
    exports3.BACK_SLASH_RE = /\\/g;
    exports3.DOUBLE_SLASH_RE = /\/\//;
    exports3.SLASH_OR_BACK_SLASH_RE = /[/\\]/;
    exports3.DOT_RE = /\..*\.(sw[px])$|~$|\.subl.*\.tmp/;
    exports3.REPLACER_RE = /^\.[/\\]/;
    exports3.SLASH = "/";
    exports3.SLASH_SLASH = "//";
    exports3.BRACE_START = "{";
    exports3.BANG = "!";
    exports3.ONE_DOT = ".";
    exports3.TWO_DOTS = "..";
    exports3.STAR = "*";
    exports3.GLOBSTAR = "**";
    exports3.ROOT_GLOBSTAR = "/**/*";
    exports3.SLASH_GLOBSTAR = "/**";
    exports3.DIR_SUFFIX = "Dir";
    exports3.ANYMATCH_OPTS = { dot: true };
    exports3.STRING_TYPE = "string";
    exports3.FUNCTION_TYPE = "function";
    exports3.EMPTY_STR = "";
    exports3.EMPTY_FN = () => {
    };
    exports3.IDENTITY_FN = (val) => val;
    exports3.isWindows = platform2 === "win32";
    exports3.isMacos = platform2 === "darwin";
    exports3.isLinux = platform2 === "linux";
    exports3.isIBMi = os2.type() === "OS400";
  }
});

// node_modules/.pnpm/chokidar@3.5.3/node_modules/chokidar/lib/nodefs-handler.js
var require_nodefs_handler = __commonJS({
  "node_modules/.pnpm/chokidar@3.5.3/node_modules/chokidar/lib/nodefs-handler.js"(exports3, module2) {
    "use strict";
    var fs6 = require_fs();
    var sysPath2 = require_path();
    var { promisify: promisify2 } = require_util();
    var isBinaryPath2 = require_is_binary_path();
    var {
      isWindows: isWindows2,
      isLinux: isLinux2,
      EMPTY_FN: EMPTY_FN2,
      EMPTY_STR: EMPTY_STR2,
      KEY_LISTENERS: KEY_LISTENERS2,
      KEY_ERR: KEY_ERR2,
      KEY_RAW: KEY_RAW2,
      HANDLER_KEYS: HANDLER_KEYS2,
      EV_CHANGE: EV_CHANGE2,
      EV_ADD: EV_ADD2,
      EV_ADD_DIR: EV_ADD_DIR2,
      EV_ERROR: EV_ERROR2,
      STR_DATA: STR_DATA2,
      STR_END: STR_END2,
      BRACE_START: BRACE_START2,
      STAR: STAR2
    } = require_constants5();
    var THROTTLE_MODE_WATCH2 = "watch";
    var open2 = promisify2(fs6.open);
    var stat2 = promisify2(fs6.stat);
    var lstat2 = promisify2(fs6.lstat);
    var close2 = promisify2(fs6.close);
    var fsrealpath2 = promisify2(fs6.realpath);
    var statMethods2 = { lstat: lstat2, stat: stat2 };
    var foreach2 = (val, fn) => {
      if (val instanceof Set) {
        val.forEach(fn);
      } else {
        fn(val);
      }
    };
    var addAndConvert2 = (main2, prop, item) => {
      let container = main2[prop];
      if (!(container instanceof Set)) {
        main2[prop] = container = /* @__PURE__ */ new Set([container]);
      }
      container.add(item);
    };
    var clearItem2 = (cont) => (key) => {
      const set3 = cont[key];
      if (set3 instanceof Set) {
        set3.clear();
      } else {
        delete cont[key];
      }
    };
    var delFromSet2 = (main2, prop, item) => {
      const container = main2[prop];
      if (container instanceof Set) {
        container.delete(item);
      } else if (container === item) {
        delete main2[prop];
      }
    };
    var isEmptySet2 = (val) => val instanceof Set ? val.size === 0 : !val;
    var FsWatchInstances2 = /* @__PURE__ */ new Map();
    function createFsWatchInstance2(path8, options3, listener2, errHandler, emitRaw) {
      const handleEvent = (rawEvent, evPath) => {
        listener2(path8);
        emitRaw(rawEvent, evPath, { watchedPath: path8 });
        if (evPath && path8 !== evPath) {
          fsWatchBroadcast2(
            sysPath2.resolve(path8, evPath),
            KEY_LISTENERS2,
            sysPath2.join(path8, evPath)
          );
        }
      };
      try {
        return fs6.watch(path8, options3, handleEvent);
      } catch (error3) {
        errHandler(error3);
      }
    }
    var fsWatchBroadcast2 = (fullPath, type, val1, val2, val3) => {
      const cont = FsWatchInstances2.get(fullPath);
      if (!cont)
        return;
      foreach2(cont[type], (listener2) => {
        listener2(val1, val2, val3);
      });
    };
    var setFsWatchListener2 = (path8, fullPath, options3, handlers) => {
      const { listener: listener2, errHandler, rawEmitter } = handlers;
      let cont = FsWatchInstances2.get(fullPath);
      let watcher;
      if (!options3.persistent) {
        watcher = createFsWatchInstance2(
          path8,
          options3,
          listener2,
          errHandler,
          rawEmitter
        );
        return watcher.close.bind(watcher);
      }
      if (cont) {
        addAndConvert2(cont, KEY_LISTENERS2, listener2);
        addAndConvert2(cont, KEY_ERR2, errHandler);
        addAndConvert2(cont, KEY_RAW2, rawEmitter);
      } else {
        watcher = createFsWatchInstance2(
          path8,
          options3,
          fsWatchBroadcast2.bind(null, fullPath, KEY_LISTENERS2),
          errHandler,
          // no need to use broadcast here
          fsWatchBroadcast2.bind(null, fullPath, KEY_RAW2)
        );
        if (!watcher)
          return;
        watcher.on(EV_ERROR2, async (error3) => {
          const broadcastErr = fsWatchBroadcast2.bind(null, fullPath, KEY_ERR2);
          cont.watcherUnusable = true;
          if (isWindows2 && error3.code === "EPERM") {
            try {
              const fd = await open2(path8, "r");
              await close2(fd);
              broadcastErr(error3);
            } catch (err2) {
            }
          } else {
            broadcastErr(error3);
          }
        });
        cont = {
          listeners: listener2,
          errHandlers: errHandler,
          rawEmitters: rawEmitter,
          watcher
        };
        FsWatchInstances2.set(fullPath, cont);
      }
      return () => {
        delFromSet2(cont, KEY_LISTENERS2, listener2);
        delFromSet2(cont, KEY_ERR2, errHandler);
        delFromSet2(cont, KEY_RAW2, rawEmitter);
        if (isEmptySet2(cont.listeners)) {
          cont.watcher.close();
          FsWatchInstances2.delete(fullPath);
          HANDLER_KEYS2.forEach(clearItem2(cont));
          cont.watcher = void 0;
          Object.freeze(cont);
        }
      };
    };
    var FsWatchFileInstances2 = /* @__PURE__ */ new Map();
    var setFsWatchFileListener2 = (path8, fullPath, options3, handlers) => {
      const { listener: listener2, rawEmitter } = handlers;
      let cont = FsWatchFileInstances2.get(fullPath);
      let listeners = /* @__PURE__ */ new Set();
      let rawEmitters = /* @__PURE__ */ new Set();
      const copts = cont && cont.options;
      if (copts && (copts.persistent < options3.persistent || copts.interval > options3.interval)) {
        listeners = cont.listeners;
        rawEmitters = cont.rawEmitters;
        fs6.unwatchFile(fullPath);
        cont = void 0;
      }
      if (cont) {
        addAndConvert2(cont, KEY_LISTENERS2, listener2);
        addAndConvert2(cont, KEY_RAW2, rawEmitter);
      } else {
        cont = {
          listeners: listener2,
          rawEmitters: rawEmitter,
          options: options3,
          watcher: fs6.watchFile(fullPath, options3, (curr, prev) => {
            foreach2(cont.rawEmitters, (rawEmitter2) => {
              rawEmitter2(EV_CHANGE2, fullPath, { curr, prev });
            });
            const currmtime = curr.mtimeMs;
            if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {
              foreach2(cont.listeners, (listener3) => listener3(path8, curr));
            }
          })
        };
        FsWatchFileInstances2.set(fullPath, cont);
      }
      return () => {
        delFromSet2(cont, KEY_LISTENERS2, listener2);
        delFromSet2(cont, KEY_RAW2, rawEmitter);
        if (isEmptySet2(cont.listeners)) {
          FsWatchFileInstances2.delete(fullPath);
          fs6.unwatchFile(fullPath);
          cont.options = cont.watcher = void 0;
          Object.freeze(cont);
        }
      };
    };
    var NodeFsHandler3 = class {
      /**
       * @param {import("../index").FSWatcher} fsW
       */
      constructor(fsW) {
        this.fsw = fsW;
        this._boundHandleError = (error3) => fsW._handleError(error3);
      }
      /**
       * Watch file for changes with fs_watchFile or fs_watch.
       * @param {String} path to file or dir
       * @param {Function} listener on fs change
       * @returns {Function} closer for the watcher instance
       */
      _watchWithNodeFs(path8, listener2) {
        const opts = this.fsw.options;
        const directory = sysPath2.dirname(path8);
        const basename2 = sysPath2.basename(path8);
        const parent = this.fsw._getWatchedDir(directory);
        parent.add(basename2);
        const absolutePath = sysPath2.resolve(path8);
        const options3 = { persistent: opts.persistent };
        if (!listener2)
          listener2 = EMPTY_FN2;
        let closer;
        if (opts.usePolling) {
          options3.interval = opts.enableBinaryInterval && isBinaryPath2(basename2) ? opts.binaryInterval : opts.interval;
          closer = setFsWatchFileListener2(path8, absolutePath, options3, {
            listener: listener2,
            rawEmitter: this.fsw._emitRaw
          });
        } else {
          closer = setFsWatchListener2(path8, absolutePath, options3, {
            listener: listener2,
            errHandler: this._boundHandleError,
            rawEmitter: this.fsw._emitRaw
          });
        }
        return closer;
      }
      /**
       * Watch a file and emit add event if warranted.
       * @param {Path} file Path
       * @param {fs.Stats} stats result of fs_stat
       * @param {Boolean} initialAdd was the file added at watch instantiation?
       * @returns {Function} closer for the watcher instance
       */
      _handleFile(file, stats, initialAdd) {
        if (this.fsw.closed) {
          return;
        }
        const dirname2 = sysPath2.dirname(file);
        const basename2 = sysPath2.basename(file);
        const parent = this.fsw._getWatchedDir(dirname2);
        let prevStats = stats;
        if (parent.has(basename2))
          return;
        const listener2 = async (path8, newStats) => {
          if (!this.fsw._throttle(THROTTLE_MODE_WATCH2, file, 5))
            return;
          if (!newStats || newStats.mtimeMs === 0) {
            try {
              const newStats2 = await stat2(file);
              if (this.fsw.closed)
                return;
              const at2 = newStats2.atimeMs;
              const mt = newStats2.mtimeMs;
              if (!at2 || at2 <= mt || mt !== prevStats.mtimeMs) {
                this.fsw._emit(EV_CHANGE2, file, newStats2);
              }
              if (isLinux2 && prevStats.ino !== newStats2.ino) {
                this.fsw._closeFile(path8);
                prevStats = newStats2;
                this.fsw._addPathCloser(path8, this._watchWithNodeFs(file, listener2));
              } else {
                prevStats = newStats2;
              }
            } catch (error3) {
              this.fsw._remove(dirname2, basename2);
            }
          } else if (parent.has(basename2)) {
            const at2 = newStats.atimeMs;
            const mt = newStats.mtimeMs;
            if (!at2 || at2 <= mt || mt !== prevStats.mtimeMs) {
              this.fsw._emit(EV_CHANGE2, file, newStats);
            }
            prevStats = newStats;
          }
        };
        const closer = this._watchWithNodeFs(file, listener2);
        if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {
          if (!this.fsw._throttle(EV_ADD2, file, 0))
            return;
          this.fsw._emit(EV_ADD2, file, stats);
        }
        return closer;
      }
      /**
       * Handle symlinks encountered while reading a dir.
       * @param {Object} entry returned by readdirp
       * @param {String} directory path of dir being read
       * @param {String} path of this item
       * @param {String} item basename of this item
       * @returns {Promise<Boolean>} true if no more processing is needed for this entry.
       */
      async _handleSymlink(entry2, directory, path8, item) {
        if (this.fsw.closed) {
          return;
        }
        const full = entry2.fullPath;
        const dir = this.fsw._getWatchedDir(directory);
        if (!this.fsw.options.followSymlinks) {
          this.fsw._incrReadyCount();
          let linkPath;
          try {
            linkPath = await fsrealpath2(path8);
          } catch (e3) {
            this.fsw._emitReady();
            return true;
          }
          if (this.fsw.closed)
            return;
          if (dir.has(item)) {
            if (this.fsw._symlinkPaths.get(full) !== linkPath) {
              this.fsw._symlinkPaths.set(full, linkPath);
              this.fsw._emit(EV_CHANGE2, path8, entry2.stats);
            }
          } else {
            dir.add(item);
            this.fsw._symlinkPaths.set(full, linkPath);
            this.fsw._emit(EV_ADD2, path8, entry2.stats);
          }
          this.fsw._emitReady();
          return true;
        }
        if (this.fsw._symlinkPaths.has(full)) {
          return true;
        }
        this.fsw._symlinkPaths.set(full, true);
      }
      _handleRead(directory, initialAdd, wh, target, dir, depth2, throttler) {
        directory = sysPath2.join(directory, EMPTY_STR2);
        if (!wh.hasGlob) {
          throttler = this.fsw._throttle("readdir", directory, 1e3);
          if (!throttler)
            return;
        }
        const previous = this.fsw._getWatchedDir(wh.path);
        const current2 = /* @__PURE__ */ new Set();
        let stream4 = this.fsw._readdirp(directory, {
          fileFilter: (entry2) => wh.filterPath(entry2),
          directoryFilter: (entry2) => wh.filterDir(entry2),
          depth: 0
        }).on(STR_DATA2, async (entry2) => {
          if (this.fsw.closed) {
            stream4 = void 0;
            return;
          }
          const item = entry2.path;
          let path8 = sysPath2.join(directory, item);
          current2.add(item);
          if (entry2.stats.isSymbolicLink() && await this._handleSymlink(entry2, directory, path8, item)) {
            return;
          }
          if (this.fsw.closed) {
            stream4 = void 0;
            return;
          }
          if (item === target || !target && !previous.has(item)) {
            this.fsw._incrReadyCount();
            path8 = sysPath2.join(dir, sysPath2.relative(dir, path8));
            this._addToNodeFs(path8, initialAdd, wh, depth2 + 1);
          }
        }).on(EV_ERROR2, this._boundHandleError);
        return new Promise(
          (resolve4) => stream4.once(STR_END2, () => {
            if (this.fsw.closed) {
              stream4 = void 0;
              return;
            }
            const wasThrottled = throttler ? throttler.clear() : false;
            resolve4();
            previous.getChildren().filter((item) => {
              return item !== directory && !current2.has(item) && // in case of intersecting globs;
              // a path may have been filtered out of this readdir, but
              // shouldn't be removed because it matches a different glob
              (!wh.hasGlob || wh.filterPath({
                fullPath: sysPath2.resolve(directory, item)
              }));
            }).forEach((item) => {
              this.fsw._remove(directory, item);
            });
            stream4 = void 0;
            if (wasThrottled)
              this._handleRead(directory, false, wh, target, dir, depth2, throttler);
          })
        );
      }
      /**
       * Read directory to add / remove files from `@watched` list and re-read it on change.
       * @param {String} dir fs path
       * @param {fs.Stats} stats
       * @param {Boolean} initialAdd
       * @param {Number} depth relative to user-supplied path
       * @param {String} target child path targeted for watch
       * @param {Object} wh Common watch helpers for this path
       * @param {String} realpath
       * @returns {Promise<Function>} closer for the watcher instance.
       */
      async _handleDir(dir, stats, initialAdd, depth2, target, wh, realpath3) {
        const parentDir = this.fsw._getWatchedDir(sysPath2.dirname(dir));
        const tracked = parentDir.has(sysPath2.basename(dir));
        if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {
          if (!wh.hasGlob || wh.globFilter(dir))
            this.fsw._emit(EV_ADD_DIR2, dir, stats);
        }
        parentDir.add(sysPath2.basename(dir));
        this.fsw._getWatchedDir(dir);
        let throttler;
        let closer;
        const oDepth = this.fsw.options.depth;
        if ((oDepth == null || depth2 <= oDepth) && !this.fsw._symlinkPaths.has(realpath3)) {
          if (!target) {
            await this._handleRead(dir, initialAdd, wh, target, dir, depth2, throttler);
            if (this.fsw.closed)
              return;
          }
          closer = this._watchWithNodeFs(dir, (dirPath, stats2) => {
            if (stats2 && stats2.mtimeMs === 0)
              return;
            this._handleRead(dirPath, false, wh, target, dir, depth2, throttler);
          });
        }
        return closer;
      }
      /**
       * Handle added file, directory, or glob pattern.
       * Delegates call to _handleFile / _handleDir after checks.
       * @param {String} path to file or ir
       * @param {Boolean} initialAdd was the file added at watch instantiation?
       * @param {Object} priorWh depth relative to user-supplied path
       * @param {Number} depth Child path actually targeted for watch
       * @param {String=} target Child path actually targeted for watch
       * @returns {Promise}
       */
      async _addToNodeFs(path8, initialAdd, priorWh, depth2, target) {
        const ready = this.fsw._emitReady;
        if (this.fsw._isIgnored(path8) || this.fsw.closed) {
          ready();
          return false;
        }
        const wh = this.fsw._getWatchHelpers(path8, depth2);
        if (!wh.hasGlob && priorWh) {
          wh.hasGlob = priorWh.hasGlob;
          wh.globFilter = priorWh.globFilter;
          wh.filterPath = (entry2) => priorWh.filterPath(entry2);
          wh.filterDir = (entry2) => priorWh.filterDir(entry2);
        }
        try {
          const stats = await statMethods2[wh.statMethod](wh.watchPath);
          if (this.fsw.closed)
            return;
          if (this.fsw._isIgnored(wh.watchPath, stats)) {
            ready();
            return false;
          }
          const follow = this.fsw.options.followSymlinks && !path8.includes(STAR2) && !path8.includes(BRACE_START2);
          let closer;
          if (stats.isDirectory()) {
            const absPath = sysPath2.resolve(path8);
            const targetPath = follow ? await fsrealpath2(path8) : path8;
            if (this.fsw.closed)
              return;
            closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth2, target, wh, targetPath);
            if (this.fsw.closed)
              return;
            if (absPath !== targetPath && targetPath !== void 0) {
              this.fsw._symlinkPaths.set(absPath, targetPath);
            }
          } else if (stats.isSymbolicLink()) {
            const targetPath = follow ? await fsrealpath2(path8) : path8;
            if (this.fsw.closed)
              return;
            const parent = sysPath2.dirname(wh.watchPath);
            this.fsw._getWatchedDir(parent).add(wh.watchPath);
            this.fsw._emit(EV_ADD2, wh.watchPath, stats);
            closer = await this._handleDir(parent, stats, initialAdd, depth2, path8, wh, targetPath);
            if (this.fsw.closed)
              return;
            if (targetPath !== void 0) {
              this.fsw._symlinkPaths.set(sysPath2.resolve(path8), targetPath);
            }
          } else {
            closer = this._handleFile(wh.watchPath, stats, initialAdd);
          }
          ready();
          this.fsw._addPathCloser(path8, closer);
          return false;
        } catch (error3) {
          if (this.fsw._handleError(error3)) {
            ready();
            return path8;
          }
        }
      }
    };
    module2.exports = NodeFsHandler3;
  }
});

// node_modules/.pnpm/chokidar@3.5.3/node_modules/chokidar/lib/fsevents-handler.js
var require_fsevents_handler = __commonJS({
  "node_modules/.pnpm/chokidar@3.5.3/node_modules/chokidar/lib/fsevents-handler.js"(exports3, module2) {
    "use strict";
    var fs6 = require_fs();
    var sysPath2 = require_path();
    var { promisify: promisify2 } = require_util();
    var fsevents2;
    try {
      fsevents2 = __require("fsevents");
    } catch (error3) {
      if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR)
        console.error(error3);
    }
    if (fsevents2) {
      const mtch = process.version.match(/v(\d+)\.(\d+)/);
      if (mtch && mtch[1] && mtch[2]) {
        const maj2 = Number.parseInt(mtch[1], 10);
        const min2 = Number.parseInt(mtch[2], 10);
        if (maj2 === 8 && min2 < 16) {
          fsevents2 = void 0;
        }
      }
    }
    var {
      EV_ADD: EV_ADD2,
      EV_CHANGE: EV_CHANGE2,
      EV_ADD_DIR: EV_ADD_DIR2,
      EV_UNLINK: EV_UNLINK2,
      EV_ERROR: EV_ERROR2,
      STR_DATA: STR_DATA2,
      STR_END: STR_END2,
      FSEVENT_CREATED: FSEVENT_CREATED2,
      FSEVENT_MODIFIED: FSEVENT_MODIFIED2,
      FSEVENT_DELETED: FSEVENT_DELETED2,
      FSEVENT_MOVED: FSEVENT_MOVED2,
      // FSEVENT_CLONED,
      FSEVENT_UNKNOWN: FSEVENT_UNKNOWN2,
      FSEVENT_TYPE_FILE: FSEVENT_TYPE_FILE2,
      FSEVENT_TYPE_DIRECTORY: FSEVENT_TYPE_DIRECTORY2,
      FSEVENT_TYPE_SYMLINK: FSEVENT_TYPE_SYMLINK2,
      ROOT_GLOBSTAR: ROOT_GLOBSTAR2,
      DIR_SUFFIX: DIR_SUFFIX2,
      DOT_SLASH: DOT_SLASH2,
      FUNCTION_TYPE: FUNCTION_TYPE2,
      EMPTY_FN: EMPTY_FN2,
      IDENTITY_FN: IDENTITY_FN2
    } = require_constants5();
    var Depth2 = (value2) => isNaN(value2) ? {} : { depth: value2 };
    var stat2 = promisify2(fs6.stat);
    var lstat2 = promisify2(fs6.lstat);
    var realpath3 = promisify2(fs6.realpath);
    var statMethods2 = { stat: stat2, lstat: lstat2 };
    var FSEventsWatchers2 = /* @__PURE__ */ new Map();
    var consolidateThreshhold2 = 10;
    var wrongEventFlags2 = /* @__PURE__ */ new Set([
      69888,
      70400,
      71424,
      72704,
      73472,
      131328,
      131840,
      262912
    ]);
    var createFSEventsInstance2 = (path8, callback) => {
      const stop = fsevents2.watch(path8, callback);
      return { stop };
    };
    function setFSEventsListener2(path8, realPath, listener2, rawEmitter) {
      let watchPath = sysPath2.extname(realPath) ? sysPath2.dirname(realPath) : realPath;
      const parentPath = sysPath2.dirname(watchPath);
      let cont = FSEventsWatchers2.get(watchPath);
      if (couldConsolidate2(parentPath)) {
        watchPath = parentPath;
      }
      const resolvedPath = sysPath2.resolve(path8);
      const hasSymlink = resolvedPath !== realPath;
      const filteredListener = (fullPath, flags, info3) => {
        if (hasSymlink)
          fullPath = fullPath.replace(realPath, resolvedPath);
        if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath2.sep))
          listener2(fullPath, flags, info3);
      };
      let watchedParent = false;
      for (const watchedPath of FSEventsWatchers2.keys()) {
        if (realPath.indexOf(sysPath2.resolve(watchedPath) + sysPath2.sep) === 0) {
          watchPath = watchedPath;
          cont = FSEventsWatchers2.get(watchPath);
          watchedParent = true;
          break;
        }
      }
      if (cont || watchedParent) {
        cont.listeners.add(filteredListener);
      } else {
        cont = {
          listeners: /* @__PURE__ */ new Set([filteredListener]),
          rawEmitter,
          watcher: createFSEventsInstance2(watchPath, (fullPath, flags) => {
            if (!cont.listeners.size)
              return;
            const info3 = fsevents2.getInfo(fullPath, flags);
            cont.listeners.forEach((list) => {
              list(fullPath, flags, info3);
            });
            cont.rawEmitter(info3.event, fullPath, info3);
          })
        };
        FSEventsWatchers2.set(watchPath, cont);
      }
      return () => {
        const lst = cont.listeners;
        lst.delete(filteredListener);
        if (!lst.size) {
          FSEventsWatchers2.delete(watchPath);
          if (cont.watcher)
            return cont.watcher.stop().then(() => {
              cont.rawEmitter = cont.watcher = void 0;
              Object.freeze(cont);
            });
        }
      };
    }
    var couldConsolidate2 = (path8) => {
      let count = 0;
      for (const watchPath of FSEventsWatchers2.keys()) {
        if (watchPath.indexOf(path8) === 0) {
          count++;
          if (count >= consolidateThreshhold2) {
            return true;
          }
        }
      }
      return false;
    };
    var canUse2 = () => fsevents2 && FSEventsWatchers2.size < 128;
    var calcDepth2 = (path8, root) => {
      let i2 = 0;
      while (!path8.indexOf(root) && (path8 = sysPath2.dirname(path8)) !== root)
        i2++;
      return i2;
    };
    var sameTypes2 = (info3, stats) => info3.type === FSEVENT_TYPE_DIRECTORY2 && stats.isDirectory() || info3.type === FSEVENT_TYPE_SYMLINK2 && stats.isSymbolicLink() || info3.type === FSEVENT_TYPE_FILE2 && stats.isFile();
    var FsEventsHandler3 = class {
      /**
       * @param {import('../index').FSWatcher} fsw
       */
      constructor(fsw) {
        this.fsw = fsw;
      }
      checkIgnored(path8, stats) {
        const ipaths = this.fsw._ignoredPaths;
        if (this.fsw._isIgnored(path8, stats)) {
          ipaths.add(path8);
          if (stats && stats.isDirectory()) {
            ipaths.add(path8 + ROOT_GLOBSTAR2);
          }
          return true;
        }
        ipaths.delete(path8);
        ipaths.delete(path8 + ROOT_GLOBSTAR2);
      }
      addOrChange(path8, fullPath, realPath, parent, watchedDir, item, info3, opts) {
        const event = watchedDir.has(item) ? EV_CHANGE2 : EV_ADD2;
        this.handleEvent(event, path8, fullPath, realPath, parent, watchedDir, item, info3, opts);
      }
      async checkExists(path8, fullPath, realPath, parent, watchedDir, item, info3, opts) {
        try {
          const stats = await stat2(path8);
          if (this.fsw.closed)
            return;
          if (sameTypes2(info3, stats)) {
            this.addOrChange(path8, fullPath, realPath, parent, watchedDir, item, info3, opts);
          } else {
            this.handleEvent(EV_UNLINK2, path8, fullPath, realPath, parent, watchedDir, item, info3, opts);
          }
        } catch (error3) {
          if (error3.code === "EACCES") {
            this.addOrChange(path8, fullPath, realPath, parent, watchedDir, item, info3, opts);
          } else {
            this.handleEvent(EV_UNLINK2, path8, fullPath, realPath, parent, watchedDir, item, info3, opts);
          }
        }
      }
      handleEvent(event, path8, fullPath, realPath, parent, watchedDir, item, info3, opts) {
        if (this.fsw.closed || this.checkIgnored(path8))
          return;
        if (event === EV_UNLINK2) {
          const isDirectory2 = info3.type === FSEVENT_TYPE_DIRECTORY2;
          if (isDirectory2 || watchedDir.has(item)) {
            this.fsw._remove(parent, item, isDirectory2);
          }
        } else {
          if (event === EV_ADD2) {
            if (info3.type === FSEVENT_TYPE_DIRECTORY2)
              this.fsw._getWatchedDir(path8);
            if (info3.type === FSEVENT_TYPE_SYMLINK2 && opts.followSymlinks) {
              const curDepth = opts.depth === void 0 ? void 0 : calcDepth2(fullPath, realPath) + 1;
              return this._addToFsEvents(path8, false, true, curDepth);
            }
            this.fsw._getWatchedDir(parent).add(item);
          }
          const eventName = info3.type === FSEVENT_TYPE_DIRECTORY2 ? event + DIR_SUFFIX2 : event;
          this.fsw._emit(eventName, path8);
          if (eventName === EV_ADD_DIR2)
            this._addToFsEvents(path8, false, true);
        }
      }
      /**
       * Handle symlinks encountered during directory scan
       * @param {String} watchPath  - file/dir path to be watched with fsevents
       * @param {String} realPath   - real path (in case of symlinks)
       * @param {Function} transform  - path transformer
       * @param {Function} globFilter - path filter in case a glob pattern was provided
       * @returns {Function} closer for the watcher instance
      */
      _watchWithFsEvents(watchPath, realPath, transform2, globFilter) {
        if (this.fsw.closed || this.fsw._isIgnored(watchPath))
          return;
        const opts = this.fsw.options;
        const watchCallback = async (fullPath, flags, info3) => {
          if (this.fsw.closed)
            return;
          if (opts.depth !== void 0 && calcDepth2(fullPath, realPath) > opts.depth)
            return;
          const path8 = transform2(sysPath2.join(
            watchPath,
            sysPath2.relative(watchPath, fullPath)
          ));
          if (globFilter && !globFilter(path8))
            return;
          const parent = sysPath2.dirname(path8);
          const item = sysPath2.basename(path8);
          const watchedDir = this.fsw._getWatchedDir(
            info3.type === FSEVENT_TYPE_DIRECTORY2 ? path8 : parent
          );
          if (wrongEventFlags2.has(flags) || info3.event === FSEVENT_UNKNOWN2) {
            if (typeof opts.ignored === FUNCTION_TYPE2) {
              let stats;
              try {
                stats = await stat2(path8);
              } catch (error3) {
              }
              if (this.fsw.closed)
                return;
              if (this.checkIgnored(path8, stats))
                return;
              if (sameTypes2(info3, stats)) {
                this.addOrChange(path8, fullPath, realPath, parent, watchedDir, item, info3, opts);
              } else {
                this.handleEvent(EV_UNLINK2, path8, fullPath, realPath, parent, watchedDir, item, info3, opts);
              }
            } else {
              this.checkExists(path8, fullPath, realPath, parent, watchedDir, item, info3, opts);
            }
          } else {
            switch (info3.event) {
              case FSEVENT_CREATED2:
              case FSEVENT_MODIFIED2:
                return this.addOrChange(path8, fullPath, realPath, parent, watchedDir, item, info3, opts);
              case FSEVENT_DELETED2:
              case FSEVENT_MOVED2:
                return this.checkExists(path8, fullPath, realPath, parent, watchedDir, item, info3, opts);
            }
          }
        };
        const closer = setFSEventsListener2(
          watchPath,
          realPath,
          watchCallback,
          this.fsw._emitRaw
        );
        this.fsw._emitReady();
        return closer;
      }
      /**
       * Handle symlinks encountered during directory scan
       * @param {String} linkPath path to symlink
       * @param {String} fullPath absolute path to the symlink
       * @param {Function} transform pre-existing path transformer
       * @param {Number} curDepth level of subdirectories traversed to where symlink is
       * @returns {Promise<void>}
       */
      async _handleFsEventsSymlink(linkPath, fullPath, transform2, curDepth) {
        if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath))
          return;
        this.fsw._symlinkPaths.set(fullPath, true);
        this.fsw._incrReadyCount();
        try {
          const linkTarget = await realpath3(linkPath);
          if (this.fsw.closed)
            return;
          if (this.fsw._isIgnored(linkTarget)) {
            return this.fsw._emitReady();
          }
          this.fsw._incrReadyCount();
          this._addToFsEvents(linkTarget || linkPath, (path8) => {
            let aliasedPath = linkPath;
            if (linkTarget && linkTarget !== DOT_SLASH2) {
              aliasedPath = path8.replace(linkTarget, linkPath);
            } else if (path8 !== DOT_SLASH2) {
              aliasedPath = sysPath2.join(linkPath, path8);
            }
            return transform2(aliasedPath);
          }, false, curDepth);
        } catch (error3) {
          if (this.fsw._handleError(error3)) {
            return this.fsw._emitReady();
          }
        }
      }
      /**
       *
       * @param {Path} newPath
       * @param {fs.Stats} stats
       */
      emitAdd(newPath, stats, processPath, opts, forceAdd) {
        const pp2 = processPath(newPath);
        const isDir = stats.isDirectory();
        const dirObj = this.fsw._getWatchedDir(sysPath2.dirname(pp2));
        const base2 = sysPath2.basename(pp2);
        if (isDir)
          this.fsw._getWatchedDir(pp2);
        if (dirObj.has(base2))
          return;
        dirObj.add(base2);
        if (!opts.ignoreInitial || forceAdd === true) {
          this.fsw._emit(isDir ? EV_ADD_DIR2 : EV_ADD2, pp2, stats);
        }
      }
      initWatch(realPath, path8, wh, processPath) {
        if (this.fsw.closed)
          return;
        const closer = this._watchWithFsEvents(
          wh.watchPath,
          sysPath2.resolve(realPath || wh.watchPath),
          processPath,
          wh.globFilter
        );
        this.fsw._addPathCloser(path8, closer);
      }
      /**
       * Handle added path with fsevents
       * @param {String} path file/dir path or glob pattern
       * @param {Function|Boolean=} transform converts working path to what the user expects
       * @param {Boolean=} forceAdd ensure add is emitted
       * @param {Number=} priorDepth Level of subdirectories already traversed.
       * @returns {Promise<void>}
       */
      async _addToFsEvents(path8, transform2, forceAdd, priorDepth) {
        if (this.fsw.closed) {
          return;
        }
        const opts = this.fsw.options;
        const processPath = typeof transform2 === FUNCTION_TYPE2 ? transform2 : IDENTITY_FN2;
        const wh = this.fsw._getWatchHelpers(path8);
        try {
          const stats = await statMethods2[wh.statMethod](wh.watchPath);
          if (this.fsw.closed)
            return;
          if (this.fsw._isIgnored(wh.watchPath, stats)) {
            throw null;
          }
          if (stats.isDirectory()) {
            if (!wh.globFilter)
              this.emitAdd(processPath(path8), stats, processPath, opts, forceAdd);
            if (priorDepth && priorDepth > opts.depth)
              return;
            this.fsw._readdirp(wh.watchPath, {
              fileFilter: (entry2) => wh.filterPath(entry2),
              directoryFilter: (entry2) => wh.filterDir(entry2),
              ...Depth2(opts.depth - (priorDepth || 0))
            }).on(STR_DATA2, (entry2) => {
              if (this.fsw.closed) {
                return;
              }
              if (entry2.stats.isDirectory() && !wh.filterPath(entry2))
                return;
              const joinedPath = sysPath2.join(wh.watchPath, entry2.path);
              const { fullPath } = entry2;
              if (wh.followSymlinks && entry2.stats.isSymbolicLink()) {
                const curDepth = opts.depth === void 0 ? void 0 : calcDepth2(joinedPath, sysPath2.resolve(wh.watchPath)) + 1;
                this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);
              } else {
                this.emitAdd(joinedPath, entry2.stats, processPath, opts, forceAdd);
              }
            }).on(EV_ERROR2, EMPTY_FN2).on(STR_END2, () => {
              this.fsw._emitReady();
            });
          } else {
            this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);
            this.fsw._emitReady();
          }
        } catch (error3) {
          if (!error3 || this.fsw._handleError(error3)) {
            this.fsw._emitReady();
            this.fsw._emitReady();
          }
        }
        if (opts.persistent && forceAdd !== true) {
          if (typeof transform2 === FUNCTION_TYPE2) {
            this.initWatch(void 0, path8, wh, processPath);
          } else {
            let realPath;
            try {
              realPath = await realpath3(wh.watchPath);
            } catch (e3) {
            }
            this.initWatch(realPath, path8, wh, processPath);
          }
        }
      }
    };
    module2.exports = FsEventsHandler3;
    module2.exports.canUse = canUse2;
  }
});

// node_modules/.pnpm/chokidar@3.5.3/node_modules/chokidar/index.js
var require_chokidar = __commonJS({
  "node_modules/.pnpm/chokidar@3.5.3/node_modules/chokidar/index.js"(exports3) {
    "use strict";
    var { EventEmitter: EventEmitter3 } = require_events();
    var fs6 = require_fs();
    var sysPath2 = require_path();
    var { promisify: promisify2 } = require_util();
    var readdirp2 = require_readdirp();
    var anymatch2 = require_anymatch().default;
    var globParent3 = require_glob_parent();
    var isGlob3 = require_is_glob();
    var braces2 = require_braces();
    var normalizePath4 = require_normalize_path();
    var NodeFsHandler3 = require_nodefs_handler();
    var FsEventsHandler3 = require_fsevents_handler();
    var {
      EV_ALL: EV_ALL2,
      EV_READY: EV_READY2,
      EV_ADD: EV_ADD2,
      EV_CHANGE: EV_CHANGE2,
      EV_UNLINK: EV_UNLINK2,
      EV_ADD_DIR: EV_ADD_DIR2,
      EV_UNLINK_DIR: EV_UNLINK_DIR2,
      EV_RAW: EV_RAW2,
      EV_ERROR: EV_ERROR2,
      STR_CLOSE: STR_CLOSE2,
      STR_END: STR_END2,
      BACK_SLASH_RE: BACK_SLASH_RE2,
      DOUBLE_SLASH_RE: DOUBLE_SLASH_RE2,
      SLASH_OR_BACK_SLASH_RE: SLASH_OR_BACK_SLASH_RE2,
      DOT_RE: DOT_RE2,
      REPLACER_RE: REPLACER_RE2,
      SLASH: SLASH2,
      SLASH_SLASH: SLASH_SLASH2,
      BRACE_START: BRACE_START2,
      BANG: BANG2,
      ONE_DOT: ONE_DOT2,
      TWO_DOTS: TWO_DOTS2,
      GLOBSTAR: GLOBSTAR2,
      SLASH_GLOBSTAR: SLASH_GLOBSTAR2,
      ANYMATCH_OPTS: ANYMATCH_OPTS2,
      STRING_TYPE: STRING_TYPE2,
      FUNCTION_TYPE: FUNCTION_TYPE2,
      EMPTY_STR: EMPTY_STR2,
      EMPTY_FN: EMPTY_FN2,
      isWindows: isWindows2,
      isMacos: isMacos2,
      isIBMi: isIBMi2
    } = require_constants5();
    var stat2 = promisify2(fs6.stat);
    var readdir2 = promisify2(fs6.readdir);
    var arrify2 = (value2 = []) => Array.isArray(value2) ? value2 : [value2];
    var flatten2 = (list, result = []) => {
      list.forEach((item) => {
        if (Array.isArray(item)) {
          flatten2(item, result);
        } else {
          result.push(item);
        }
      });
      return result;
    };
    var unifyPaths2 = (paths_) => {
      const paths = flatten2(arrify2(paths_));
      if (!paths.every((p2) => typeof p2 === STRING_TYPE2)) {
        throw new TypeError(`Non-string provided as watch path: ${paths}`);
      }
      return paths.map(normalizePathToUnix2);
    };
    var toUnix2 = (string3) => {
      let str2 = string3.replace(BACK_SLASH_RE2, SLASH2);
      let prepend = false;
      if (str2.startsWith(SLASH_SLASH2)) {
        prepend = true;
      }
      while (str2.match(DOUBLE_SLASH_RE2)) {
        str2 = str2.replace(DOUBLE_SLASH_RE2, SLASH2);
      }
      if (prepend) {
        str2 = SLASH2 + str2;
      }
      return str2;
    };
    var normalizePathToUnix2 = (path8) => toUnix2(sysPath2.normalize(toUnix2(path8)));
    var normalizeIgnored2 = (cwd = EMPTY_STR2) => (path8) => {
      if (typeof path8 !== STRING_TYPE2)
        return path8;
      return normalizePathToUnix2(sysPath2.isAbsolute(path8) ? path8 : sysPath2.join(cwd, path8));
    };
    var getAbsolutePath2 = (path8, cwd) => {
      if (sysPath2.isAbsolute(path8)) {
        return path8;
      }
      if (path8.startsWith(BANG2)) {
        return BANG2 + sysPath2.join(cwd, path8.slice(1));
      }
      return sysPath2.join(cwd, path8);
    };
    var undef2 = (opts, key) => opts[key] === void 0;
    var DirEntry2 = class {
      /**
       * @param {Path} dir
       * @param {Function} removeWatcher
       */
      constructor(dir, removeWatcher) {
        this.path = dir;
        this._removeWatcher = removeWatcher;
        this.items = /* @__PURE__ */ new Set();
      }
      add(item) {
        const { items } = this;
        if (!items)
          return;
        if (item !== ONE_DOT2 && item !== TWO_DOTS2)
          items.add(item);
      }
      async remove(item) {
        const { items } = this;
        if (!items)
          return;
        items.delete(item);
        if (items.size > 0)
          return;
        const dir = this.path;
        try {
          await readdir2(dir);
        } catch (err2) {
          if (this._removeWatcher) {
            this._removeWatcher(sysPath2.dirname(dir), sysPath2.basename(dir));
          }
        }
      }
      has(item) {
        const { items } = this;
        if (!items)
          return;
        return items.has(item);
      }
      /**
       * @returns {Array<String>}
       */
      getChildren() {
        const { items } = this;
        if (!items)
          return;
        return [...items.values()];
      }
      dispose() {
        this.items.clear();
        delete this.path;
        delete this._removeWatcher;
        delete this.items;
        Object.freeze(this);
      }
    };
    var STAT_METHOD_F2 = "stat";
    var STAT_METHOD_L2 = "lstat";
    var WatchHelper2 = class {
      constructor(path8, watchPath, follow, fsw) {
        this.fsw = fsw;
        this.path = path8 = path8.replace(REPLACER_RE2, EMPTY_STR2);
        this.watchPath = watchPath;
        this.fullWatchPath = sysPath2.resolve(watchPath);
        this.hasGlob = watchPath !== path8;
        if (path8 === EMPTY_STR2)
          this.hasGlob = false;
        this.globSymlink = this.hasGlob && follow ? void 0 : false;
        this.globFilter = this.hasGlob ? anymatch2(path8, void 0, ANYMATCH_OPTS2) : false;
        this.dirParts = this.getDirParts(path8);
        this.dirParts.forEach((parts) => {
          if (parts.length > 1)
            parts.pop();
        });
        this.followSymlinks = follow;
        this.statMethod = follow ? STAT_METHOD_F2 : STAT_METHOD_L2;
      }
      checkGlobSymlink(entry2) {
        if (this.globSymlink === void 0) {
          this.globSymlink = entry2.fullParentDir === this.fullWatchPath ? false : { realPath: entry2.fullParentDir, linkPath: this.fullWatchPath };
        }
        if (this.globSymlink) {
          return entry2.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);
        }
        return entry2.fullPath;
      }
      entryPath(entry2) {
        return sysPath2.join(
          this.watchPath,
          sysPath2.relative(this.watchPath, this.checkGlobSymlink(entry2))
        );
      }
      filterPath(entry2) {
        const { stats } = entry2;
        if (stats && stats.isSymbolicLink())
          return this.filterDir(entry2);
        const resolvedPath = this.entryPath(entry2);
        const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE2 ? this.globFilter(resolvedPath) : true;
        return matchesGlob && this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);
      }
      getDirParts(path8) {
        if (!this.hasGlob)
          return [];
        const parts = [];
        const expandedPath = path8.includes(BRACE_START2) ? braces2.expand(path8) : [path8];
        expandedPath.forEach((path9) => {
          parts.push(sysPath2.relative(this.watchPath, path9).split(SLASH_OR_BACK_SLASH_RE2));
        });
        return parts;
      }
      filterDir(entry2) {
        if (this.hasGlob) {
          const entryParts = this.getDirParts(this.checkGlobSymlink(entry2));
          let globstar = false;
          this.unmatchedGlob = !this.dirParts.some((parts) => {
            return parts.every((part, i2) => {
              if (part === GLOBSTAR2)
                globstar = true;
              return globstar || !entryParts[0][i2] || anymatch2(part, entryParts[0][i2], ANYMATCH_OPTS2);
            });
          });
        }
        return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry2), entry2.stats);
      }
    };
    var FSWatcher2 = class extends EventEmitter3 {
      // Not indenting methods for history sake; for now.
      constructor(_opts) {
        super();
        const opts = {};
        if (_opts)
          Object.assign(opts, _opts);
        this._watched = /* @__PURE__ */ new Map();
        this._closers = /* @__PURE__ */ new Map();
        this._ignoredPaths = /* @__PURE__ */ new Set();
        this._throttled = /* @__PURE__ */ new Map();
        this._symlinkPaths = /* @__PURE__ */ new Map();
        this._streams = /* @__PURE__ */ new Set();
        this.closed = false;
        if (undef2(opts, "persistent"))
          opts.persistent = true;
        if (undef2(opts, "ignoreInitial"))
          opts.ignoreInitial = false;
        if (undef2(opts, "ignorePermissionErrors"))
          opts.ignorePermissionErrors = false;
        if (undef2(opts, "interval"))
          opts.interval = 100;
        if (undef2(opts, "binaryInterval"))
          opts.binaryInterval = 300;
        if (undef2(opts, "disableGlobbing"))
          opts.disableGlobbing = false;
        opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;
        if (undef2(opts, "useFsEvents"))
          opts.useFsEvents = !opts.usePolling;
        const canUseFsEvents = FsEventsHandler3.canUse();
        if (!canUseFsEvents)
          opts.useFsEvents = false;
        if (undef2(opts, "usePolling") && !opts.useFsEvents) {
          opts.usePolling = isMacos2;
        }
        if (isIBMi2) {
          opts.usePolling = true;
        }
        const envPoll = process.env.CHOKIDAR_USEPOLLING;
        if (envPoll !== void 0) {
          const envLower = envPoll.toLowerCase();
          if (envLower === "false" || envLower === "0") {
            opts.usePolling = false;
          } else if (envLower === "true" || envLower === "1") {
            opts.usePolling = true;
          } else {
            opts.usePolling = !!envLower;
          }
        }
        const envInterval = process.env.CHOKIDAR_INTERVAL;
        if (envInterval) {
          opts.interval = Number.parseInt(envInterval, 10);
        }
        if (undef2(opts, "atomic"))
          opts.atomic = !opts.usePolling && !opts.useFsEvents;
        if (opts.atomic)
          this._pendingUnlinks = /* @__PURE__ */ new Map();
        if (undef2(opts, "followSymlinks"))
          opts.followSymlinks = true;
        if (undef2(opts, "awaitWriteFinish"))
          opts.awaitWriteFinish = false;
        if (opts.awaitWriteFinish === true)
          opts.awaitWriteFinish = {};
        const awf = opts.awaitWriteFinish;
        if (awf) {
          if (!awf.stabilityThreshold)
            awf.stabilityThreshold = 2e3;
          if (!awf.pollInterval)
            awf.pollInterval = 100;
          this._pendingWrites = /* @__PURE__ */ new Map();
        }
        if (opts.ignored)
          opts.ignored = arrify2(opts.ignored);
        let readyCalls = 0;
        this._emitReady = () => {
          readyCalls++;
          if (readyCalls >= this._readyCount) {
            this._emitReady = EMPTY_FN2;
            this._readyEmitted = true;
            process.nextTick(() => this.emit(EV_READY2));
          }
        };
        this._emitRaw = (...args) => this.emit(EV_RAW2, ...args);
        this._readyEmitted = false;
        this.options = opts;
        if (opts.useFsEvents) {
          this._fsEventsHandler = new FsEventsHandler3(this);
        } else {
          this._nodeFsHandler = new NodeFsHandler3(this);
        }
        Object.freeze(opts);
      }
      // Public methods
      /**
       * Adds paths to be watched on an existing FSWatcher instance
       * @param {Path|Array<Path>} paths_
       * @param {String=} _origAdd private; for handling non-existent paths to be watched
       * @param {Boolean=} _internal private; indicates a non-user add
       * @returns {FSWatcher} for chaining
       */
      add(paths_, _origAdd, _internal) {
        const { cwd, disableGlobbing } = this.options;
        this.closed = false;
        let paths = unifyPaths2(paths_);
        if (cwd) {
          paths = paths.map((path8) => {
            const absPath = getAbsolutePath2(path8, cwd);
            if (disableGlobbing || !isGlob3(path8)) {
              return absPath;
            }
            return normalizePath4(absPath);
          });
        }
        paths = paths.filter((path8) => {
          if (path8.startsWith(BANG2)) {
            this._ignoredPaths.add(path8.slice(1));
            return false;
          }
          this._ignoredPaths.delete(path8);
          this._ignoredPaths.delete(path8 + SLASH_GLOBSTAR2);
          this._userIgnored = void 0;
          return true;
        });
        if (this.options.useFsEvents && this._fsEventsHandler) {
          if (!this._readyCount)
            this._readyCount = paths.length;
          if (this.options.persistent)
            this._readyCount *= 2;
          paths.forEach((path8) => this._fsEventsHandler._addToFsEvents(path8));
        } else {
          if (!this._readyCount)
            this._readyCount = 0;
          this._readyCount += paths.length;
          Promise.all(
            paths.map(async (path8) => {
              const res = await this._nodeFsHandler._addToNodeFs(path8, !_internal, 0, 0, _origAdd);
              if (res)
                this._emitReady();
              return res;
            })
          ).then((results) => {
            if (this.closed)
              return;
            results.filter((item) => item).forEach((item) => {
              this.add(sysPath2.dirname(item), sysPath2.basename(_origAdd || item));
            });
          });
        }
        return this;
      }
      /**
       * Close watchers or start ignoring events from specified paths.
       * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs
       * @returns {FSWatcher} for chaining
      */
      unwatch(paths_) {
        if (this.closed)
          return this;
        const paths = unifyPaths2(paths_);
        const { cwd } = this.options;
        paths.forEach((path8) => {
          if (!sysPath2.isAbsolute(path8) && !this._closers.has(path8)) {
            if (cwd)
              path8 = sysPath2.join(cwd, path8);
            path8 = sysPath2.resolve(path8);
          }
          this._closePath(path8);
          this._ignoredPaths.add(path8);
          if (this._watched.has(path8)) {
            this._ignoredPaths.add(path8 + SLASH_GLOBSTAR2);
          }
          this._userIgnored = void 0;
        });
        return this;
      }
      /**
       * Close watchers and remove all listeners from watched paths.
       * @returns {Promise<void>}.
      */
      close() {
        if (this.closed)
          return this._closePromise;
        this.closed = true;
        this.removeAllListeners();
        const closers = [];
        this._closers.forEach((closerList) => closerList.forEach((closer) => {
          const promise2 = closer();
          if (promise2 instanceof Promise)
            closers.push(promise2);
        }));
        this._streams.forEach((stream4) => stream4.destroy());
        this._userIgnored = void 0;
        this._readyCount = 0;
        this._readyEmitted = false;
        this._watched.forEach((dirent) => dirent.dispose());
        ["closers", "watched", "streams", "symlinkPaths", "throttled"].forEach((key) => {
          this[`_${key}`].clear();
        });
        this._closePromise = closers.length ? Promise.all(closers).then(() => void 0) : Promise.resolve();
        return this._closePromise;
      }
      /**
       * Expose list of watched paths
       * @returns {Object} for chaining
      */
      getWatched() {
        const watchList = {};
        this._watched.forEach((entry2, dir) => {
          const key = this.options.cwd ? sysPath2.relative(this.options.cwd, dir) : dir;
          watchList[key || ONE_DOT2] = entry2.getChildren().sort();
        });
        return watchList;
      }
      emitWithAll(event, args) {
        this.emit(...args);
        if (event !== EV_ERROR2)
          this.emit(EV_ALL2, ...args);
      }
      // Common helpers
      // --------------
      /**
       * Normalize and emit events.
       * Calling _emit DOES NOT MEAN emit() would be called!
       * @param {EventName} event Type of event
       * @param {Path} path File or directory path
       * @param {*=} val1 arguments to be passed with event
       * @param {*=} val2
       * @param {*=} val3
       * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag
       */
      async _emit(event, path8, val1, val2, val3) {
        if (this.closed)
          return;
        const opts = this.options;
        if (isWindows2)
          path8 = sysPath2.normalize(path8);
        if (opts.cwd)
          path8 = sysPath2.relative(opts.cwd, path8);
        const args = [event, path8];
        if (val3 !== void 0)
          args.push(val1, val2, val3);
        else if (val2 !== void 0)
          args.push(val1, val2);
        else if (val1 !== void 0)
          args.push(val1);
        const awf = opts.awaitWriteFinish;
        let pw;
        if (awf && (pw = this._pendingWrites.get(path8))) {
          pw.lastChange = new Date();
          return this;
        }
        if (opts.atomic) {
          if (event === EV_UNLINK2) {
            this._pendingUnlinks.set(path8, args);
            setTimeout(() => {
              this._pendingUnlinks.forEach((entry2, path9) => {
                this.emit(...entry2);
                this.emit(EV_ALL2, ...entry2);
                this._pendingUnlinks.delete(path9);
              });
            }, typeof opts.atomic === "number" ? opts.atomic : 100);
            return this;
          }
          if (event === EV_ADD2 && this._pendingUnlinks.has(path8)) {
            event = args[0] = EV_CHANGE2;
            this._pendingUnlinks.delete(path8);
          }
        }
        if (awf && (event === EV_ADD2 || event === EV_CHANGE2) && this._readyEmitted) {
          const awfEmit = (err2, stats) => {
            if (err2) {
              event = args[0] = EV_ERROR2;
              args[1] = err2;
              this.emitWithAll(event, args);
            } else if (stats) {
              if (args.length > 2) {
                args[2] = stats;
              } else {
                args.push(stats);
              }
              this.emitWithAll(event, args);
            }
          };
          this._awaitWriteFinish(path8, awf.stabilityThreshold, event, awfEmit);
          return this;
        }
        if (event === EV_CHANGE2) {
          const isThrottled = !this._throttle(EV_CHANGE2, path8, 50);
          if (isThrottled)
            return this;
        }
        if (opts.alwaysStat && val1 === void 0 && (event === EV_ADD2 || event === EV_ADD_DIR2 || event === EV_CHANGE2)) {
          const fullPath = opts.cwd ? sysPath2.join(opts.cwd, path8) : path8;
          let stats;
          try {
            stats = await stat2(fullPath);
          } catch (err2) {
          }
          if (!stats || this.closed)
            return;
          args.push(stats);
        }
        this.emitWithAll(event, args);
        return this;
      }
      /**
       * Common handler for errors
       * @param {Error} error
       * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag
       */
      _handleError(error3) {
        const code = error3 && error3.code;
        if (error3 && code !== "ENOENT" && code !== "ENOTDIR" && (!this.options.ignorePermissionErrors || code !== "EPERM" && code !== "EACCES")) {
          this.emit(EV_ERROR2, error3);
        }
        return error3 || this.closed;
      }
      /**
       * Helper utility for throttling
       * @param {ThrottleType} actionType type being throttled
       * @param {Path} path being acted upon
       * @param {Number} timeout duration of time to suppress duplicate actions
       * @returns {Object|false} tracking object or false if action should be suppressed
       */
      _throttle(actionType, path8, timeout2) {
        if (!this._throttled.has(actionType)) {
          this._throttled.set(actionType, /* @__PURE__ */ new Map());
        }
        const action = this._throttled.get(actionType);
        const actionPath = action.get(path8);
        if (actionPath) {
          actionPath.count++;
          return false;
        }
        let timeoutObject;
        const clear = () => {
          const item = action.get(path8);
          const count = item ? item.count : 0;
          action.delete(path8);
          clearTimeout(timeoutObject);
          if (item)
            clearTimeout(item.timeoutObject);
          return count;
        };
        timeoutObject = setTimeout(clear, timeout2);
        const thr = { timeoutObject, clear, count: 0 };
        action.set(path8, thr);
        return thr;
      }
      _incrReadyCount() {
        return this._readyCount++;
      }
      /**
       * Awaits write operation to finish.
       * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.
       * @param {Path} path being acted upon
       * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished
       * @param {EventName} event
       * @param {Function} awfEmit Callback to be called when ready for event to be emitted.
       */
      _awaitWriteFinish(path8, threshold2, event, awfEmit) {
        let timeoutHandler;
        let fullPath = path8;
        if (this.options.cwd && !sysPath2.isAbsolute(path8)) {
          fullPath = sysPath2.join(this.options.cwd, path8);
        }
        const now = new Date();
        const awaitWriteFinish = (prevStat) => {
          fs6.stat(fullPath, (err2, curStat) => {
            if (err2 || !this._pendingWrites.has(path8)) {
              if (err2 && err2.code !== "ENOENT")
                awfEmit(err2);
              return;
            }
            const now2 = Number(new Date());
            if (prevStat && curStat.size !== prevStat.size) {
              this._pendingWrites.get(path8).lastChange = now2;
            }
            const pw = this._pendingWrites.get(path8);
            const df = now2 - pw.lastChange;
            if (df >= threshold2) {
              this._pendingWrites.delete(path8);
              awfEmit(void 0, curStat);
            } else {
              timeoutHandler = setTimeout(
                awaitWriteFinish,
                this.options.awaitWriteFinish.pollInterval,
                curStat
              );
            }
          });
        };
        if (!this._pendingWrites.has(path8)) {
          this._pendingWrites.set(path8, {
            lastChange: now,
            cancelWait: () => {
              this._pendingWrites.delete(path8);
              clearTimeout(timeoutHandler);
              return event;
            }
          });
          timeoutHandler = setTimeout(
            awaitWriteFinish,
            this.options.awaitWriteFinish.pollInterval
          );
        }
      }
      _getGlobIgnored() {
        return [...this._ignoredPaths.values()];
      }
      /**
       * Determines whether user has asked to ignore this path.
       * @param {Path} path filepath or dir
       * @param {fs.Stats=} stats result of fs.stat
       * @returns {Boolean}
       */
      _isIgnored(path8, stats) {
        if (this.options.atomic && DOT_RE2.test(path8))
          return true;
        if (!this._userIgnored) {
          const { cwd } = this.options;
          const ign = this.options.ignored;
          const ignored = ign && ign.map(normalizeIgnored2(cwd));
          const paths = arrify2(ignored).filter((path9) => typeof path9 === STRING_TYPE2 && !isGlob3(path9)).map((path9) => path9 + SLASH_GLOBSTAR2);
          const list = this._getGlobIgnored().map(normalizeIgnored2(cwd)).concat(ignored, paths);
          this._userIgnored = anymatch2(list, void 0, ANYMATCH_OPTS2);
        }
        return this._userIgnored([path8, stats]);
      }
      _isntIgnored(path8, stat3) {
        return !this._isIgnored(path8, stat3);
      }
      /**
       * Provides a set of common helpers and properties relating to symlink and glob handling.
       * @param {Path} path file, directory, or glob pattern being watched
       * @param {Number=} depth at any depth > 0, this isn't a glob
       * @returns {WatchHelper} object containing helpers for this path
       */
      _getWatchHelpers(path8, depth2) {
        const watchPath = depth2 || this.options.disableGlobbing || !isGlob3(path8) ? path8 : globParent3(path8);
        const follow = this.options.followSymlinks;
        return new WatchHelper2(path8, watchPath, follow, this);
      }
      // Directory helpers
      // -----------------
      /**
       * Provides directory tracking objects
       * @param {String} directory path of the directory
       * @returns {DirEntry} the directory's tracking object
       */
      _getWatchedDir(directory) {
        if (!this._boundRemove)
          this._boundRemove = this._remove.bind(this);
        const dir = sysPath2.resolve(directory);
        if (!this._watched.has(dir))
          this._watched.set(dir, new DirEntry2(dir, this._boundRemove));
        return this._watched.get(dir);
      }
      // File helpers
      // ------------
      /**
       * Check for read permissions.
       * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405
       * @param {fs.Stats} stats - object, result of fs_stat
       * @returns {Boolean} indicates whether the file can be read
      */
      _hasReadPermissions(stats) {
        if (this.options.ignorePermissionErrors)
          return true;
        const md = stats && Number.parseInt(stats.mode, 10);
        const st = md & 511;
        const it = Number.parseInt(st.toString(8)[0], 10);
        return Boolean(4 & it);
      }
      /**
       * Handles emitting unlink events for
       * files and directories, and via recursion, for
       * files and directories within directories that are unlinked
       * @param {String} directory within which the following item is located
       * @param {String} item      base path of item/directory
       * @returns {void}
      */
      _remove(directory, item, isDirectory2) {
        const path8 = sysPath2.join(directory, item);
        const fullPath = sysPath2.resolve(path8);
        isDirectory2 = isDirectory2 != null ? isDirectory2 : this._watched.has(path8) || this._watched.has(fullPath);
        if (!this._throttle("remove", path8, 100))
          return;
        if (!isDirectory2 && !this.options.useFsEvents && this._watched.size === 1) {
          this.add(directory, item, true);
        }
        const wp = this._getWatchedDir(path8);
        const nestedDirectoryChildren = wp.getChildren();
        nestedDirectoryChildren.forEach((nested) => this._remove(path8, nested));
        const parent = this._getWatchedDir(directory);
        const wasTracked = parent.has(item);
        parent.remove(item);
        if (this._symlinkPaths.has(fullPath)) {
          this._symlinkPaths.delete(fullPath);
        }
        let relPath = path8;
        if (this.options.cwd)
          relPath = sysPath2.relative(this.options.cwd, path8);
        if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {
          const event = this._pendingWrites.get(relPath).cancelWait();
          if (event === EV_ADD2)
            return;
        }
        this._watched.delete(path8);
        this._watched.delete(fullPath);
        const eventName = isDirectory2 ? EV_UNLINK_DIR2 : EV_UNLINK2;
        if (wasTracked && !this._isIgnored(path8))
          this._emit(eventName, path8);
        if (!this.options.useFsEvents) {
          this._closePath(path8);
        }
      }
      /**
       * Closes all watchers for a path
       * @param {Path} path
       */
      _closePath(path8) {
        this._closeFile(path8);
        const dir = sysPath2.dirname(path8);
        this._getWatchedDir(dir).remove(sysPath2.basename(path8));
      }
      /**
       * Closes only file-specific watchers
       * @param {Path} path
       */
      _closeFile(path8) {
        const closers = this._closers.get(path8);
        if (!closers)
          return;
        closers.forEach((closer) => closer());
        this._closers.delete(path8);
      }
      /**
       *
       * @param {Path} path
       * @param {Function} closer
       */
      _addPathCloser(path8, closer) {
        if (!closer)
          return;
        let list = this._closers.get(path8);
        if (!list) {
          list = [];
          this._closers.set(path8, list);
        }
        list.push(closer);
      }
      _readdirp(root, opts) {
        if (this.closed)
          return;
        const options3 = { type: EV_ALL2, alwaysStat: true, lstat: true, ...opts };
        let stream4 = readdirp2(root, options3);
        this._streams.add(stream4);
        stream4.once(STR_CLOSE2, () => {
          stream4 = void 0;
        });
        stream4.once(STR_END2, () => {
          if (stream4) {
            this._streams.delete(stream4);
            stream4 = void 0;
          }
        });
        return stream4;
      }
    };
    exports3.FSWatcher = FSWatcher2;
    var watch2 = (paths, options3) => {
      const watcher = new FSWatcher2(options3);
      watcher.add(paths);
      return watcher;
    };
    exports3.watch = watch2;
  }
});

// node_modules/.pnpm/envinfo@7.8.1/node_modules/envinfo/dist/envinfo.js
var require_envinfo = __commonJS({
  "node_modules/.pnpm/envinfo@7.8.1/node_modules/envinfo/dist/envinfo.js"(exports3, module2) {
    module2.exports = function(e3) {
      var t3 = {};
      function n3(r3) {
        if (t3[r3])
          return t3[r3].exports;
        var o3 = t3[r3] = { i: r3, l: false, exports: {} };
        return e3[r3].call(o3.exports, o3, o3.exports, n3), o3.l = true, o3.exports;
      }
      return n3.m = e3, n3.c = t3, n3.d = function(e4, t4, r3) {
        n3.o(e4, t4) || Object.defineProperty(e4, t4, { enumerable: true, get: r3 });
      }, n3.r = function(e4) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e4, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e4, "__esModule", { value: true });
      }, n3.t = function(e4, t4) {
        if (1 & t4 && (e4 = n3(e4)), 8 & t4)
          return e4;
        if (4 & t4 && "object" == typeof e4 && e4 && e4.__esModule)
          return e4;
        var r3 = /* @__PURE__ */ Object.create(null);
        if (n3.r(r3), Object.defineProperty(r3, "default", { enumerable: true, value: e4 }), 2 & t4 && "string" != typeof e4)
          for (var o3 in e4)
            n3.d(r3, o3, function(t5) {
              return e4[t5];
            }.bind(null, o3));
        return r3;
      }, n3.n = function(e4) {
        var t4 = e4 && e4.__esModule ? function() {
          return e4.default;
        } : function() {
          return e4;
        };
        return n3.d(t4, "a", t4), t4;
      }, n3.o = function(e4, t4) {
        return Object.prototype.hasOwnProperty.call(e4, t4);
      }, n3.p = "", n3(n3.s = 78);
    }([function(e3, t3) {
      e3.exports = require_path();
    }, function(e3, t3, n3) {
      "use strict";
      n3(22), n3(101), n3(21), n3(103), n3(114), n3(16), n3(27), n3(74), n3(116), n3(2);
      var r3 = n3(0), o3 = n3(5), i2 = n3(17), s2 = n3(49), a2 = n3(76), c2 = n3(45), u2 = n3(121), l2 = function(e4) {
        var t4 = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}).unify, n4 = void 0 !== t4 && t4;
        return new Promise(function(t5) {
          s2.exec(e4, { stdio: [0, "pipe", "ignore"] }, function(e5, r4, o4) {
            var i3 = "";
            i3 = n4 ? r4.toString() + o4.toString() : r4.toString(), t5((e5 ? "" : i3).trim());
          });
        });
      }, f2 = function(e4) {
        var t4 = Object.values(Array.prototype.slice.call(arguments).slice(1));
        (process.env.ENVINFO_DEBUG || "").toLowerCase() === e4 && console.log(e4, JSON.stringify(t4));
      }, p2 = function(e4) {
        return new Promise(function(t4) {
          o3.readFile(e4, "utf8", function(e5, n4) {
            return t4(n4 || null);
          });
        });
      }, h = function(e4) {
        return p2(e4).then(function(e5) {
          return e5 ? JSON.parse(e5) : null;
        });
      }, d2 = /\d+\.[\d+|.]+/g, m = function(e4) {
        f2("trace", "findDarwinApplication", e4);
        var t4 = `mdfind "kMDItemCFBundleIdentifier=='${e4}'"`;
        return f2("trace", t4), l2(t4).then(function(e5) {
          return e5.replace(/(\s)/g, "\\ ");
        });
      }, g = function(e4, t4) {
        var n4 = (t4 || ["CFBundleShortVersionString"]).map(function(e5) {
          return "-c Print:" + e5;
        });
        return ["/usr/libexec/PlistBuddy"].concat(n4).concat([e4]).join(" ");
      }, v = function(e4, t4) {
        for (var n4 = [], r4 = null; null !== (r4 = e4.exec(t4)); )
          n4.push(r4);
        return n4;
      };
      e3.exports = { run: l2, log: f2, fileExists: function(e4) {
        return new Promise(function(t4) {
          o3.stat(e4, function(n4) {
            return t4(n4 ? null : e4);
          });
        });
      }, readFile: p2, requireJson: h, versionRegex: d2, findDarwinApplication: m, generatePlistBuddyCommand: g, matchAll: v, parseSDKManagerOutput: function(e4) {
        var t4 = e4.split("Available")[0];
        return { apiLevels: v(u2.androidAPILevels, t4).map(function(e5) {
          return e5[1];
        }), buildTools: v(u2.androidBuildTools, t4).map(function(e5) {
          return e5[1];
        }), systemImages: v(u2.androidSystemImages, t4).map(function(e5) {
          return e5[1].split("|").map(function(e6) {
            return e6.trim();
          });
        }).map(function(e5) {
          return e5[0].split(";")[0] + " | " + e5[2].split(" System Image")[0];
        }) };
      }, isLinux: "linux" === process.platform, isMacOS: "darwin" === process.platform, NA: "N/A", NotFound: "Not Found", isWindows: process.platform.startsWith("win"), isObject: function(e4) {
        return "object" == typeof e4 && !Array.isArray(e4);
      }, noop: function(e4) {
        return e4;
      }, pipe: function(e4) {
        return function(t4) {
          return e4.reduce(function(e5, t5) {
            return t5(e5);
          }, t4);
        };
      }, browserBundleIdentifiers: { "Brave Browser": "com.brave.Browser", Chrome: "com.google.Chrome", "Chrome Canary": "com.google.Chrome.canary", Firefox: "org.mozilla.firefox", "Firefox Developer Edition": "org.mozilla.firefoxdeveloperedition", "Firefox Nightly": "org.mozilla.nightly", "Microsoft Edge": "com.microsoft.edgemac", Safari: "com.apple.Safari", "Safari Technology Preview": "com.apple.SafariTechnologyPreview" }, ideBundleIdentifiers: { Atom: "com.github.atom", IntelliJ: "com.jetbrains.intellij", PhpStorm: "com.jetbrains.PhpStorm", "Sublime Text": "com.sublimetext.3", WebStorm: "com.jetbrains.WebStorm" }, runSync: function(e4) {
        return (s2.execSync(e4, { stdio: [0, "pipe", "ignore"] }).toString() || "").trim();
      }, which: function(e4) {
        return new Promise(function(t4) {
          return a2(e4, function(e5, n4) {
            return t4(n4);
          });
        });
      }, getDarwinApplicationVersion: function(e4) {
        var t4;
        return f2("trace", "getDarwinApplicationVersion", e4), t4 = "darwin" !== process.platform ? "N/A" : m(e4).then(function(e5) {
          return l2(g(r3.join(e5, "Contents", "Info.plist"), ["CFBundleShortVersionString"]));
        }), Promise.resolve(t4);
      }, uniq: function(e4) {
        return Array.from(new Set(e4));
      }, toReadableBytes: function(e4) {
        var t4 = Math.floor(Math.log(e4) / Math.log(1024));
        return e4 ? (e4 / Math.pow(1024, t4)).toFixed(2) + " " + ["B", "KB", "MB", "GB", "TB", "PB"][t4] : "0 Bytes";
      }, omit: function(e4, t4) {
        return Object.keys(e4).filter(function(e5) {
          return t4.indexOf(e5) < 0;
        }).reduce(function(t5, n4) {
          return Object.assign(t5, { [n4]: e4[n4] });
        }, {});
      }, pick: function(e4, t4) {
        return Object.keys(e4).filter(function(e5) {
          return t4.indexOf(e5) >= 0;
        }).reduce(function(t5, n4) {
          return Object.assign(t5, { [n4]: e4[n4] });
        }, {});
      }, getPackageJsonByName: function(e4) {
        return h(r3.join(process.cwd(), "node_modules", e4, "package.json"));
      }, getPackageJsonByPath: function(e4) {
        return h(r3.join(process.cwd(), e4));
      }, getPackageJsonByFullPath: function(e4) {
        return f2("trace", "getPackageJsonByFullPath", e4), h(e4);
      }, getAllPackageJsonPaths: function(e4) {
        return f2("trace", "getAllPackageJsonPaths", e4), new Promise(function(t4) {
          var n4 = function(e5, n5) {
            return t4(n5.map(r3.normalize) || []);
          };
          return c2(e4 ? r3.join("node_modules", e4, "package.json") : r3.join("node_modules", "**", "package.json"), n4);
        });
      }, sortObject: function(e4) {
        return Object.keys(e4).sort().reduce(function(t4, n4) {
          return t4[n4] = e4[n4], t4;
        }, {});
      }, findVersion: function(e4, t4, n4) {
        f2("trace", "findVersion", e4, t4, n4);
        var r4 = n4 || 0, o4 = t4 || d2, i3 = e4.match(o4);
        return i3 ? i3[r4] : e4;
      }, condensePath: function(e4) {
        return (e4 || "").replace(i2.homedir(), "~");
      }, determineFound: function(e4, t4, n4) {
        return f2("trace", "determineFound", e4, t4, n4), "N/A" === t4 ? Promise.resolve([e4, "N/A"]) : t4 && 0 !== Object.keys(t4).length ? n4 ? Promise.resolve([e4, t4, n4]) : Promise.resolve([e4, t4]) : Promise.resolve([e4, "Not Found"]);
      } };
    }, function(e3, t3, n3) {
      "use strict";
      var r3, o3, i2, s2, a2 = n3(36), c2 = n3(4), u2 = n3(12), l2 = n3(56), f2 = n3(8), p2 = n3(6), h = n3(19), d2 = n3(37), m = n3(38), g = n3(81), v = n3(60).set, y = n3(83)(), b = n3(62), w = n3(84), x = n3(85), S = n3(86), P = c2.TypeError, O = c2.process, j = O && O.versions, E2 = j && j.v8 || "", I = c2.Promise, _ = "process" == l2(O), A2 = function() {
      }, k = o3 = b.f, N = !!function() {
        try {
          var e4 = I.resolve(1), t4 = (e4.constructor = {})[n3(3)("species")] = function(e5) {
            e5(A2, A2);
          };
          return (_ || "function" == typeof PromiseRejectionEvent) && e4.then(A2) instanceof t4 && 0 !== E2.indexOf("6.6") && -1 === x.indexOf("Chrome/66");
        } catch (e5) {
        }
      }(), F = function(e4) {
        var t4;
        return !(!p2(e4) || "function" != typeof (t4 = e4.then)) && t4;
      }, C2 = function(e4, t4) {
        if (!e4._n) {
          e4._n = true;
          var n4 = e4._c;
          y(function() {
            for (var r4 = e4._v, o4 = 1 == e4._s, i3 = 0, s3 = function(t5) {
              var n5, i4, s4, a3 = o4 ? t5.ok : t5.fail, c3 = t5.resolve, u3 = t5.reject, l3 = t5.domain;
              try {
                a3 ? (o4 || (2 == e4._h && V(e4), e4._h = 1), true === a3 ? n5 = r4 : (l3 && l3.enter(), n5 = a3(r4), l3 && (l3.exit(), s4 = true)), n5 === t5.promise ? u3(P("Promise-chain cycle")) : (i4 = F(n5)) ? i4.call(n5, c3, u3) : c3(n5)) : u3(r4);
              } catch (e5) {
                l3 && !s4 && l3.exit(), u3(e5);
              }
            }; n4.length > i3; )
              s3(n4[i3++]);
            e4._c = [], e4._n = false, t4 && !e4._h && M(e4);
          });
        }
      }, M = function(e4) {
        v.call(c2, function() {
          var t4, n4, r4, o4 = e4._v, i3 = T(e4);
          if (i3 && (t4 = w(function() {
            _ ? O.emit("unhandledRejection", o4, e4) : (n4 = c2.onunhandledrejection) ? n4({ promise: e4, reason: o4 }) : (r4 = c2.console) && r4.error && r4.error("Unhandled promise rejection", o4);
          }), e4._h = _ || T(e4) ? 2 : 1), e4._a = void 0, i3 && t4.e)
            throw t4.v;
        });
      }, T = function(e4) {
        return 1 !== e4._h && 0 === (e4._a || e4._c).length;
      }, V = function(e4) {
        v.call(c2, function() {
          var t4;
          _ ? O.emit("rejectionHandled", e4) : (t4 = c2.onrejectionhandled) && t4({ promise: e4, reason: e4._v });
        });
      }, D = function(e4) {
        var t4 = this;
        t4._d || (t4._d = true, (t4 = t4._w || t4)._v = e4, t4._s = 2, t4._a || (t4._a = t4._c.slice()), C2(t4, true));
      }, B2 = function(e4) {
        var t4, n4 = this;
        if (!n4._d) {
          n4._d = true, n4 = n4._w || n4;
          try {
            if (n4 === e4)
              throw P("Promise can't be resolved itself");
            (t4 = F(e4)) ? y(function() {
              var r4 = { _w: n4, _d: false };
              try {
                t4.call(e4, u2(B2, r4, 1), u2(D, r4, 1));
              } catch (e5) {
                D.call(r4, e5);
              }
            }) : (n4._v = e4, n4._s = 1, C2(n4, false));
          } catch (e5) {
            D.call({ _w: n4, _d: false }, e5);
          }
        }
      };
      N || (I = function(e4) {
        d2(this, I, "Promise", "_h"), h(e4), r3.call(this);
        try {
          e4(u2(B2, this, 1), u2(D, this, 1));
        } catch (e5) {
          D.call(this, e5);
        }
      }, (r3 = function(e4) {
        this._c = [], this._a = void 0, this._s = 0, this._d = false, this._v = void 0, this._h = 0, this._n = false;
      }).prototype = n3(40)(I.prototype, { then: function(e4, t4) {
        var n4 = k(g(this, I));
        return n4.ok = "function" != typeof e4 || e4, n4.fail = "function" == typeof t4 && t4, n4.domain = _ ? O.domain : void 0, this._c.push(n4), this._a && this._a.push(n4), this._s && C2(this, false), n4.promise;
      }, catch: function(e4) {
        return this.then(void 0, e4);
      } }), i2 = function() {
        var e4 = new r3();
        this.promise = e4, this.resolve = u2(B2, e4, 1), this.reject = u2(D, e4, 1);
      }, b.f = k = function(e4) {
        return e4 === I || e4 === s2 ? new i2(e4) : o3(e4);
      }), f2(f2.G + f2.W + f2.F * !N, { Promise: I }), n3(26)(I, "Promise"), n3(63)("Promise"), s2 = n3(18).Promise, f2(f2.S + f2.F * !N, "Promise", { reject: function(e4) {
        var t4 = k(this);
        return (0, t4.reject)(e4), t4.promise;
      } }), f2(f2.S + f2.F * (a2 || !N), "Promise", { resolve: function(e4) {
        return S(a2 && this === s2 ? I : this, e4);
      } }), f2(f2.S + f2.F * !(N && n3(41)(function(e4) {
        I.all(e4).catch(A2);
      })), "Promise", { all: function(e4) {
        var t4 = this, n4 = k(t4), r4 = n4.resolve, o4 = n4.reject, i3 = w(function() {
          var n5 = [], i4 = 0, s3 = 1;
          m(e4, false, function(e5) {
            var a3 = i4++, c3 = false;
            n5.push(void 0), s3++, t4.resolve(e5).then(function(e6) {
              c3 || (c3 = true, n5[a3] = e6, --s3 || r4(n5));
            }, o4);
          }), --s3 || r4(n5);
        });
        return i3.e && o4(i3.v), n4.promise;
      }, race: function(e4) {
        var t4 = this, n4 = k(t4), r4 = n4.reject, o4 = w(function() {
          m(e4, false, function(e5) {
            t4.resolve(e5).then(n4.resolve, r4);
          });
        });
        return o4.e && r4(o4.v), n4.promise;
      } });
    }, function(e3, t3, n3) {
      var r3 = n3(55)("wks"), o3 = n3(24), i2 = n3(4).Symbol, s2 = "function" == typeof i2;
      (e3.exports = function(e4) {
        return r3[e4] || (r3[e4] = s2 && i2[e4] || (s2 ? i2 : o3)("Symbol." + e4));
      }).store = r3;
    }, function(e3, t3) {
      var n3 = e3.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
      "number" == typeof __g && (__g = n3);
    }, function(e3, t3) {
      e3.exports = require_fs();
    }, function(e3, t3) {
      e3.exports = function(e4) {
        return "object" == typeof e4 ? null !== e4 : "function" == typeof e4;
      };
    }, function(e3, t3, n3) {
      var r3 = n3(6);
      e3.exports = function(e4) {
        if (!r3(e4))
          throw TypeError(e4 + " is not an object!");
        return e4;
      };
    }, function(e3, t3, n3) {
      var r3 = n3(4), o3 = n3(18), i2 = n3(13), s2 = n3(14), a2 = n3(12), c2 = function(e4, t4, n4) {
        var u2, l2, f2, p2, h = e4 & c2.F, d2 = e4 & c2.G, m = e4 & c2.S, g = e4 & c2.P, v = e4 & c2.B, y = d2 ? r3 : m ? r3[t4] || (r3[t4] = {}) : (r3[t4] || {}).prototype, b = d2 ? o3 : o3[t4] || (o3[t4] = {}), w = b.prototype || (b.prototype = {});
        for (u2 in d2 && (n4 = t4), n4)
          f2 = ((l2 = !h && y && void 0 !== y[u2]) ? y : n4)[u2], p2 = v && l2 ? a2(f2, r3) : g && "function" == typeof f2 ? a2(Function.call, f2) : f2, y && s2(y, u2, f2, e4 & c2.U), b[u2] != f2 && i2(b, u2, p2), g && w[u2] != f2 && (w[u2] = f2);
      };
      r3.core = o3, c2.F = 1, c2.G = 2, c2.S = 4, c2.P = 8, c2.B = 16, c2.W = 32, c2.U = 64, c2.R = 128, e3.exports = c2;
    }, function(e3, t3, n3) {
      e3.exports = !n3(10)(function() {
        return 7 != Object.defineProperty({}, "a", { get: function() {
          return 7;
        } }).a;
      });
    }, function(e3, t3) {
      e3.exports = function(e4) {
        try {
          return !!e4();
        } catch (e5) {
          return true;
        }
      };
    }, function(e3, t3, n3) {
      var r3 = n3(7), o3 = n3(50), i2 = n3(51), s2 = Object.defineProperty;
      t3.f = n3(9) ? Object.defineProperty : function(e4, t4, n4) {
        if (r3(e4), t4 = i2(t4, true), r3(n4), o3)
          try {
            return s2(e4, t4, n4);
          } catch (e5) {
          }
        if ("get" in n4 || "set" in n4)
          throw TypeError("Accessors not supported!");
        return "value" in n4 && (e4[t4] = n4.value), e4;
      };
    }, function(e3, t3, n3) {
      var r3 = n3(19);
      e3.exports = function(e4, t4, n4) {
        if (r3(e4), void 0 === t4)
          return e4;
        switch (n4) {
          case 1:
            return function(n5) {
              return e4.call(t4, n5);
            };
          case 2:
            return function(n5, r4) {
              return e4.call(t4, n5, r4);
            };
          case 3:
            return function(n5, r4, o3) {
              return e4.call(t4, n5, r4, o3);
            };
        }
        return function() {
          return e4.apply(t4, arguments);
        };
      };
    }, function(e3, t3, n3) {
      var r3 = n3(11), o3 = n3(23);
      e3.exports = n3(9) ? function(e4, t4, n4) {
        return r3.f(e4, t4, o3(1, n4));
      } : function(e4, t4, n4) {
        return e4[t4] = n4, e4;
      };
    }, function(e3, t3, n3) {
      var r3 = n3(4), o3 = n3(13), i2 = n3(15), s2 = n3(24)("src"), a2 = Function.toString, c2 = ("" + a2).split("toString");
      n3(18).inspectSource = function(e4) {
        return a2.call(e4);
      }, (e3.exports = function(e4, t4, n4, a3) {
        var u2 = "function" == typeof n4;
        u2 && (i2(n4, "name") || o3(n4, "name", t4)), e4[t4] !== n4 && (u2 && (i2(n4, s2) || o3(n4, s2, e4[t4] ? "" + e4[t4] : c2.join(String(t4)))), e4 === r3 ? e4[t4] = n4 : a3 ? e4[t4] ? e4[t4] = n4 : o3(e4, t4, n4) : (delete e4[t4], o3(e4, t4, n4)));
      })(Function.prototype, "toString", function() {
        return "function" == typeof this && this[s2] || a2.call(this);
      });
    }, function(e3, t3) {
      var n3 = {}.hasOwnProperty;
      e3.exports = function(e4, t4) {
        return n3.call(e4, t4);
      };
    }, function(e3, t3, n3) {
      n3(28)("split", 2, function(e4, t4, r3) {
        "use strict";
        var o3 = n3(92), i2 = r3, s2 = [].push;
        if ("c" == "abbc".split(/(b)*/)[1] || 4 != "test".split(/(?:)/, -1).length || 2 != "ab".split(/(?:ab)*/).length || 4 != ".".split(/(.?)(.?)/).length || ".".split(/()()/).length > 1 || "".split(/.?/).length) {
          var a2 = void 0 === /()??/.exec("")[1];
          r3 = function(e5, t5) {
            var n4 = String(this);
            if (void 0 === e5 && 0 === t5)
              return [];
            if (!o3(e5))
              return i2.call(n4, e5, t5);
            var r4, c2, u2, l2, f2, p2 = [], h = (e5.ignoreCase ? "i" : "") + (e5.multiline ? "m" : "") + (e5.unicode ? "u" : "") + (e5.sticky ? "y" : ""), d2 = 0, m = void 0 === t5 ? 4294967295 : t5 >>> 0, g = new RegExp(e5.source, h + "g");
            for (a2 || (r4 = new RegExp("^" + g.source + "$(?!\\s)", h)); (c2 = g.exec(n4)) && !((u2 = c2.index + c2[0].length) > d2 && (p2.push(n4.slice(d2, c2.index)), !a2 && c2.length > 1 && c2[0].replace(r4, function() {
              for (f2 = 1; f2 < arguments.length - 2; f2++)
                void 0 === arguments[f2] && (c2[f2] = void 0);
            }), c2.length > 1 && c2.index < n4.length && s2.apply(p2, c2.slice(1)), l2 = c2[0].length, d2 = u2, p2.length >= m)); )
              g.lastIndex === c2.index && g.lastIndex++;
            return d2 === n4.length ? !l2 && g.test("") || p2.push("") : p2.push(n4.slice(d2)), p2.length > m ? p2.slice(0, m) : p2;
          };
        } else
          "0".split(void 0, 0).length && (r3 = function(e5, t5) {
            return void 0 === e5 && 0 === t5 ? [] : i2.call(this, e5, t5);
          });
        return [function(n4, o4) {
          var i3 = e4(this), s3 = null == n4 ? void 0 : n4[t4];
          return void 0 !== s3 ? s3.call(n4, i3, o4) : r3.call(String(i3), n4, o4);
        }, r3];
      });
    }, function(e3, t3) {
      e3.exports = require_os();
    }, function(e3, t3) {
      var n3 = e3.exports = { version: "2.5.7" };
      "number" == typeof __e && (__e = n3);
    }, function(e3, t3) {
      e3.exports = function(e4) {
        if ("function" != typeof e4)
          throw TypeError(e4 + " is not a function!");
        return e4;
      };
    }, function(e3, t3) {
      var n3 = {}.toString;
      e3.exports = function(e4) {
        return n3.call(e4).slice(8, -1);
      };
    }, function(e3, t3, n3) {
      var r3 = n3(8);
      r3(r3.S + r3.F, "Object", { assign: n3(88) });
    }, function(e3, t3, n3) {
      n3(28)("match", 1, function(e4, t4, n4) {
        return [function(n5) {
          "use strict";
          var r3 = e4(this), o3 = null == n5 ? void 0 : n5[t4];
          return void 0 !== o3 ? o3.call(n5, r3) : new RegExp(n5)[t4](String(r3));
        }, n4];
      });
    }, function(e3, t3) {
      e3.exports = function(e4, t4) {
        return { enumerable: !(1 & e4), configurable: !(2 & e4), writable: !(4 & e4), value: t4 };
      };
    }, function(e3, t3) {
      var n3 = 0, r3 = Math.random();
      e3.exports = function(e4) {
        return "Symbol(".concat(void 0 === e4 ? "" : e4, ")_", (++n3 + r3).toString(36));
      };
    }, function(e3, t3, n3) {
      var r3 = n3(53), o3 = n3(34);
      e3.exports = function(e4) {
        return r3(o3(e4));
      };
    }, function(e3, t3, n3) {
      var r3 = n3(11).f, o3 = n3(15), i2 = n3(3)("toStringTag");
      e3.exports = function(e4, t4, n4) {
        e4 && !o3(e4 = n4 ? e4 : e4.prototype, i2) && r3(e4, i2, { configurable: true, value: t4 });
      };
    }, function(e3, t3, n3) {
      n3(28)("replace", 2, function(e4, t4, n4) {
        return [function(r3, o3) {
          "use strict";
          var i2 = e4(this), s2 = null == r3 ? void 0 : r3[t4];
          return void 0 !== s2 ? s2.call(r3, i2, o3) : n4.call(String(i2), r3, o3);
        }, n4];
      });
    }, function(e3, t3, n3) {
      "use strict";
      var r3 = n3(13), o3 = n3(14), i2 = n3(10), s2 = n3(34), a2 = n3(3);
      e3.exports = function(e4, t4, n4) {
        var c2 = a2(e4), u2 = n4(s2, c2, ""[e4]), l2 = u2[0], f2 = u2[1];
        i2(function() {
          var t5 = {};
          return t5[c2] = function() {
            return 7;
          }, 7 != ""[e4](t5);
        }) && (o3(String.prototype, e4, l2), r3(RegExp.prototype, c2, 2 == t4 ? function(e5, t5) {
          return f2.call(e5, this, t5);
        } : function(e5) {
          return f2.call(e5, this);
        }));
      };
    }, function(e3, t3, n3) {
      var r3 = n3(34);
      e3.exports = function(e4) {
        return Object(r3(e4));
      };
    }, function(e3, t3) {
      e3.exports = require_util();
    }, function(e3, t3, n3) {
      var r3 = n3(70);
      function o3(e4) {
        var t4 = function() {
          return t4.called ? t4.value : (t4.called = true, t4.value = e4.apply(this, arguments));
        };
        return t4.called = false, t4;
      }
      function i2(e4) {
        var t4 = function() {
          if (t4.called)
            throw new Error(t4.onceError);
          return t4.called = true, t4.value = e4.apply(this, arguments);
        }, n4 = e4.name || "Function wrapped with `once`";
        return t4.onceError = n4 + " shouldn't be called more than once", t4.called = false, t4;
      }
      e3.exports = r3(o3), e3.exports.strict = r3(i2), o3.proto = o3(function() {
        Object.defineProperty(Function.prototype, "once", { value: function() {
          return o3(this);
        }, configurable: true }), Object.defineProperty(Function.prototype, "onceStrict", { value: function() {
          return i2(this);
        }, configurable: true });
      });
    }, function(e3, t3, n3) {
      "use strict";
      var r3 = n3(8), o3 = n3(52)(true);
      r3(r3.P, "Array", { includes: function(e4) {
        return o3(this, e4, arguments.length > 1 ? arguments[1] : void 0);
      } }), n3(80)("includes");
    }, function(e3, t3, n3) {
      var r3 = n3(6), o3 = n3(4).document, i2 = r3(o3) && r3(o3.createElement);
      e3.exports = function(e4) {
        return i2 ? o3.createElement(e4) : {};
      };
    }, function(e3, t3) {
      e3.exports = function(e4) {
        if (null == e4)
          throw TypeError("Can't call method on  " + e4);
        return e4;
      };
    }, function(e3, t3, n3) {
      var r3 = n3(54), o3 = Math.min;
      e3.exports = function(e4) {
        return e4 > 0 ? o3(r3(e4), 9007199254740991) : 0;
      };
    }, function(e3, t3) {
      e3.exports = false;
    }, function(e3, t3) {
      e3.exports = function(e4, t4, n3, r3) {
        if (!(e4 instanceof t4) || void 0 !== r3 && r3 in e4)
          throw TypeError(n3 + ": incorrect invocation!");
        return e4;
      };
    }, function(e3, t3, n3) {
      var r3 = n3(12), o3 = n3(57), i2 = n3(58), s2 = n3(7), a2 = n3(35), c2 = n3(59), u2 = {}, l2 = {};
      (t3 = e3.exports = function(e4, t4, n4, f2, p2) {
        var h, d2, m, g, v = p2 ? function() {
          return e4;
        } : c2(e4), y = r3(n4, f2, t4 ? 2 : 1), b = 0;
        if ("function" != typeof v)
          throw TypeError(e4 + " is not iterable!");
        if (i2(v)) {
          for (h = a2(e4.length); h > b; b++)
            if ((g = t4 ? y(s2(d2 = e4[b])[0], d2[1]) : y(e4[b])) === u2 || g === l2)
              return g;
        } else
          for (m = v.call(e4); !(d2 = m.next()).done; )
            if ((g = o3(m, y, d2.value, t4)) === u2 || g === l2)
              return g;
      }).BREAK = u2, t3.RETURN = l2;
    }, function(e3, t3) {
      e3.exports = {};
    }, function(e3, t3, n3) {
      var r3 = n3(14);
      e3.exports = function(e4, t4, n4) {
        for (var o3 in t4)
          r3(e4, o3, t4[o3], n4);
        return e4;
      };
    }, function(e3, t3, n3) {
      var r3 = n3(3)("iterator"), o3 = false;
      try {
        var i2 = [7][r3]();
        i2.return = function() {
          o3 = true;
        }, Array.from(i2, function() {
          throw 2;
        });
      } catch (e4) {
      }
      e3.exports = function(e4, t4) {
        if (!t4 && !o3)
          return false;
        var n4 = false;
        try {
          var i3 = [7], s2 = i3[r3]();
          s2.next = function() {
            return { done: n4 = true };
          }, i3[r3] = function() {
            return s2;
          }, e4(i3);
        } catch (e5) {
        }
        return n4;
      };
    }, function(e3, t3, n3) {
      var r3 = n3(87), o3 = n3(66);
      e3.exports = Object.keys || function(e4) {
        return r3(e4, o3);
      };
    }, function(e3, t3, n3) {
      var r3 = n3(55)("keys"), o3 = n3(24);
      e3.exports = function(e4) {
        return r3[e4] || (r3[e4] = o3(e4));
      };
    }, function(e3, t3) {
      t3.f = {}.propertyIsEnumerable;
    }, function(e3, t3, n3) {
      e3.exports = b;
      var r3 = n3(5), o3 = n3(67), i2 = n3(46), s2 = (i2.Minimatch, n3(97)), a2 = n3(68).EventEmitter, c2 = n3(0), u2 = n3(47), l2 = n3(48), f2 = n3(99), p2 = n3(69), h = (p2.alphasort, p2.alphasorti, p2.setopts), d2 = p2.ownProp, m = n3(100), g = (n3(30), p2.childrenIgnored), v = p2.isIgnored, y = n3(31);
      function b(e4, t4, n4) {
        if ("function" == typeof t4 && (n4 = t4, t4 = {}), t4 || (t4 = {}), t4.sync) {
          if (n4)
            throw new TypeError("callback provided to sync glob");
          return f2(e4, t4);
        }
        return new x(e4, t4, n4);
      }
      b.sync = f2;
      var w = b.GlobSync = f2.GlobSync;
      function x(e4, t4, n4) {
        if ("function" == typeof t4 && (n4 = t4, t4 = null), t4 && t4.sync) {
          if (n4)
            throw new TypeError("callback provided to sync glob");
          return new w(e4, t4);
        }
        if (!(this instanceof x))
          return new x(e4, t4, n4);
        h(this, e4, t4), this._didRealPath = false;
        var r4 = this.minimatch.set.length;
        this.matches = new Array(r4), "function" == typeof n4 && (n4 = y(n4), this.on("error", n4), this.on("end", function(e5) {
          n4(null, e5);
        }));
        var o4 = this;
        if (this._processing = 0, this._emitQueue = [], this._processQueue = [], this.paused = false, this.noprocess)
          return this;
        if (0 === r4)
          return a3();
        for (var i3 = true, s3 = 0; s3 < r4; s3++)
          this._process(this.minimatch.set[s3], s3, false, a3);
        function a3() {
          --o4._processing, o4._processing <= 0 && (i3 ? process.nextTick(function() {
            o4._finish();
          }) : o4._finish());
        }
        i3 = false;
      }
      b.glob = b, b.hasMagic = function(e4, t4) {
        var n4 = function(e5, t5) {
          if (null === t5 || "object" != typeof t5)
            return e5;
          for (var n5 = Object.keys(t5), r5 = n5.length; r5--; )
            e5[n5[r5]] = t5[n5[r5]];
          return e5;
        }({}, t4);
        n4.noprocess = true;
        var r4 = new x(e4, n4).minimatch.set;
        if (!e4)
          return false;
        if (r4.length > 1)
          return true;
        for (var o4 = 0; o4 < r4[0].length; o4++)
          if ("string" != typeof r4[0][o4])
            return true;
        return false;
      }, b.Glob = x, s2(x, a2), x.prototype._finish = function() {
        if (u2(this instanceof x), !this.aborted) {
          if (this.realpath && !this._didRealpath)
            return this._realpath();
          p2.finish(this), this.emit("end", this.found);
        }
      }, x.prototype._realpath = function() {
        if (!this._didRealpath) {
          this._didRealpath = true;
          var e4 = this.matches.length;
          if (0 === e4)
            return this._finish();
          for (var t4 = this, n4 = 0; n4 < this.matches.length; n4++)
            this._realpathSet(n4, r4);
        }
        function r4() {
          0 == --e4 && t4._finish();
        }
      }, x.prototype._realpathSet = function(e4, t4) {
        var n4 = this.matches[e4];
        if (!n4)
          return t4();
        var r4 = Object.keys(n4), i3 = this, s3 = r4.length;
        if (0 === s3)
          return t4();
        var a3 = this.matches[e4] = /* @__PURE__ */ Object.create(null);
        r4.forEach(function(n5, r5) {
          n5 = i3._makeAbs(n5), o3.realpath(n5, i3.realpathCache, function(r6, o4) {
            r6 ? "stat" === r6.syscall ? a3[n5] = true : i3.emit("error", r6) : a3[o4] = true, 0 == --s3 && (i3.matches[e4] = a3, t4());
          });
        });
      }, x.prototype._mark = function(e4) {
        return p2.mark(this, e4);
      }, x.prototype._makeAbs = function(e4) {
        return p2.makeAbs(this, e4);
      }, x.prototype.abort = function() {
        this.aborted = true, this.emit("abort");
      }, x.prototype.pause = function() {
        this.paused || (this.paused = true, this.emit("pause"));
      }, x.prototype.resume = function() {
        if (this.paused) {
          if (this.emit("resume"), this.paused = false, this._emitQueue.length) {
            var e4 = this._emitQueue.slice(0);
            this._emitQueue.length = 0;
            for (var t4 = 0; t4 < e4.length; t4++) {
              var n4 = e4[t4];
              this._emitMatch(n4[0], n4[1]);
            }
          }
          if (this._processQueue.length) {
            var r4 = this._processQueue.slice(0);
            this._processQueue.length = 0;
            for (t4 = 0; t4 < r4.length; t4++) {
              var o4 = r4[t4];
              this._processing--, this._process(o4[0], o4[1], o4[2], o4[3]);
            }
          }
        }
      }, x.prototype._process = function(e4, t4, n4, r4) {
        if (u2(this instanceof x), u2("function" == typeof r4), !this.aborted)
          if (this._processing++, this.paused)
            this._processQueue.push([e4, t4, n4, r4]);
          else {
            for (var o4, s3 = 0; "string" == typeof e4[s3]; )
              s3++;
            switch (s3) {
              case e4.length:
                return void this._processSimple(e4.join("/"), t4, r4);
              case 0:
                o4 = null;
                break;
              default:
                o4 = e4.slice(0, s3).join("/");
            }
            var a3, c3 = e4.slice(s3);
            null === o4 ? a3 = "." : l2(o4) || l2(e4.join("/")) ? (o4 && l2(o4) || (o4 = "/" + o4), a3 = o4) : a3 = o4;
            var f3 = this._makeAbs(a3);
            if (g(this, a3))
              return r4();
            c3[0] === i2.GLOBSTAR ? this._processGlobStar(o4, a3, f3, c3, t4, n4, r4) : this._processReaddir(o4, a3, f3, c3, t4, n4, r4);
          }
      }, x.prototype._processReaddir = function(e4, t4, n4, r4, o4, i3, s3) {
        var a3 = this;
        this._readdir(n4, i3, function(c3, u3) {
          return a3._processReaddir2(e4, t4, n4, r4, o4, i3, u3, s3);
        });
      }, x.prototype._processReaddir2 = function(e4, t4, n4, r4, o4, i3, s3, a3) {
        if (!s3)
          return a3();
        for (var u3 = r4[0], l3 = !!this.minimatch.negate, f3 = u3._glob, p3 = this.dot || "." === f3.charAt(0), h2 = [], d3 = 0; d3 < s3.length; d3++) {
          if ("." !== (g2 = s3[d3]).charAt(0) || p3)
            (l3 && !e4 ? !g2.match(u3) : g2.match(u3)) && h2.push(g2);
        }
        var m2 = h2.length;
        if (0 === m2)
          return a3();
        if (1 === r4.length && !this.mark && !this.stat) {
          this.matches[o4] || (this.matches[o4] = /* @__PURE__ */ Object.create(null));
          for (d3 = 0; d3 < m2; d3++) {
            var g2 = h2[d3];
            e4 && (g2 = "/" !== e4 ? e4 + "/" + g2 : e4 + g2), "/" !== g2.charAt(0) || this.nomount || (g2 = c2.join(this.root, g2)), this._emitMatch(o4, g2);
          }
          return a3();
        }
        r4.shift();
        for (d3 = 0; d3 < m2; d3++) {
          g2 = h2[d3];
          e4 && (g2 = "/" !== e4 ? e4 + "/" + g2 : e4 + g2), this._process([g2].concat(r4), o4, i3, a3);
        }
        a3();
      }, x.prototype._emitMatch = function(e4, t4) {
        if (!this.aborted && !v(this, t4))
          if (this.paused)
            this._emitQueue.push([e4, t4]);
          else {
            var n4 = l2(t4) ? t4 : this._makeAbs(t4);
            if (this.mark && (t4 = this._mark(t4)), this.absolute && (t4 = n4), !this.matches[e4][t4]) {
              if (this.nodir) {
                var r4 = this.cache[n4];
                if ("DIR" === r4 || Array.isArray(r4))
                  return;
              }
              this.matches[e4][t4] = true;
              var o4 = this.statCache[n4];
              o4 && this.emit("stat", t4, o4), this.emit("match", t4);
            }
          }
      }, x.prototype._readdirInGlobStar = function(e4, t4) {
        if (!this.aborted) {
          if (this.follow)
            return this._readdir(e4, false, t4);
          var n4 = this, o4 = m("lstat\0" + e4, function(r4, o5) {
            if (r4 && "ENOENT" === r4.code)
              return t4();
            var i3 = o5 && o5.isSymbolicLink();
            n4.symlinks[e4] = i3, i3 || !o5 || o5.isDirectory() ? n4._readdir(e4, false, t4) : (n4.cache[e4] = "FILE", t4());
          });
          o4 && r3.lstat(e4, o4);
        }
      }, x.prototype._readdir = function(e4, t4, n4) {
        if (!this.aborted && (n4 = m("readdir\0" + e4 + "\0" + t4, n4))) {
          if (t4 && !d2(this.symlinks, e4))
            return this._readdirInGlobStar(e4, n4);
          if (d2(this.cache, e4)) {
            var o4 = this.cache[e4];
            if (!o4 || "FILE" === o4)
              return n4();
            if (Array.isArray(o4))
              return n4(null, o4);
          }
          r3.readdir(e4, function(e5, t5, n5) {
            return function(r4, o5) {
              r4 ? e5._readdirError(t5, r4, n5) : e5._readdirEntries(t5, o5, n5);
            };
          }(this, e4, n4));
        }
      }, x.prototype._readdirEntries = function(e4, t4, n4) {
        if (!this.aborted) {
          if (!this.mark && !this.stat)
            for (var r4 = 0; r4 < t4.length; r4++) {
              var o4 = t4[r4];
              o4 = "/" === e4 ? e4 + o4 : e4 + "/" + o4, this.cache[o4] = true;
            }
          return this.cache[e4] = t4, n4(null, t4);
        }
      }, x.prototype._readdirError = function(e4, t4, n4) {
        if (!this.aborted) {
          switch (t4.code) {
            case "ENOTSUP":
            case "ENOTDIR":
              var r4 = this._makeAbs(e4);
              if (this.cache[r4] = "FILE", r4 === this.cwdAbs) {
                var o4 = new Error(t4.code + " invalid cwd " + this.cwd);
                o4.path = this.cwd, o4.code = t4.code, this.emit("error", o4), this.abort();
              }
              break;
            case "ENOENT":
            case "ELOOP":
            case "ENAMETOOLONG":
            case "UNKNOWN":
              this.cache[this._makeAbs(e4)] = false;
              break;
            default:
              this.cache[this._makeAbs(e4)] = false, this.strict && (this.emit("error", t4), this.abort()), this.silent || console.error("glob error", t4);
          }
          return n4();
        }
      }, x.prototype._processGlobStar = function(e4, t4, n4, r4, o4, i3, s3) {
        var a3 = this;
        this._readdir(n4, i3, function(c3, u3) {
          a3._processGlobStar2(e4, t4, n4, r4, o4, i3, u3, s3);
        });
      }, x.prototype._processGlobStar2 = function(e4, t4, n4, r4, o4, i3, s3, a3) {
        if (!s3)
          return a3();
        var c3 = r4.slice(1), u3 = e4 ? [e4] : [], l3 = u3.concat(c3);
        this._process(l3, o4, false, a3);
        var f3 = this.symlinks[n4], p3 = s3.length;
        if (f3 && i3)
          return a3();
        for (var h2 = 0; h2 < p3; h2++) {
          if ("." !== s3[h2].charAt(0) || this.dot) {
            var d3 = u3.concat(s3[h2], c3);
            this._process(d3, o4, true, a3);
            var m2 = u3.concat(s3[h2], r4);
            this._process(m2, o4, true, a3);
          }
        }
        a3();
      }, x.prototype._processSimple = function(e4, t4, n4) {
        var r4 = this;
        this._stat(e4, function(o4, i3) {
          r4._processSimple2(e4, t4, o4, i3, n4);
        });
      }, x.prototype._processSimple2 = function(e4, t4, n4, r4, o4) {
        if (this.matches[t4] || (this.matches[t4] = /* @__PURE__ */ Object.create(null)), !r4)
          return o4();
        if (e4 && l2(e4) && !this.nomount) {
          var i3 = /[\/\\]$/.test(e4);
          "/" === e4.charAt(0) ? e4 = c2.join(this.root, e4) : (e4 = c2.resolve(this.root, e4), i3 && (e4 += "/"));
        }
        "win32" === process.platform && (e4 = e4.replace(/\\/g, "/")), this._emitMatch(t4, e4), o4();
      }, x.prototype._stat = function(e4, t4) {
        var n4 = this._makeAbs(e4), o4 = "/" === e4.slice(-1);
        if (e4.length > this.maxLength)
          return t4();
        if (!this.stat && d2(this.cache, n4)) {
          var i3 = this.cache[n4];
          if (Array.isArray(i3) && (i3 = "DIR"), !o4 || "DIR" === i3)
            return t4(null, i3);
          if (o4 && "FILE" === i3)
            return t4();
        }
        var s3 = this.statCache[n4];
        if (void 0 !== s3) {
          if (false === s3)
            return t4(null, s3);
          var a3 = s3.isDirectory() ? "DIR" : "FILE";
          return o4 && "FILE" === a3 ? t4() : t4(null, a3, s3);
        }
        var c3 = this, u3 = m("stat\0" + n4, function(o5, i4) {
          if (i4 && i4.isSymbolicLink())
            return r3.stat(n4, function(r4, o6) {
              r4 ? c3._stat2(e4, n4, null, i4, t4) : c3._stat2(e4, n4, r4, o6, t4);
            });
          c3._stat2(e4, n4, o5, i4, t4);
        });
        u3 && r3.lstat(n4, u3);
      }, x.prototype._stat2 = function(e4, t4, n4, r4, o4) {
        if (n4 && ("ENOENT" === n4.code || "ENOTDIR" === n4.code))
          return this.statCache[t4] = false, o4();
        var i3 = "/" === e4.slice(-1);
        if (this.statCache[t4] = r4, "/" === t4.slice(-1) && r4 && !r4.isDirectory())
          return o4(null, false, r4);
        var s3 = true;
        return r4 && (s3 = r4.isDirectory() ? "DIR" : "FILE"), this.cache[t4] = this.cache[t4] || s3, i3 && "FILE" === s3 ? o4() : o4(null, s3, r4);
      };
    }, function(e3, t3, n3) {
      e3.exports = d2, d2.Minimatch = m;
      var r3 = { sep: "/" };
      try {
        r3 = n3(0);
      } catch (e4) {
      }
      var o3 = d2.GLOBSTAR = m.GLOBSTAR = {}, i2 = n3(94), s2 = { "!": { open: "(?:(?!(?:", close: "))[^/]*?)" }, "?": { open: "(?:", close: ")?" }, "+": { open: "(?:", close: ")+" }, "*": { open: "(?:", close: ")*" }, "@": { open: "(?:", close: ")" } }, a2 = "[^/]", c2 = a2 + "*?", u2 = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?", l2 = "(?:(?!(?:\\/|^)\\.).)*?", f2 = "().*{}+?[]^$\\!".split("").reduce(function(e4, t4) {
        return e4[t4] = true, e4;
      }, {});
      var p2 = /\/+/;
      function h(e4, t4) {
        e4 = e4 || {}, t4 = t4 || {};
        var n4 = {};
        return Object.keys(t4).forEach(function(e5) {
          n4[e5] = t4[e5];
        }), Object.keys(e4).forEach(function(t5) {
          n4[t5] = e4[t5];
        }), n4;
      }
      function d2(e4, t4, n4) {
        if ("string" != typeof t4)
          throw new TypeError("glob pattern string required");
        return n4 || (n4 = {}), !(!n4.nocomment && "#" === t4.charAt(0)) && ("" === t4.trim() ? "" === e4 : new m(t4, n4).match(e4));
      }
      function m(e4, t4) {
        if (!(this instanceof m))
          return new m(e4, t4);
        if ("string" != typeof e4)
          throw new TypeError("glob pattern string required");
        t4 || (t4 = {}), e4 = e4.trim(), "/" !== r3.sep && (e4 = e4.split(r3.sep).join("/")), this.options = t4, this.set = [], this.pattern = e4, this.regexp = null, this.negate = false, this.comment = false, this.empty = false, this.make();
      }
      function g(e4, t4) {
        if (t4 || (t4 = this instanceof m ? this.options : {}), void 0 === (e4 = void 0 === e4 ? this.pattern : e4))
          throw new TypeError("undefined pattern");
        return t4.nobrace || !e4.match(/\{.*\}/) ? [e4] : i2(e4);
      }
      d2.filter = function(e4, t4) {
        return t4 = t4 || {}, function(n4, r4, o4) {
          return d2(n4, e4, t4);
        };
      }, d2.defaults = function(e4) {
        if (!e4 || !Object.keys(e4).length)
          return d2;
        var t4 = d2, n4 = function(n5, r4, o4) {
          return t4.minimatch(n5, r4, h(e4, o4));
        };
        return n4.Minimatch = function(n5, r4) {
          return new t4.Minimatch(n5, h(e4, r4));
        }, n4;
      }, m.defaults = function(e4) {
        return e4 && Object.keys(e4).length ? d2.defaults(e4).Minimatch : m;
      }, m.prototype.debug = function() {
      }, m.prototype.make = function() {
        if (this._made)
          return;
        var e4 = this.pattern, t4 = this.options;
        if (!t4.nocomment && "#" === e4.charAt(0))
          return void (this.comment = true);
        if (!e4)
          return void (this.empty = true);
        this.parseNegate();
        var n4 = this.globSet = this.braceExpand();
        t4.debug && (this.debug = console.error);
        this.debug(this.pattern, n4), n4 = this.globParts = n4.map(function(e5) {
          return e5.split(p2);
        }), this.debug(this.pattern, n4), n4 = n4.map(function(e5, t5, n5) {
          return e5.map(this.parse, this);
        }, this), this.debug(this.pattern, n4), n4 = n4.filter(function(e5) {
          return -1 === e5.indexOf(false);
        }), this.debug(this.pattern, n4), this.set = n4;
      }, m.prototype.parseNegate = function() {
        var e4 = this.pattern, t4 = false, n4 = this.options, r4 = 0;
        if (n4.nonegate)
          return;
        for (var o4 = 0, i3 = e4.length; o4 < i3 && "!" === e4.charAt(o4); o4++)
          t4 = !t4, r4++;
        r4 && (this.pattern = e4.substr(r4));
        this.negate = t4;
      }, d2.braceExpand = function(e4, t4) {
        return g(e4, t4);
      }, m.prototype.braceExpand = g, m.prototype.parse = function(e4, t4) {
        if (e4.length > 65536)
          throw new TypeError("pattern is too long");
        var n4 = this.options;
        if (!n4.noglobstar && "**" === e4)
          return o3;
        if ("" === e4)
          return "";
        var r4, i3 = "", u3 = !!n4.nocase, l3 = false, p3 = [], h2 = [], d3 = false, m2 = -1, g2 = -1, y = "." === e4.charAt(0) ? "" : n4.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)", b = this;
        function w() {
          if (r4) {
            switch (r4) {
              case "*":
                i3 += c2, u3 = true;
                break;
              case "?":
                i3 += a2, u3 = true;
                break;
              default:
                i3 += "\\" + r4;
            }
            b.debug("clearStateChar %j %j", r4, i3), r4 = false;
          }
        }
        for (var x, S = 0, P = e4.length; S < P && (x = e4.charAt(S)); S++)
          if (this.debug("%s	%s %s %j", e4, S, i3, x), l3 && f2[x])
            i3 += "\\" + x, l3 = false;
          else
            switch (x) {
              case "/":
                return false;
              case "\\":
                w(), l3 = true;
                continue;
              case "?":
              case "*":
              case "+":
              case "@":
              case "!":
                if (this.debug("%s	%s %s %j <-- stateChar", e4, S, i3, x), d3) {
                  this.debug("  in class"), "!" === x && S === g2 + 1 && (x = "^"), i3 += x;
                  continue;
                }
                b.debug("call clearStateChar %j", r4), w(), r4 = x, n4.noext && w();
                continue;
              case "(":
                if (d3) {
                  i3 += "(";
                  continue;
                }
                if (!r4) {
                  i3 += "\\(";
                  continue;
                }
                p3.push({ type: r4, start: S - 1, reStart: i3.length, open: s2[r4].open, close: s2[r4].close }), i3 += "!" === r4 ? "(?:(?!(?:" : "(?:", this.debug("plType %j %j", r4, i3), r4 = false;
                continue;
              case ")":
                if (d3 || !p3.length) {
                  i3 += "\\)";
                  continue;
                }
                w(), u3 = true;
                var O = p3.pop();
                i3 += O.close, "!" === O.type && h2.push(O), O.reEnd = i3.length;
                continue;
              case "|":
                if (d3 || !p3.length || l3) {
                  i3 += "\\|", l3 = false;
                  continue;
                }
                w(), i3 += "|";
                continue;
              case "[":
                if (w(), d3) {
                  i3 += "\\" + x;
                  continue;
                }
                d3 = true, g2 = S, m2 = i3.length, i3 += x;
                continue;
              case "]":
                if (S === g2 + 1 || !d3) {
                  i3 += "\\" + x, l3 = false;
                  continue;
                }
                if (d3) {
                  var j = e4.substring(g2 + 1, S);
                  try {
                    RegExp("[" + j + "]");
                  } catch (e5) {
                    var E2 = this.parse(j, v);
                    i3 = i3.substr(0, m2) + "\\[" + E2[0] + "\\]", u3 = u3 || E2[1], d3 = false;
                    continue;
                  }
                }
                u3 = true, d3 = false, i3 += x;
                continue;
              default:
                w(), l3 ? l3 = false : !f2[x] || "^" === x && d3 || (i3 += "\\"), i3 += x;
            }
        d3 && (j = e4.substr(g2 + 1), E2 = this.parse(j, v), i3 = i3.substr(0, m2) + "\\[" + E2[0], u3 = u3 || E2[1]);
        for (O = p3.pop(); O; O = p3.pop()) {
          var I = i3.slice(O.reStart + O.open.length);
          this.debug("setting tail", i3, O), I = I.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(e5, t5, n5) {
            return n5 || (n5 = "\\"), t5 + t5 + n5 + "|";
          }), this.debug("tail=%j\n   %s", I, I, O, i3);
          var _ = "*" === O.type ? c2 : "?" === O.type ? a2 : "\\" + O.type;
          u3 = true, i3 = i3.slice(0, O.reStart) + _ + "\\(" + I;
        }
        w(), l3 && (i3 += "\\\\");
        var A2 = false;
        switch (i3.charAt(0)) {
          case ".":
          case "[":
          case "(":
            A2 = true;
        }
        for (var k = h2.length - 1; k > -1; k--) {
          var N = h2[k], F = i3.slice(0, N.reStart), C2 = i3.slice(N.reStart, N.reEnd - 8), M = i3.slice(N.reEnd - 8, N.reEnd), T = i3.slice(N.reEnd);
          M += T;
          var V = F.split("(").length - 1, D = T;
          for (S = 0; S < V; S++)
            D = D.replace(/\)[+*?]?/, "");
          var B2 = "";
          "" === (T = D) && t4 !== v && (B2 = "$");
          var L = F + C2 + T + B2 + M;
          i3 = L;
        }
        "" !== i3 && u3 && (i3 = "(?=.)" + i3);
        A2 && (i3 = y + i3);
        if (t4 === v)
          return [i3, u3];
        if (!u3)
          return e4.replace(/\\(.)/g, "$1");
        var $ = n4.nocase ? "i" : "";
        try {
          var R = new RegExp("^" + i3 + "$", $);
        } catch (e5) {
          return new RegExp("$.");
        }
        return R._glob = e4, R._src = i3, R;
      };
      var v = {};
      d2.makeRe = function(e4, t4) {
        return new m(e4, t4 || {}).makeRe();
      }, m.prototype.makeRe = function() {
        if (this.regexp || false === this.regexp)
          return this.regexp;
        var e4 = this.set;
        if (!e4.length)
          return this.regexp = false, this.regexp;
        var t4 = this.options, n4 = t4.noglobstar ? c2 : t4.dot ? u2 : l2, r4 = t4.nocase ? "i" : "", i3 = e4.map(function(e5) {
          return e5.map(function(e6) {
            return e6 === o3 ? n4 : "string" == typeof e6 ? e6.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&") : e6._src;
          }).join("\\/");
        }).join("|");
        i3 = "^(?:" + i3 + ")$", this.negate && (i3 = "^(?!" + i3 + ").*$");
        try {
          this.regexp = new RegExp(i3, r4);
        } catch (e5) {
          this.regexp = false;
        }
        return this.regexp;
      }, d2.match = function(e4, t4, n4) {
        var r4 = new m(t4, n4 = n4 || {});
        return e4 = e4.filter(function(e5) {
          return r4.match(e5);
        }), r4.options.nonull && !e4.length && e4.push(t4), e4;
      }, m.prototype.match = function(e4, t4) {
        if (this.debug("match", e4, this.pattern), this.comment)
          return false;
        if (this.empty)
          return "" === e4;
        if ("/" === e4 && t4)
          return true;
        var n4 = this.options;
        "/" !== r3.sep && (e4 = e4.split(r3.sep).join("/"));
        e4 = e4.split(p2), this.debug(this.pattern, "split", e4);
        var o4, i3, s3 = this.set;
        for (this.debug(this.pattern, "set", s3), i3 = e4.length - 1; i3 >= 0 && !(o4 = e4[i3]); i3--)
          ;
        for (i3 = 0; i3 < s3.length; i3++) {
          var a3 = s3[i3], c3 = e4;
          n4.matchBase && 1 === a3.length && (c3 = [o4]);
          var u3 = this.matchOne(c3, a3, t4);
          if (u3)
            return !!n4.flipNegate || !this.negate;
        }
        return !n4.flipNegate && this.negate;
      }, m.prototype.matchOne = function(e4, t4, n4) {
        var r4 = this.options;
        this.debug("matchOne", { this: this, file: e4, pattern: t4 }), this.debug("matchOne", e4.length, t4.length);
        for (var i3 = 0, s3 = 0, a3 = e4.length, c3 = t4.length; i3 < a3 && s3 < c3; i3++, s3++) {
          this.debug("matchOne loop");
          var u3, l3 = t4[s3], f3 = e4[i3];
          if (this.debug(t4, l3, f3), false === l3)
            return false;
          if (l3 === o3) {
            this.debug("GLOBSTAR", [t4, l3, f3]);
            var p3 = i3, h2 = s3 + 1;
            if (h2 === c3) {
              for (this.debug("** at the end"); i3 < a3; i3++)
                if ("." === e4[i3] || ".." === e4[i3] || !r4.dot && "." === e4[i3].charAt(0))
                  return false;
              return true;
            }
            for (; p3 < a3; ) {
              var d3 = e4[p3];
              if (this.debug("\nglobstar while", e4, p3, t4, h2, d3), this.matchOne(e4.slice(p3), t4.slice(h2), n4))
                return this.debug("globstar found match!", p3, a3, d3), true;
              if ("." === d3 || ".." === d3 || !r4.dot && "." === d3.charAt(0)) {
                this.debug("dot detected!", e4, p3, t4, h2);
                break;
              }
              this.debug("globstar swallow a segment, and continue"), p3++;
            }
            return !(!n4 || (this.debug("\n>>> no match, partial?", e4, p3, t4, h2), p3 !== a3));
          }
          if ("string" == typeof l3 ? (u3 = r4.nocase ? f3.toLowerCase() === l3.toLowerCase() : f3 === l3, this.debug("string match", l3, f3, u3)) : (u3 = f3.match(l3), this.debug("pattern match", l3, f3, u3)), !u3)
            return false;
        }
        if (i3 === a3 && s3 === c3)
          return true;
        if (i3 === a3)
          return n4;
        if (s3 === c3)
          return i3 === a3 - 1 && "" === e4[i3];
        throw new Error("wtf?");
      };
    }, function(e3, t3) {
      e3.exports = require_assert();
    }, function(e3, t3, n3) {
      "use strict";
      function r3(e4) {
        return "/" === e4.charAt(0);
      }
      function o3(e4) {
        var t4 = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/.exec(e4), n4 = t4[1] || "", r4 = Boolean(n4 && ":" !== n4.charAt(1));
        return Boolean(t4[2] || r4);
      }
      e3.exports = "win32" === process.platform ? o3 : r3, e3.exports.posix = r3, e3.exports.win32 = o3;
    }, function(e3, t3) {
      e3.exports = require_child_process();
    }, function(e3, t3, n3) {
      e3.exports = !n3(9) && !n3(10)(function() {
        return 7 != Object.defineProperty(n3(33)("div"), "a", { get: function() {
          return 7;
        } }).a;
      });
    }, function(e3, t3, n3) {
      var r3 = n3(6);
      e3.exports = function(e4, t4) {
        if (!r3(e4))
          return e4;
        var n4, o3;
        if (t4 && "function" == typeof (n4 = e4.toString) && !r3(o3 = n4.call(e4)))
          return o3;
        if ("function" == typeof (n4 = e4.valueOf) && !r3(o3 = n4.call(e4)))
          return o3;
        if (!t4 && "function" == typeof (n4 = e4.toString) && !r3(o3 = n4.call(e4)))
          return o3;
        throw TypeError("Can't convert object to primitive value");
      };
    }, function(e3, t3, n3) {
      var r3 = n3(25), o3 = n3(35), i2 = n3(79);
      e3.exports = function(e4) {
        return function(t4, n4, s2) {
          var a2, c2 = r3(t4), u2 = o3(c2.length), l2 = i2(s2, u2);
          if (e4 && n4 != n4) {
            for (; u2 > l2; )
              if ((a2 = c2[l2++]) != a2)
                return true;
          } else
            for (; u2 > l2; l2++)
              if ((e4 || l2 in c2) && c2[l2] === n4)
                return e4 || l2 || 0;
          return !e4 && -1;
        };
      };
    }, function(e3, t3, n3) {
      var r3 = n3(20);
      e3.exports = Object("z").propertyIsEnumerable(0) ? Object : function(e4) {
        return "String" == r3(e4) ? e4.split("") : Object(e4);
      };
    }, function(e3, t3) {
      var n3 = Math.ceil, r3 = Math.floor;
      e3.exports = function(e4) {
        return isNaN(e4 = +e4) ? 0 : (e4 > 0 ? r3 : n3)(e4);
      };
    }, function(e3, t3, n3) {
      var r3 = n3(18), o3 = n3(4), i2 = o3["__core-js_shared__"] || (o3["__core-js_shared__"] = {});
      (e3.exports = function(e4, t4) {
        return i2[e4] || (i2[e4] = void 0 !== t4 ? t4 : {});
      })("versions", []).push({ version: r3.version, mode: n3(36) ? "pure" : "global", copyright: "© 2018 Denis Pushkarev (zloirock.ru)" });
    }, function(e3, t3, n3) {
      var r3 = n3(20), o3 = n3(3)("toStringTag"), i2 = "Arguments" == r3(function() {
        return arguments;
      }());
      e3.exports = function(e4) {
        var t4, n4, s2;
        return void 0 === e4 ? "Undefined" : null === e4 ? "Null" : "string" == typeof (n4 = function(e5, t5) {
          try {
            return e5[t5];
          } catch (e6) {
          }
        }(t4 = Object(e4), o3)) ? n4 : i2 ? r3(t4) : "Object" == (s2 = r3(t4)) && "function" == typeof t4.callee ? "Arguments" : s2;
      };
    }, function(e3, t3, n3) {
      var r3 = n3(7);
      e3.exports = function(e4, t4, n4, o3) {
        try {
          return o3 ? t4(r3(n4)[0], n4[1]) : t4(n4);
        } catch (t5) {
          var i2 = e4.return;
          throw void 0 !== i2 && r3(i2.call(e4)), t5;
        }
      };
    }, function(e3, t3, n3) {
      var r3 = n3(39), o3 = n3(3)("iterator"), i2 = Array.prototype;
      e3.exports = function(e4) {
        return void 0 !== e4 && (r3.Array === e4 || i2[o3] === e4);
      };
    }, function(e3, t3, n3) {
      var r3 = n3(56), o3 = n3(3)("iterator"), i2 = n3(39);
      e3.exports = n3(18).getIteratorMethod = function(e4) {
        if (null != e4)
          return e4[o3] || e4["@@iterator"] || i2[r3(e4)];
      };
    }, function(e3, t3, n3) {
      var r3, o3, i2, s2 = n3(12), a2 = n3(82), c2 = n3(61), u2 = n3(33), l2 = n3(4), f2 = l2.process, p2 = l2.setImmediate, h = l2.clearImmediate, d2 = l2.MessageChannel, m = l2.Dispatch, g = 0, v = {}, y = function() {
        var e4 = +this;
        if (v.hasOwnProperty(e4)) {
          var t4 = v[e4];
          delete v[e4], t4();
        }
      }, b = function(e4) {
        y.call(e4.data);
      };
      p2 && h || (p2 = function(e4) {
        for (var t4 = [], n4 = 1; arguments.length > n4; )
          t4.push(arguments[n4++]);
        return v[++g] = function() {
          a2("function" == typeof e4 ? e4 : Function(e4), t4);
        }, r3(g), g;
      }, h = function(e4) {
        delete v[e4];
      }, "process" == n3(20)(f2) ? r3 = function(e4) {
        f2.nextTick(s2(y, e4, 1));
      } : m && m.now ? r3 = function(e4) {
        m.now(s2(y, e4, 1));
      } : d2 ? (i2 = (o3 = new d2()).port2, o3.port1.onmessage = b, r3 = s2(i2.postMessage, i2, 1)) : l2.addEventListener && "function" == typeof postMessage && !l2.importScripts ? (r3 = function(e4) {
        l2.postMessage(e4 + "", "*");
      }, l2.addEventListener("message", b, false)) : r3 = "onreadystatechange" in u2("script") ? function(e4) {
        c2.appendChild(u2("script")).onreadystatechange = function() {
          c2.removeChild(this), y.call(e4);
        };
      } : function(e4) {
        setTimeout(s2(y, e4, 1), 0);
      }), e3.exports = { set: p2, clear: h };
    }, function(e3, t3, n3) {
      var r3 = n3(4).document;
      e3.exports = r3 && r3.documentElement;
    }, function(e3, t3, n3) {
      "use strict";
      var r3 = n3(19);
      function o3(e4) {
        var t4, n4;
        this.promise = new e4(function(e5, r4) {
          if (void 0 !== t4 || void 0 !== n4)
            throw TypeError("Bad Promise constructor");
          t4 = e5, n4 = r4;
        }), this.resolve = r3(t4), this.reject = r3(n4);
      }
      e3.exports.f = function(e4) {
        return new o3(e4);
      };
    }, function(e3, t3, n3) {
      "use strict";
      var r3 = n3(4), o3 = n3(11), i2 = n3(9), s2 = n3(3)("species");
      e3.exports = function(e4) {
        var t4 = r3[e4];
        i2 && t4 && !t4[s2] && o3.f(t4, s2, { configurable: true, get: function() {
          return this;
        } });
      };
    }, function(e3, t3, n3) {
      var r3 = n3(8), o3 = n3(65)(true);
      r3(r3.S, "Object", { entries: function(e4) {
        return o3(e4);
      } });
    }, function(e3, t3, n3) {
      var r3 = n3(42), o3 = n3(25), i2 = n3(44).f;
      e3.exports = function(e4) {
        return function(t4) {
          for (var n4, s2 = o3(t4), a2 = r3(s2), c2 = a2.length, u2 = 0, l2 = []; c2 > u2; )
            i2.call(s2, n4 = a2[u2++]) && l2.push(e4 ? [n4, s2[n4]] : s2[n4]);
          return l2;
        };
      };
    }, function(e3, t3) {
      e3.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
    }, function(e3, t3, n3) {
      e3.exports = l2, l2.realpath = l2, l2.sync = f2, l2.realpathSync = f2, l2.monkeypatch = function() {
        r3.realpath = l2, r3.realpathSync = f2;
      }, l2.unmonkeypatch = function() {
        r3.realpath = o3, r3.realpathSync = i2;
      };
      var r3 = n3(5), o3 = r3.realpath, i2 = r3.realpathSync, s2 = process.version, a2 = /^v[0-5]\./.test(s2), c2 = n3(93);
      function u2(e4) {
        return e4 && "realpath" === e4.syscall && ("ELOOP" === e4.code || "ENOMEM" === e4.code || "ENAMETOOLONG" === e4.code);
      }
      function l2(e4, t4, n4) {
        if (a2)
          return o3(e4, t4, n4);
        "function" == typeof t4 && (n4 = t4, t4 = null), o3(e4, t4, function(r4, o4) {
          u2(r4) ? c2.realpath(e4, t4, n4) : n4(r4, o4);
        });
      }
      function f2(e4, t4) {
        if (a2)
          return i2(e4, t4);
        try {
          return i2(e4, t4);
        } catch (n4) {
          if (u2(n4))
            return c2.realpathSync(e4, t4);
          throw n4;
        }
      }
    }, function(e3, t3) {
      e3.exports = require_events();
    }, function(e3, t3, n3) {
      function r3(e4, t4) {
        return Object.prototype.hasOwnProperty.call(e4, t4);
      }
      t3.alphasort = u2, t3.alphasorti = c2, t3.setopts = function(e4, t4, n4) {
        n4 || (n4 = {});
        if (n4.matchBase && -1 === t4.indexOf("/")) {
          if (n4.noglobstar)
            throw new Error("base matching requires globstar");
          t4 = "**/" + t4;
        }
        e4.silent = !!n4.silent, e4.pattern = t4, e4.strict = false !== n4.strict, e4.realpath = !!n4.realpath, e4.realpathCache = n4.realpathCache || /* @__PURE__ */ Object.create(null), e4.follow = !!n4.follow, e4.dot = !!n4.dot, e4.mark = !!n4.mark, e4.nodir = !!n4.nodir, e4.nodir && (e4.mark = true);
        e4.sync = !!n4.sync, e4.nounique = !!n4.nounique, e4.nonull = !!n4.nonull, e4.nosort = !!n4.nosort, e4.nocase = !!n4.nocase, e4.stat = !!n4.stat, e4.noprocess = !!n4.noprocess, e4.absolute = !!n4.absolute, e4.maxLength = n4.maxLength || 1 / 0, e4.cache = n4.cache || /* @__PURE__ */ Object.create(null), e4.statCache = n4.statCache || /* @__PURE__ */ Object.create(null), e4.symlinks = n4.symlinks || /* @__PURE__ */ Object.create(null), function(e5, t5) {
          e5.ignore = t5.ignore || [], Array.isArray(e5.ignore) || (e5.ignore = [e5.ignore]);
          e5.ignore.length && (e5.ignore = e5.ignore.map(l2));
        }(e4, n4), e4.changedCwd = false;
        var i3 = process.cwd();
        r3(n4, "cwd") ? (e4.cwd = o3.resolve(n4.cwd), e4.changedCwd = e4.cwd !== i3) : e4.cwd = i3;
        e4.root = n4.root || o3.resolve(e4.cwd, "/"), e4.root = o3.resolve(e4.root), "win32" === process.platform && (e4.root = e4.root.replace(/\\/g, "/"));
        e4.cwdAbs = s2(e4.cwd) ? e4.cwd : f2(e4, e4.cwd), "win32" === process.platform && (e4.cwdAbs = e4.cwdAbs.replace(/\\/g, "/"));
        e4.nomount = !!n4.nomount, n4.nonegate = true, n4.nocomment = true, e4.minimatch = new a2(t4, n4), e4.options = e4.minimatch.options;
      }, t3.ownProp = r3, t3.makeAbs = f2, t3.finish = function(e4) {
        for (var t4 = e4.nounique, n4 = t4 ? [] : /* @__PURE__ */ Object.create(null), r4 = 0, o4 = e4.matches.length; r4 < o4; r4++) {
          var i3 = e4.matches[r4];
          if (i3 && 0 !== Object.keys(i3).length) {
            var s3 = Object.keys(i3);
            t4 ? n4.push.apply(n4, s3) : s3.forEach(function(e5) {
              n4[e5] = true;
            });
          } else if (e4.nonull) {
            var a3 = e4.minimatch.globSet[r4];
            t4 ? n4.push(a3) : n4[a3] = true;
          }
        }
        t4 || (n4 = Object.keys(n4));
        e4.nosort || (n4 = n4.sort(e4.nocase ? c2 : u2));
        if (e4.mark) {
          for (var r4 = 0; r4 < n4.length; r4++)
            n4[r4] = e4._mark(n4[r4]);
          e4.nodir && (n4 = n4.filter(function(t5) {
            var n5 = !/\/$/.test(t5), r5 = e4.cache[t5] || e4.cache[f2(e4, t5)];
            return n5 && r5 && (n5 = "DIR" !== r5 && !Array.isArray(r5)), n5;
          }));
        }
        e4.ignore.length && (n4 = n4.filter(function(t5) {
          return !p2(e4, t5);
        }));
        e4.found = n4;
      }, t3.mark = function(e4, t4) {
        var n4 = f2(e4, t4), r4 = e4.cache[n4], o4 = t4;
        if (r4) {
          var i3 = "DIR" === r4 || Array.isArray(r4), s3 = "/" === t4.slice(-1);
          if (i3 && !s3 ? o4 += "/" : !i3 && s3 && (o4 = o4.slice(0, -1)), o4 !== t4) {
            var a3 = f2(e4, o4);
            e4.statCache[a3] = e4.statCache[n4], e4.cache[a3] = e4.cache[n4];
          }
        }
        return o4;
      }, t3.isIgnored = p2, t3.childrenIgnored = function(e4, t4) {
        return !!e4.ignore.length && e4.ignore.some(function(e5) {
          return !(!e5.gmatcher || !e5.gmatcher.match(t4));
        });
      };
      var o3 = n3(0), i2 = n3(46), s2 = n3(48), a2 = i2.Minimatch;
      function c2(e4, t4) {
        return e4.toLowerCase().localeCompare(t4.toLowerCase());
      }
      function u2(e4, t4) {
        return e4.localeCompare(t4);
      }
      function l2(e4) {
        var t4 = null;
        if ("/**" === e4.slice(-3)) {
          var n4 = e4.replace(/(\/\*\*)+$/, "");
          t4 = new a2(n4, { dot: true });
        }
        return { matcher: new a2(e4, { dot: true }), gmatcher: t4 };
      }
      function f2(e4, t4) {
        var n4 = t4;
        return n4 = "/" === t4.charAt(0) ? o3.join(e4.root, t4) : s2(t4) || "" === t4 ? t4 : e4.changedCwd ? o3.resolve(e4.cwd, t4) : o3.resolve(t4), "win32" === process.platform && (n4 = n4.replace(/\\/g, "/")), n4;
      }
      function p2(e4, t4) {
        return !!e4.ignore.length && e4.ignore.some(function(e5) {
          return e5.matcher.match(t4) || !(!e5.gmatcher || !e5.gmatcher.match(t4));
        });
      }
    }, function(e3, t3) {
      e3.exports = function e4(t4, n3) {
        if (t4 && n3)
          return e4(t4)(n3);
        if ("function" != typeof t4)
          throw new TypeError("need wrapper function");
        Object.keys(t4).forEach(function(e5) {
          r3[e5] = t4[e5];
        });
        return r3;
        function r3() {
          for (var e5 = new Array(arguments.length), n4 = 0; n4 < e5.length; n4++)
            e5[n4] = arguments[n4];
          var r4 = t4.apply(this, e5), o3 = e5[e5.length - 1];
          return "function" == typeof r4 && r4 !== o3 && Object.keys(o3).forEach(function(e6) {
            r4[e6] = o3[e6];
          }), r4;
        }
      };
    }, function(e3, t3, n3) {
      var r3 = n3(7), o3 = n3(105), i2 = n3(66), s2 = n3(43)("IE_PROTO"), a2 = function() {
      }, c2 = function() {
        var e4, t4 = n3(33)("iframe"), r4 = i2.length;
        for (t4.style.display = "none", n3(61).appendChild(t4), t4.src = "javascript:", (e4 = t4.contentWindow.document).open(), e4.write("<script>document.F=Object<\/script>"), e4.close(), c2 = e4.F; r4--; )
          delete c2.prototype[i2[r4]];
        return c2();
      };
      e3.exports = Object.create || function(e4, t4) {
        var n4;
        return null !== e4 ? (a2.prototype = r3(e4), n4 = new a2(), a2.prototype = null, n4[s2] = e4) : n4 = c2(), void 0 === t4 ? n4 : o3(n4, t4);
      };
    }, function(e3, t3, n3) {
      var r3 = n3(24)("meta"), o3 = n3(6), i2 = n3(15), s2 = n3(11).f, a2 = 0, c2 = Object.isExtensible || function() {
        return true;
      }, u2 = !n3(10)(function() {
        return c2(Object.preventExtensions({}));
      }), l2 = function(e4) {
        s2(e4, r3, { value: { i: "O" + ++a2, w: {} } });
      }, f2 = e3.exports = { KEY: r3, NEED: false, fastKey: function(e4, t4) {
        if (!o3(e4))
          return "symbol" == typeof e4 ? e4 : ("string" == typeof e4 ? "S" : "P") + e4;
        if (!i2(e4, r3)) {
          if (!c2(e4))
            return "F";
          if (!t4)
            return "E";
          l2(e4);
        }
        return e4[r3].i;
      }, getWeak: function(e4, t4) {
        if (!i2(e4, r3)) {
          if (!c2(e4))
            return true;
          if (!t4)
            return false;
          l2(e4);
        }
        return e4[r3].w;
      }, onFreeze: function(e4) {
        return u2 && f2.NEED && c2(e4) && !i2(e4, r3) && l2(e4), e4;
      } };
    }, function(e3, t3, n3) {
      var r3 = n3(6);
      e3.exports = function(e4, t4) {
        if (!r3(e4) || e4._t !== t4)
          throw TypeError("Incompatible receiver, " + t4 + " required!");
        return e4;
      };
    }, function(e3, t3, n3) {
      var r3 = n3(8), o3 = n3(65)(false);
      r3(r3.S, "Object", { values: function(e4) {
        return o3(e4);
      } });
    }, function(e3, t3, n3) {
      "use strict";
      var r3 = n3(7);
      e3.exports = function() {
        var e4 = r3(this), t4 = "";
        return e4.global && (t4 += "g"), e4.ignoreCase && (t4 += "i"), e4.multiline && (t4 += "m"), e4.unicode && (t4 += "u"), e4.sticky && (t4 += "y"), t4;
      };
    }, function(e3, t3, n3) {
      e3.exports = u2, u2.sync = function(e4, t4) {
        for (var n4 = c2(e4, t4 = t4 || {}), r4 = n4.env, i3 = n4.ext, u3 = n4.extExe, l2 = [], f2 = 0, p2 = r4.length; f2 < p2; f2++) {
          var h = r4[f2];
          '"' === h.charAt(0) && '"' === h.slice(-1) && (h = h.slice(1, -1));
          var d2 = o3.join(h, e4);
          !h && /^\.[\\\/]/.test(e4) && (d2 = e4.slice(0, 2) + d2);
          for (var m = 0, g = i3.length; m < g; m++) {
            var v = d2 + i3[m];
            try {
              if (s2.sync(v, { pathExt: u3 })) {
                if (!t4.all)
                  return v;
                l2.push(v);
              }
            } catch (e5) {
            }
          }
        }
        if (t4.all && l2.length)
          return l2;
        if (t4.nothrow)
          return null;
        throw a2(e4);
      };
      var r3 = "win32" === process.platform || "cygwin" === process.env.OSTYPE || "msys" === process.env.OSTYPE, o3 = n3(0), i2 = r3 ? ";" : ":", s2 = n3(118);
      function a2(e4) {
        var t4 = new Error("not found: " + e4);
        return t4.code = "ENOENT", t4;
      }
      function c2(e4, t4) {
        var n4 = t4.colon || i2, o4 = t4.path || process.env.PATH || "", s3 = [""];
        o4 = o4.split(n4);
        var a3 = "";
        return r3 && (o4.unshift(process.cwd()), s3 = (a3 = t4.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM").split(n4), -1 !== e4.indexOf(".") && "" !== s3[0] && s3.unshift("")), (e4.match(/\//) || r3 && e4.match(/\\/)) && (o4 = [""]), { env: o4, ext: s3, extExe: a3 };
      }
      function u2(e4, t4, n4) {
        "function" == typeof t4 && (n4 = t4, t4 = {});
        var r4 = c2(e4, t4), i3 = r4.env, u3 = r4.ext, l2 = r4.extExe, f2 = [];
        !function r5(c3, p2) {
          if (c3 === p2)
            return t4.all && f2.length ? n4(null, f2) : n4(a2(e4));
          var h = i3[c3];
          '"' === h.charAt(0) && '"' === h.slice(-1) && (h = h.slice(1, -1));
          var d2 = o3.join(h, e4);
          !h && /^\.[\\\/]/.test(e4) && (d2 = e4.slice(0, 2) + d2), function e5(o4, i4) {
            if (o4 === i4)
              return r5(c3 + 1, p2);
            var a3 = u3[o4];
            s2(d2 + a3, { pathExt: l2 }, function(r6, s3) {
              if (!r6 && s3) {
                if (!t4.all)
                  return n4(null, d2 + a3);
                f2.push(d2 + a3);
              }
              return e5(o4 + 1, i4);
            });
          }(0, u3.length);
        }(0, i3.length);
      }
    }, function(e3, t3, n3) {
      "use strict";
      e3.exports = (e4) => {
        const t4 = (e4 = e4 || {}).env || process.env;
        return "win32" !== (e4.platform || process.platform) ? "PATH" : Object.keys(t4).find((e5) => "PATH" === e5.toUpperCase()) || "Path";
      };
    }, function(e3, t3, n3) {
      "use strict";
      n3(32), n3(2), n3(27), n3(64), n3(21);
      var r3 = n3(90), o3 = n3(161), i2 = n3(170), s2 = n3(1);
      function a2(e4, t4) {
        (t4 = t4 || {}).clipboard && console.log("\n*** Clipboard option removed - use clipboardy or clipboard-cli directly ***\n");
        var n4 = Object.keys(e4).length > 0 ? e4 : i2.defaults, s3 = Object.entries(n4).reduce(function(e5, n5) {
          var o4 = n5[0], i3 = n5[1], s4 = r3[`get${o4}`];
          return s4 ? (i3 && e5.push(s4(i3, t4)), e5) : e5 = e5.concat((i3 || []).map(function(e6) {
            var t5 = r3[`get${e6.replace(/\s/g, "")}Info`];
            return t5 ? t5() : Promise.resolve(["Unknown"]);
          }));
        }, []);
        return Promise.all(s3).then(function(e5) {
          var n5 = e5.reduce(function(e6, t5) {
            return t5 && t5[0] && Object.assign(e6, { [t5[0]]: t5 }), e6;
          }, {});
          return function(e6, t5) {
            var n6 = t5.json ? o3.json : t5.markdown ? o3.markdown : o3.yaml;
            if (t5.console) {
              var r4 = false;
              process.stdout.isTTY && (r4 = true), console.log(n6(e6, Object.assign({}, t5, { console: r4 })));
            }
            return n6(e6, Object.assign({}, t5, { console: false }));
          }(Object.entries(i2.defaults).reduce(function(e6, t5) {
            var r4 = t5[0], o4 = t5[1];
            return n5[r4] ? Object.assign(e6, { [r4]: n5[r4][1] }) : Object.assign(e6, { [r4]: (o4 || []).reduce(function(e7, t6) {
              return n5[t6] ? (n5[t6].shift(), 1 === n5[t6].length ? Object.assign(e7, { [t6]: n5[t6][0] }) : Object.assign(e7, { [t6]: { version: n5[t6][0], path: n5[t6][1] } })) : e7;
            }, {}) });
          }, {}), t4);
        });
      }
      e3.exports = { cli: function(e4) {
        if (e4.all)
          return a2(Object.assign({}, i2.defaults, { npmPackages: true, npmGlobalPackages: true }), e4);
        if (e4.raw)
          return a2(JSON.parse(e4.raw), e4);
        if (e4.helper) {
          var t4 = r3[`get${e4.helper}`] || r3[`get${e4.helper}Info`] || r3[e4.helper];
          return t4 ? t4().then(console.log) : console.error("Not Found");
        }
        var n4 = function(e5, t5) {
          return e5.toLowerCase().includes(t5.toLowerCase());
        }, o4 = Object.keys(e4).filter(function(e5) {
          return Object.keys(i2.defaults).some(function(t5) {
            return n4(t5, e5);
          });
        }), c2 = Object.entries(i2.defaults).reduce(function(t5, r4) {
          return o4.some(function(e5) {
            return n4(e5, r4[0]);
          }) ? Object.assign(t5, { [r4[0]]: r4[1] || e4[r4[0]] }) : t5;
        }, {});
        return e4.preset ? i2[e4.preset] ? a2(Object.assign({}, s2.omit(i2[e4.preset], ["options"]), c2), Object.assign({}, i2[e4.preset].options, s2.pick(e4, ["duplicates", "fullTree", "json", "markdown", "console"]))) : console.error(`
No "${e4.preset}" preset found.`) : a2(c2, e4);
      }, helpers: r3, main: a2, run: function(e4, t4) {
        return "string" == typeof e4.preset ? a2(i2[e4.preset], t4) : a2(e4, t4);
      } };
    }, function(e3, t3, n3) {
      var r3 = n3(54), o3 = Math.max, i2 = Math.min;
      e3.exports = function(e4, t4) {
        return (e4 = r3(e4)) < 0 ? o3(e4 + t4, 0) : i2(e4, t4);
      };
    }, function(e3, t3, n3) {
      var r3 = n3(3)("unscopables"), o3 = Array.prototype;
      null == o3[r3] && n3(13)(o3, r3, {}), e3.exports = function(e4) {
        o3[r3][e4] = true;
      };
    }, function(e3, t3, n3) {
      var r3 = n3(7), o3 = n3(19), i2 = n3(3)("species");
      e3.exports = function(e4, t4) {
        var n4, s2 = r3(e4).constructor;
        return void 0 === s2 || null == (n4 = r3(s2)[i2]) ? t4 : o3(n4);
      };
    }, function(e3, t3) {
      e3.exports = function(e4, t4, n3) {
        var r3 = void 0 === n3;
        switch (t4.length) {
          case 0:
            return r3 ? e4() : e4.call(n3);
          case 1:
            return r3 ? e4(t4[0]) : e4.call(n3, t4[0]);
          case 2:
            return r3 ? e4(t4[0], t4[1]) : e4.call(n3, t4[0], t4[1]);
          case 3:
            return r3 ? e4(t4[0], t4[1], t4[2]) : e4.call(n3, t4[0], t4[1], t4[2]);
          case 4:
            return r3 ? e4(t4[0], t4[1], t4[2], t4[3]) : e4.call(n3, t4[0], t4[1], t4[2], t4[3]);
        }
        return e4.apply(n3, t4);
      };
    }, function(e3, t3, n3) {
      var r3 = n3(4), o3 = n3(60).set, i2 = r3.MutationObserver || r3.WebKitMutationObserver, s2 = r3.process, a2 = r3.Promise, c2 = "process" == n3(20)(s2);
      e3.exports = function() {
        var e4, t4, n4, u2 = function() {
          var r4, o4;
          for (c2 && (r4 = s2.domain) && r4.exit(); e4; ) {
            o4 = e4.fn, e4 = e4.next;
            try {
              o4();
            } catch (r5) {
              throw e4 ? n4() : t4 = void 0, r5;
            }
          }
          t4 = void 0, r4 && r4.enter();
        };
        if (c2)
          n4 = function() {
            s2.nextTick(u2);
          };
        else if (!i2 || r3.navigator && r3.navigator.standalone)
          if (a2 && a2.resolve) {
            var l2 = a2.resolve(void 0);
            n4 = function() {
              l2.then(u2);
            };
          } else
            n4 = function() {
              o3.call(r3, u2);
            };
        else {
          var f2 = true, p2 = document.createTextNode("");
          new i2(u2).observe(p2, { characterData: true }), n4 = function() {
            p2.data = f2 = !f2;
          };
        }
        return function(r4) {
          var o4 = { fn: r4, next: void 0 };
          t4 && (t4.next = o4), e4 || (e4 = o4, n4()), t4 = o4;
        };
      };
    }, function(e3, t3) {
      e3.exports = function(e4) {
        try {
          return { e: false, v: e4() };
        } catch (e5) {
          return { e: true, v: e5 };
        }
      };
    }, function(e3, t3, n3) {
      var r3 = n3(4).navigator;
      e3.exports = r3 && r3.userAgent || "";
    }, function(e3, t3, n3) {
      var r3 = n3(7), o3 = n3(6), i2 = n3(62);
      e3.exports = function(e4, t4) {
        if (r3(e4), o3(t4) && t4.constructor === e4)
          return t4;
        var n4 = i2.f(e4);
        return (0, n4.resolve)(t4), n4.promise;
      };
    }, function(e3, t3, n3) {
      var r3 = n3(15), o3 = n3(25), i2 = n3(52)(false), s2 = n3(43)("IE_PROTO");
      e3.exports = function(e4, t4) {
        var n4, a2 = o3(e4), c2 = 0, u2 = [];
        for (n4 in a2)
          n4 != s2 && r3(a2, n4) && u2.push(n4);
        for (; t4.length > c2; )
          r3(a2, n4 = t4[c2++]) && (~i2(u2, n4) || u2.push(n4));
        return u2;
      };
    }, function(e3, t3, n3) {
      "use strict";
      var r3 = n3(42), o3 = n3(89), i2 = n3(44), s2 = n3(29), a2 = n3(53), c2 = Object.assign;
      e3.exports = !c2 || n3(10)(function() {
        var e4 = {}, t4 = {}, n4 = Symbol(), r4 = "abcdefghijklmnopqrst";
        return e4[n4] = 7, r4.split("").forEach(function(e5) {
          t4[e5] = e5;
        }), 7 != c2({}, e4)[n4] || Object.keys(c2({}, t4)).join("") != r4;
      }) ? function(e4, t4) {
        for (var n4 = s2(e4), c3 = arguments.length, u2 = 1, l2 = o3.f, f2 = i2.f; c3 > u2; )
          for (var p2, h = a2(arguments[u2++]), d2 = l2 ? r3(h).concat(l2(h)) : r3(h), m = d2.length, g = 0; m > g; )
            f2.call(h, p2 = d2[g++]) && (n4[p2] = h[p2]);
        return n4;
      } : c2;
    }, function(e3, t3) {
      t3.f = Object.getOwnPropertySymbols;
    }, function(e3, t3, n3) {
      "use strict";
      function r3(e4, t4, n4) {
        return t4 in e4 ? Object.defineProperty(e4, t4, { value: n4, enumerable: true, configurable: true, writable: true }) : e4[t4] = n4, e4;
      }
      n3(21);
      var o3 = n3(91), i2 = n3(1), s2 = n3(122), a2 = n3(123), c2 = n3(124), u2 = n3(125), l2 = n3(126), f2 = n3(127), p2 = n3(128), h = n3(129), d2 = n3(130), m = n3(131), g = n3(159), v = n3(160);
      e3.exports = Object.assign({}, i2, o3, function(e4) {
        for (var t4 = 1; t4 < arguments.length; t4++) {
          var n4 = null != arguments[t4] ? arguments[t4] : {}, o4 = Object.keys(n4);
          "function" == typeof Object.getOwnPropertySymbols && (o4 = o4.concat(Object.getOwnPropertySymbols(n4).filter(function(e5) {
            return Object.getOwnPropertyDescriptor(n4, e5).enumerable;
          }))), o4.forEach(function(t5) {
            r3(e4, t5, n4[t5]);
          });
        }
        return e4;
      }({}, s2, a2, c2, u2, l2, f2, p2, h, d2, m, g, v));
    }, function(e3, t3, n3) {
      "use strict";
      n3(22), n3(21), n3(2), n3(32), n3(16);
      var r3 = n3(45), o3 = n3(0), i2 = n3(1), s2 = function(e4) {
        var t4 = e4.split("node_modules" + o3.sep), n4 = t4[t4.length - 1];
        return "@" === n4.charAt(0) ? [n4.split(o3.sep)[0], n4.split(o3.sep)[1]].join("/") : n4.split(o3.sep)[0];
      };
      e3.exports = { getnpmPackages: function(e4, t4) {
        i2.log("trace", "getnpmPackages"), t4 || (t4 = {});
        var n4 = null, r4 = null;
        return "string" == typeof e4 && (e4.includes("*") || e4.includes("?") || e4.includes("+") || e4.includes("!") ? n4 = e4 : e4 = e4.split(",")), Promise.all(["npmPackages", i2.getPackageJsonByPath("package.json").then(function(e5) {
          return Object.assign({}, (e5 || {}).devDependencies || {}, (e5 || {}).dependencies || {});
        }).then(function(e5) {
          return r4 = e5, t4.fullTree || t4.duplicates || n4 ? i2.getAllPackageJsonPaths(n4) : Promise.resolve(Object.keys(e5 || []).map(function(e6) {
            return o3.join("node_modules", e6, "package.json");
          }));
        }).then(function(o4) {
          return !n4 && "boolean" != typeof e4 || t4.fullTree ? Array.isArray(e4) ? Promise.resolve((o4 || []).filter(function(t5) {
            return e4.includes(s2(t5));
          })) : Promise.resolve(o4) : Promise.resolve((o4 || []).filter(function(e5) {
            return Object.keys(r4 || []).includes(s2(e5));
          }));
        }).then(function(e5) {
          return Promise.all([e5, Promise.all(e5.map(function(e6) {
            return i2.getPackageJsonByPath(e6);
          }))]);
        }).then(function(e5) {
          var n5 = e5[0], o4 = e5[1].reduce(function(e6, r5, o5) {
            return r5 && r5.name ? (e6[r5.name] || (e6[r5.name] = {}), t4.duplicates && (e6[r5.name].duplicates = i2.uniq((e6[r5.name].duplicates || []).concat(r5.version))), 1 === (n5[o5].match(/node_modules/g) || []).length && (e6[r5.name].installed = r5.version), e6) : e6;
          }, {});
          return Object.keys(o4).forEach(function(e6) {
            o4[e6].duplicates && o4[e6].installed && (o4[e6].duplicates = o4[e6].duplicates.filter(function(t5) {
              return t5 !== o4[e6].installed;
            })), r4[e6] && (o4[e6].wanted = r4[e6]);
          }), o4;
        }).then(function(n5) {
          return t4.showNotFound && Array.isArray(e4) && e4.forEach(function(e5) {
            n5[e5] || (n5[e5] = "Not Found");
          }), n5;
        }).then(function(e5) {
          return i2.sortObject(e5);
        })]);
      }, getnpmGlobalPackages: function(e4, t4) {
        i2.log("trace", "getnpmGlobalPackages", e4);
        var n4 = null;
        return "string" == typeof e4 ? e4.includes("*") || e4.includes("?") || e4.includes("+") || e4.includes("!") ? n4 = e4 : e4 = e4.split(",") : Array.isArray(e4) || (e4 = true), Promise.all(["npmGlobalPackages", i2.run("npm get prefix --global").then(function(e5) {
          return new Promise(function(t5, s3) {
            return r3(o3.join(e5, i2.isWindows ? "" : "lib", "node_modules", n4 || "{*,@*/*}", "package.json"), function(e6, n5) {
              e6 || t5(n5), s3(e6);
            });
          });
        }).then(function(t5) {
          return Promise.all(t5.filter(function(t6) {
            return "boolean" == typeof e4 || null !== n4 || e4.includes(s2(t6));
          }).map(function(e5) {
            return i2.getPackageJsonByFullPath(e5);
          }));
        }).then(function(e5) {
          return e5.reduce(function(e6, t5) {
            return t5 ? Object.assign(e6, { [t5.name]: t5.version }) : e6;
          }, {});
        }).then(function(n5) {
          return t4.showNotFound && Array.isArray(e4) && e4.forEach(function(e5) {
            n5[e5] || (n5[e5] = "Not Found");
          }), n5;
        })]);
      } };
    }, function(e3, t3, n3) {
      var r3 = n3(6), o3 = n3(20), i2 = n3(3)("match");
      e3.exports = function(e4) {
        var t4;
        return r3(e4) && (void 0 !== (t4 = e4[i2]) ? !!t4 : "RegExp" == o3(e4));
      };
    }, function(e3, t3, n3) {
      var r3 = n3(0), o3 = "win32" === process.platform, i2 = n3(5), s2 = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
      function a2(e4) {
        return "function" == typeof e4 ? e4 : function() {
          var e5;
          if (s2) {
            var t4 = new Error();
            e5 = function(e6) {
              e6 && (t4.message = e6.message, n4(e6 = t4));
            };
          } else
            e5 = n4;
          return e5;
          function n4(e6) {
            if (e6) {
              if (process.throwDeprecation)
                throw e6;
              if (!process.noDeprecation) {
                var t5 = "fs: missing callback " + (e6.stack || e6.message);
                process.traceDeprecation ? console.trace(t5) : console.error(t5);
              }
            }
          }
        }();
      }
      r3.normalize;
      if (o3)
        var c2 = /(.*?)(?:[\/\\]+|$)/g;
      else
        c2 = /(.*?)(?:[\/]+|$)/g;
      if (o3)
        var u2 = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
      else
        u2 = /^[\/]*/;
      t3.realpathSync = function(e4, t4) {
        if (e4 = r3.resolve(e4), t4 && Object.prototype.hasOwnProperty.call(t4, e4))
          return t4[e4];
        var n4, s3, a3, l2, f2 = e4, p2 = {}, h = {};
        function d2() {
          var t5 = u2.exec(e4);
          n4 = t5[0].length, s3 = t5[0], a3 = t5[0], l2 = "", o3 && !h[a3] && (i2.lstatSync(a3), h[a3] = true);
        }
        for (d2(); n4 < e4.length; ) {
          c2.lastIndex = n4;
          var m = c2.exec(e4);
          if (l2 = s3, s3 += m[0], a3 = l2 + m[1], n4 = c2.lastIndex, !(h[a3] || t4 && t4[a3] === a3)) {
            var g;
            if (t4 && Object.prototype.hasOwnProperty.call(t4, a3))
              g = t4[a3];
            else {
              var v = i2.lstatSync(a3);
              if (!v.isSymbolicLink()) {
                h[a3] = true, t4 && (t4[a3] = a3);
                continue;
              }
              var y = null;
              if (!o3) {
                var b = v.dev.toString(32) + ":" + v.ino.toString(32);
                p2.hasOwnProperty(b) && (y = p2[b]);
              }
              null === y && (i2.statSync(a3), y = i2.readlinkSync(a3)), g = r3.resolve(l2, y), t4 && (t4[a3] = g), o3 || (p2[b] = y);
            }
            e4 = r3.resolve(g, e4.slice(n4)), d2();
          }
        }
        return t4 && (t4[f2] = e4), e4;
      }, t3.realpath = function(e4, t4, n4) {
        if ("function" != typeof n4 && (n4 = a2(t4), t4 = null), e4 = r3.resolve(e4), t4 && Object.prototype.hasOwnProperty.call(t4, e4))
          return process.nextTick(n4.bind(null, null, t4[e4]));
        var s3, l2, f2, p2, h = e4, d2 = {}, m = {};
        function g() {
          var t5 = u2.exec(e4);
          s3 = t5[0].length, l2 = t5[0], f2 = t5[0], p2 = "", o3 && !m[f2] ? i2.lstat(f2, function(e5) {
            if (e5)
              return n4(e5);
            m[f2] = true, v();
          }) : process.nextTick(v);
        }
        function v() {
          if (s3 >= e4.length)
            return t4 && (t4[h] = e4), n4(null, e4);
          c2.lastIndex = s3;
          var r4 = c2.exec(e4);
          return p2 = l2, l2 += r4[0], f2 = p2 + r4[1], s3 = c2.lastIndex, m[f2] || t4 && t4[f2] === f2 ? process.nextTick(v) : t4 && Object.prototype.hasOwnProperty.call(t4, f2) ? w(t4[f2]) : i2.lstat(f2, y);
        }
        function y(e5, r4) {
          if (e5)
            return n4(e5);
          if (!r4.isSymbolicLink())
            return m[f2] = true, t4 && (t4[f2] = f2), process.nextTick(v);
          if (!o3) {
            var s4 = r4.dev.toString(32) + ":" + r4.ino.toString(32);
            if (d2.hasOwnProperty(s4))
              return b(null, d2[s4], f2);
          }
          i2.stat(f2, function(e6) {
            if (e6)
              return n4(e6);
            i2.readlink(f2, function(e7, t5) {
              o3 || (d2[s4] = t5), b(e7, t5);
            });
          });
        }
        function b(e5, o4, i3) {
          if (e5)
            return n4(e5);
          var s4 = r3.resolve(p2, o4);
          t4 && (t4[i3] = s4), w(s4);
        }
        function w(t5) {
          e4 = r3.resolve(t5, e4.slice(s3)), g();
        }
        g();
      };
    }, function(e3, t3, n3) {
      var r3 = n3(95), o3 = n3(96);
      e3.exports = function(e4) {
        if (!e4)
          return [];
        "{}" === e4.substr(0, 2) && (e4 = "\\{\\}" + e4.substr(2));
        return function e5(t4, n4) {
          var i3 = [];
          var s3 = o3("{", "}", t4);
          if (!s3 || /\$$/.test(s3.pre))
            return [t4];
          var c3 = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(s3.body);
          var u3 = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(s3.body);
          var f3 = c3 || u3;
          var g = s3.body.indexOf(",") >= 0;
          if (!f3 && !g)
            return s3.post.match(/,.*\}/) ? (t4 = s3.pre + "{" + s3.body + a2 + s3.post, e5(t4)) : [t4];
          var v;
          if (f3)
            v = s3.body.split(/\.\./);
          else if (1 === (v = function e6(t5) {
            if (!t5)
              return [""];
            var n5 = [];
            var r4 = o3("{", "}", t5);
            if (!r4)
              return t5.split(",");
            var i4 = r4.pre;
            var s4 = r4.body;
            var a3 = r4.post;
            var c4 = i4.split(",");
            c4[c4.length - 1] += "{" + s4 + "}";
            var u4 = e6(a3);
            a3.length && (c4[c4.length - 1] += u4.shift(), c4.push.apply(c4, u4));
            n5.push.apply(n5, c4);
            return n5;
          }(s3.body)).length && 1 === (v = e5(v[0], false).map(p2)).length) {
            var y = s3.post.length ? e5(s3.post, false) : [""];
            return y.map(function(e6) {
              return s3.pre + v[0] + e6;
            });
          }
          var b = s3.pre;
          var y = s3.post.length ? e5(s3.post, false) : [""];
          var w;
          if (f3) {
            var x = l2(v[0]), S = l2(v[1]), P = Math.max(v[0].length, v[1].length), O = 3 == v.length ? Math.abs(l2(v[2])) : 1, j = d2, E2 = S < x;
            E2 && (O *= -1, j = m);
            var I = v.some(h);
            w = [];
            for (var _ = x; j(_, S); _ += O) {
              var A2;
              if (u3)
                "\\" === (A2 = String.fromCharCode(_)) && (A2 = "");
              else if (A2 = String(_), I) {
                var k = P - A2.length;
                if (k > 0) {
                  var N = new Array(k + 1).join("0");
                  A2 = _ < 0 ? "-" + N + A2.slice(1) : N + A2;
                }
              }
              w.push(A2);
            }
          } else
            w = r3(v, function(t5) {
              return e5(t5, false);
            });
          for (var F = 0; F < w.length; F++)
            for (var C2 = 0; C2 < y.length; C2++) {
              var M = b + w[F] + y[C2];
              (!n4 || f3 || M) && i3.push(M);
            }
          return i3;
        }(function(e5) {
          return e5.split("\\\\").join(i2).split("\\{").join(s2).split("\\}").join(a2).split("\\,").join(c2).split("\\.").join(u2);
        }(e4), true).map(f2);
      };
      var i2 = "\0SLASH" + Math.random() + "\0", s2 = "\0OPEN" + Math.random() + "\0", a2 = "\0CLOSE" + Math.random() + "\0", c2 = "\0COMMA" + Math.random() + "\0", u2 = "\0PERIOD" + Math.random() + "\0";
      function l2(e4) {
        return parseInt(e4, 10) == e4 ? parseInt(e4, 10) : e4.charCodeAt(0);
      }
      function f2(e4) {
        return e4.split(i2).join("\\").split(s2).join("{").split(a2).join("}").split(c2).join(",").split(u2).join(".");
      }
      function p2(e4) {
        return "{" + e4 + "}";
      }
      function h(e4) {
        return /^-?0\d/.test(e4);
      }
      function d2(e4, t4) {
        return e4 <= t4;
      }
      function m(e4, t4) {
        return e4 >= t4;
      }
    }, function(e3, t3) {
      e3.exports = function(e4, t4) {
        for (var r3 = [], o3 = 0; o3 < e4.length; o3++) {
          var i2 = t4(e4[o3], o3);
          n3(i2) ? r3.push.apply(r3, i2) : r3.push(i2);
        }
        return r3;
      };
      var n3 = Array.isArray || function(e4) {
        return "[object Array]" === Object.prototype.toString.call(e4);
      };
    }, function(e3, t3, n3) {
      "use strict";
      function r3(e4, t4, n4) {
        e4 instanceof RegExp && (e4 = o3(e4, n4)), t4 instanceof RegExp && (t4 = o3(t4, n4));
        var r4 = i2(e4, t4, n4);
        return r4 && { start: r4[0], end: r4[1], pre: n4.slice(0, r4[0]), body: n4.slice(r4[0] + e4.length, r4[1]), post: n4.slice(r4[1] + t4.length) };
      }
      function o3(e4, t4) {
        var n4 = t4.match(e4);
        return n4 ? n4[0] : null;
      }
      function i2(e4, t4, n4) {
        var r4, o4, i3, s2, a2, c2 = n4.indexOf(e4), u2 = n4.indexOf(t4, c2 + 1), l2 = c2;
        if (c2 >= 0 && u2 > 0) {
          for (r4 = [], i3 = n4.length; l2 >= 0 && !a2; )
            l2 == c2 ? (r4.push(l2), c2 = n4.indexOf(e4, l2 + 1)) : 1 == r4.length ? a2 = [r4.pop(), u2] : ((o4 = r4.pop()) < i3 && (i3 = o4, s2 = u2), u2 = n4.indexOf(t4, l2 + 1)), l2 = c2 < u2 && c2 >= 0 ? c2 : u2;
          r4.length && (a2 = [i3, s2]);
        }
        return a2;
      }
      e3.exports = r3, r3.range = i2;
    }, function(e3, t3, n3) {
      try {
        var r3 = n3(30);
        if ("function" != typeof r3.inherits)
          throw "";
        e3.exports = r3.inherits;
      } catch (t4) {
        e3.exports = n3(98);
      }
    }, function(e3, t3) {
      "function" == typeof Object.create ? e3.exports = function(e4, t4) {
        e4.super_ = t4, e4.prototype = Object.create(t4.prototype, { constructor: { value: e4, enumerable: false, writable: true, configurable: true } });
      } : e3.exports = function(e4, t4) {
        e4.super_ = t4;
        var n3 = function() {
        };
        n3.prototype = t4.prototype, e4.prototype = new n3(), e4.prototype.constructor = e4;
      };
    }, function(e3, t3, n3) {
      e3.exports = d2, d2.GlobSync = m;
      var r3 = n3(5), o3 = n3(67), i2 = n3(46), s2 = (i2.Minimatch, n3(45).Glob, n3(30), n3(0)), a2 = n3(47), c2 = n3(48), u2 = n3(69), l2 = (u2.alphasort, u2.alphasorti, u2.setopts), f2 = u2.ownProp, p2 = u2.childrenIgnored, h = u2.isIgnored;
      function d2(e4, t4) {
        if ("function" == typeof t4 || 3 === arguments.length)
          throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
        return new m(e4, t4).found;
      }
      function m(e4, t4) {
        if (!e4)
          throw new Error("must provide pattern");
        if ("function" == typeof t4 || 3 === arguments.length)
          throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
        if (!(this instanceof m))
          return new m(e4, t4);
        if (l2(this, e4, t4), this.noprocess)
          return this;
        var n4 = this.minimatch.set.length;
        this.matches = new Array(n4);
        for (var r4 = 0; r4 < n4; r4++)
          this._process(this.minimatch.set[r4], r4, false);
        this._finish();
      }
      m.prototype._finish = function() {
        if (a2(this instanceof m), this.realpath) {
          var e4 = this;
          this.matches.forEach(function(t4, n4) {
            var r4 = e4.matches[n4] = /* @__PURE__ */ Object.create(null);
            for (var i3 in t4)
              try {
                i3 = e4._makeAbs(i3), r4[o3.realpathSync(i3, e4.realpathCache)] = true;
              } catch (t5) {
                if ("stat" !== t5.syscall)
                  throw t5;
                r4[e4._makeAbs(i3)] = true;
              }
          });
        }
        u2.finish(this);
      }, m.prototype._process = function(e4, t4, n4) {
        a2(this instanceof m);
        for (var r4, o4 = 0; "string" == typeof e4[o4]; )
          o4++;
        switch (o4) {
          case e4.length:
            return void this._processSimple(e4.join("/"), t4);
          case 0:
            r4 = null;
            break;
          default:
            r4 = e4.slice(0, o4).join("/");
        }
        var s3, u3 = e4.slice(o4);
        null === r4 ? s3 = "." : c2(r4) || c2(e4.join("/")) ? (r4 && c2(r4) || (r4 = "/" + r4), s3 = r4) : s3 = r4;
        var l3 = this._makeAbs(s3);
        p2(this, s3) || (u3[0] === i2.GLOBSTAR ? this._processGlobStar(r4, s3, l3, u3, t4, n4) : this._processReaddir(r4, s3, l3, u3, t4, n4));
      }, m.prototype._processReaddir = function(e4, t4, n4, r4, o4, i3) {
        var a3 = this._readdir(n4, i3);
        if (a3) {
          for (var c3 = r4[0], u3 = !!this.minimatch.negate, l3 = c3._glob, f3 = this.dot || "." === l3.charAt(0), p3 = [], h2 = 0; h2 < a3.length; h2++) {
            if ("." !== (g = a3[h2]).charAt(0) || f3)
              (u3 && !e4 ? !g.match(c3) : g.match(c3)) && p3.push(g);
          }
          var d3 = p3.length;
          if (0 !== d3)
            if (1 !== r4.length || this.mark || this.stat) {
              r4.shift();
              for (h2 = 0; h2 < d3; h2++) {
                var m2;
                g = p3[h2];
                m2 = e4 ? [e4, g] : [g], this._process(m2.concat(r4), o4, i3);
              }
            } else {
              this.matches[o4] || (this.matches[o4] = /* @__PURE__ */ Object.create(null));
              for (var h2 = 0; h2 < d3; h2++) {
                var g = p3[h2];
                e4 && (g = "/" !== e4.slice(-1) ? e4 + "/" + g : e4 + g), "/" !== g.charAt(0) || this.nomount || (g = s2.join(this.root, g)), this._emitMatch(o4, g);
              }
            }
        }
      }, m.prototype._emitMatch = function(e4, t4) {
        if (!h(this, t4)) {
          var n4 = this._makeAbs(t4);
          if (this.mark && (t4 = this._mark(t4)), this.absolute && (t4 = n4), !this.matches[e4][t4]) {
            if (this.nodir) {
              var r4 = this.cache[n4];
              if ("DIR" === r4 || Array.isArray(r4))
                return;
            }
            this.matches[e4][t4] = true, this.stat && this._stat(t4);
          }
        }
      }, m.prototype._readdirInGlobStar = function(e4) {
        if (this.follow)
          return this._readdir(e4, false);
        var t4, n4;
        try {
          n4 = r3.lstatSync(e4);
        } catch (e5) {
          if ("ENOENT" === e5.code)
            return null;
        }
        var o4 = n4 && n4.isSymbolicLink();
        return this.symlinks[e4] = o4, o4 || !n4 || n4.isDirectory() ? t4 = this._readdir(e4, false) : this.cache[e4] = "FILE", t4;
      }, m.prototype._readdir = function(e4, t4) {
        if (t4 && !f2(this.symlinks, e4))
          return this._readdirInGlobStar(e4);
        if (f2(this.cache, e4)) {
          var n4 = this.cache[e4];
          if (!n4 || "FILE" === n4)
            return null;
          if (Array.isArray(n4))
            return n4;
        }
        try {
          return this._readdirEntries(e4, r3.readdirSync(e4));
        } catch (t5) {
          return this._readdirError(e4, t5), null;
        }
      }, m.prototype._readdirEntries = function(e4, t4) {
        if (!this.mark && !this.stat)
          for (var n4 = 0; n4 < t4.length; n4++) {
            var r4 = t4[n4];
            r4 = "/" === e4 ? e4 + r4 : e4 + "/" + r4, this.cache[r4] = true;
          }
        return this.cache[e4] = t4, t4;
      }, m.prototype._readdirError = function(e4, t4) {
        switch (t4.code) {
          case "ENOTSUP":
          case "ENOTDIR":
            var n4 = this._makeAbs(e4);
            if (this.cache[n4] = "FILE", n4 === this.cwdAbs) {
              var r4 = new Error(t4.code + " invalid cwd " + this.cwd);
              throw r4.path = this.cwd, r4.code = t4.code, r4;
            }
            break;
          case "ENOENT":
          case "ELOOP":
          case "ENAMETOOLONG":
          case "UNKNOWN":
            this.cache[this._makeAbs(e4)] = false;
            break;
          default:
            if (this.cache[this._makeAbs(e4)] = false, this.strict)
              throw t4;
            this.silent || console.error("glob error", t4);
        }
      }, m.prototype._processGlobStar = function(e4, t4, n4, r4, o4, i3) {
        var s3 = this._readdir(n4, i3);
        if (s3) {
          var a3 = r4.slice(1), c3 = e4 ? [e4] : [], u3 = c3.concat(a3);
          this._process(u3, o4, false);
          var l3 = s3.length;
          if (!this.symlinks[n4] || !i3)
            for (var f3 = 0; f3 < l3; f3++) {
              if ("." !== s3[f3].charAt(0) || this.dot) {
                var p3 = c3.concat(s3[f3], a3);
                this._process(p3, o4, true);
                var h2 = c3.concat(s3[f3], r4);
                this._process(h2, o4, true);
              }
            }
        }
      }, m.prototype._processSimple = function(e4, t4) {
        var n4 = this._stat(e4);
        if (this.matches[t4] || (this.matches[t4] = /* @__PURE__ */ Object.create(null)), n4) {
          if (e4 && c2(e4) && !this.nomount) {
            var r4 = /[\/\\]$/.test(e4);
            "/" === e4.charAt(0) ? e4 = s2.join(this.root, e4) : (e4 = s2.resolve(this.root, e4), r4 && (e4 += "/"));
          }
          "win32" === process.platform && (e4 = e4.replace(/\\/g, "/")), this._emitMatch(t4, e4);
        }
      }, m.prototype._stat = function(e4) {
        var t4 = this._makeAbs(e4), n4 = "/" === e4.slice(-1);
        if (e4.length > this.maxLength)
          return false;
        if (!this.stat && f2(this.cache, t4)) {
          var o4 = this.cache[t4];
          if (Array.isArray(o4) && (o4 = "DIR"), !n4 || "DIR" === o4)
            return o4;
          if (n4 && "FILE" === o4)
            return false;
        }
        var i3 = this.statCache[t4];
        if (!i3) {
          var s3;
          try {
            s3 = r3.lstatSync(t4);
          } catch (e5) {
            if (e5 && ("ENOENT" === e5.code || "ENOTDIR" === e5.code))
              return this.statCache[t4] = false, false;
          }
          if (s3 && s3.isSymbolicLink())
            try {
              i3 = r3.statSync(t4);
            } catch (e5) {
              i3 = s3;
            }
          else
            i3 = s3;
        }
        this.statCache[t4] = i3;
        o4 = true;
        return i3 && (o4 = i3.isDirectory() ? "DIR" : "FILE"), this.cache[t4] = this.cache[t4] || o4, (!n4 || "FILE" !== o4) && o4;
      }, m.prototype._mark = function(e4) {
        return u2.mark(this, e4);
      }, m.prototype._makeAbs = function(e4) {
        return u2.makeAbs(this, e4);
      };
    }, function(e3, t3, n3) {
      var r3 = n3(70), o3 = /* @__PURE__ */ Object.create(null), i2 = n3(31);
      e3.exports = r3(function(e4, t4) {
        return o3[e4] ? (o3[e4].push(t4), null) : (o3[e4] = [t4], function(e5) {
          return i2(function t5() {
            var n4 = o3[e5], r4 = n4.length, i3 = function(e6) {
              for (var t6 = e6.length, n5 = [], r5 = 0; r5 < t6; r5++)
                n5[r5] = e6[r5];
              return n5;
            }(arguments);
            try {
              for (var s2 = 0; s2 < r4; s2++)
                n4[s2].apply(null, i3);
            } finally {
              n4.length > r4 ? (n4.splice(0, r4), process.nextTick(function() {
                t5.apply(null, i3);
              })) : delete o3[e5];
            }
          });
        }(e4));
      });
    }, function(e3, t3, n3) {
      "use strict";
      var r3 = n3(8), o3 = n3(19), i2 = n3(29), s2 = n3(10), a2 = [].sort, c2 = [1, 2, 3];
      r3(r3.P + r3.F * (s2(function() {
        c2.sort(void 0);
      }) || !s2(function() {
        c2.sort(null);
      }) || !n3(102)(a2)), "Array", { sort: function(e4) {
        return void 0 === e4 ? a2.call(i2(this)) : a2.call(i2(this), o3(e4));
      } });
    }, function(e3, t3, n3) {
      "use strict";
      var r3 = n3(10);
      e3.exports = function(e4, t4) {
        return !!e4 && r3(function() {
          t4 ? e4.call(null, function() {
          }, 1) : e4.call(null);
        });
      };
    }, function(e3, t3, n3) {
      "use strict";
      var r3 = n3(104), o3 = n3(73);
      e3.exports = n3(110)("Set", function(e4) {
        return function() {
          return e4(this, arguments.length > 0 ? arguments[0] : void 0);
        };
      }, { add: function(e4) {
        return r3.def(o3(this, "Set"), e4 = 0 === e4 ? 0 : e4, e4);
      } }, r3);
    }, function(e3, t3, n3) {
      "use strict";
      var r3 = n3(11).f, o3 = n3(71), i2 = n3(40), s2 = n3(12), a2 = n3(37), c2 = n3(38), u2 = n3(106), l2 = n3(109), f2 = n3(63), p2 = n3(9), h = n3(72).fastKey, d2 = n3(73), m = p2 ? "_s" : "size", g = function(e4, t4) {
        var n4, r4 = h(t4);
        if ("F" !== r4)
          return e4._i[r4];
        for (n4 = e4._f; n4; n4 = n4.n)
          if (n4.k == t4)
            return n4;
      };
      e3.exports = { getConstructor: function(e4, t4, n4, u3) {
        var l3 = e4(function(e5, r4) {
          a2(e5, l3, t4, "_i"), e5._t = t4, e5._i = o3(null), e5._f = void 0, e5._l = void 0, e5[m] = 0, null != r4 && c2(r4, n4, e5[u3], e5);
        });
        return i2(l3.prototype, { clear: function() {
          for (var e5 = d2(this, t4), n5 = e5._i, r4 = e5._f; r4; r4 = r4.n)
            r4.r = true, r4.p && (r4.p = r4.p.n = void 0), delete n5[r4.i];
          e5._f = e5._l = void 0, e5[m] = 0;
        }, delete: function(e5) {
          var n5 = d2(this, t4), r4 = g(n5, e5);
          if (r4) {
            var o4 = r4.n, i3 = r4.p;
            delete n5._i[r4.i], r4.r = true, i3 && (i3.n = o4), o4 && (o4.p = i3), n5._f == r4 && (n5._f = o4), n5._l == r4 && (n5._l = i3), n5[m]--;
          }
          return !!r4;
        }, forEach: function(e5) {
          d2(this, t4);
          for (var n5, r4 = s2(e5, arguments.length > 1 ? arguments[1] : void 0, 3); n5 = n5 ? n5.n : this._f; )
            for (r4(n5.v, n5.k, this); n5 && n5.r; )
              n5 = n5.p;
        }, has: function(e5) {
          return !!g(d2(this, t4), e5);
        } }), p2 && r3(l3.prototype, "size", { get: function() {
          return d2(this, t4)[m];
        } }), l3;
      }, def: function(e4, t4, n4) {
        var r4, o4, i3 = g(e4, t4);
        return i3 ? i3.v = n4 : (e4._l = i3 = { i: o4 = h(t4, true), k: t4, v: n4, p: r4 = e4._l, n: void 0, r: false }, e4._f || (e4._f = i3), r4 && (r4.n = i3), e4[m]++, "F" !== o4 && (e4._i[o4] = i3)), e4;
      }, getEntry: g, setStrong: function(e4, t4, n4) {
        u2(e4, t4, function(e5, n5) {
          this._t = d2(e5, t4), this._k = n5, this._l = void 0;
        }, function() {
          for (var e5 = this._k, t5 = this._l; t5 && t5.r; )
            t5 = t5.p;
          return this._t && (this._l = t5 = t5 ? t5.n : this._t._f) ? l2(0, "keys" == e5 ? t5.k : "values" == e5 ? t5.v : [t5.k, t5.v]) : (this._t = void 0, l2(1));
        }, n4 ? "entries" : "values", !n4, true), f2(t4);
      } };
    }, function(e3, t3, n3) {
      var r3 = n3(11), o3 = n3(7), i2 = n3(42);
      e3.exports = n3(9) ? Object.defineProperties : function(e4, t4) {
        o3(e4);
        for (var n4, s2 = i2(t4), a2 = s2.length, c2 = 0; a2 > c2; )
          r3.f(e4, n4 = s2[c2++], t4[n4]);
        return e4;
      };
    }, function(e3, t3, n3) {
      "use strict";
      var r3 = n3(36), o3 = n3(8), i2 = n3(14), s2 = n3(13), a2 = n3(39), c2 = n3(107), u2 = n3(26), l2 = n3(108), f2 = n3(3)("iterator"), p2 = !([].keys && "next" in [].keys()), h = function() {
        return this;
      };
      e3.exports = function(e4, t4, n4, d2, m, g, v) {
        c2(n4, t4, d2);
        var y, b, w, x = function(e5) {
          if (!p2 && e5 in j)
            return j[e5];
          switch (e5) {
            case "keys":
            case "values":
              return function() {
                return new n4(this, e5);
              };
          }
          return function() {
            return new n4(this, e5);
          };
        }, S = t4 + " Iterator", P = "values" == m, O = false, j = e4.prototype, E2 = j[f2] || j["@@iterator"] || m && j[m], I = E2 || x(m), _ = m ? P ? x("entries") : I : void 0, A2 = "Array" == t4 && j.entries || E2;
        if (A2 && (w = l2(A2.call(new e4()))) !== Object.prototype && w.next && (u2(w, S, true), r3 || "function" == typeof w[f2] || s2(w, f2, h)), P && E2 && "values" !== E2.name && (O = true, I = function() {
          return E2.call(this);
        }), r3 && !v || !p2 && !O && j[f2] || s2(j, f2, I), a2[t4] = I, a2[S] = h, m)
          if (y = { values: P ? I : x("values"), keys: g ? I : x("keys"), entries: _ }, v)
            for (b in y)
              b in j || i2(j, b, y[b]);
          else
            o3(o3.P + o3.F * (p2 || O), t4, y);
        return y;
      };
    }, function(e3, t3, n3) {
      "use strict";
      var r3 = n3(71), o3 = n3(23), i2 = n3(26), s2 = {};
      n3(13)(s2, n3(3)("iterator"), function() {
        return this;
      }), e3.exports = function(e4, t4, n4) {
        e4.prototype = r3(s2, { next: o3(1, n4) }), i2(e4, t4 + " Iterator");
      };
    }, function(e3, t3, n3) {
      var r3 = n3(15), o3 = n3(29), i2 = n3(43)("IE_PROTO"), s2 = Object.prototype;
      e3.exports = Object.getPrototypeOf || function(e4) {
        return e4 = o3(e4), r3(e4, i2) ? e4[i2] : "function" == typeof e4.constructor && e4 instanceof e4.constructor ? e4.constructor.prototype : e4 instanceof Object ? s2 : null;
      };
    }, function(e3, t3) {
      e3.exports = function(e4, t4) {
        return { value: t4, done: !!e4 };
      };
    }, function(e3, t3, n3) {
      "use strict";
      var r3 = n3(4), o3 = n3(8), i2 = n3(14), s2 = n3(40), a2 = n3(72), c2 = n3(38), u2 = n3(37), l2 = n3(6), f2 = n3(10), p2 = n3(41), h = n3(26), d2 = n3(111);
      e3.exports = function(e4, t4, n4, m, g, v) {
        var y = r3[e4], b = y, w = g ? "set" : "add", x = b && b.prototype, S = {}, P = function(e5) {
          var t5 = x[e5];
          i2(x, e5, "delete" == e5 ? function(e6) {
            return !(v && !l2(e6)) && t5.call(this, 0 === e6 ? 0 : e6);
          } : "has" == e5 ? function(e6) {
            return !(v && !l2(e6)) && t5.call(this, 0 === e6 ? 0 : e6);
          } : "get" == e5 ? function(e6) {
            return v && !l2(e6) ? void 0 : t5.call(this, 0 === e6 ? 0 : e6);
          } : "add" == e5 ? function(e6) {
            return t5.call(this, 0 === e6 ? 0 : e6), this;
          } : function(e6, n5) {
            return t5.call(this, 0 === e6 ? 0 : e6, n5), this;
          });
        };
        if ("function" == typeof b && (v || x.forEach && !f2(function() {
          new b().entries().next();
        }))) {
          var O = new b(), j = O[w](v ? {} : -0, 1) != O, E2 = f2(function() {
            O.has(1);
          }), I = p2(function(e5) {
            new b(e5);
          }), _ = !v && f2(function() {
            for (var e5 = new b(), t5 = 5; t5--; )
              e5[w](t5, t5);
            return !e5.has(-0);
          });
          I || ((b = t4(function(t5, n5) {
            u2(t5, b, e4);
            var r4 = d2(new y(), t5, b);
            return null != n5 && c2(n5, g, r4[w], r4), r4;
          })).prototype = x, x.constructor = b), (E2 || _) && (P("delete"), P("has"), g && P("get")), (_ || j) && P(w), v && x.clear && delete x.clear;
        } else
          b = m.getConstructor(t4, e4, g, w), s2(b.prototype, n4), a2.NEED = true;
        return h(b, e4), S[e4] = b, o3(o3.G + o3.W + o3.F * (b != y), S), v || m.setStrong(b, e4, g), b;
      };
    }, function(e3, t3, n3) {
      var r3 = n3(6), o3 = n3(112).set;
      e3.exports = function(e4, t4, n4) {
        var i2, s2 = t4.constructor;
        return s2 !== n4 && "function" == typeof s2 && (i2 = s2.prototype) !== n4.prototype && r3(i2) && o3 && o3(e4, i2), e4;
      };
    }, function(e3, t3, n3) {
      var r3 = n3(6), o3 = n3(7), i2 = function(e4, t4) {
        if (o3(e4), !r3(t4) && null !== t4)
          throw TypeError(t4 + ": can't set as prototype!");
      };
      e3.exports = { set: Object.setPrototypeOf || ("__proto__" in {} ? function(e4, t4, r4) {
        try {
          (r4 = n3(12)(Function.call, n3(113).f(Object.prototype, "__proto__").set, 2))(e4, []), t4 = !(e4 instanceof Array);
        } catch (e5) {
          t4 = true;
        }
        return function(e5, n4) {
          return i2(e5, n4), t4 ? e5.__proto__ = n4 : r4(e5, n4), e5;
        };
      }({}, false) : void 0), check: i2 };
    }, function(e3, t3, n3) {
      var r3 = n3(44), o3 = n3(23), i2 = n3(25), s2 = n3(51), a2 = n3(15), c2 = n3(50), u2 = Object.getOwnPropertyDescriptor;
      t3.f = n3(9) ? u2 : function(e4, t4) {
        if (e4 = i2(e4), t4 = s2(t4, true), c2)
          try {
            return u2(e4, t4);
          } catch (e5) {
          }
        if (a2(e4, t4))
          return o3(!r3.f.call(e4, t4), e4[t4]);
      };
    }, function(e3, t3, n3) {
      "use strict";
      var r3 = n3(12), o3 = n3(8), i2 = n3(29), s2 = n3(57), a2 = n3(58), c2 = n3(35), u2 = n3(115), l2 = n3(59);
      o3(o3.S + o3.F * !n3(41)(function(e4) {
        Array.from(e4);
      }), "Array", { from: function(e4) {
        var t4, n4, o4, f2, p2 = i2(e4), h = "function" == typeof this ? this : Array, d2 = arguments.length, m = d2 > 1 ? arguments[1] : void 0, g = void 0 !== m, v = 0, y = l2(p2);
        if (g && (m = r3(m, d2 > 2 ? arguments[2] : void 0, 2)), null == y || h == Array && a2(y))
          for (n4 = new h(t4 = c2(p2.length)); t4 > v; v++)
            u2(n4, v, g ? m(p2[v], v) : p2[v]);
        else
          for (f2 = y.call(p2), n4 = new h(); !(o4 = f2.next()).done; v++)
            u2(n4, v, g ? s2(f2, m, [o4.value, v], true) : o4.value);
        return n4.length = v, n4;
      } });
    }, function(e3, t3, n3) {
      "use strict";
      var r3 = n3(11), o3 = n3(23);
      e3.exports = function(e4, t4, n4) {
        t4 in e4 ? r3.f(e4, t4, o3(0, n4)) : e4[t4] = n4;
      };
    }, function(e3, t3, n3) {
      "use strict";
      n3(117);
      var r3 = n3(7), o3 = n3(75), i2 = n3(9), s2 = /./.toString, a2 = function(e4) {
        n3(14)(RegExp.prototype, "toString", e4, true);
      };
      n3(10)(function() {
        return "/a/b" != s2.call({ source: "a", flags: "b" });
      }) ? a2(function() {
        var e4 = r3(this);
        return "/".concat(e4.source, "/", "flags" in e4 ? e4.flags : !i2 && e4 instanceof RegExp ? o3.call(e4) : void 0);
      }) : "toString" != s2.name && a2(function() {
        return s2.call(this);
      });
    }, function(e3, t3, n3) {
      n3(9) && "g" != /./g.flags && n3(11).f(RegExp.prototype, "flags", { configurable: true, get: n3(75) });
    }, function(e3, t3, n3) {
      var r3;
      n3(5);
      function o3(e4, t4, n4) {
        if ("function" == typeof t4 && (n4 = t4, t4 = {}), !n4) {
          if ("function" != typeof Promise)
            throw new TypeError("callback not provided");
          return new Promise(function(n5, r4) {
            o3(e4, t4 || {}, function(e5, t5) {
              e5 ? r4(e5) : n5(t5);
            });
          });
        }
        r3(e4, t4 || {}, function(e5, r4) {
          e5 && ("EACCES" === e5.code || t4 && t4.ignoreErrors) && (e5 = null, r4 = false), n4(e5, r4);
        });
      }
      r3 = "win32" === process.platform || global.TESTING_WINDOWS ? n3(119) : n3(120), e3.exports = o3, o3.sync = function(e4, t4) {
        try {
          return r3.sync(e4, t4 || {});
        } catch (e5) {
          if (t4 && t4.ignoreErrors || "EACCES" === e5.code)
            return false;
          throw e5;
        }
      };
    }, function(e3, t3, n3) {
      e3.exports = i2, i2.sync = function(e4, t4) {
        return o3(r3.statSync(e4), e4, t4);
      };
      var r3 = n3(5);
      function o3(e4, t4, n4) {
        return !(!e4.isSymbolicLink() && !e4.isFile()) && function(e5, t5) {
          var n5 = void 0 !== t5.pathExt ? t5.pathExt : process.env.PATHEXT;
          if (!n5)
            return true;
          if (-1 !== (n5 = n5.split(";")).indexOf(""))
            return true;
          for (var r4 = 0; r4 < n5.length; r4++) {
            var o4 = n5[r4].toLowerCase();
            if (o4 && e5.substr(-o4.length).toLowerCase() === o4)
              return true;
          }
          return false;
        }(t4, n4);
      }
      function i2(e4, t4, n4) {
        r3.stat(e4, function(r4, i3) {
          n4(r4, !r4 && o3(i3, e4, t4));
        });
      }
    }, function(e3, t3, n3) {
      e3.exports = o3, o3.sync = function(e4, t4) {
        return i2(r3.statSync(e4), t4);
      };
      var r3 = n3(5);
      function o3(e4, t4, n4) {
        r3.stat(e4, function(e5, r4) {
          n4(e5, !e5 && i2(r4, t4));
        });
      }
      function i2(e4, t4) {
        return e4.isFile() && function(e5, t5) {
          var n4 = e5.mode, r4 = e5.uid, o4 = e5.gid, i3 = void 0 !== t5.uid ? t5.uid : process.getuid && process.getuid(), s2 = void 0 !== t5.gid ? t5.gid : process.getgid && process.getgid(), a2 = parseInt("100", 8), c2 = parseInt("010", 8), u2 = parseInt("001", 8), l2 = a2 | c2;
          return n4 & u2 || n4 & c2 && o4 === s2 || n4 & a2 && r4 === i3 || n4 & l2 && 0 === i3;
        }(e4, t4);
      }
    }, function(e3, t3, n3) {
      "use strict";
      e3.exports = { androidSystemImages: /system-images;([\S \t]+)/g, androidAPILevels: /platforms;android-(\d+)[\S\s]/g, androidBuildTools: /build-tools;([\d|.]+)[\S\s]/g };
    }, function(e3, t3, n3) {
      "use strict";
      n3(2);
      var r3 = n3(1);
      e3.exports = { getNodeInfo: function() {
        return r3.log("trace", "getNodeInfo"), Promise.all([r3.isWindows ? r3.run("node -v").then(r3.findVersion) : r3.which("node").then(function(e4) {
          return e4 ? r3.run(e4 + " -v") : Promise.resolve("");
        }).then(r3.findVersion), r3.which("node").then(r3.condensePath)]).then(function(e4) {
          return r3.determineFound("Node", e4[0], e4[1]);
        });
      }, getnpmInfo: function() {
        return r3.log("trace", "getnpmInfo"), Promise.all([r3.run("npm -v"), r3.which("npm").then(r3.condensePath)]).then(function(e4) {
          return r3.determineFound("npm", e4[0], e4[1]);
        });
      }, getWatchmanInfo: function() {
        return r3.log("trace", "getWatchmanInfo"), Promise.all([r3.which("watchman").then(function(e4) {
          return e4 ? r3.run(e4 + " -v") : void 0;
        }), r3.which("watchman")]).then(function(e4) {
          return r3.determineFound("Watchman", e4[0], e4[1]);
        });
      }, getYarnInfo: function() {
        return r3.log("trace", "getYarnInfo"), Promise.all([r3.run("yarn -v"), r3.which("yarn").then(r3.condensePath)]).then(function(e4) {
          return r3.determineFound("Yarn", e4[0], e4[1]);
        });
      } };
    }, function(e3, t3, n3) {
      "use strict";
      n3(16), n3(2), n3(27);
      var r3 = n3(5), o3 = n3(17), i2 = n3(1), s2 = n3(0);
      e3.exports = { getBraveBrowserInfo: function() {
        return i2.log("trace", "getBraveBrowser"), (i2.isLinux ? i2.run("brave --version || brave-browser --version").then(function(e4) {
          return e4.replace(/^.* ([^ ]*)/g, "$1");
        }) : i2.isMacOS ? i2.getDarwinApplicationVersion(i2.browserBundleIdentifiers["Brave Browser"]).then(i2.findVersion) : Promise.resolve("N/A")).then(function(e4) {
          return i2.determineFound("Brave Browser", e4, "N/A");
        });
      }, getChromeInfo: function() {
        var e4;
        if (i2.log("trace", "getChromeInfo"), i2.isLinux)
          e4 = i2.run("google-chrome --version").then(function(e5) {
            return e5.replace(" dev", "").replace(/^.* ([^ ]*)/g, "$1");
          });
        else if (i2.isMacOS)
          e4 = i2.getDarwinApplicationVersion(i2.browserBundleIdentifiers.Chrome).then(i2.findVersion);
        else if (i2.isWindows) {
          var t4;
          try {
            t4 = i2.findVersion(r3.readdirSync(s2.join(process.env["ProgramFiles(x86)"], "Google/Chrome/Application")).join("\n"));
          } catch (e5) {
            t4 = i2.NotFound;
          }
          e4 = Promise.resolve(t4);
        } else
          e4 = Promise.resolve("N/A");
        return e4.then(function(e5) {
          return i2.determineFound("Chrome", e5, "N/A");
        });
      }, getChromeCanaryInfo: function() {
        return i2.log("trace", "getChromeCanaryInfo"), i2.getDarwinApplicationVersion(i2.browserBundleIdentifiers["Chrome Canary"]).then(function(e4) {
          return i2.determineFound("Chrome Canary", e4, "N/A");
        });
      }, getChromiumInfo: function() {
        return i2.log("trace", "getChromiumInfo"), (i2.isLinux ? i2.run("chromium --version").then(i2.findVersion) : Promise.resolve("N/A")).then(function(e4) {
          return i2.determineFound("Chromium", e4, "N/A");
        });
      }, getEdgeInfo: function() {
        var e4;
        if (i2.log("trace", "getEdgeInfo"), i2.isWindows && "10" === o3.release().split(".")[0]) {
          var t4 = { Spartan: "Microsoft.MicrosoftEdge", Chromium: "Microsoft.MicrosoftEdge.Stable", ChromiumDev: "Microsoft.MicrosoftEdge.Dev" };
          e4 = Promise.all(Object.keys(t4).map(function(e5) {
            return function(e6, t5) {
              return i2.run(`powershell get-appxpackage ${e6}`).then(function(e7) {
                if ("" !== i2.findVersion(e7))
                  return `${t5} (${i2.findVersion(e7)})`;
              });
            }(t4[e5], e5);
          }).filter(function(e5) {
            return void 0 !== e5;
          }));
        } else {
          if (!i2.isMacOS)
            return Promise.resolve("N/A");
          e4 = i2.getDarwinApplicationVersion(i2.browserBundleIdentifiers["Microsoft Edge"]);
        }
        return e4.then(function(e5) {
          return i2.determineFound("Edge", Array.isArray(e5) ? e5.filter(function(e6) {
            return void 0 !== e6;
          }) : e5, i2.NA);
        });
      }, getFirefoxInfo: function() {
        return i2.log("trace", "getFirefoxInfo"), (i2.isLinux ? i2.run("firefox --version").then(function(e4) {
          return e4.replace(/^.* ([^ ]*)/g, "$1");
        }) : i2.isMacOS ? i2.getDarwinApplicationVersion(i2.browserBundleIdentifiers.Firefox) : Promise.resolve("N/A")).then(function(e4) {
          return i2.determineFound("Firefox", e4, "N/A");
        });
      }, getFirefoxDeveloperEditionInfo: function() {
        return i2.log("trace", "getFirefoxDeveloperEditionInfo"), i2.getDarwinApplicationVersion(i2.browserBundleIdentifiers["Firefox Developer Edition"]).then(function(e4) {
          return i2.determineFound("Firefox Developer Edition", e4, "N/A");
        });
      }, getFirefoxNightlyInfo: function() {
        return i2.log("trace", "getFirefoxNightlyInfo"), (i2.isLinux ? i2.run("firefox-trunk --version").then(function(e4) {
          return e4.replace(/^.* ([^ ]*)/g, "$1");
        }) : i2.isMacOS ? i2.getDarwinApplicationVersion(i2.browserBundleIdentifiers["Firefox Nightly"]) : Promise.resolve("N/A")).then(function(e4) {
          return i2.determineFound("Firefox Nightly", e4, "N/A");
        });
      }, getInternetExplorerInfo: function() {
        var e4;
        if (i2.log("trace", "getInternetExplorerInfo"), i2.isWindows) {
          var t4 = [process.env.SYSTEMDRIVE || "C:", "Program Files", "Internet Explorer", "iexplore.exe"].join("\\\\");
          e4 = i2.run(`wmic datafile where "name='${t4}'" get Version`).then(i2.findVersion);
        } else
          e4 = Promise.resolve("N/A");
        return e4.then(function(e5) {
          return i2.determineFound("Internet Explorer", e5, "N/A");
        });
      }, getSafariTechnologyPreviewInfo: function() {
        return i2.log("trace", "getSafariTechnologyPreviewInfo"), i2.getDarwinApplicationVersion(i2.browserBundleIdentifiers["Safari Technology Preview"]).then(function(e4) {
          return i2.determineFound("Safari Technology Preview", e4, "N/A");
        });
      }, getSafariInfo: function() {
        return i2.log("trace", "getSafariInfo"), i2.getDarwinApplicationVersion(i2.browserBundleIdentifiers.Safari).then(function(e4) {
          return i2.determineFound("Safari", e4, "N/A");
        });
      } };
    }, function(e3, t3, n3) {
      "use strict";
      n3(32), n3(2);
      var r3 = n3(1);
      e3.exports = { getMongoDBInfo: function() {
        return r3.log("trace", "getMongoDBInfo"), Promise.all([r3.run("mongo --version").then(r3.findVersion), r3.which("mongo")]).then(function(e4) {
          return r3.determineFound("MongoDB", e4[0], e4[1]);
        });
      }, getMySQLInfo: function() {
        return r3.log("trace", "getMySQLInfo"), Promise.all([r3.run("mysql --version").then(function(e4) {
          return `${r3.findVersion(e4, null, 1)}${e4.includes("MariaDB") ? " (MariaDB)" : ""}`;
        }), r3.which("mysql")]).then(function(e4) {
          return r3.determineFound("MySQL", e4[0], e4[1]);
        });
      }, getPostgreSQLInfo: function() {
        return r3.log("trace", "getPostgreSQLInfo"), Promise.all([r3.run("postgres --version").then(r3.findVersion), r3.which("postgres")]).then(function(e4) {
          return r3.determineFound("PostgreSQL", e4[0], e4[1]);
        });
      }, getSQLiteInfo: function() {
        return r3.log("trace", "getSQLiteInfo"), Promise.all([r3.run("sqlite3 --version").then(r3.findVersion), r3.which("sqlite3")]).then(function(e4) {
          return r3.determineFound("SQLite", e4[0], e4[1]);
        });
      } };
    }, function(e3, t3, n3) {
      "use strict";
      n3(27), n3(16), n3(2);
      var r3 = n3(0), o3 = n3(1);
      e3.exports = { getAndroidStudioInfo: function() {
        var e4 = Promise.resolve("N/A");
        return o3.isMacOS ? e4 = o3.run(o3.generatePlistBuddyCommand(r3.join("/", "Applications", "Android\\ Studio.app", "Contents", "Info.plist"), ["CFBundleShortVersionString", "CFBundleVersion"])).then(function(e5) {
          return e5 || o3.run(o3.generatePlistBuddyCommand(r3.join("~", "Applications", "JetBrains\\ Toolbox", "Android\\ Studio.app", "Contents", "Info.plist"), ["CFBundleShortVersionString", "CFBundleVersion"]));
        }).then(function(e5) {
          return e5.split("\n").join(" ");
        }) : o3.isLinux ? e4 = Promise.all([o3.run('cat /opt/android-studio/bin/studio.sh | grep "$Home/.AndroidStudio" | head -1').then(o3.findVersion), o3.run("cat /opt/android-studio/build.txt")]).then(function(e5) {
          return `${e5[0]} ${e5[1]}`.trim() || o3.NotFound;
        }) : o3.isWindows && (e4 = Promise.all([o3.run('wmic datafile where name="C:\\\\Program Files\\\\Android\\\\Android Studio\\\\bin\\\\studio.exe" get Version').then(function(e5) {
          return e5.replace(/(\r\n|\n|\r)/gm, "");
        }), o3.run('type "C:\\\\Program Files\\\\Android\\\\Android Studio\\\\build.txt"').then(function(e5) {
          return e5.replace(/(\r\n|\n|\r)/gm, "");
        })]).then(function(e5) {
          return `${e5[0]} ${e5[1]}`.trim() || o3.NotFound;
        })), e4.then(function(e5) {
          return o3.determineFound("Android Studio", e5);
        });
      }, getAtomInfo: function() {
        return o3.log("trace", "getAtomInfo"), Promise.all([o3.getDarwinApplicationVersion(o3.ideBundleIdentifiers.Atom), "N/A"]).then(function(e4) {
          return o3.determineFound("Atom", e4[0], e4[1]);
        });
      }, getEmacsInfo: function() {
        return o3.log("trace", "getEmacsInfo"), o3.isMacOS || o3.isLinux ? Promise.all([o3.run("emacs --version").then(o3.findVersion), o3.run("which emacs")]).then(function(e4) {
          return o3.determineFound("Emacs", e4[0], e4[1]);
        }) : Promise.resolve(["Emacs", "N/A"]);
      }, getIntelliJInfo: function() {
        return o3.log("trace", "getIntelliJInfo"), o3.getDarwinApplicationVersion(o3.ideBundleIdentifiers.IntelliJ).then(function(e4) {
          return o3.determineFound("IntelliJ", e4);
        });
      }, getNanoInfo: function() {
        return o3.log("trace", "getNanoInfo"), o3.isMacOS || o3.isLinux ? Promise.all([o3.run("nano --version").then(o3.findVersion), o3.run("which nano")]).then(function(e4) {
          return o3.determineFound("Nano", e4[0], e4[1]);
        }) : Promise.resolve(["Nano", "N/A"]);
      }, getNvimInfo: function() {
        return o3.log("trace", "getNvimInfo"), o3.isMacOS || o3.isLinux ? Promise.all([o3.run("nvim --version").then(o3.findVersion), o3.run("which nvim")]).then(function(e4) {
          return o3.determineFound("Nvim", e4[0], e4[1]);
        }) : Promise.resolve(["Vim", "N/A"]);
      }, getPhpStormInfo: function() {
        return o3.log("trace", "getPhpStormInfo"), o3.getDarwinApplicationVersion(o3.ideBundleIdentifiers.PhpStorm).then(function(e4) {
          return o3.determineFound("PhpStorm", e4);
        });
      }, getSublimeTextInfo: function() {
        return o3.log("trace", "getSublimeTextInfo"), Promise.all([o3.run("subl --version").then(function(e4) {
          return o3.findVersion(e4, /\d+/);
        }), o3.which("subl")]).then(function(e4) {
          return "" === e4[0] && o3.isMacOS ? (o3.log("trace", "getSublimeTextInfo using plist"), Promise.all([o3.getDarwinApplicationVersion(o3.ideBundleIdentifiers["Sublime Text"]), "N/A"])) : e4;
        }).then(function(e4) {
          return o3.determineFound("Sublime Text", e4[0], e4[1]);
        });
      }, getVimInfo: function() {
        return o3.log("trace", "getVimInfo"), o3.isMacOS || o3.isLinux ? Promise.all([o3.run("vim --version").then(o3.findVersion), o3.run("which vim")]).then(function(e4) {
          return o3.determineFound("Vim", e4[0], e4[1]);
        }) : Promise.resolve(["Vim", "N/A"]);
      }, getVSCodeInfo: function() {
        return o3.log("trace", "getVSCodeInfo"), Promise.all([o3.run("code --version").then(o3.findVersion), o3.which("code")]).then(function(e4) {
          return o3.determineFound("VSCode", e4[0], e4[1]);
        });
      }, getVisualStudioInfo: function() {
        return o3.log("trace", "getVisualStudioInfo"), o3.isWindows ? o3.run(`"${process.env["ProgramFiles(x86)"]}/Microsoft Visual Studio/Installer/vswhere.exe" -format json -prerelease`).then(function(e4) {
          var t4 = JSON.parse(e4).map(function(e5) {
            return { Version: e5.installationVersion, DisplayName: e5.displayName };
          });
          return o3.determineFound("Visual Studio", t4.map(function(e5) {
            return `${e5.Version} (${e5.DisplayName})`;
          }));
        }).catch(function() {
          return Promise.resolve(["Visual Studio", o3.NotFound]);
        }) : Promise.resolve(["Visual Studio", o3.NA]);
      }, getWebStormInfo: function() {
        return o3.log("trace", "getWebStormInfo"), o3.getDarwinApplicationVersion(o3.ideBundleIdentifiers.WebStorm).then(function(e4) {
          return o3.determineFound("WebStorm", e4);
        });
      }, getXcodeInfo: function() {
        return o3.log("trace", "getXcodeInfo"), o3.isMacOS ? Promise.all([o3.which("xcodebuild").then(function(e4) {
          return o3.run(e4 + " -version");
        }).then(function(e4) {
          return `${o3.findVersion(e4)}/${e4.split("Build version ")[1]}`;
        }), o3.which("xcodebuild")]).then(function(e4) {
          return o3.determineFound("Xcode", e4[0], e4[1]);
        }) : Promise.resolve(["Xcode", "N/A"]);
      } };
    }, function(e3, t3, n3) {
      "use strict";
      n3(2);
      var r3 = n3(1);
      e3.exports = { getBashInfo: function() {
        return r3.log("trace", "getBashInfo"), Promise.all([r3.run("bash --version").then(r3.findVersion), r3.which("bash")]).then(function(e4) {
          return r3.determineFound("Bash", e4[0], e4[1]);
        });
      }, getElixirInfo: function() {
        return r3.log("trace", "getElixirInfo"), Promise.all([r3.run("elixir --version").then(function(e4) {
          return r3.findVersion(e4, /[Elixir]+\s([\d+.[\d+|.]+)/, 1);
        }), r3.which("elixir")]).then(function(e4) {
          return Promise.resolve(r3.determineFound("Elixir", e4[0], e4[1]));
        });
      }, getErlangInfo: function() {
        return r3.log("trace", "getErlangInfo"), Promise.all([r3.run(`erl -eval "{ok, Version} = file:read_file(filename:join([code:root_dir(), 'releases', erlang:system_info(otp_release), 'OTP_VERSION'])), io:fwrite(Version), halt()." -noshell`).then(r3.findVersion), r3.which("erl")]).then(function(e4) {
          return Promise.resolve(r3.determineFound("Erlang", e4[0], e4[1]));
        });
      }, getGoInfo: function() {
        return r3.log("trace", "getGoInfo"), Promise.all([r3.run("go version").then(r3.findVersion), r3.which("go")]).then(function(e4) {
          return r3.determineFound("Go", e4[0], e4[1]);
        });
      }, getJavaInfo: function() {
        return r3.log("trace", "getJavaInfo"), Promise.all([r3.run("javac -version", { unify: true }).then(function(e4) {
          return r3.findVersion(e4, /\d+\.[\w+|.|_|-]+/);
        }), r3.run("which javac")]).then(function(e4) {
          return r3.determineFound("Java", e4[0], e4[1]);
        });
      }, getPerlInfo: function() {
        return r3.log("trace", "getPerlInfo"), Promise.all([r3.run("perl -v").then(r3.findVersion), r3.which("perl")]).then(function(e4) {
          return r3.determineFound("Perl", e4[0], e4[1]);
        });
      }, getPHPInfo: function() {
        return r3.log("trace", "getPHPInfo"), Promise.all([r3.run("php -v").then(r3.findVersion), r3.which("php")]).then(function(e4) {
          return r3.determineFound("PHP", e4[0], e4[1]);
        });
      }, getProtocInfo: function() {
        return r3.log("trace", "getProtocInfo"), Promise.all([r3.run("protoc --version").then(r3.findVersion), r3.run("which protoc")]).then(function(e4) {
          return r3.determineFound("Protoc", e4[0], e4[1]);
        });
      }, getPythonInfo: function() {
        return r3.log("trace", "getPythonInfo"), Promise.all([r3.run("python -V 2>&1").then(r3.findVersion), r3.run("which python")]).then(function(e4) {
          return r3.determineFound("Python", e4[0], e4[1]);
        });
      }, getPython3Info: function() {
        return r3.log("trace", "getPython3Info"), Promise.all([r3.run("python3 -V 2>&1").then(r3.findVersion), r3.run("which python3")]).then(function(e4) {
          return r3.determineFound("Python3", e4[0], e4[1]);
        });
      }, getRInfo: function() {
        return r3.log("trace", "getRInfo"), Promise.all([r3.run("R --version", { unify: true }).then(r3.findVersion), r3.which("R")]).then(function(e4) {
          return r3.determineFound("R", e4[0], e4[1]);
        });
      }, getRubyInfo: function() {
        return r3.log("trace", "getRubyInfo"), Promise.all([r3.run("ruby -v").then(r3.findVersion), r3.which("ruby")]).then(function(e4) {
          return r3.determineFound("Ruby", e4[0], e4[1]);
        });
      }, getRustInfo: function() {
        return r3.log("trace", "getRustInfo"), Promise.all([r3.run("rustc --version").then(r3.findVersion), r3.run("which rustc")]).then(function(e4) {
          return r3.determineFound("Rust", e4[0], e4[1]);
        });
      }, getScalaInfo: function() {
        return r3.log("trace", "getScalaInfo"), r3.isMacOS || r3.isLinux ? Promise.all([r3.run("scalac -version").then(r3.findVersion), r3.run("which scalac")]).then(function(e4) {
          return r3.determineFound("Scala", e4[0], e4[1]);
        }) : Promise.resolve(["Scala", "N/A"]);
      } };
    }, function(e3, t3, n3) {
      "use strict";
      n3(2);
      var r3 = n3(1);
      e3.exports = { getAptInfo: function() {
        return r3.log("trace", "getAptInfo"), r3.isLinux ? Promise.all([r3.run("apt --version").then(r3.findVersion), r3.which("apt")]).then(function(e4) {
          return r3.determineFound("Apt", e4[0], e4[1]);
        }) : Promise.all(["Apt", "N/A"]);
      }, getCargoInfo: function() {
        return r3.log("trace", "getCargoInfo"), Promise.all([r3.run("cargo --version").then(r3.findVersion), r3.which("cargo").then(r3.condensePath)]).then(function(e4) {
          return r3.determineFound("Cargo", e4[0], e4[1]);
        });
      }, getCocoaPodsInfo: function() {
        return r3.log("trace", "getCocoaPodsInfo"), r3.isMacOS ? Promise.all([r3.run("pod --version").then(r3.findVersion), r3.which("pod")]).then(function(e4) {
          return r3.determineFound("CocoaPods", e4[0], e4[1]);
        }) : Promise.all(["CocoaPods", "N/A"]);
      }, getComposerInfo: function() {
        return r3.log("trace", "getComposerInfo"), Promise.all([r3.run("composer --version").then(r3.findVersion), r3.which("composer").then(r3.condensePath)]).then(function(e4) {
          return r3.determineFound("Composer", e4[0], e4[1]);
        });
      }, getGradleInfo: function() {
        return r3.log("trace", "getGradleInfo"), Promise.all([r3.run("gradle --version").then(r3.findVersion), r3.which("gradle").then(r3.condensePath)]).then(function(e4) {
          return r3.determineFound("Gradle", e4[0], e4[1]);
        });
      }, getHomebrewInfo: function() {
        return r3.log("trace", "getHomebrewInfo"), r3.isMacOS ? Promise.all([r3.run("brew --version").then(r3.findVersion), r3.which("brew")]).then(function(e4) {
          return r3.determineFound("Homebrew", e4[0], e4[1]);
        }) : Promise.all(["Homebrew", "N/A"]);
      }, getMavenInfo: function() {
        return r3.log("trace", "getMavenInfo"), Promise.all([r3.run("mvn --version").then(r3.findVersion), r3.which("mvn").then(r3.condensePath)]).then(function(e4) {
          return r3.determineFound("Maven", e4[0], e4[1]);
        });
      }, getpip2Info: function() {
        return r3.log("trace", "getpip2Info"), Promise.all([r3.run("pip2 --version").then(r3.findVersion), r3.which("pip2").then(r3.condensePath)]).then(function(e4) {
          return r3.determineFound("pip2", e4[0], e4[1]);
        });
      }, getpip3Info: function() {
        return r3.log("trace", "getpip3Info"), Promise.all([r3.run("pip3 --version").then(r3.findVersion), r3.which("pip3").then(r3.condensePath)]).then(function(e4) {
          return r3.determineFound("pip3", e4[0], e4[1]);
        });
      }, getRubyGemsInfo: function() {
        return r3.log("trace", "getRubyGemsInfo"), Promise.all([r3.run("gem --version").then(r3.findVersion), r3.which("gem")]).then(function(e4) {
          return r3.determineFound("RubyGems", e4[0], e4[1]);
        });
      }, getYumInfo: function() {
        return r3.log("trace", "getYumInfo"), r3.isLinux ? Promise.all([r3.run("yum --version").then(r3.findVersion), r3.which("yum")]).then(function(e4) {
          return r3.determineFound("Yum", e4[0], e4[1]);
        }) : Promise.all(["Yum", "N/A"]);
      } };
    }, function(e3, t3, n3) {
      "use strict";
      n3(2);
      var r3 = n3(1), o3 = n3(0);
      e3.exports = { getYarnWorkspacesInfo: function() {
        return r3.log("trace", "getYarnWorkspacesInfo"), Promise.all([r3.run("yarn -v"), r3.getPackageJsonByPath("package.json").then(function(e4) {
          return e4 && "workspaces" in e4;
        })]).then(function(e4) {
          var t4 = "Yarn Workspaces";
          return e4[0] && e4[1] ? Promise.resolve([t4, e4[0]]) : Promise.resolve([t4, "Not Found"]);
        });
      }, getLernaInfo: function() {
        return r3.log("trace", "getLernaInfo"), Promise.all([r3.getPackageJsonByName("lerna").then(function(e4) {
          return e4 && e4.version;
        }), r3.fileExists(o3.join(process.cwd(), "lerna.json"))]).then(function(e4) {
          return e4[0] && e4[1] ? Promise.resolve(["Lerna", e4[0]]) : Promise.resolve(["Lerna", "Not Found"]);
        });
      } };
    }, function(e3, t3, n3) {
      "use strict";
      n3(22), n3(2), n3(16);
      var r3 = n3(5), o3 = n3(0), i2 = n3(1);
      e3.exports = { getAndroidSDKInfo: function() {
        return i2.run("sdkmanager --list").then(function(e4) {
          return !e4 && process.env.ANDROID_HOME ? i2.run(`${process.env.ANDROID_HOME}/tools/bin/sdkmanager --list`) : e4;
        }).then(function(e4) {
          return !e4 && process.env.ANDROID_HOME ? i2.run(`${process.env.ANDROID_HOME}/cmdline-tools/latest/bin/sdkmanager --list`) : e4;
        }).then(function(e4) {
          return !e4 && i2.isMacOS ? i2.run("~/Library/Android/sdk/tools/bin/sdkmanager --list") : e4;
        }).then(function(e4) {
          var t4 = i2.parseSDKManagerOutput(e4), n4 = function(e5) {
            var t5, n5 = o3.join(e5, "source.properties");
            try {
              t5 = r3.readFileSync(n5, "utf8");
            } catch (e6) {
              if ("ENOENT" === e6.code)
                return;
              throw e6;
            }
            for (var i3 = t5.split("\n"), s3 = 0; s3 < i3.length; s3 += 1) {
              var a2 = i3[s3].split("=");
              if (2 === a2.length && "Pkg.Revision" === a2[0].trim())
                return a2[1].trim();
            }
          }, s2 = process.env.ANDROID_NDK ? n4(process.env.ANDROID_NDK) : process.env.ANDROID_NDK_HOME ? n4(process.env.ANDROID_NDK_HOME) : process.env.ANDROID_HOME ? n4(o3.join(process.env.ANDROID_HOME, "ndk-bundle")) : void 0;
          return t4.buildTools.length || t4.apiLevels.length || t4.systemImages.length || s2 ? Promise.resolve(["Android SDK", { "API Levels": t4.apiLevels || i2.NotFound, "Build Tools": t4.buildTools || i2.NotFound, "System Images": t4.systemImages || i2.NotFound, "Android NDK": s2 || i2.NotFound }]) : Promise.resolve(["Android SDK", i2.NotFound]);
        });
      }, getiOSSDKInfo: function() {
        return i2.isMacOS ? i2.run("xcodebuild -showsdks").then(function(e4) {
          return e4.match(/[\w]+\s[\d|.]+/g);
        }).then(i2.uniq).then(function(e4) {
          return e4.length ? ["iOS SDK", { Platforms: e4 }] : ["iOS SDK", i2.NotFound];
        }) : Promise.resolve(["iOS SDK", "N/A"]);
      }, getWindowsSDKInfo: function() {
        if (i2.log("trace", "getWindowsSDKInfo"), i2.isWindows) {
          var e4 = i2.NotFound;
          return i2.run("reg query HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppModelUnlock").then(function(t4) {
            e4 = t4.split(/[\r\n]/g).slice(1).filter(function(e5) {
              return "" !== e5;
            }).reduce(function(e5, t5) {
              var n5 = t5.match(/[^\s]+/g);
              return "0x0" !== n5[2] && "0x1" !== n5[2] || (n5[2] = "0x1" === n5[2] ? "Enabled" : "Disabled"), e5[n5[0]] = n5[2], e5;
            }, {}), 0 === Object.keys(e4).length && (e4 = i2.NotFound);
            try {
              var n4 = r3.readdirSync(`${process.env["ProgramFiles(x86)"]}/Windows Kits/10/Platforms/UAP`);
              e4.Versions = n4;
            } catch (e5) {
            }
            return Promise.resolve(["Windows SDK", e4]);
          });
        }
        return Promise.resolve(["Windows SDK", i2.NA]);
      } };
    }, function(e3, t3, n3) {
      "use strict";
      n3(2);
      var r3 = n3(1);
      e3.exports = { getApacheInfo: function() {
        return r3.log("trace", "getApacheInfo"), r3.isMacOS || r3.isLinux ? Promise.all([r3.run("apachectl -v").then(r3.findVersion), r3.run("which apachectl")]).then(function(e4) {
          return r3.determineFound("Apache", e4[0], e4[1]);
        }) : Promise.resolve(["Apache", "N/A"]);
      }, getNginxInfo: function() {
        return r3.log("trace", "getNginxInfo"), r3.isMacOS || r3.isLinux ? Promise.all([r3.run("nginx -v 2>&1").then(r3.findVersion), r3.run("which nginx")]).then(function(e4) {
          return r3.determineFound("Nginx", e4[0], e4[1]);
        }) : Promise.resolve(["Nginx", "N/A"]);
      } };
    }, function(e3, t3, n3) {
      "use strict";
      n3(22), n3(2);
      var r3 = n3(132), o3 = n3(1), i2 = n3(17);
      e3.exports = { getContainerInfo: function() {
        return o3.log("trace", "getContainerInfo"), o3.isLinux ? Promise.all([o3.fileExists("/.dockerenv"), o3.readFile("/proc/self/cgroup")]).then(function(e4) {
          return o3.log("trace", "getContainerInfoThen", e4), Promise.resolve(["Container", e4[0] || e4[1] ? "Yes" : "N/A"]);
        }).catch(function(e4) {
          return o3.log("trace", "getContainerInfoCatch", e4);
        }) : Promise.resolve(["Container", "N/A"]);
      }, getCPUInfo: function() {
        var e4;
        o3.log("trace", "getCPUInfo");
        try {
          var t4 = i2.cpus();
          e4 = "(" + t4.length + ") " + i2.arch() + " " + t4[0].model;
        } catch (t5) {
          e4 = "Unknown";
        }
        return Promise.all(["CPU", e4]);
      }, getMemoryInfo: function() {
        return o3.log("trace", "getMemoryInfo"), Promise.all(["Memory", `${o3.toReadableBytes(i2.freemem())} / ${o3.toReadableBytes(i2.totalmem())}`]);
      }, getOSInfo: function() {
        return o3.log("trace", "getOSInfo"), (o3.isMacOS ? o3.run("sw_vers -productVersion ") : o3.isLinux ? o3.run("cat /etc/os-release").then(function(e4) {
          var t4 = (e4 || "").match(/NAME="(.+)"/) || "", n4 = (e4 || "").match(/VERSION="(.+)"/) || ["", ""], r4 = null !== n4 ? n4[1] : "";
          return `${t4[1]} ${r4}`.trim() || "";
        }) : o3.isWindows ? Promise.resolve(i2.release()) : Promise.resolve()).then(function(e4) {
          var t4 = r3(i2.platform(), i2.release());
          return e4 && (t4 += ` ${e4}`), ["OS", t4];
        });
      }, getShellInfo: function() {
        if (o3.log("trace", "getShellInfo", process.env), o3.isMacOS || o3.isLinux) {
          var e4 = process.env.SHELL || o3.runSync("getent passwd $LOGNAME | cut -d: -f7 | head -1"), t4 = `${e4} --version 2>&1`;
          return e4.match("/bin/ash") && (t4 = `${e4} --help 2>&1`), Promise.all([o3.run(t4).then(o3.findVersion), o3.which(e4)]).then(function(e5) {
            return o3.determineFound("Shell", e5[0] || "Unknown", e5[1]);
          });
        }
        return Promise.resolve(["Shell", "N/A"]);
      }, getGLibcInfo: function() {
        return o3.log("trace", "getGLibc"), o3.isLinux ? Promise.all([o3.run("ldd --version").then(o3.findVersion)]).then(function(e4) {
          return o3.determineFound("GLibc", e4[0] || "Unknown");
        }) : Promise.resolve(["GLibc", "N/A"]);
      } };
    }, function(e3, t3, n3) {
      "use strict";
      const r3 = n3(17), o3 = n3(133), i2 = n3(134);
      e3.exports = (e4, t4) => {
        if (!e4 && t4)
          throw new Error("You can't specify a `release` without specifying `platform`");
        let n4;
        if ("darwin" === (e4 = e4 || r3.platform()))
          return t4 || "darwin" !== r3.platform() || (t4 = r3.release()), (t4 ? Number(t4.split(".")[0]) > 15 ? "macOS" : "OS X" : "macOS") + ((n4 = t4 ? o3(t4).name : "") ? " " + n4 : "");
        return "linux" === e4 ? (t4 || "linux" !== r3.platform() || (t4 = r3.release()), "Linux" + ((n4 = t4 ? t4.replace(/^(\d+\.\d+).*/, "$1") : "") ? " " + n4 : "")) : "win32" === e4 ? (t4 || "win32" !== r3.platform() || (t4 = r3.release()), "Windows" + ((n4 = t4 ? i2(t4) : "") ? " " + n4 : "")) : e4;
      };
    }, function(e3, t3, n3) {
      "use strict";
      const r3 = n3(17), o3 = /* @__PURE__ */ new Map([[18, "Mojave"], [17, "High Sierra"], [16, "Sierra"], [15, "El Capitan"], [14, "Yosemite"], [13, "Mavericks"], [12, "Mountain Lion"], [11, "Lion"], [10, "Snow Leopard"], [9, "Leopard"], [8, "Tiger"], [7, "Panther"], [6, "Jaguar"], [5, "Puma"]]), i2 = (e4) => (e4 = Number((e4 || r3.release()).split(".")[0]), { name: o3.get(e4), version: "10." + (e4 - 4) });
      e3.exports = i2, e3.exports.default = i2;
    }, function(e3, t3, n3) {
      "use strict";
      const r3 = n3(17), o3 = n3(135), i2 = /* @__PURE__ */ new Map([["10.0", "10"], ["6.3", "8.1"], ["6.2", "8"], ["6.1", "7"], ["6.0", "Vista"], ["5.2", "Server 2003"], ["5.1", "XP"], ["5.0", "2000"], ["4.9", "ME"], ["4.1", "98"], ["4.0", "95"]]);
      e3.exports = (e4) => {
        const t4 = /\d+\.\d/.exec(e4 || r3.release());
        if (e4 && !t4)
          throw new Error("`release` argument doesn't match `n.n`");
        const n4 = (t4 || [])[0];
        if ((!e4 || e4 === r3.release()) && ["6.1", "6.2", "6.3", "10.0"].includes(n4)) {
          const e5 = ((o3.sync("wmic", ["os", "get", "Caption"]).stdout || "").match(/2008|2012|2016/) || [])[0];
          if (e5)
            return `Server ${e5}`;
        }
        return i2.get(n4);
      };
    }, function(e3, t3, n3) {
      "use strict";
      const r3 = n3(0), o3 = n3(49), i2 = n3(136), s2 = n3(146), a2 = n3(147), c2 = n3(148), u2 = n3(149), l2 = n3(154), f2 = n3(155), p2 = n3(157), h = n3(158), d2 = 1e7;
      function m(e4, t4, n4) {
        let o4;
        return (n4 = Object.assign({ extendEnv: true, env: {} }, n4)).extendEnv && (n4.env = Object.assign({}, process.env, n4.env)), true === n4.__winShell ? (delete n4.__winShell, o4 = { command: e4, args: t4, options: n4, file: e4, original: { cmd: e4, args: t4 } }) : o4 = i2._parse(e4, t4, n4), (n4 = Object.assign({ maxBuffer: d2, buffer: true, stripEof: true, preferLocal: true, localDir: o4.options.cwd || process.cwd(), encoding: "utf8", reject: true, cleanup: true }, o4.options)).stdio = h(n4), n4.preferLocal && (n4.env = a2.env(Object.assign({}, n4, { cwd: n4.localDir }))), n4.detached && (n4.cleanup = false), "win32" === process.platform && "cmd.exe" === r3.basename(o4.command) && o4.args.unshift("/q"), { cmd: o4.command, args: o4.args, opts: n4, parsed: o4 };
      }
      function g(e4, t4) {
        return t4 && e4.stripEof && (t4 = s2(t4)), t4;
      }
      function v(e4, t4, n4) {
        let r4 = "/bin/sh", o4 = ["-c", t4];
        return n4 = Object.assign({}, n4), "win32" === process.platform && (n4.__winShell = true, r4 = process.env.comspec || "cmd.exe", o4 = ["/s", "/c", `"${t4}"`], n4.windowsVerbatimArguments = true), n4.shell && (r4 = n4.shell, delete n4.shell), e4(r4, o4, n4);
      }
      function y(e4, t4, { encoding: n4, buffer: r4, maxBuffer: o4 }) {
        if (!e4[t4])
          return null;
        let i3;
        return (i3 = r4 ? n4 ? u2(e4[t4], { encoding: n4, maxBuffer: o4 }) : u2.buffer(e4[t4], { maxBuffer: o4 }) : new Promise((n5, r5) => {
          e4[t4].once("end", n5).once("error", r5);
        })).catch((e5) => {
          throw e5.stream = t4, e5.message = `${t4} ${e5.message}`, e5;
        });
      }
      function b(e4, t4) {
        const { stdout: n4, stderr: r4 } = e4;
        let o4 = e4.error;
        const { code: i3, signal: s3 } = e4, { parsed: a3, joinedCmd: c3 } = t4, u3 = t4.timedOut || false;
        if (!o4) {
          let e5 = "";
          Array.isArray(a3.opts.stdio) ? ("inherit" !== a3.opts.stdio[2] && (e5 += e5.length > 0 ? r4 : `
${r4}`), "inherit" !== a3.opts.stdio[1] && (e5 += `
${n4}`)) : "inherit" !== a3.opts.stdio && (e5 = `
${r4}${n4}`), (o4 = new Error(`Command failed: ${c3}${e5}`)).code = i3 < 0 ? p2(i3) : i3;
        }
        return o4.stdout = n4, o4.stderr = r4, o4.failed = true, o4.signal = s3 || null, o4.cmd = c3, o4.timedOut = u3, o4;
      }
      function w(e4, t4) {
        let n4 = e4;
        return Array.isArray(t4) && t4.length > 0 && (n4 += " " + t4.join(" ")), n4;
      }
      e3.exports = (e4, t4, n4) => {
        const r4 = m(e4, t4, n4), { encoding: s3, buffer: a3, maxBuffer: u3 } = r4.opts, p3 = w(e4, t4);
        let h2, d3;
        try {
          h2 = o3.spawn(r4.cmd, r4.args, r4.opts);
        } catch (e5) {
          return Promise.reject(e5);
        }
        r4.opts.cleanup && (d3 = f2(() => {
          h2.kill();
        }));
        let v2 = null, x = false;
        const S = () => {
          v2 && (clearTimeout(v2), v2 = null), d3 && d3();
        };
        r4.opts.timeout > 0 && (v2 = setTimeout(() => {
          v2 = null, x = true, h2.kill(r4.opts.killSignal);
        }, r4.opts.timeout));
        const P = new Promise((e5) => {
          h2.on("exit", (t5, n5) => {
            S(), e5({ code: t5, signal: n5 });
          }), h2.on("error", (t5) => {
            S(), e5({ error: t5 });
          }), h2.stdin && h2.stdin.on("error", (t5) => {
            S(), e5({ error: t5 });
          });
        });
        function O() {
          h2.stdout && h2.stdout.destroy(), h2.stderr && h2.stderr.destroy();
        }
        const j = () => l2(Promise.all([P, y(h2, "stdout", { encoding: s3, buffer: a3, maxBuffer: u3 }), y(h2, "stderr", { encoding: s3, buffer: a3, maxBuffer: u3 })]).then((e5) => {
          const t5 = e5[0];
          if (t5.stdout = e5[1], t5.stderr = e5[2], t5.error || 0 !== t5.code || null !== t5.signal) {
            const e6 = b(t5, { joinedCmd: p3, parsed: r4, timedOut: x });
            if (e6.killed = e6.killed || h2.killed, !r4.opts.reject)
              return e6;
            throw e6;
          }
          return { stdout: g(r4.opts, t5.stdout), stderr: g(r4.opts, t5.stderr), code: 0, failed: false, killed: false, signal: null, cmd: p3, timedOut: false };
        }), O);
        return i2._enoent.hookChildProcess(h2, r4.parsed), function(e5, t5) {
          null != t5 && (c2(t5) ? t5.pipe(e5.stdin) : e5.stdin.end(t5));
        }(h2, r4.opts.input), h2.then = (e5, t5) => j().then(e5, t5), h2.catch = (e5) => j().catch(e5), h2;
      }, e3.exports.stdout = (...t4) => e3.exports(...t4).then((e4) => e4.stdout), e3.exports.stderr = (...t4) => e3.exports(...t4).then((e4) => e4.stderr), e3.exports.shell = (t4, n4) => v(e3.exports, t4, n4), e3.exports.sync = (e4, t4, n4) => {
        const r4 = m(e4, t4, n4), i3 = w(e4, t4);
        if (c2(r4.opts.input))
          throw new TypeError("The `input` option cannot be a stream in sync mode");
        const s3 = o3.spawnSync(r4.cmd, r4.args, r4.opts);
        if (s3.code = s3.status, s3.error || 0 !== s3.status || null !== s3.signal) {
          const e5 = b(s3, { joinedCmd: i3, parsed: r4 });
          if (!r4.opts.reject)
            return e5;
          throw e5;
        }
        return { stdout: g(r4.opts, s3.stdout), stderr: g(r4.opts, s3.stderr), code: 0, failed: false, signal: null, cmd: i3, timedOut: false };
      }, e3.exports.shellSync = (t4, n4) => v(e3.exports.sync, t4, n4);
    }, function(e3, t3, n3) {
      "use strict";
      const r3 = n3(49), o3 = n3(137), i2 = n3(145);
      function s2(e4, t4, n4) {
        const s3 = o3(e4, t4, n4), a2 = r3.spawn(s3.command, s3.args, s3.options);
        return i2.hookChildProcess(a2, s3), a2;
      }
      e3.exports = s2, e3.exports.spawn = s2, e3.exports.sync = function(e4, t4, n4) {
        const s3 = o3(e4, t4, n4), a2 = r3.spawnSync(s3.command, s3.args, s3.options);
        return a2.error = a2.error || i2.verifyENOENTSync(a2.status, s3), a2;
      }, e3.exports._parse = o3, e3.exports._enoent = i2;
    }, function(e3, t3, n3) {
      "use strict";
      const r3 = n3(0), o3 = n3(138), i2 = n3(139), s2 = n3(140), a2 = n3(141), c2 = n3(144), u2 = "win32" === process.platform, l2 = /\.(?:com|exe)$/i, f2 = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i, p2 = o3(() => c2.satisfies(process.version, "^4.8.0 || ^5.7.0 || >= 6.0.0", true)) || false;
      function h(e4) {
        if (!u2)
          return e4;
        const t4 = function(e5) {
          e5.file = i2(e5);
          const t5 = e5.file && a2(e5.file);
          return t5 ? (e5.args.unshift(e5.file), e5.command = t5, i2(e5)) : e5.file;
        }(e4), n4 = !l2.test(t4);
        if (e4.options.forceShell || n4) {
          const n5 = f2.test(t4);
          e4.command = r3.normalize(e4.command), e4.command = s2.command(e4.command), e4.args = e4.args.map((e5) => s2.argument(e5, n5));
          const o4 = [e4.command].concat(e4.args).join(" ");
          e4.args = ["/d", "/s", "/c", `"${o4}"`], e4.command = process.env.comspec || "cmd.exe", e4.options.windowsVerbatimArguments = true;
        }
        return e4;
      }
      e3.exports = function(e4, t4, n4) {
        t4 && !Array.isArray(t4) && (n4 = t4, t4 = null);
        const r4 = { command: e4, args: t4 = t4 ? t4.slice(0) : [], options: n4 = Object.assign({}, n4), file: void 0, original: { command: e4, args: t4 } };
        return n4.shell ? function(e5) {
          if (p2)
            return e5;
          const t5 = [e5.command].concat(e5.args).join(" ");
          return u2 ? (e5.command = "string" == typeof e5.options.shell ? e5.options.shell : process.env.comspec || "cmd.exe", e5.args = ["/d", "/s", "/c", `"${t5}"`], e5.options.windowsVerbatimArguments = true) : ("string" == typeof e5.options.shell ? e5.command = e5.options.shell : "android" === process.platform ? e5.command = "/system/bin/sh" : e5.command = "/bin/sh", e5.args = ["-c", t5]), e5;
        }(r4) : h(r4);
      };
    }, function(e3, t3, n3) {
      "use strict";
      e3.exports = function(e4) {
        try {
          return e4();
        } catch (e5) {
        }
      };
    }, function(e3, t3, n3) {
      "use strict";
      const r3 = n3(0), o3 = n3(76), i2 = n3(77)();
      function s2(e4, t4) {
        const n4 = process.cwd(), s3 = null != e4.options.cwd;
        if (s3)
          try {
            process.chdir(e4.options.cwd);
          } catch (e5) {
          }
        let a2;
        try {
          a2 = o3.sync(e4.command, { path: (e4.options.env || process.env)[i2], pathExt: t4 ? r3.delimiter : void 0 });
        } catch (e5) {
        } finally {
          process.chdir(n4);
        }
        return a2 && (a2 = r3.resolve(s3 ? e4.options.cwd : "", a2)), a2;
      }
      e3.exports = function(e4) {
        return s2(e4) || s2(e4, true);
      };
    }, function(e3, t3, n3) {
      "use strict";
      const r3 = /([()\][%!^"`<>&|;, *?])/g;
      e3.exports.command = function(e4) {
        return e4 = e4.replace(r3, "^$1");
      }, e3.exports.argument = function(e4, t4) {
        return e4 = (e4 = `"${e4 = (e4 = (e4 = `${e4}`).replace(/(\\*)"/g, '$1$1\\"')).replace(/(\\*)$/, "$1$1")}"`).replace(r3, "^$1"), t4 && (e4 = e4.replace(r3, "^$1")), e4;
      };
    }, function(e3, t3, n3) {
      "use strict";
      const r3 = n3(5), o3 = n3(142);
      e3.exports = function(e4) {
        let t4, n4;
        Buffer.alloc ? t4 = Buffer.alloc(150) : (t4 = new Buffer(150)).fill(0);
        try {
          n4 = r3.openSync(e4, "r"), r3.readSync(n4, t4, 0, 150, 0), r3.closeSync(n4);
        } catch (e5) {
        }
        return o3(t4.toString());
      };
    }, function(e3, t3, n3) {
      "use strict";
      var r3 = n3(143);
      e3.exports = function(e4) {
        var t4 = e4.match(r3);
        if (!t4)
          return null;
        var n4 = t4[0].replace(/#! ?/, "").split(" "), o3 = n4[0].split("/").pop(), i2 = n4[1];
        return "env" === o3 ? i2 : o3 + (i2 ? " " + i2 : "");
      };
    }, function(e3, t3, n3) {
      "use strict";
      e3.exports = /^#!.*/;
    }, function(e3, t3) {
      var n3;
      t3 = e3.exports = Y, n3 = "object" == typeof process && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? function() {
        var e4 = Array.prototype.slice.call(arguments, 0);
        e4.unshift("SEMVER"), console.log.apply(console, e4);
      } : function() {
      }, t3.SEMVER_SPEC_VERSION = "2.0.0";
      var r3 = 256, o3 = Number.MAX_SAFE_INTEGER || 9007199254740991, i2 = t3.re = [], s2 = t3.src = [], a2 = 0, c2 = a2++;
      s2[c2] = "0|[1-9]\\d*";
      var u2 = a2++;
      s2[u2] = "[0-9]+";
      var l2 = a2++;
      s2[l2] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
      var f2 = a2++;
      s2[f2] = "(" + s2[c2] + ")\\.(" + s2[c2] + ")\\.(" + s2[c2] + ")";
      var p2 = a2++;
      s2[p2] = "(" + s2[u2] + ")\\.(" + s2[u2] + ")\\.(" + s2[u2] + ")";
      var h = a2++;
      s2[h] = "(?:" + s2[c2] + "|" + s2[l2] + ")";
      var d2 = a2++;
      s2[d2] = "(?:" + s2[u2] + "|" + s2[l2] + ")";
      var m = a2++;
      s2[m] = "(?:-(" + s2[h] + "(?:\\." + s2[h] + ")*))";
      var g = a2++;
      s2[g] = "(?:-?(" + s2[d2] + "(?:\\." + s2[d2] + ")*))";
      var v = a2++;
      s2[v] = "[0-9A-Za-z-]+";
      var y = a2++;
      s2[y] = "(?:\\+(" + s2[v] + "(?:\\." + s2[v] + ")*))";
      var b = a2++, w = "v?" + s2[f2] + s2[m] + "?" + s2[y] + "?";
      s2[b] = "^" + w + "$";
      var x = "[v=\\s]*" + s2[p2] + s2[g] + "?" + s2[y] + "?", S = a2++;
      s2[S] = "^" + x + "$";
      var P = a2++;
      s2[P] = "((?:<|>)?=?)";
      var O = a2++;
      s2[O] = s2[u2] + "|x|X|\\*";
      var j = a2++;
      s2[j] = s2[c2] + "|x|X|\\*";
      var E2 = a2++;
      s2[E2] = "[v=\\s]*(" + s2[j] + ")(?:\\.(" + s2[j] + ")(?:\\.(" + s2[j] + ")(?:" + s2[m] + ")?" + s2[y] + "?)?)?";
      var I = a2++;
      s2[I] = "[v=\\s]*(" + s2[O] + ")(?:\\.(" + s2[O] + ")(?:\\.(" + s2[O] + ")(?:" + s2[g] + ")?" + s2[y] + "?)?)?";
      var _ = a2++;
      s2[_] = "^" + s2[P] + "\\s*" + s2[E2] + "$";
      var A2 = a2++;
      s2[A2] = "^" + s2[P] + "\\s*" + s2[I] + "$";
      var k = a2++;
      s2[k] = "(?:^|[^\\d])(\\d{1,16})(?:\\.(\\d{1,16}))?(?:\\.(\\d{1,16}))?(?:$|[^\\d])";
      var N = a2++;
      s2[N] = "(?:~>?)";
      var F = a2++;
      s2[F] = "(\\s*)" + s2[N] + "\\s+", i2[F] = new RegExp(s2[F], "g");
      var C2 = a2++;
      s2[C2] = "^" + s2[N] + s2[E2] + "$";
      var M = a2++;
      s2[M] = "^" + s2[N] + s2[I] + "$";
      var T = a2++;
      s2[T] = "(?:\\^)";
      var V = a2++;
      s2[V] = "(\\s*)" + s2[T] + "\\s+", i2[V] = new RegExp(s2[V], "g");
      var D = a2++;
      s2[D] = "^" + s2[T] + s2[E2] + "$";
      var B2 = a2++;
      s2[B2] = "^" + s2[T] + s2[I] + "$";
      var L = a2++;
      s2[L] = "^" + s2[P] + "\\s*(" + x + ")$|^$";
      var $ = a2++;
      s2[$] = "^" + s2[P] + "\\s*(" + w + ")$|^$";
      var R = a2++;
      s2[R] = "(\\s*)" + s2[P] + "\\s*(" + x + "|" + s2[E2] + ")", i2[R] = new RegExp(s2[R], "g");
      var G = a2++;
      s2[G] = "^\\s*(" + s2[E2] + ")\\s+-\\s+(" + s2[E2] + ")\\s*$";
      var W = a2++;
      s2[W] = "^\\s*(" + s2[I] + ")\\s+-\\s+(" + s2[I] + ")\\s*$";
      var U = a2++;
      s2[U] = "(<|>)?=?\\s*\\*";
      for (var q = 0; q < 35; q++)
        n3(q, s2[q]), i2[q] || (i2[q] = new RegExp(s2[q]));
      function K(e4, t4) {
        if (t4 && "object" == typeof t4 || (t4 = { loose: !!t4, includePrerelease: false }), e4 instanceof Y)
          return e4;
        if ("string" != typeof e4)
          return null;
        if (e4.length > r3)
          return null;
        if (!(t4.loose ? i2[S] : i2[b]).test(e4))
          return null;
        try {
          return new Y(e4, t4);
        } catch (e5) {
          return null;
        }
      }
      function Y(e4, t4) {
        if (t4 && "object" == typeof t4 || (t4 = { loose: !!t4, includePrerelease: false }), e4 instanceof Y) {
          if (e4.loose === t4.loose)
            return e4;
          e4 = e4.version;
        } else if ("string" != typeof e4)
          throw new TypeError("Invalid Version: " + e4);
        if (e4.length > r3)
          throw new TypeError("version is longer than " + r3 + " characters");
        if (!(this instanceof Y))
          return new Y(e4, t4);
        n3("SemVer", e4, t4), this.options = t4, this.loose = !!t4.loose;
        var s3 = e4.trim().match(t4.loose ? i2[S] : i2[b]);
        if (!s3)
          throw new TypeError("Invalid Version: " + e4);
        if (this.raw = e4, this.major = +s3[1], this.minor = +s3[2], this.patch = +s3[3], this.major > o3 || this.major < 0)
          throw new TypeError("Invalid major version");
        if (this.minor > o3 || this.minor < 0)
          throw new TypeError("Invalid minor version");
        if (this.patch > o3 || this.patch < 0)
          throw new TypeError("Invalid patch version");
        s3[4] ? this.prerelease = s3[4].split(".").map(function(e5) {
          if (/^[0-9]+$/.test(e5)) {
            var t5 = +e5;
            if (t5 >= 0 && t5 < o3)
              return t5;
          }
          return e5;
        }) : this.prerelease = [], this.build = s3[5] ? s3[5].split(".") : [], this.format();
      }
      t3.parse = K, t3.valid = function(e4, t4) {
        var n4 = K(e4, t4);
        return n4 ? n4.version : null;
      }, t3.clean = function(e4, t4) {
        var n4 = K(e4.trim().replace(/^[=v]+/, ""), t4);
        return n4 ? n4.version : null;
      }, t3.SemVer = Y, Y.prototype.format = function() {
        return this.version = this.major + "." + this.minor + "." + this.patch, this.prerelease.length && (this.version += "-" + this.prerelease.join(".")), this.version;
      }, Y.prototype.toString = function() {
        return this.version;
      }, Y.prototype.compare = function(e4) {
        return n3("SemVer.compare", this.version, this.options, e4), e4 instanceof Y || (e4 = new Y(e4, this.options)), this.compareMain(e4) || this.comparePre(e4);
      }, Y.prototype.compareMain = function(e4) {
        return e4 instanceof Y || (e4 = new Y(e4, this.options)), J(this.major, e4.major) || J(this.minor, e4.minor) || J(this.patch, e4.patch);
      }, Y.prototype.comparePre = function(e4) {
        if (e4 instanceof Y || (e4 = new Y(e4, this.options)), this.prerelease.length && !e4.prerelease.length)
          return -1;
        if (!this.prerelease.length && e4.prerelease.length)
          return 1;
        if (!this.prerelease.length && !e4.prerelease.length)
          return 0;
        var t4 = 0;
        do {
          var r4 = this.prerelease[t4], o4 = e4.prerelease[t4];
          if (n3("prerelease compare", t4, r4, o4), void 0 === r4 && void 0 === o4)
            return 0;
          if (void 0 === o4)
            return 1;
          if (void 0 === r4)
            return -1;
          if (r4 !== o4)
            return J(r4, o4);
        } while (++t4);
      }, Y.prototype.inc = function(e4, t4) {
        switch (e4) {
          case "premajor":
            this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t4);
            break;
          case "preminor":
            this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t4);
            break;
          case "prepatch":
            this.prerelease.length = 0, this.inc("patch", t4), this.inc("pre", t4);
            break;
          case "prerelease":
            0 === this.prerelease.length && this.inc("patch", t4), this.inc("pre", t4);
            break;
          case "major":
            0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
            break;
          case "minor":
            0 === this.patch && 0 !== this.prerelease.length || this.minor++, this.patch = 0, this.prerelease = [];
            break;
          case "patch":
            0 === this.prerelease.length && this.patch++, this.prerelease = [];
            break;
          case "pre":
            if (0 === this.prerelease.length)
              this.prerelease = [0];
            else {
              for (var n4 = this.prerelease.length; --n4 >= 0; )
                "number" == typeof this.prerelease[n4] && (this.prerelease[n4]++, n4 = -2);
              -1 === n4 && this.prerelease.push(0);
            }
            t4 && (this.prerelease[0] === t4 ? isNaN(this.prerelease[1]) && (this.prerelease = [t4, 0]) : this.prerelease = [t4, 0]);
            break;
          default:
            throw new Error("invalid increment argument: " + e4);
        }
        return this.format(), this.raw = this.version, this;
      }, t3.inc = function(e4, t4, n4, r4) {
        "string" == typeof n4 && (r4 = n4, n4 = void 0);
        try {
          return new Y(e4, n4).inc(t4, r4).version;
        } catch (e5) {
          return null;
        }
      }, t3.diff = function(e4, t4) {
        if (Z(e4, t4))
          return null;
        var n4 = K(e4), r4 = K(t4);
        if (n4.prerelease.length || r4.prerelease.length) {
          for (var o4 in n4)
            if (("major" === o4 || "minor" === o4 || "patch" === o4) && n4[o4] !== r4[o4])
              return "pre" + o4;
          return "prerelease";
        }
        for (var o4 in n4)
          if (("major" === o4 || "minor" === o4 || "patch" === o4) && n4[o4] !== r4[o4])
            return o4;
      }, t3.compareIdentifiers = J;
      var H = /^[0-9]+$/;
      function J(e4, t4) {
        var n4 = H.test(e4), r4 = H.test(t4);
        return n4 && r4 && (e4 = +e4, t4 = +t4), n4 && !r4 ? -1 : r4 && !n4 ? 1 : e4 < t4 ? -1 : e4 > t4 ? 1 : 0;
      }
      function z(e4, t4, n4) {
        return new Y(e4, n4).compare(new Y(t4, n4));
      }
      function Q2(e4, t4, n4) {
        return z(e4, t4, n4) > 0;
      }
      function X(e4, t4, n4) {
        return z(e4, t4, n4) < 0;
      }
      function Z(e4, t4, n4) {
        return 0 === z(e4, t4, n4);
      }
      function ee(e4, t4, n4) {
        return 0 !== z(e4, t4, n4);
      }
      function te(e4, t4, n4) {
        return z(e4, t4, n4) >= 0;
      }
      function ne(e4, t4, n4) {
        return z(e4, t4, n4) <= 0;
      }
      function re(e4, t4, n4, r4) {
        var o4;
        switch (t4) {
          case "===":
            "object" == typeof e4 && (e4 = e4.version), "object" == typeof n4 && (n4 = n4.version), o4 = e4 === n4;
            break;
          case "!==":
            "object" == typeof e4 && (e4 = e4.version), "object" == typeof n4 && (n4 = n4.version), o4 = e4 !== n4;
            break;
          case "":
          case "=":
          case "==":
            o4 = Z(e4, n4, r4);
            break;
          case "!=":
            o4 = ee(e4, n4, r4);
            break;
          case ">":
            o4 = Q2(e4, n4, r4);
            break;
          case ">=":
            o4 = te(e4, n4, r4);
            break;
          case "<":
            o4 = X(e4, n4, r4);
            break;
          case "<=":
            o4 = ne(e4, n4, r4);
            break;
          default:
            throw new TypeError("Invalid operator: " + t4);
        }
        return o4;
      }
      function oe(e4, t4) {
        if (t4 && "object" == typeof t4 || (t4 = { loose: !!t4, includePrerelease: false }), e4 instanceof oe) {
          if (e4.loose === !!t4.loose)
            return e4;
          e4 = e4.value;
        }
        if (!(this instanceof oe))
          return new oe(e4, t4);
        n3("comparator", e4, t4), this.options = t4, this.loose = !!t4.loose, this.parse(e4), this.semver === ie ? this.value = "" : this.value = this.operator + this.semver.version, n3("comp", this);
      }
      t3.rcompareIdentifiers = function(e4, t4) {
        return J(t4, e4);
      }, t3.major = function(e4, t4) {
        return new Y(e4, t4).major;
      }, t3.minor = function(e4, t4) {
        return new Y(e4, t4).minor;
      }, t3.patch = function(e4, t4) {
        return new Y(e4, t4).patch;
      }, t3.compare = z, t3.compareLoose = function(e4, t4) {
        return z(e4, t4, true);
      }, t3.rcompare = function(e4, t4, n4) {
        return z(t4, e4, n4);
      }, t3.sort = function(e4, n4) {
        return e4.sort(function(e5, r4) {
          return t3.compare(e5, r4, n4);
        });
      }, t3.rsort = function(e4, n4) {
        return e4.sort(function(e5, r4) {
          return t3.rcompare(e5, r4, n4);
        });
      }, t3.gt = Q2, t3.lt = X, t3.eq = Z, t3.neq = ee, t3.gte = te, t3.lte = ne, t3.cmp = re, t3.Comparator = oe;
      var ie = {};
      function se(e4, t4) {
        if (t4 && "object" == typeof t4 || (t4 = { loose: !!t4, includePrerelease: false }), e4 instanceof se)
          return e4.loose === !!t4.loose && e4.includePrerelease === !!t4.includePrerelease ? e4 : new se(e4.raw, t4);
        if (e4 instanceof oe)
          return new se(e4.value, t4);
        if (!(this instanceof se))
          return new se(e4, t4);
        if (this.options = t4, this.loose = !!t4.loose, this.includePrerelease = !!t4.includePrerelease, this.raw = e4, this.set = e4.split(/\s*\|\|\s*/).map(function(e5) {
          return this.parseRange(e5.trim());
        }, this).filter(function(e5) {
          return e5.length;
        }), !this.set.length)
          throw new TypeError("Invalid SemVer Range: " + e4);
        this.format();
      }
      function ae(e4) {
        return !e4 || "x" === e4.toLowerCase() || "*" === e4;
      }
      function ce(e4, t4, n4, r4, o4, i3, s3, a3, c3, u3, l3, f3, p3) {
        return ((t4 = ae(n4) ? "" : ae(r4) ? ">=" + n4 + ".0.0" : ae(o4) ? ">=" + n4 + "." + r4 + ".0" : ">=" + t4) + " " + (a3 = ae(c3) ? "" : ae(u3) ? "<" + (+c3 + 1) + ".0.0" : ae(l3) ? "<" + c3 + "." + (+u3 + 1) + ".0" : f3 ? "<=" + c3 + "." + u3 + "." + l3 + "-" + f3 : "<=" + a3)).trim();
      }
      function ue(e4, t4, r4) {
        for (var o4 = 0; o4 < e4.length; o4++)
          if (!e4[o4].test(t4))
            return false;
        if (r4 || (r4 = {}), t4.prerelease.length && !r4.includePrerelease) {
          for (o4 = 0; o4 < e4.length; o4++)
            if (n3(e4[o4].semver), e4[o4].semver !== ie && e4[o4].semver.prerelease.length > 0) {
              var i3 = e4[o4].semver;
              if (i3.major === t4.major && i3.minor === t4.minor && i3.patch === t4.patch)
                return true;
            }
          return false;
        }
        return true;
      }
      function le(e4, t4, n4) {
        try {
          t4 = new se(t4, n4);
        } catch (e5) {
          return false;
        }
        return t4.test(e4);
      }
      function fe(e4, t4, n4, r4) {
        var o4, i3, s3, a3, c3;
        switch (e4 = new Y(e4, r4), t4 = new se(t4, r4), n4) {
          case ">":
            o4 = Q2, i3 = ne, s3 = X, a3 = ">", c3 = ">=";
            break;
          case "<":
            o4 = X, i3 = te, s3 = Q2, a3 = "<", c3 = "<=";
            break;
          default:
            throw new TypeError('Must provide a hilo val of "<" or ">"');
        }
        if (le(e4, t4, r4))
          return false;
        for (var u3 = 0; u3 < t4.set.length; ++u3) {
          var l3 = t4.set[u3], f3 = null, p3 = null;
          if (l3.forEach(function(e5) {
            e5.semver === ie && (e5 = new oe(">=0.0.0")), f3 = f3 || e5, p3 = p3 || e5, o4(e5.semver, f3.semver, r4) ? f3 = e5 : s3(e5.semver, p3.semver, r4) && (p3 = e5);
          }), f3.operator === a3 || f3.operator === c3)
            return false;
          if ((!p3.operator || p3.operator === a3) && i3(e4, p3.semver))
            return false;
          if (p3.operator === c3 && s3(e4, p3.semver))
            return false;
        }
        return true;
      }
      oe.prototype.parse = function(e4) {
        var t4 = this.options.loose ? i2[L] : i2[$], n4 = e4.match(t4);
        if (!n4)
          throw new TypeError("Invalid comparator: " + e4);
        this.operator = n4[1], "=" === this.operator && (this.operator = ""), n4[2] ? this.semver = new Y(n4[2], this.options.loose) : this.semver = ie;
      }, oe.prototype.toString = function() {
        return this.value;
      }, oe.prototype.test = function(e4) {
        return n3("Comparator.test", e4, this.options.loose), this.semver === ie || ("string" == typeof e4 && (e4 = new Y(e4, this.options)), re(e4, this.operator, this.semver, this.options));
      }, oe.prototype.intersects = function(e4, t4) {
        if (!(e4 instanceof oe))
          throw new TypeError("a Comparator is required");
        var n4;
        if (t4 && "object" == typeof t4 || (t4 = { loose: !!t4, includePrerelease: false }), "" === this.operator)
          return n4 = new se(e4.value, t4), le(this.value, n4, t4);
        if ("" === e4.operator)
          return n4 = new se(this.value, t4), le(e4.semver, n4, t4);
        var r4 = !(">=" !== this.operator && ">" !== this.operator || ">=" !== e4.operator && ">" !== e4.operator), o4 = !("<=" !== this.operator && "<" !== this.operator || "<=" !== e4.operator && "<" !== e4.operator), i3 = this.semver.version === e4.semver.version, s3 = !(">=" !== this.operator && "<=" !== this.operator || ">=" !== e4.operator && "<=" !== e4.operator), a3 = re(this.semver, "<", e4.semver, t4) && (">=" === this.operator || ">" === this.operator) && ("<=" === e4.operator || "<" === e4.operator), c3 = re(this.semver, ">", e4.semver, t4) && ("<=" === this.operator || "<" === this.operator) && (">=" === e4.operator || ">" === e4.operator);
        return r4 || o4 || i3 && s3 || a3 || c3;
      }, t3.Range = se, se.prototype.format = function() {
        return this.range = this.set.map(function(e4) {
          return e4.join(" ").trim();
        }).join("||").trim(), this.range;
      }, se.prototype.toString = function() {
        return this.range;
      }, se.prototype.parseRange = function(e4) {
        var t4 = this.options.loose;
        e4 = e4.trim();
        var r4 = t4 ? i2[W] : i2[G];
        e4 = e4.replace(r4, ce), n3("hyphen replace", e4), e4 = e4.replace(i2[R], "$1$2$3"), n3("comparator trim", e4, i2[R]), e4 = (e4 = (e4 = e4.replace(i2[F], "$1~")).replace(i2[V], "$1^")).split(/\s+/).join(" ");
        var o4 = t4 ? i2[L] : i2[$], s3 = e4.split(" ").map(function(e5) {
          return function(e6, t5) {
            return n3("comp", e6, t5), e6 = function(e7, t6) {
              return e7.trim().split(/\s+/).map(function(e8) {
                return function(e9, t7) {
                  n3("caret", e9, t7), t7 && "object" == typeof t7 || (t7 = { loose: !!t7, includePrerelease: false });
                  var r5 = t7.loose ? i2[B2] : i2[D];
                  return e9.replace(r5, function(t8, r6, o5, i3, s4) {
                    var a3;
                    return n3("caret", e9, t8, r6, o5, i3, s4), ae(r6) ? a3 = "" : ae(o5) ? a3 = ">=" + r6 + ".0.0 <" + (+r6 + 1) + ".0.0" : ae(i3) ? a3 = "0" === r6 ? ">=" + r6 + "." + o5 + ".0 <" + r6 + "." + (+o5 + 1) + ".0" : ">=" + r6 + "." + o5 + ".0 <" + (+r6 + 1) + ".0.0" : s4 ? (n3("replaceCaret pr", s4), "-" !== s4.charAt(0) && (s4 = "-" + s4), a3 = "0" === r6 ? "0" === o5 ? ">=" + r6 + "." + o5 + "." + i3 + s4 + " <" + r6 + "." + o5 + "." + (+i3 + 1) : ">=" + r6 + "." + o5 + "." + i3 + s4 + " <" + r6 + "." + (+o5 + 1) + ".0" : ">=" + r6 + "." + o5 + "." + i3 + s4 + " <" + (+r6 + 1) + ".0.0") : (n3("no pr"), a3 = "0" === r6 ? "0" === o5 ? ">=" + r6 + "." + o5 + "." + i3 + " <" + r6 + "." + o5 + "." + (+i3 + 1) : ">=" + r6 + "." + o5 + "." + i3 + " <" + r6 + "." + (+o5 + 1) + ".0" : ">=" + r6 + "." + o5 + "." + i3 + " <" + (+r6 + 1) + ".0.0"), n3("caret return", a3), a3;
                  });
                }(e8, t6);
              }).join(" ");
            }(e6, t5), n3("caret", e6), e6 = function(e7, t6) {
              return e7.trim().split(/\s+/).map(function(e8) {
                return function(e9, t7) {
                  t7 && "object" == typeof t7 || (t7 = { loose: !!t7, includePrerelease: false });
                  var r5 = t7.loose ? i2[M] : i2[C2];
                  return e9.replace(r5, function(t8, r6, o5, i3, s4) {
                    var a3;
                    return n3("tilde", e9, t8, r6, o5, i3, s4), ae(r6) ? a3 = "" : ae(o5) ? a3 = ">=" + r6 + ".0.0 <" + (+r6 + 1) + ".0.0" : ae(i3) ? a3 = ">=" + r6 + "." + o5 + ".0 <" + r6 + "." + (+o5 + 1) + ".0" : s4 ? (n3("replaceTilde pr", s4), "-" !== s4.charAt(0) && (s4 = "-" + s4), a3 = ">=" + r6 + "." + o5 + "." + i3 + s4 + " <" + r6 + "." + (+o5 + 1) + ".0") : a3 = ">=" + r6 + "." + o5 + "." + i3 + " <" + r6 + "." + (+o5 + 1) + ".0", n3("tilde return", a3), a3;
                  });
                }(e8, t6);
              }).join(" ");
            }(e6, t5), n3("tildes", e6), e6 = function(e7, t6) {
              return n3("replaceXRanges", e7, t6), e7.split(/\s+/).map(function(e8) {
                return function(e9, t7) {
                  e9 = e9.trim(), t7 && "object" == typeof t7 || (t7 = { loose: !!t7, includePrerelease: false });
                  var r5 = t7.loose ? i2[A2] : i2[_];
                  return e9.replace(r5, function(t8, r6, o5, i3, s4, a3) {
                    n3("xRange", e9, t8, r6, o5, i3, s4, a3);
                    var c3 = ae(o5), u3 = c3 || ae(i3), l3 = u3 || ae(s4), f3 = l3;
                    return "=" === r6 && f3 && (r6 = ""), c3 ? t8 = ">" === r6 || "<" === r6 ? "<0.0.0" : "*" : r6 && f3 ? (u3 && (i3 = 0), l3 && (s4 = 0), ">" === r6 ? (r6 = ">=", u3 ? (o5 = +o5 + 1, i3 = 0, s4 = 0) : l3 && (i3 = +i3 + 1, s4 = 0)) : "<=" === r6 && (r6 = "<", u3 ? o5 = +o5 + 1 : i3 = +i3 + 1), t8 = r6 + o5 + "." + i3 + "." + s4) : u3 ? t8 = ">=" + o5 + ".0.0 <" + (+o5 + 1) + ".0.0" : l3 && (t8 = ">=" + o5 + "." + i3 + ".0 <" + o5 + "." + (+i3 + 1) + ".0"), n3("xRange return", t8), t8;
                  });
                }(e8, t6);
              }).join(" ");
            }(e6, t5), n3("xrange", e6), e6 = function(e7, t6) {
              return n3("replaceStars", e7, t6), e7.trim().replace(i2[U], "");
            }(e6, t5), n3("stars", e6), e6;
          }(e5, this.options);
        }, this).join(" ").split(/\s+/);
        return this.options.loose && (s3 = s3.filter(function(e5) {
          return !!e5.match(o4);
        })), s3 = s3.map(function(e5) {
          return new oe(e5, this.options);
        }, this);
      }, se.prototype.intersects = function(e4, t4) {
        if (!(e4 instanceof se))
          throw new TypeError("a Range is required");
        return this.set.some(function(n4) {
          return n4.every(function(n5) {
            return e4.set.some(function(e5) {
              return e5.every(function(e6) {
                return n5.intersects(e6, t4);
              });
            });
          });
        });
      }, t3.toComparators = function(e4, t4) {
        return new se(e4, t4).set.map(function(e5) {
          return e5.map(function(e6) {
            return e6.value;
          }).join(" ").trim().split(" ");
        });
      }, se.prototype.test = function(e4) {
        if (!e4)
          return false;
        "string" == typeof e4 && (e4 = new Y(e4, this.options));
        for (var t4 = 0; t4 < this.set.length; t4++)
          if (ue(this.set[t4], e4, this.options))
            return true;
        return false;
      }, t3.satisfies = le, t3.maxSatisfying = function(e4, t4, n4) {
        var r4 = null, o4 = null;
        try {
          var i3 = new se(t4, n4);
        } catch (e5) {
          return null;
        }
        return e4.forEach(function(e5) {
          i3.test(e5) && (r4 && -1 !== o4.compare(e5) || (o4 = new Y(r4 = e5, n4)));
        }), r4;
      }, t3.minSatisfying = function(e4, t4, n4) {
        var r4 = null, o4 = null;
        try {
          var i3 = new se(t4, n4);
        } catch (e5) {
          return null;
        }
        return e4.forEach(function(e5) {
          i3.test(e5) && (r4 && 1 !== o4.compare(e5) || (o4 = new Y(r4 = e5, n4)));
        }), r4;
      }, t3.validRange = function(e4, t4) {
        try {
          return new se(e4, t4).range || "*";
        } catch (e5) {
          return null;
        }
      }, t3.ltr = function(e4, t4, n4) {
        return fe(e4, t4, "<", n4);
      }, t3.gtr = function(e4, t4, n4) {
        return fe(e4, t4, ">", n4);
      }, t3.outside = fe, t3.prerelease = function(e4, t4) {
        var n4 = K(e4, t4);
        return n4 && n4.prerelease.length ? n4.prerelease : null;
      }, t3.intersects = function(e4, t4, n4) {
        return e4 = new se(e4, n4), t4 = new se(t4, n4), e4.intersects(t4);
      }, t3.coerce = function(e4) {
        if (e4 instanceof Y)
          return e4;
        if ("string" != typeof e4)
          return null;
        var t4 = e4.match(i2[k]);
        return null == t4 ? null : K((t4[1] || "0") + "." + (t4[2] || "0") + "." + (t4[3] || "0"));
      };
    }, function(e3, t3, n3) {
      "use strict";
      const r3 = "win32" === process.platform;
      function o3(e4, t4) {
        return Object.assign(new Error(`${t4} ${e4.command} ENOENT`), { code: "ENOENT", errno: "ENOENT", syscall: `${t4} ${e4.command}`, path: e4.command, spawnargs: e4.args });
      }
      function i2(e4, t4) {
        return r3 && 1 === e4 && !t4.file ? o3(t4.original, "spawn") : null;
      }
      e3.exports = { hookChildProcess: function(e4, t4) {
        if (!r3)
          return;
        const n4 = e4.emit;
        e4.emit = function(r4, o4) {
          if ("exit" === r4) {
            const r5 = i2(o4, t4);
            if (r5)
              return n4.call(e4, "error", r5);
          }
          return n4.apply(e4, arguments);
        };
      }, verifyENOENT: i2, verifyENOENTSync: function(e4, t4) {
        return r3 && 1 === e4 && !t4.file ? o3(t4.original, "spawnSync") : null;
      }, notFoundError: o3 };
    }, function(e3, t3, n3) {
      "use strict";
      e3.exports = function(e4) {
        var t4 = "string" == typeof e4 ? "\n" : "\n".charCodeAt(), n4 = "string" == typeof e4 ? "\r" : "\r".charCodeAt();
        return e4[e4.length - 1] === t4 && (e4 = e4.slice(0, e4.length - 1)), e4[e4.length - 1] === n4 && (e4 = e4.slice(0, e4.length - 1)), e4;
      };
    }, function(e3, t3, n3) {
      "use strict";
      const r3 = n3(0), o3 = n3(77);
      e3.exports = (e4) => {
        let t4;
        e4 = Object.assign({ cwd: process.cwd(), path: process.env[o3()] }, e4);
        let n4 = r3.resolve(e4.cwd);
        const i2 = [];
        for (; t4 !== n4; )
          i2.push(r3.join(n4, "node_modules/.bin")), t4 = n4, n4 = r3.resolve(n4, "..");
        return i2.push(r3.dirname(process.execPath)), i2.concat(e4.path).join(r3.delimiter);
      }, e3.exports.env = (t4) => {
        t4 = Object.assign({ env: process.env }, t4);
        const n4 = Object.assign({}, t4.env), r4 = o3({ env: n4 });
        return t4.path = n4[r4], n4[r4] = e3.exports(t4), n4;
      };
    }, function(e3, t3, n3) {
      "use strict";
      var r3 = e3.exports = function(e4) {
        return null !== e4 && "object" == typeof e4 && "function" == typeof e4.pipe;
      };
      r3.writable = function(e4) {
        return r3(e4) && false !== e4.writable && "function" == typeof e4._write && "object" == typeof e4._writableState;
      }, r3.readable = function(e4) {
        return r3(e4) && false !== e4.readable && "function" == typeof e4._read && "object" == typeof e4._readableState;
      }, r3.duplex = function(e4) {
        return r3.writable(e4) && r3.readable(e4);
      }, r3.transform = function(e4) {
        return r3.duplex(e4) && "function" == typeof e4._transform && "object" == typeof e4._transformState;
      };
    }, function(e3, t3, n3) {
      "use strict";
      const r3 = n3(150), o3 = n3(152);
      class i2 extends Error {
        constructor() {
          super("maxBuffer exceeded"), this.name = "MaxBufferError";
        }
      }
      function s2(e4, t4) {
        if (!e4)
          return Promise.reject(new Error("Expected a stream"));
        t4 = Object.assign({ maxBuffer: 1 / 0 }, t4);
        const { maxBuffer: n4 } = t4;
        let s3;
        return new Promise((a2, c2) => {
          const u2 = (e5) => {
            e5 && (e5.bufferedData = s3.getBufferedValue()), c2(e5);
          };
          (s3 = r3(e4, o3(t4), (e5) => {
            e5 ? u2(e5) : a2();
          })).on("data", () => {
            s3.getBufferedLength() > n4 && u2(new i2());
          });
        }).then(() => s3.getBufferedValue());
      }
      e3.exports = s2, e3.exports.buffer = (e4, t4) => s2(e4, Object.assign({}, t4, { encoding: "buffer" })), e3.exports.array = (e4, t4) => s2(e4, Object.assign({}, t4, { array: true })), e3.exports.MaxBufferError = i2;
    }, function(e3, t3, n3) {
      var r3 = n3(31), o3 = n3(151), i2 = n3(5), s2 = function() {
      }, a2 = /^v?\.0/.test(process.version), c2 = function(e4) {
        return "function" == typeof e4;
      }, u2 = function(e4, t4, n4, u3) {
        u3 = r3(u3);
        var l3 = false;
        e4.on("close", function() {
          l3 = true;
        }), o3(e4, { readable: t4, writable: n4 }, function(e5) {
          if (e5)
            return u3(e5);
          l3 = true, u3();
        });
        var f3 = false;
        return function(t5) {
          if (!l3 && !f3)
            return f3 = true, function(e5) {
              return !!a2 && !!i2 && (e5 instanceof (i2.ReadStream || s2) || e5 instanceof (i2.WriteStream || s2)) && c2(e5.close);
            }(e4) ? e4.close(s2) : function(e5) {
              return e5.setHeader && c2(e5.abort);
            }(e4) ? e4.abort() : c2(e4.destroy) ? e4.destroy() : void u3(t5 || new Error("stream was destroyed"));
        };
      }, l2 = function(e4) {
        e4();
      }, f2 = function(e4, t4) {
        return e4.pipe(t4);
      };
      e3.exports = function() {
        var e4, t4 = Array.prototype.slice.call(arguments), n4 = c2(t4[t4.length - 1] || s2) && t4.pop() || s2;
        if (Array.isArray(t4[0]) && (t4 = t4[0]), t4.length < 2)
          throw new Error("pump requires two streams per minimum");
        var r4 = t4.map(function(o4, i3) {
          var s3 = i3 < t4.length - 1;
          return u2(o4, s3, i3 > 0, function(t5) {
            e4 || (e4 = t5), t5 && r4.forEach(l2), s3 || (r4.forEach(l2), n4(e4));
          });
        });
        return t4.reduce(f2);
      };
    }, function(e3, t3, n3) {
      var r3 = n3(31), o3 = function() {
      }, i2 = function(e4, t4, n4) {
        if ("function" == typeof t4)
          return i2(e4, null, t4);
        t4 || (t4 = {}), n4 = r3(n4 || o3);
        var s2 = e4._writableState, a2 = e4._readableState, c2 = t4.readable || false !== t4.readable && e4.readable, u2 = t4.writable || false !== t4.writable && e4.writable, l2 = function() {
          e4.writable || f2();
        }, f2 = function() {
          u2 = false, c2 || n4.call(e4);
        }, p2 = function() {
          c2 = false, u2 || n4.call(e4);
        }, h = function(t5) {
          n4.call(e4, t5 ? new Error("exited with error code: " + t5) : null);
        }, d2 = function(t5) {
          n4.call(e4, t5);
        }, m = function() {
          return (!c2 || a2 && a2.ended) && (!u2 || s2 && s2.ended) ? void 0 : n4.call(e4, new Error("premature close"));
        }, g = function() {
          e4.req.on("finish", f2);
        };
        return !function(e5) {
          return e5.setHeader && "function" == typeof e5.abort;
        }(e4) ? u2 && !s2 && (e4.on("end", l2), e4.on("close", l2)) : (e4.on("complete", f2), e4.on("abort", m), e4.req ? g() : e4.on("request", g)), function(e5) {
          return e5.stdio && Array.isArray(e5.stdio) && 3 === e5.stdio.length;
        }(e4) && e4.on("exit", h), e4.on("end", p2), e4.on("finish", f2), false !== t4.error && e4.on("error", d2), e4.on("close", m), function() {
          e4.removeListener("complete", f2), e4.removeListener("abort", m), e4.removeListener("request", g), e4.req && e4.req.removeListener("finish", f2), e4.removeListener("end", l2), e4.removeListener("close", l2), e4.removeListener("finish", f2), e4.removeListener("exit", h), e4.removeListener("end", p2), e4.removeListener("error", d2), e4.removeListener("close", m);
        };
      };
      e3.exports = i2;
    }, function(e3, t3, n3) {
      "use strict";
      const { PassThrough: r3 } = n3(153);
      e3.exports = (e4) => {
        e4 = Object.assign({}, e4);
        const { array: t4 } = e4;
        let { encoding: n4 } = e4;
        const o3 = "buffer" === n4;
        let i2 = false;
        t4 ? i2 = !(n4 || o3) : n4 = n4 || "utf8", o3 && (n4 = null);
        let s2 = 0;
        const a2 = [], c2 = new r3({ objectMode: i2 });
        return n4 && c2.setEncoding(n4), c2.on("data", (e5) => {
          a2.push(e5), i2 ? s2 = a2.length : s2 += e5.length;
        }), c2.getBufferedValue = () => t4 ? a2 : o3 ? Buffer.concat(a2, s2) : a2.join(""), c2.getBufferedLength = () => s2, c2;
      };
    }, function(e3, t3) {
      e3.exports = require_stream();
    }, function(e3, t3, n3) {
      "use strict";
      e3.exports = (e4, t4) => (t4 = t4 || (() => {
      }), e4.then((e5) => new Promise((e6) => {
        e6(t4());
      }).then(() => e5), (e5) => new Promise((e6) => {
        e6(t4());
      }).then(() => {
        throw e5;
      })));
    }, function(e3, t3, n3) {
      var r3, o3 = n3(47), i2 = n3(156), s2 = n3(68);
      function a2() {
        l2 && (l2 = false, i2.forEach(function(e4) {
          try {
            process.removeListener(e4, u2[e4]);
          } catch (e5) {
          }
        }), process.emit = d2, process.reallyExit = p2, r3.count -= 1);
      }
      function c2(e4, t4, n4) {
        r3.emitted[e4] || (r3.emitted[e4] = true, r3.emit(e4, t4, n4));
      }
      "function" != typeof s2 && (s2 = s2.EventEmitter), process.__signal_exit_emitter__ ? r3 = process.__signal_exit_emitter__ : ((r3 = process.__signal_exit_emitter__ = new s2()).count = 0, r3.emitted = {}), r3.infinite || (r3.setMaxListeners(1 / 0), r3.infinite = true), e3.exports = function(e4, t4) {
        o3.equal(typeof e4, "function", "a callback must be provided for exit handler"), false === l2 && f2();
        var n4 = "exit";
        t4 && t4.alwaysLast && (n4 = "afterexit");
        return r3.on(n4, e4), function() {
          r3.removeListener(n4, e4), 0 === r3.listeners("exit").length && 0 === r3.listeners("afterexit").length && a2();
        };
      }, e3.exports.unload = a2;
      var u2 = {};
      i2.forEach(function(e4) {
        u2[e4] = function() {
          process.listeners(e4).length === r3.count && (a2(), c2("exit", null, e4), c2("afterexit", null, e4), process.kill(process.pid, e4));
        };
      }), e3.exports.signals = function() {
        return i2;
      }, e3.exports.load = f2;
      var l2 = false;
      function f2() {
        l2 || (l2 = true, r3.count += 1, i2 = i2.filter(function(e4) {
          try {
            return process.on(e4, u2[e4]), true;
          } catch (e5) {
            return false;
          }
        }), process.emit = m, process.reallyExit = h);
      }
      var p2 = process.reallyExit;
      function h(e4) {
        process.exitCode = e4 || 0, c2("exit", process.exitCode, null), c2("afterexit", process.exitCode, null), p2.call(process, process.exitCode);
      }
      var d2 = process.emit;
      function m(e4, t4) {
        if ("exit" === e4) {
          void 0 !== t4 && (process.exitCode = t4);
          var n4 = d2.apply(this, arguments);
          return c2("exit", process.exitCode, null), c2("afterexit", process.exitCode, null), n4;
        }
        return d2.apply(this, arguments);
      }
    }, function(e3, t3) {
      e3.exports = ["SIGABRT", "SIGALRM", "SIGHUP", "SIGINT", "SIGTERM"], "win32" !== process.platform && e3.exports.push("SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT"), "linux" === process.platform && e3.exports.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT", "SIGUNUSED");
    }, function(e3, t3, n3) {
      "use strict";
      const r3 = n3(30);
      let o3;
      if ("function" == typeof r3.getSystemErrorName)
        e3.exports = r3.getSystemErrorName;
      else {
        try {
          if ("function" != typeof (o3 = process.binding("uv")).errname)
            throw new TypeError("uv.errname is not a function");
        } catch (e4) {
          console.error("execa/lib/errname: unable to establish process.binding('uv')", e4), o3 = null;
        }
        e3.exports = (e4) => i2(o3, e4);
      }
      function i2(e4, t4) {
        if (e4)
          return e4.errname(t4);
        if (!(t4 < 0))
          throw new Error("err >= 0");
        return `Unknown system error ${t4}`;
      }
      e3.exports.__test__ = i2;
    }, function(e3, t3, n3) {
      "use strict";
      const r3 = ["stdin", "stdout", "stderr"];
      e3.exports = (e4) => {
        if (!e4)
          return null;
        if (e4.stdio && ((e5) => r3.some((t5) => Boolean(e5[t5])))(e4))
          throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${r3.map((e5) => `\`${e5}\``).join(", ")}`);
        if ("string" == typeof e4.stdio)
          return e4.stdio;
        const t4 = e4.stdio || [];
        if (!Array.isArray(t4))
          throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof t4}\``);
        const n4 = [], o3 = Math.max(t4.length, r3.length);
        for (let i2 = 0; i2 < o3; i2++) {
          let o4 = null;
          void 0 !== t4[i2] ? o4 = t4[i2] : void 0 !== e4[r3[i2]] && (o4 = e4[r3[i2]]), n4[i2] = o4;
        }
        return n4;
      };
    }, function(e3, t3, n3) {
      "use strict";
      n3(2);
      var r3 = n3(1);
      e3.exports = { getBazelInfo: function() {
        return r3.log("trace", "getBazelInfo"), Promise.all([r3.run("bazel --version").then(r3.findVersion), r3.run("which bazel")]).then(function(e4) {
          return r3.determineFound("Bazel", e4[0], e4[1]);
        });
      }, getCMakeInfo: function() {
        return r3.log("trace", "getCMakeInfo"), Promise.all([r3.run("cmake --version").then(r3.findVersion), r3.run("which cmake")]).then(function(e4) {
          return r3.determineFound("CMake", e4[0], e4[1]);
        });
      }, getGCCInfo: function() {
        return r3.log("trace", "getGCCInfo"), r3.isMacOS || r3.isLinux ? Promise.all([r3.run("gcc -v 2>&1").then(r3.findVersion), r3.run("which gcc")]).then(function(e4) {
          return r3.determineFound("GCC", e4[0], e4[1]);
        }) : Promise.resolve(["GCC", "N/A"]);
      }, getClangInfo: function() {
        return r3.log("trace", "getClangInfo"), Promise.all([r3.run("clang --version").then(r3.findVersion), r3.which("clang")]).then(function(e4) {
          return r3.determineFound("Clang", e4[0], e4[1]);
        });
      }, getGitInfo: function() {
        return r3.log("trace", "getGitInfo"), Promise.all([r3.run("git --version").then(r3.findVersion), r3.run("which git")]).then(function(e4) {
          return r3.determineFound("Git", e4[0], e4[1]);
        });
      }, getMakeInfo: function() {
        return r3.log("trace", "getMakeInfo"), r3.isMacOS || r3.isLinux ? Promise.all([r3.run("make --version").then(r3.findVersion), r3.run("which make")]).then(function(e4) {
          return r3.determineFound("Make", e4[0], e4[1]);
        }) : Promise.resolve(["Make", "N/A"]);
      }, getNinjaInfo: function() {
        return r3.log("trace", "getNinjaInfo"), Promise.all([r3.run("ninja --version").then(r3.findVersion), r3.run("which ninja")]).then(function(e4) {
          return r3.determineFound("Ninja", e4[0], e4[1]);
        });
      }, getMercurialInfo: function() {
        return r3.log("trace", "getMercurialInfo"), r3.isMacOS || r3.isLinux ? Promise.all([r3.run("hg --version").then(r3.findVersion), r3.run("which hg")]).then(function(e4) {
          return r3.determineFound("Mercurial", e4[0], e4[1]);
        }) : Promise.resolve(["Mercurial", "N/A"]);
      }, getSubversionInfo: function() {
        return r3.log("trace", "getSubversionInfo"), r3.isMacOS || r3.isLinux ? Promise.all([r3.run("svn --version").then(r3.findVersion), r3.run("which svn")]).then(function(e4) {
          return r3.determineFound("Subversion", e4[0], e4[1]);
        }) : Promise.resolve(["Subversion", "N/A"]);
      }, getFFmpegInfo: function() {
        return r3.log("trace", "getFFmpegInfo"), Promise.all([r3.run("ffmpeg -version").then(r3.findVersion), r3.which("ffmpeg")]).then(function(e4) {
          return r3.determineFound("FFmpeg", e4[0], e4[1]);
        });
      } };
    }, function(e3, t3, n3) {
      "use strict";
      n3(2);
      var r3 = n3(1);
      e3.exports = { getDockerInfo: function() {
        return r3.log("trace", "getDockerInfo"), Promise.all([r3.run("docker --version").then(r3.findVersion), r3.which("docker")]).then(function(e4) {
          return r3.determineFound("Docker", e4[0], e4[1]);
        });
      }, getParallelsInfo: function() {
        return r3.log("trace", "getParallelsInfo"), Promise.all([r3.run("prlctl --version").then(r3.findVersion), r3.which("prlctl")]).then(function(e4) {
          return r3.determineFound("Parallels", e4[0], e4[1]);
        });
      }, getVirtualBoxInfo: function() {
        return r3.log("trace", "getVirtualBoxInfo"), Promise.all([r3.run("vboxmanage --version").then(r3.findVersion), r3.which("vboxmanage")]).then(function(e4) {
          return r3.determineFound("VirtualBox", e4[0], e4[1]);
        });
      }, getVMwareFusionInfo: function() {
        return r3.log("trace", "getVMwareFusionInfo"), r3.getDarwinApplicationVersion("com.vmware.fusion").then(function(e4) {
          return r3.determineFound("VMWare Fusion", e4, "N/A");
        });
      } };
    }, function(e3, t3, n3) {
      "use strict";
      n3(162), n3(64), n3(22), n3(16), n3(21), n3(74);
      var r3 = n3(163), o3 = n3(1);
      function i2(e4, t4) {
        return o3.log("trace", "clean", e4), Object.keys(e4).reduce(function(n4, r4) {
          return !t4.showNotFound && "Not Found" === e4[r4] || "N/A" === e4[r4] || void 0 === e4[r4] || 0 === Object.keys(e4[r4]).length ? n4 : o3.isObject(e4[r4]) ? Object.values(e4[r4]).every(function(e5) {
            return "N/A" === e5 || !t4.showNotFound && "Not Found" === e5;
          }) ? n4 : Object.assign(n4, { [r4]: i2(e4[r4], t4) }) : Object.assign(n4, { [r4]: e4[r4] });
        }, {});
      }
      function s2(e4, t4) {
        o3.log("trace", "formatHeaders"), t4 || (t4 = { type: "underline" });
        var n4 = { underline: ["\x1B[4m", "\x1B[0m"] };
        return e4.slice().split("\n").map(function(e5) {
          if (":" === e5.slice("-1")) {
            var r4 = e5.match(/^[\s]*/g)[0];
            return `${r4}${n4[t4.type][0]}${e5.slice(r4.length)}${n4[t4.type][1]}`;
          }
          return e5;
        }).join("\n");
      }
      function a2(e4) {
        return o3.log("trace", "formatPackages"), e4.npmPackages ? Object.assign(e4, { npmPackages: Object.entries(e4.npmPackages || {}).reduce(function(e5, t4) {
          var n4 = t4[0], r4 = t4[1];
          if ("Not Found" === r4)
            return Object.assign(e5, { [n4]: r4 });
          var o4 = r4.wanted ? `${r4.wanted} =>` : "", i3 = Array.isArray(r4.installed) ? r4.installed.join(", ") : r4.installed, s3 = r4.duplicates ? `(${r4.duplicates.join(", ")})` : "";
          return Object.assign(e5, { [n4]: `${o4} ${i3} ${s3}` });
        }, {}) }) : e4;
      }
      function c2(e4, t4, n4) {
        return n4 || (n4 = { emptyMessage: "None" }), Array.isArray(t4) && (t4 = t4.length > 0 ? t4.join(", ") : n4.emptyMessage), { [e4]: t4 };
      }
      function u2(e4) {
        return o3.log("trace", "serializeArrays"), function e5(t4, n4) {
          return Object.entries(t4).reduce(function(t5, r4) {
            var i3 = r4[0], s3 = r4[1];
            return o3.isObject(s3) ? Object.assign(t5, { [i3]: e5(s3, n4) }) : Object.assign(t5, n4(i3, s3));
          }, {});
        }(e4, c2);
      }
      function l2(e4) {
        return o3.log("trace", "serializeVersionsAndPaths"), Object.entries(e4).reduce(function(e5, t4) {
          return Object.assign(e5, { [t4[0]]: Object.entries(t4[1]).reduce(function(e6, t5) {
            var n4 = t5[0], r4 = t5[1];
            return r4.version ? Object.assign(e6, { [n4]: [r4.version, r4.path].filter(Boolean).join(" - ") }) : Object.assign(e6, { [n4]: [r4][0] });
          }, {}) }, {});
        }, {});
      }
      function f2(e4) {
        return r3(e4, { indent: "  ", prefix: "\n", postfix: "\n" });
      }
      function p2(e4) {
        return e4.slice().split("\n").map(function(e5) {
          if ("" !== e5) {
            var t4 = ":" === e5.slice("-1"), n4 = e5.search(/\S|$/);
            return t4 ? `${"#".repeat(n4 / 2 + 1)} ` + e5.slice(n4) : " - " + e5.slice(n4);
          }
          return "";
        }).join("\n");
      }
      function h(e4, t4) {
        return t4 || (t4 = { indent: "  " }), JSON.stringify(e4, null, t4.indent);
      }
      e3.exports = { json: function(e4, t4) {
        return o3.log("trace", "formatToJson"), t4 || (t4 = {}), e4 = o3.pipe([function() {
          return i2(e4, t4);
        }, t4.title ? function(e5) {
          return { [t4.title]: e5 };
        } : o3.noop, h])(e4), e4 = t4.console ? `
${e4}
` : e4;
      }, markdown: function(e4, t4) {
        return o3.log("trace", "formatToMarkdown"), o3.pipe([function() {
          return i2(e4, t4);
        }, a2, u2, l2, f2, p2, t4.title ? function(e5) {
          return `
# ${t4.title}${e5}`;
        } : o3.noop])(e4, t4);
      }, yaml: function(e4, t4) {
        return o3.log("trace", "formatToYaml", t4), o3.pipe([function() {
          return i2(e4, t4);
        }, a2, u2, l2, t4.title ? function(e5) {
          return { [t4.title]: e5 };
        } : o3.noop, f2, t4.console ? s2 : o3.noop])(e4, t4);
      } };
    }, function(e3, t3, n3) {
      n3(28)("search", 1, function(e4, t4, n4) {
        return [function(n5) {
          "use strict";
          var r3 = e4(this), o3 = null == n5 ? void 0 : n5[t4];
          return void 0 !== o3 ? o3.call(n5, r3) : new RegExp(n5)[t4](String(r3));
        }, n4];
      });
    }, function(e3, t3, n3) {
      "use strict";
      var r3 = n3(164), o3 = n3(165), i2 = n3(169), s2 = ["object", "array"];
      e3.exports = function(e4, t4) {
        var n4 = o3(t4), a2 = n4.colors, c2 = n4.prefix, u2 = n4.postfix, l2 = n4.dateToString, f2 = n4.errorToString, p2 = n4.indent, h = /* @__PURE__ */ new Map();
        function d2(e5) {
          var t5 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, n5 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
          if (0 === Object.keys(e5).length)
            return " {}";
          var o4 = "\n", a3 = i2(t5, p2);
          return Object.keys(e5).forEach(function(c3) {
            var u3 = e5[c3], l3 = r3(u3), f3 = i2(n5, "  "), p3 = -1 !== s2.indexOf(l3) ? "" : " ", h2 = v(u3) ? " [Circular]" : g(l3, u3, t5 + 1, n5);
            o4 += `${f3}${a3}${c3}:${p3}${h2}
`;
          }), o4.substring(0, o4.length - 1);
        }
        function m(e5) {
          var t5 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, n5 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
          if (0 === e5.length)
            return " []";
          var o4 = "\n", s3 = i2(t5, p2);
          return e5.forEach(function(e6) {
            var a3 = r3(e6), c3 = i2(n5, "  "), u3 = v(e6) ? "[Circular]" : g(a3, e6, t5, n5 + 1).toString().trimLeft();
            o4 += `${c3}${s3}- ${u3}
`;
          }), o4.substring(0, o4.length - 1);
        }
        function g(e5, t5, n5, r4) {
          switch (e5) {
            case "array":
              return m(t5, n5, r4);
            case "object":
              return d2(t5, n5, r4);
            case "string":
              return a2.string(t5);
            case "symbol":
              return a2.symbol(t5.toString());
            case "number":
              return a2.number(t5);
            case "boolean":
              return a2.boolean(t5);
            case "null":
              return a2.null("null");
            case "undefined":
              return a2.undefined("undefined");
            case "date":
              return a2.date(l2(t5));
            case "error":
              return a2.error(f2(t5));
            default:
              return t5 && t5.toString ? t5.toString() : Object.prototype.toString.call(t5);
          }
        }
        function v(e5) {
          return -1 !== ["object", "array"].indexOf(r3(e5)) && (!!h.has(e5) || (h.set(e5), false));
        }
        var y = "";
        return h.set(e4), "object" === r3(e4) && Object.keys(e4).length > 0 ? y = d2(e4) : "array" === r3(e4) && e4.length > 0 && (y = m(e4)), 0 === y.length ? "" : `${c2}${y.slice(1)}${u2}`;
      };
    }, function(e3, t3, n3) {
      "use strict";
      e3.exports = function(e4) {
        return Array.isArray(e4) ? "array" : e4 instanceof Date ? "date" : e4 instanceof Error ? "error" : null === e4 ? "null" : "object" == typeof e4 && "[object Object]" === Object.prototype.toString.call(e4) ? "object" : typeof e4;
      };
    }, function(e3, t3, n3) {
      "use strict";
      var r3 = n3(166), o3 = n3(167), i2 = n3(168), s2 = " ", a2 = "\n", c2 = "";
      function u2(e4, t4) {
        return void 0 === e4 ? t4 : e4;
      }
      e3.exports = function() {
        var e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
        return { indent: u2(e4.indent, s2), prefix: u2(e4.prefix, a2), postfix: u2(e4.postfix, c2), errorToString: e4.errorToString || r3, dateToString: e4.dateToString || o3, colors: Object.assign({}, i2, e4.colors) };
      };
    }, function(e3, t3, n3) {
      "use strict";
      e3.exports = function(e4) {
        return Error.prototype.toString.call(e4);
      };
    }, function(e3, t3, n3) {
      "use strict";
      e3.exports = function(e4) {
        return `new Date(${Date.prototype.toISOString.call(e4)})`;
      };
    }, function(e3, t3, n3) {
      "use strict";
      function r3(e4) {
        return e4;
      }
      e3.exports = { date: r3, error: r3, symbol: r3, string: r3, number: r3, boolean: r3, null: r3, undefined: r3 };
    }, function(e3, t3, n3) {
      "use strict";
      e3.exports = function() {
        for (var e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1, t4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "  ", n4 = "", r3 = 0; r3 < e4; r3 += 1)
          n4 += t4;
        return n4;
      };
    }, function(e3, t3, n3) {
      "use strict";
      e3.exports = { defaults: { System: ["OS", "CPU", "Memory", "Container", "Shell"], Binaries: ["Node", "Yarn", "npm", "Watchman"], Managers: ["Apt", "Cargo", "CocoaPods", "Composer", "Gradle", "Homebrew", "Maven", "pip2", "pip3", "RubyGems", "Yum"], Utilities: ["Bazel", "CMake", "Make", "GCC", "Git", "Clang", "Ninja", "Mercurial", "Subversion", "FFmpeg"], Servers: ["Apache", "Nginx"], Virtualization: ["Docker", "Parallels", "VirtualBox", "VMware Fusion"], SDKs: ["iOS SDK", "Android SDK", "Windows SDK"], IDEs: ["Android Studio", "Atom", "Emacs", "IntelliJ", "NVim", "Nano", "PhpStorm", "Sublime Text", "VSCode", "Visual Studio", "Vim", "WebStorm", "Xcode"], Languages: ["Bash", "Go", "Elixir", "Erlang", "Java", "Perl", "PHP", "Protoc", "Python", "Python3", "R", "Ruby", "Rust", "Scala"], Databases: ["MongoDB", "MySQL", "PostgreSQL", "SQLite"], Browsers: ["Brave Browser", "Chrome", "Chrome Canary", "Chromium", "Edge", "Firefox", "Firefox Developer Edition", "Firefox Nightly", "Internet Explorer", "Safari", "Safari Technology Preview"], Monorepos: ["Yarn Workspaces", "Lerna"], npmPackages: null, npmGlobalPackages: null }, jest: { System: ["OS", "CPU"], Binaries: ["Node", "Yarn", "npm"], npmPackages: ["jest"] }, "react-native": { System: ["OS", "CPU"], Binaries: ["Node", "Yarn", "npm", "Watchman"], SDKs: ["iOS SDK", "Android SDK", "Windows SDK"], IDEs: ["Android Studio", "Xcode", "Visual Studio"], npmPackages: ["react", "react-native"], npmGlobalPackages: ["react-native-cli"] }, nyc: { System: ["OS", "CPU", "Memory"], Binaries: ["Node", "Yarn", "npm"], npmPackages: "/**/{*babel*,@babel/*/,*istanbul*,nyc,source-map-support,typescript,ts-node}" }, webpack: { System: ["OS", "CPU"], Binaries: ["Node", "Yarn", "npm"], npmPackages: "*webpack*", npmGlobalPackages: ["webpack", "webpack-cli"] }, "styled-components": { System: ["OS", "CPU"], Binaries: ["Node", "Yarn", "npm"], Browsers: ["Chrome", "Firefox", "Safari"], npmPackages: "*styled-components*" }, "create-react-app": { System: ["OS", "CPU"], Binaries: ["Node", "npm", "Yarn"], Browsers: ["Chrome", "Edge", "Internet Explorer", "Firefox", "Safari"], npmPackages: ["react", "react-dom", "react-scripts"], npmGlobalPackages: ["create-react-app"], options: { duplicates: true, showNotFound: true } }, apollo: { System: ["OS"], Binaries: ["Node", "npm", "Yarn"], Browsers: ["Chrome", "Edge", "Firefox", "Safari"], npmPackages: "{*apollo*,@apollo/*}", npmGlobalPackages: "{*apollo*,@apollo/*}" }, "react-native-web": { System: ["OS", "CPU"], Binaries: ["Node", "npm", "Yarn"], Browsers: ["Chrome", "Edge", "Internet Explorer", "Firefox", "Safari"], npmPackages: ["react", "react-native-web"], options: { showNotFound: true } }, babel: { System: ["OS"], Binaries: ["Node", "npm", "Yarn"], Monorepos: ["Yarn Workspaces", "Lerna"], npmPackages: "{*babel*,@babel/*,eslint,webpack,create-react-app,react-native,lerna,jest}" }, playwright: { System: ["OS", "Memory", "Container"], Binaries: ["Node", "Yarn", "npm"], Languages: ["Bash"], npmPackages: "playwright*" } };
    }]);
  }
});

// node_modules/.pnpm/vuepress@2.0.0-beta.61_@vuepress+client@2.0.0-beta.61_vue@3.2.47/node_modules/vuepress/lib/index.js
var lib_exports2 = {};
__export(lib_exports2, {
  appInit: () => appInit,
  appPrepare: () => appPrepare,
  appUse: () => appUse,
  cli: () => cli,
  createAppDirFunction: () => createAppDirFunction,
  createBaseApp: () => createBaseApp,
  createBuild: () => createBuild,
  createBuildApp: () => createBuildApp,
  createDev: () => createDev,
  createDevApp: () => createDevApp,
  createHookQueue: () => createHookQueue,
  createPage: () => createPage,
  createPluginApi: () => createPluginApi,
  createPluginApiHooks: () => createPluginApiHooks,
  createPluginApiRegisterHooks: () => createPluginApiRegisterHooks,
  defineUserConfig: () => defineUserConfig,
  handlePageAdd: () => handlePageAdd,
  handlePageChange: () => handlePageChange,
  handlePageUnlink: () => handlePageUnlink,
  inferPagePath: () => inferPagePath,
  info: () => info2,
  loadUserConfig: () => loadUserConfig,
  normalizeAliasDefineHook: () => normalizeAliasDefineHook,
  normalizeClientConfigFileHook: () => normalizeClientConfigFileHook,
  prepareClientConfigs: () => prepareClientConfigs,
  preparePageComponent: () => preparePageComponent,
  preparePageData: () => preparePageData,
  preparePagesComponents: () => preparePagesComponents,
  preparePagesData: () => preparePagesData,
  preparePagesRoutes: () => preparePagesRoutes,
  prepareSiteData: () => prepareSiteData,
  renderPageContent: () => renderPageContent,
  resolveAppConfig: () => resolveAppConfig,
  resolveAppDir: () => resolveAppDir,
  resolveAppEnv: () => resolveAppEnv,
  resolveAppOptions: () => resolveAppOptions,
  resolveAppPages: () => resolveAppPages,
  resolveAppSiteData: () => resolveAppSiteData,
  resolveAppVersion: () => resolveAppVersion,
  resolveAppWriteTemp: () => resolveAppWriteTemp,
  resolveCliAppConfig: () => resolveCliAppConfig,
  resolvePageComponentInfo: () => resolvePageComponentInfo,
  resolvePageDataInfo: () => resolvePageDataInfo,
  resolvePageDate: () => resolvePageDate,
  resolvePageFileContent: () => resolvePageFileContent,
  resolvePageFilePath: () => resolvePageFilePath,
  resolvePageHtmlInfo: () => resolvePageHtmlInfo,
  resolvePageKey: () => resolvePageKey,
  resolvePageLang: () => resolvePageLang,
  resolvePagePath: () => resolvePagePath,
  resolvePagePermalink: () => resolvePagePermalink,
  resolvePageRouteMeta: () => resolvePageRouteMeta,
  resolvePageSlug: () => resolvePageSlug,
  resolvePluginObject: () => resolvePluginObject,
  resolveThemeInfo: () => resolveThemeInfo,
  resolveUserConfigConventionalPath: () => resolveUserConfigConventionalPath,
  resolveUserConfigPath: () => resolveUserConfigPath,
  transformUserConfigToPlugin: () => transformUserConfigToPlugin,
  viteBundler: () => viteBundler,
  watchPageFiles: () => watchPageFiles,
  watchUserConfigFile: () => watchUserConfigFile
});

// node_modules/.pnpm/vuepress-vite@2.0.0-beta.61_@vuepress+client@2.0.0-beta.61_vue@3.2.47/node_modules/vuepress-vite/lib/index.js
var lib_exports = {};
__export(lib_exports, {
  appInit: () => appInit,
  appPrepare: () => appPrepare,
  appUse: () => appUse,
  cli: () => cli,
  createAppDirFunction: () => createAppDirFunction,
  createBaseApp: () => createBaseApp,
  createBuild: () => createBuild,
  createBuildApp: () => createBuildApp,
  createDev: () => createDev,
  createDevApp: () => createDevApp,
  createHookQueue: () => createHookQueue,
  createPage: () => createPage,
  createPluginApi: () => createPluginApi,
  createPluginApiHooks: () => createPluginApiHooks,
  createPluginApiRegisterHooks: () => createPluginApiRegisterHooks,
  defineUserConfig: () => defineUserConfig,
  handlePageAdd: () => handlePageAdd,
  handlePageChange: () => handlePageChange,
  handlePageUnlink: () => handlePageUnlink,
  inferPagePath: () => inferPagePath,
  info: () => info2,
  loadUserConfig: () => loadUserConfig,
  normalizeAliasDefineHook: () => normalizeAliasDefineHook,
  normalizeClientConfigFileHook: () => normalizeClientConfigFileHook,
  prepareClientConfigs: () => prepareClientConfigs,
  preparePageComponent: () => preparePageComponent,
  preparePageData: () => preparePageData,
  preparePagesComponents: () => preparePagesComponents,
  preparePagesData: () => preparePagesData,
  preparePagesRoutes: () => preparePagesRoutes,
  prepareSiteData: () => prepareSiteData,
  renderPageContent: () => renderPageContent,
  resolveAppConfig: () => resolveAppConfig,
  resolveAppDir: () => resolveAppDir,
  resolveAppEnv: () => resolveAppEnv,
  resolveAppOptions: () => resolveAppOptions,
  resolveAppPages: () => resolveAppPages,
  resolveAppSiteData: () => resolveAppSiteData,
  resolveAppVersion: () => resolveAppVersion,
  resolveAppWriteTemp: () => resolveAppWriteTemp,
  resolveCliAppConfig: () => resolveCliAppConfig,
  resolvePageComponentInfo: () => resolvePageComponentInfo,
  resolvePageDataInfo: () => resolvePageDataInfo,
  resolvePageDate: () => resolvePageDate,
  resolvePageFileContent: () => resolvePageFileContent,
  resolvePageFilePath: () => resolvePageFilePath,
  resolvePageHtmlInfo: () => resolvePageHtmlInfo,
  resolvePageKey: () => resolvePageKey,
  resolvePageLang: () => resolvePageLang,
  resolvePagePath: () => resolvePagePath,
  resolvePagePermalink: () => resolvePagePermalink,
  resolvePageRouteMeta: () => resolvePageRouteMeta,
  resolvePageSlug: () => resolvePageSlug,
  resolvePluginObject: () => resolvePluginObject,
  resolveThemeInfo: () => resolveThemeInfo,
  resolveUserConfigConventionalPath: () => resolveUserConfigConventionalPath,
  resolveUserConfigPath: () => resolveUserConfigPath,
  transformUserConfigToPlugin: () => transformUserConfigToPlugin,
  viteBundler: () => viteBundler,
  watchPageFiles: () => watchPageFiles,
  watchUserConfigFile: () => watchUserConfigFile
});

// node_modules/.pnpm/@vuepress+utils@2.0.0-beta.61/node_modules/@vuepress/utils/dist/index.js
var import_debug = __toESM(require_browser());
var import_fs_extra = __toESM(require_lib());

// node_modules/.pnpm/globby@13.1.4/node_modules/globby/index.js
var import_node_fs2 = __toESM(require_node_fs());
var import_node_path2 = __toESM(require_node_path());
var import_merge2 = __toESM(require_merge2());
var import_fast_glob2 = __toESM(require_out4());
var import_dir_glob = __toESM(require_dir_glob());

// node_modules/.pnpm/globby@13.1.4/node_modules/globby/ignore.js
var import_node_process = __toESM(require_node_process(), 1);
var import_node_fs = __toESM(require_node_fs(), 1);
var import_node_path = __toESM(require_node_path(), 1);
var import_fast_glob = __toESM(require_out4(), 1);
var import_ignore = __toESM(require_ignore(), 1);

// node_modules/.pnpm/slash@4.0.0/node_modules/slash/index.js
function slash(path8) {
  const isExtendedLengthPath = /^\\\\\?\\/.test(path8);
  const hasNonAscii = /[^\u0000-\u0080]+/.test(path8);
  if (isExtendedLengthPath || hasNonAscii) {
    return path8;
  }
  return path8.replace(/\\/g, "/");
}

// node_modules/.pnpm/globby@13.1.4/node_modules/globby/utilities.js
var import_node_url = __toESM(require_node_url(), 1);
var import_node_stream = __toESM(require_node_stream(), 1);
var toPath = (urlOrPath) => urlOrPath instanceof URL ? (0, import_node_url.fileURLToPath)(urlOrPath) : urlOrPath;
var FilterStream = class extends import_node_stream.Transform {
  constructor(filter2) {
    super({
      objectMode: true,
      transform(data2, encoding, callback) {
        callback(void 0, filter2(data2) ? data2 : void 0);
      }
    });
  }
};
var isNegativePattern = (pattern2) => pattern2[0] === "!";

// node_modules/.pnpm/globby@13.1.4/node_modules/globby/ignore.js
var ignoreFilesGlobOptions = {
  ignore: [
    "**/node_modules",
    "**/flow-typed",
    "**/coverage",
    "**/.git"
  ],
  absolute: true,
  dot: true
};
var GITIGNORE_FILES_PATTERN = "**/.gitignore";
var applyBaseToPattern = (pattern2, base2) => isNegativePattern(pattern2) ? "!" + import_node_path.default.posix.join(base2, pattern2.slice(1)) : import_node_path.default.posix.join(base2, pattern2);
var parseIgnoreFile = (file, cwd) => {
  const base2 = slash(import_node_path.default.relative(cwd, import_node_path.default.dirname(file.filePath)));
  return file.content.split(/\r?\n/).filter((line) => line && !line.startsWith("#")).map((pattern2) => applyBaseToPattern(pattern2, base2));
};
var toRelativePath = (fileOrDirectory, cwd) => {
  cwd = slash(cwd);
  if (import_node_path.default.isAbsolute(fileOrDirectory)) {
    if (slash(fileOrDirectory).startsWith(cwd)) {
      return import_node_path.default.relative(cwd, fileOrDirectory);
    }
    throw new Error(`Path ${fileOrDirectory} is not in cwd ${cwd}`);
  }
  return fileOrDirectory;
};
var getIsIgnoredPredicate = (files, cwd) => {
  const patterns2 = files.flatMap((file) => parseIgnoreFile(file, cwd));
  const ignores = (0, import_ignore.default)().add(patterns2);
  return (fileOrDirectory) => {
    fileOrDirectory = toPath(fileOrDirectory);
    fileOrDirectory = toRelativePath(fileOrDirectory, cwd);
    return fileOrDirectory ? ignores.ignores(slash(fileOrDirectory)) : false;
  };
};
var normalizeOptions = (options3 = {}) => ({
  cwd: toPath(options3.cwd) || import_node_process.default.cwd(),
  suppressErrors: Boolean(options3.suppressErrors)
});
var isIgnoredByIgnoreFiles = async (patterns2, options3) => {
  const { cwd, suppressErrors } = normalizeOptions(options3);
  const paths = await (0, import_fast_glob.default)(patterns2, { cwd, suppressErrors, ...ignoreFilesGlobOptions });
  const files = await Promise.all(
    paths.map(async (filePath) => ({
      filePath,
      content: await import_node_fs.default.promises.readFile(filePath, "utf8")
    }))
  );
  return getIsIgnoredPredicate(files, cwd);
};
var isIgnoredByIgnoreFilesSync = (patterns2, options3) => {
  const { cwd, suppressErrors } = normalizeOptions(options3);
  const paths = import_fast_glob.default.sync(patterns2, { cwd, suppressErrors, ...ignoreFilesGlobOptions });
  const files = paths.map((filePath) => ({
    filePath,
    content: import_node_fs.default.readFileSync(filePath, "utf8")
  }));
  return getIsIgnoredPredicate(files, cwd);
};

// node_modules/.pnpm/globby@13.1.4/node_modules/globby/index.js
var assertPatternsInput = (patterns2) => {
  if (patterns2.some((pattern2) => typeof pattern2 !== "string")) {
    throw new TypeError("Patterns must be a string or an array of strings");
  }
};
var toPatternsArray = (patterns2) => {
  patterns2 = [...new Set([patterns2].flat())];
  assertPatternsInput(patterns2);
  return patterns2;
};
var checkCwdOption = (options3) => {
  if (!options3.cwd) {
    return;
  }
  let stat2;
  try {
    stat2 = import_node_fs2.default.statSync(options3.cwd);
  } catch {
    return;
  }
  if (!stat2.isDirectory()) {
    throw new Error("The `cwd` option must be a path to a directory");
  }
};
var normalizeOptions2 = (options3 = {}) => {
  options3 = {
    ignore: [],
    expandDirectories: true,
    ...options3,
    cwd: toPath(options3.cwd)
  };
  checkCwdOption(options3);
  return options3;
};
var normalizeArguments = (fn) => async (patterns2, options3) => fn(toPatternsArray(patterns2), normalizeOptions2(options3));
var normalizeArgumentsSync = (fn) => (patterns2, options3) => fn(toPatternsArray(patterns2), normalizeOptions2(options3));
var getIgnoreFilesPatterns = (options3) => {
  const { ignoreFiles, gitignore } = options3;
  const patterns2 = ignoreFiles ? toPatternsArray(ignoreFiles) : [];
  if (gitignore) {
    patterns2.push(GITIGNORE_FILES_PATTERN);
  }
  return patterns2;
};
var getFilter = async (options3) => {
  const ignoreFilesPatterns = getIgnoreFilesPatterns(options3);
  return createFilterFunction(
    ignoreFilesPatterns.length > 0 && await isIgnoredByIgnoreFiles(ignoreFilesPatterns, options3)
  );
};
var getFilterSync = (options3) => {
  const ignoreFilesPatterns = getIgnoreFilesPatterns(options3);
  return createFilterFunction(
    ignoreFilesPatterns.length > 0 && isIgnoredByIgnoreFilesSync(ignoreFilesPatterns, options3)
  );
};
var createFilterFunction = (isIgnored2) => {
  const seen2 = /* @__PURE__ */ new Set();
  return (fastGlobResult) => {
    const path8 = fastGlobResult.path || fastGlobResult;
    const pathKey2 = import_node_path2.default.normalize(path8);
    const seenOrIgnored = seen2.has(pathKey2) || isIgnored2 && isIgnored2(path8);
    seen2.add(pathKey2);
    return !seenOrIgnored;
  };
};
var unionFastGlobResults = (results, filter2) => results.flat().filter((fastGlobResult) => filter2(fastGlobResult));
var unionFastGlobStreams = (streams, filter2) => (0, import_merge2.default)(streams).pipe(new FilterStream((fastGlobResult) => filter2(fastGlobResult)));
var convertNegativePatterns = (patterns2, options3) => {
  const tasks2 = [];
  while (patterns2.length > 0) {
    const index2 = patterns2.findIndex((pattern2) => isNegativePattern(pattern2));
    if (index2 === -1) {
      tasks2.push({ patterns: patterns2, options: options3 });
      break;
    }
    const ignorePattern = patterns2[index2].slice(1);
    for (const task of tasks2) {
      task.options.ignore.push(ignorePattern);
    }
    if (index2 !== 0) {
      tasks2.push({
        patterns: patterns2.slice(0, index2),
        options: {
          ...options3,
          ignore: [
            ...options3.ignore,
            ignorePattern
          ]
        }
      });
    }
    patterns2 = patterns2.slice(index2 + 1);
  }
  return tasks2;
};
var getDirGlobOptions = (options3, cwd) => ({
  ...cwd ? { cwd } : {},
  ...Array.isArray(options3) ? { files: options3 } : options3
});
var generateTasks = async (patterns2, options3) => {
  const globTasks = convertNegativePatterns(patterns2, options3);
  const { cwd, expandDirectories } = options3;
  if (!expandDirectories) {
    return globTasks;
  }
  const patternExpandOptions = getDirGlobOptions(expandDirectories, cwd);
  const ignoreExpandOptions = cwd ? { cwd } : void 0;
  return Promise.all(
    globTasks.map(async (task) => {
      let { patterns: patterns3, options: options4 } = task;
      [
        patterns3,
        options4.ignore
      ] = await Promise.all([
        (0, import_dir_glob.default)(patterns3, patternExpandOptions),
        (0, import_dir_glob.default)(options4.ignore, ignoreExpandOptions)
      ]);
      return { patterns: patterns3, options: options4 };
    })
  );
};
var generateTasksSync = (patterns2, options3) => {
  const globTasks = convertNegativePatterns(patterns2, options3);
  const { cwd, expandDirectories } = options3;
  if (!expandDirectories) {
    return globTasks;
  }
  const patternExpandOptions = getDirGlobOptions(expandDirectories, cwd);
  const ignoreExpandOptions = cwd ? { cwd } : void 0;
  return globTasks.map((task) => {
    let { patterns: patterns3, options: options4 } = task;
    patterns3 = import_dir_glob.default.sync(patterns3, patternExpandOptions);
    options4.ignore = import_dir_glob.default.sync(options4.ignore, ignoreExpandOptions);
    return { patterns: patterns3, options: options4 };
  });
};
var globby = normalizeArguments(async (patterns2, options3) => {
  const [
    tasks2,
    filter2
  ] = await Promise.all([
    generateTasks(patterns2, options3),
    getFilter(options3)
  ]);
  const results = await Promise.all(tasks2.map((task) => (0, import_fast_glob2.default)(task.patterns, task.options)));
  return unionFastGlobResults(results, filter2);
});
var globbySync = normalizeArgumentsSync((patterns2, options3) => {
  const tasks2 = generateTasksSync(patterns2, options3);
  const filter2 = getFilterSync(options3);
  const results = tasks2.map((task) => import_fast_glob2.default.sync(task.patterns, task.options));
  return unionFastGlobResults(results, filter2);
});
var globbyStream = normalizeArgumentsSync((patterns2, options3) => {
  const tasks2 = generateTasksSync(patterns2, options3);
  const filter2 = getFilterSync(options3);
  const streams = tasks2.map((task) => import_fast_glob2.default.stream(task.patterns, task.options));
  return unionFastGlobStreams(streams, filter2);
});
var isDynamicPattern = normalizeArgumentsSync(
  (patterns2, options3) => patterns2.some((pattern2) => import_fast_glob2.default.isDynamicPattern(pattern2, options3))
);
var generateGlobTasks = normalizeArguments(generateTasks);
var generateGlobTasksSync = normalizeArgumentsSync(generateTasksSync);

// node_modules/.pnpm/@vuepress+utils@2.0.0-beta.61/node_modules/@vuepress/utils/dist/index.js
var import_hash_sum = __toESM(require_hash_sum());

// node_modules/.pnpm/ora@6.3.0/node_modules/ora/index.js
var import_node_process6 = __toESM(require_node_process());

// node_modules/.pnpm/chalk@5.2.0/node_modules/chalk/source/vendor/ansi-styles/index.js
var ANSI_BACKGROUND_OFFSET = 10;
var wrapAnsi16 = (offset3 = 0) => (code) => `\x1B[${code + offset3}m`;
var wrapAnsi256 = (offset3 = 0) => (code) => `\x1B[${38 + offset3};5;${code}m`;
var wrapAnsi16m = (offset3 = 0) => (red, green, blue) => `\x1B[${38 + offset3};2;${red};${green};${blue}m`;
var styles = {
  modifier: {
    reset: [0, 0],
    // 21 isn't widely supported and 22 does the same thing
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    // Bright color
    blackBright: [90, 39],
    gray: [90, 39],
    // Alias of `blackBright`
    grey: [90, 39],
    // Alias of `blackBright`
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    // Bright color
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    // Alias of `bgBlackBright`
    bgGrey: [100, 49],
    // Alias of `bgBlackBright`
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
};
var modifierNames = Object.keys(styles.modifier);
var foregroundColorNames = Object.keys(styles.color);
var backgroundColorNames = Object.keys(styles.bgColor);
var colorNames = [...foregroundColorNames, ...backgroundColorNames];
function assembleStyles() {
  const codes2 = /* @__PURE__ */ new Map();
  for (const [groupName, group] of Object.entries(styles)) {
    for (const [styleName, style] of Object.entries(group)) {
      styles[styleName] = {
        open: `\x1B[${style[0]}m`,
        close: `\x1B[${style[1]}m`
      };
      group[styleName] = styles[styleName];
      codes2.set(style[0], style[1]);
    }
    Object.defineProperty(styles, groupName, {
      value: group,
      enumerable: false
    });
  }
  Object.defineProperty(styles, "codes", {
    value: codes2,
    enumerable: false
  });
  styles.color.close = "\x1B[39m";
  styles.bgColor.close = "\x1B[49m";
  styles.color.ansi = wrapAnsi16();
  styles.color.ansi256 = wrapAnsi256();
  styles.color.ansi16m = wrapAnsi16m();
  styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
  Object.defineProperties(styles, {
    rgbToAnsi256: {
      value(red, green, blue) {
        if (red === green && green === blue) {
          if (red < 8) {
            return 16;
          }
          if (red > 248) {
            return 231;
          }
          return Math.round((red - 8) / 247 * 24) + 232;
        }
        return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
      },
      enumerable: false
    },
    hexToRgb: {
      value(hex) {
        const matches2 = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
        if (!matches2) {
          return [0, 0, 0];
        }
        let [colorString] = matches2;
        if (colorString.length === 3) {
          colorString = [...colorString].map((character) => character + character).join("");
        }
        const integer = Number.parseInt(colorString, 16);
        return [
          /* eslint-disable no-bitwise */
          integer >> 16 & 255,
          integer >> 8 & 255,
          integer & 255
          /* eslint-enable no-bitwise */
        ];
      },
      enumerable: false
    },
    hexToAnsi256: {
      value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
      enumerable: false
    },
    ansi256ToAnsi: {
      value(code) {
        if (code < 8) {
          return 30 + code;
        }
        if (code < 16) {
          return 90 + (code - 8);
        }
        let red;
        let green;
        let blue;
        if (code >= 232) {
          red = ((code - 232) * 10 + 8) / 255;
          green = red;
          blue = red;
        } else {
          code -= 16;
          const remainder = code % 36;
          red = Math.floor(code / 36) / 5;
          green = Math.floor(remainder / 6) / 5;
          blue = remainder % 6 / 5;
        }
        const value2 = Math.max(red, green, blue) * 2;
        if (value2 === 0) {
          return 30;
        }
        let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
        if (value2 === 2) {
          result += 60;
        }
        return result;
      },
      enumerable: false
    },
    rgbToAnsi: {
      value: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
      enumerable: false
    },
    hexToAnsi: {
      value: (hex) => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
      enumerable: false
    }
  });
  return styles;
}
var ansiStyles = assembleStyles();
var ansi_styles_default = ansiStyles;

// node_modules/.pnpm/chalk@5.2.0/node_modules/chalk/source/vendor/supports-color/browser.js
var level = (() => {
  if (navigator.userAgentData) {
    const brand = navigator.userAgentData.brands.find(({ brand: brand2 }) => brand2 === "Chromium");
    if (brand && brand.version > 93) {
      return 3;
    }
  }
  if (/\b(Chrome|Chromium)\//.test(navigator.userAgent)) {
    return 1;
  }
  return 0;
})();
var colorSupport = level !== 0 && {
  level,
  hasBasic: true,
  has256: level >= 2,
  has16m: level >= 3
};
var supportsColor = {
  stdout: colorSupport,
  stderr: colorSupport
};
var browser_default = supportsColor;

// node_modules/.pnpm/chalk@5.2.0/node_modules/chalk/source/utilities.js
function stringReplaceAll(string3, substring, replacer) {
  let index2 = string3.indexOf(substring);
  if (index2 === -1) {
    return string3;
  }
  const substringLength = substring.length;
  let endIndex = 0;
  let returnValue = "";
  do {
    returnValue += string3.slice(endIndex, index2) + substring + replacer;
    endIndex = index2 + substringLength;
    index2 = string3.indexOf(substring, endIndex);
  } while (index2 !== -1);
  returnValue += string3.slice(endIndex);
  return returnValue;
}
function stringEncaseCRLFWithFirstIndex(string3, prefix, postfix, index2) {
  let endIndex = 0;
  let returnValue = "";
  do {
    const gotCR = string3[index2 - 1] === "\r";
    returnValue += string3.slice(endIndex, gotCR ? index2 - 1 : index2) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
    endIndex = index2 + 1;
    index2 = string3.indexOf("\n", endIndex);
  } while (index2 !== -1);
  returnValue += string3.slice(endIndex);
  return returnValue;
}

// node_modules/.pnpm/chalk@5.2.0/node_modules/chalk/source/index.js
var { stdout: stdoutColor, stderr: stderrColor } = browser_default;
var GENERATOR = Symbol("GENERATOR");
var STYLER = Symbol("STYLER");
var IS_EMPTY = Symbol("IS_EMPTY");
var levelMapping = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
];
var styles2 = /* @__PURE__ */ Object.create(null);
var applyOptions = (object, options3 = {}) => {
  if (options3.level && !(Number.isInteger(options3.level) && options3.level >= 0 && options3.level <= 3)) {
    throw new Error("The `level` option should be an integer from 0 to 3");
  }
  const colorLevel = stdoutColor ? stdoutColor.level : 0;
  object.level = options3.level === void 0 ? colorLevel : options3.level;
};
var chalkFactory = (options3) => {
  const chalk2 = (...strings) => strings.join(" ");
  applyOptions(chalk2, options3);
  Object.setPrototypeOf(chalk2, createChalk.prototype);
  return chalk2;
};
function createChalk(options3) {
  return chalkFactory(options3);
}
Object.setPrototypeOf(createChalk.prototype, Function.prototype);
for (const [styleName, style] of Object.entries(ansi_styles_default)) {
  styles2[styleName] = {
    get() {
      const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
      Object.defineProperty(this, styleName, { value: builder });
      return builder;
    }
  };
}
styles2.visible = {
  get() {
    const builder = createBuilder(this, this[STYLER], true);
    Object.defineProperty(this, "visible", { value: builder });
    return builder;
  }
};
var getModelAnsi = (model, level3, type, ...arguments_) => {
  if (model === "rgb") {
    if (level3 === "ansi16m") {
      return ansi_styles_default[type].ansi16m(...arguments_);
    }
    if (level3 === "ansi256") {
      return ansi_styles_default[type].ansi256(ansi_styles_default.rgbToAnsi256(...arguments_));
    }
    return ansi_styles_default[type].ansi(ansi_styles_default.rgbToAnsi(...arguments_));
  }
  if (model === "hex") {
    return getModelAnsi("rgb", level3, type, ...ansi_styles_default.hexToRgb(...arguments_));
  }
  return ansi_styles_default[type][model](...arguments_);
};
var usedModels = ["rgb", "hex", "ansi256"];
for (const model of usedModels) {
  styles2[model] = {
    get() {
      const { level: level3 } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level3], "color", ...arguments_), ansi_styles_default.color.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
  const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
  styles2[bgModel] = {
    get() {
      const { level: level3 } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level3], "bgColor", ...arguments_), ansi_styles_default.bgColor.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
}
var proto = Object.defineProperties(() => {
}, {
  ...styles2,
  level: {
    enumerable: true,
    get() {
      return this[GENERATOR].level;
    },
    set(level3) {
      this[GENERATOR].level = level3;
    }
  }
});
var createStyler = (open2, close2, parent) => {
  let openAll;
  let closeAll;
  if (parent === void 0) {
    openAll = open2;
    closeAll = close2;
  } else {
    openAll = parent.openAll + open2;
    closeAll = close2 + parent.closeAll;
  }
  return {
    open: open2,
    close: close2,
    openAll,
    closeAll,
    parent
  };
};
var createBuilder = (self2, _styler, _isEmpty) => {
  const builder = (...arguments_) => applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
  Object.setPrototypeOf(builder, proto);
  builder[GENERATOR] = self2;
  builder[STYLER] = _styler;
  builder[IS_EMPTY] = _isEmpty;
  return builder;
};
var applyStyle = (self2, string3) => {
  if (self2.level <= 0 || !string3) {
    return self2[IS_EMPTY] ? "" : string3;
  }
  let styler = self2[STYLER];
  if (styler === void 0) {
    return string3;
  }
  const { openAll, closeAll } = styler;
  if (string3.includes("\x1B")) {
    while (styler !== void 0) {
      string3 = stringReplaceAll(string3, styler.close, styler.open);
      styler = styler.parent;
    }
  }
  const lfIndex = string3.indexOf("\n");
  if (lfIndex !== -1) {
    string3 = stringEncaseCRLFWithFirstIndex(string3, closeAll, openAll, lfIndex);
  }
  return openAll + string3 + closeAll;
};
Object.defineProperties(createChalk.prototype, styles2);
var chalk = createChalk();
var chalkStderr = createChalk({ level: stderrColor ? stderrColor.level : 0 });
var source_default = chalk;

// node_modules/.pnpm/cli-cursor@4.0.0/node_modules/cli-cursor/index.js
var import_node_process3 = __toESM(require_node_process());

// node_modules/.pnpm/restore-cursor@4.0.0/node_modules/restore-cursor/index.js
var import_node_process2 = __toESM(require_node_process());
var import_onetime = __toESM(require_onetime());
var import_signal_exit = __toESM(require_signal_exit());
var restoreCursor = (0, import_onetime.default)(() => {
  (0, import_signal_exit.default)(() => {
    import_node_process2.default.stderr.write("\x1B[?25h");
  }, { alwaysLast: true });
});
var restore_cursor_default = restoreCursor;

// node_modules/.pnpm/cli-cursor@4.0.0/node_modules/cli-cursor/index.js
var isHidden = false;
var cliCursor = {};
cliCursor.show = (writableStream = import_node_process3.default.stderr) => {
  if (!writableStream.isTTY) {
    return;
  }
  isHidden = false;
  writableStream.write("\x1B[?25h");
};
cliCursor.hide = (writableStream = import_node_process3.default.stderr) => {
  if (!writableStream.isTTY) {
    return;
  }
  restore_cursor_default();
  isHidden = true;
  writableStream.write("\x1B[?25l");
};
cliCursor.toggle = (force, writableStream) => {
  if (force !== void 0) {
    isHidden = force;
  }
  if (isHidden) {
    cliCursor.show(writableStream);
  } else {
    cliCursor.hide(writableStream);
  }
};
var cli_cursor_default = cliCursor;

// node_modules/.pnpm/ora@6.3.0/node_modules/ora/index.js
var import_cli_spinners = __toESM(require_cli_spinners());

// node_modules/.pnpm/log-symbols@5.1.0/node_modules/log-symbols/browser.js
var logSymbols = {
  info: "ℹ️",
  success: "✅",
  warning: "⚠️",
  error: "❌️"
};
var browser_default2 = logSymbols;

// node_modules/.pnpm/ansi-regex@6.0.1/node_modules/ansi-regex/index.js
function ansiRegex({ onlyFirst = false } = {}) {
  const pattern2 = [
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
  ].join("|");
  return new RegExp(pattern2, onlyFirst ? void 0 : "g");
}

// node_modules/.pnpm/strip-ansi@7.0.1/node_modules/strip-ansi/index.js
function stripAnsi(string3) {
  if (typeof string3 !== "string") {
    throw new TypeError(`Expected a \`string\`, got \`${typeof string3}\``);
  }
  return string3.replace(ansiRegex(), "");
}

// node_modules/.pnpm/ora@6.3.0/node_modules/ora/index.js
var import_wcwidth = __toESM(require_wcwidth());

// node_modules/.pnpm/is-interactive@2.0.0/node_modules/is-interactive/index.js
function isInteractive({ stream: stream4 = process.stdout } = {}) {
  return Boolean(
    stream4 && stream4.isTTY && process.env.TERM !== "dumb" && !("CI" in process.env)
  );
}

// node_modules/.pnpm/is-unicode-supported@1.3.0/node_modules/is-unicode-supported/index.js
var import_node_process4 = __toESM(require_node_process());
function isUnicodeSupported() {
  if (import_node_process4.default.platform !== "win32") {
    return import_node_process4.default.env.TERM !== "linux";
  }
  return Boolean(import_node_process4.default.env.CI) || Boolean(import_node_process4.default.env.WT_SESSION) || Boolean(import_node_process4.default.env.TERMINUS_SUBLIME) || import_node_process4.default.env.ConEmuTask === "{cmd::Cmder}" || import_node_process4.default.env.TERM_PROGRAM === "Terminus-Sublime" || import_node_process4.default.env.TERM_PROGRAM === "vscode" || import_node_process4.default.env.TERM === "xterm-256color" || import_node_process4.default.env.TERM === "alacritty" || import_node_process4.default.env.TERMINAL_EMULATOR === "JetBrains-JediTerm";
}

// node_modules/.pnpm/stdin-discarder@0.1.0/node_modules/stdin-discarder/index.js
var import_node_process5 = __toESM(require_node_process());
var import_node_readline = __toESM(require_node_readline());
var import_bl = __toESM(require_bl());
var ASCII_ETX_CODE = 3;
var _requests, _mutedStream, _ourEmit, _rl;
var StdinDiscarder = class {
  constructor() {
    __privateAdd(this, _requests, 0);
    __privateAdd(this, _mutedStream, new import_bl.BufferListStream());
    __privateAdd(this, _ourEmit, void 0);
    __privateAdd(this, _rl, void 0);
    __privateGet(this, _mutedStream).pipe(import_node_process5.default.stdout);
    const self2 = this;
    __privateSet(this, _ourEmit, function(event, data2, ...arguments_) {
      const { stdin } = import_node_process5.default;
      if (__privateGet(self2, _requests) > 0 || stdin.emit === __privateGet(self2, _ourEmit)) {
        if (event === "keypress") {
          return;
        }
        if (event === "data" && data2.includes(ASCII_ETX_CODE)) {
          import_node_process5.default.emit("SIGINT");
        }
        Reflect.apply(__privateGet(self2, _ourEmit), this, [event, data2, ...arguments_]);
      } else {
        Reflect.apply(import_node_process5.default.stdin.emit, this, [event, data2, ...arguments_]);
      }
    });
  }
  start() {
    __privateWrapper(this, _requests)._++;
    if (__privateGet(this, _requests) === 1) {
      this._realStart();
    }
  }
  stop() {
    if (__privateGet(this, _requests) <= 0) {
      throw new Error("`stop` called more times than `start`");
    }
    __privateWrapper(this, _requests)._--;
    if (__privateGet(this, _requests) === 0) {
      this._realStop();
    }
  }
  // TODO: Use private methods when targeting Node.js 14.
  _realStart() {
    if (import_node_process5.default.platform === "win32") {
      return;
    }
    __privateSet(this, _rl, import_node_readline.default.createInterface({
      input: import_node_process5.default.stdin,
      output: __privateGet(this, _mutedStream)
    }));
    __privateGet(this, _rl).on("SIGINT", () => {
      if (import_node_process5.default.listenerCount("SIGINT") === 0) {
        import_node_process5.default.emit("SIGINT");
      } else {
        __privateGet(this, _rl).close();
        import_node_process5.default.kill(import_node_process5.default.pid, "SIGINT");
      }
    });
  }
  _realStop() {
    if (import_node_process5.default.platform === "win32") {
      return;
    }
    __privateGet(this, _rl).close();
    __privateSet(this, _rl, void 0);
  }
};
_requests = new WeakMap();
_mutedStream = new WeakMap();
_ourEmit = new WeakMap();
_rl = new WeakMap();
var stdinDiscarder = new StdinDiscarder();
var stdin_discarder_default = stdinDiscarder;

// node_modules/.pnpm/ora@6.3.0/node_modules/ora/index.js
var import_cli_spinners2 = __toESM(require_cli_spinners());
var _linesToClear, _isDiscardingStdin, _lineCount, _frameIndex, _options, _spinner, _stream, _id, _initialInterval, _isEnabled, _isSilent, _indent, _text, _prefixText, _suffixText;
var Ora = class {
  constructor(options3) {
    __privateAdd(this, _linesToClear, 0);
    __privateAdd(this, _isDiscardingStdin, false);
    __privateAdd(this, _lineCount, 0);
    __privateAdd(this, _frameIndex, 0);
    __privateAdd(this, _options, void 0);
    __privateAdd(this, _spinner, void 0);
    __privateAdd(this, _stream, void 0);
    __privateAdd(this, _id, void 0);
    __privateAdd(this, _initialInterval, void 0);
    __privateAdd(this, _isEnabled, void 0);
    __privateAdd(this, _isSilent, void 0);
    __privateAdd(this, _indent, void 0);
    __privateAdd(this, _text, void 0);
    __privateAdd(this, _prefixText, void 0);
    __privateAdd(this, _suffixText, void 0);
    __publicField(this, "color");
    if (typeof options3 === "string") {
      options3 = {
        text: options3
      };
    }
    __privateSet(this, _options, {
      color: "cyan",
      stream: import_node_process6.default.stderr,
      discardStdin: true,
      hideCursor: true,
      ...options3
    });
    this.color = __privateGet(this, _options).color;
    this.spinner = __privateGet(this, _options).spinner;
    __privateSet(this, _initialInterval, __privateGet(this, _options).interval);
    __privateSet(this, _stream, __privateGet(this, _options).stream);
    __privateSet(this, _isEnabled, typeof __privateGet(this, _options).isEnabled === "boolean" ? __privateGet(this, _options).isEnabled : isInteractive({ stream: __privateGet(this, _stream) }));
    __privateSet(this, _isSilent, typeof __privateGet(this, _options).isSilent === "boolean" ? __privateGet(this, _options).isSilent : false);
    this.text = __privateGet(this, _options).text;
    this.prefixText = __privateGet(this, _options).prefixText;
    this.suffixText = __privateGet(this, _options).suffixText;
    this.indent = __privateGet(this, _options).indent;
    if (import_node_process6.default.env.NODE_ENV === "test") {
      this._stream = __privateGet(this, _stream);
      this._isEnabled = __privateGet(this, _isEnabled);
      Object.defineProperty(this, "_linesToClear", {
        get() {
          return __privateGet(this, _linesToClear);
        },
        set(newValue) {
          __privateSet(this, _linesToClear, newValue);
        }
      });
      Object.defineProperty(this, "_frameIndex", {
        get() {
          return __privateGet(this, _frameIndex);
        }
      });
      Object.defineProperty(this, "_lineCount", {
        get() {
          return __privateGet(this, _lineCount);
        }
      });
    }
  }
  get indent() {
    return __privateGet(this, _indent);
  }
  set indent(indent = 0) {
    if (!(indent >= 0 && Number.isInteger(indent))) {
      throw new Error("The `indent` option must be an integer from 0 and up");
    }
    __privateSet(this, _indent, indent);
    this.updateLineCount();
  }
  get interval() {
    return __privateGet(this, _initialInterval) || __privateGet(this, _spinner).interval || 100;
  }
  get spinner() {
    return __privateGet(this, _spinner);
  }
  set spinner(spinner) {
    __privateSet(this, _frameIndex, 0);
    __privateSet(this, _initialInterval, void 0);
    if (typeof spinner === "object") {
      if (spinner.frames === void 0) {
        throw new Error("The given spinner must have a `frames` property");
      }
      __privateSet(this, _spinner, spinner);
    } else if (!isUnicodeSupported()) {
      __privateSet(this, _spinner, import_cli_spinners.default.line);
    } else if (spinner === void 0) {
      __privateSet(this, _spinner, import_cli_spinners.default.dots);
    } else if (spinner !== "default" && import_cli_spinners.default[spinner]) {
      __privateSet(this, _spinner, import_cli_spinners.default[spinner]);
    } else {
      throw new Error(`There is no built-in spinner named '${spinner}'. See https://github.com/sindresorhus/cli-spinners/blob/main/spinners.json for a full list.`);
    }
  }
  get text() {
    return __privateGet(this, _text);
  }
  set text(value2) {
    __privateSet(this, _text, value2 || "");
    this.updateLineCount();
  }
  get prefixText() {
    return __privateGet(this, _prefixText);
  }
  set prefixText(value2) {
    __privateSet(this, _prefixText, value2 || "");
    this.updateLineCount();
  }
  get suffixText() {
    return __privateGet(this, _suffixText);
  }
  set suffixText(value2) {
    __privateSet(this, _suffixText, value2 || "");
    this.updateLineCount();
  }
  get isSpinning() {
    return __privateGet(this, _id) !== void 0;
  }
  // TODO: Use private methods when targeting Node.js 14.
  getFullPrefixText(prefixText = __privateGet(this, _prefixText), postfix = " ") {
    if (typeof prefixText === "string" && prefixText !== "") {
      return prefixText + postfix;
    }
    if (typeof prefixText === "function") {
      return prefixText() + postfix;
    }
    return "";
  }
  getFullSuffixText(suffixText = __privateGet(this, _suffixText), prefix = " ") {
    if (typeof suffixText === "string" && suffixText !== "") {
      return prefix + suffixText;
    }
    if (typeof suffixText === "function") {
      return prefix + suffixText();
    }
    return "";
  }
  updateLineCount() {
    const columns = __privateGet(this, _stream).columns || 80;
    const fullPrefixText = this.getFullPrefixText(__privateGet(this, _prefixText), "-");
    const fullSuffixText = this.getFullSuffixText(__privateGet(this, _suffixText), "-");
    const fullText = " ".repeat(__privateGet(this, _indent)) + fullPrefixText + "--" + __privateGet(this, _text) + "--" + fullSuffixText;
    __privateSet(this, _lineCount, 0);
    for (const line of stripAnsi(fullText).split("\n")) {
      __privateSet(this, _lineCount, __privateGet(this, _lineCount) + Math.max(1, Math.ceil((0, import_wcwidth.default)(line) / columns)));
    }
  }
  get isEnabled() {
    return __privateGet(this, _isEnabled) && !__privateGet(this, _isSilent);
  }
  set isEnabled(value2) {
    if (typeof value2 !== "boolean") {
      throw new TypeError("The `isEnabled` option must be a boolean");
    }
    __privateSet(this, _isEnabled, value2);
  }
  get isSilent() {
    return __privateGet(this, _isSilent);
  }
  set isSilent(value2) {
    if (typeof value2 !== "boolean") {
      throw new TypeError("The `isSilent` option must be a boolean");
    }
    __privateSet(this, _isSilent, value2);
  }
  frame() {
    const { frames } = __privateGet(this, _spinner);
    let frame = frames[__privateGet(this, _frameIndex)];
    if (this.color) {
      frame = source_default[this.color](frame);
    }
    __privateSet(this, _frameIndex, ++__privateWrapper(this, _frameIndex)._ % frames.length);
    const fullPrefixText = typeof __privateGet(this, _prefixText) === "string" && __privateGet(this, _prefixText) !== "" ? __privateGet(this, _prefixText) + " " : "";
    const fullText = typeof this.text === "string" ? " " + this.text : "";
    const fullSuffixText = typeof __privateGet(this, _suffixText) === "string" && __privateGet(this, _suffixText) !== "" ? " " + __privateGet(this, _suffixText) : "";
    return fullPrefixText + frame + fullText + fullSuffixText;
  }
  clear() {
    if (!__privateGet(this, _isEnabled) || !__privateGet(this, _stream).isTTY) {
      return this;
    }
    __privateGet(this, _stream).cursorTo(0);
    for (let index2 = 0; index2 < __privateGet(this, _linesToClear); index2++) {
      if (index2 > 0) {
        __privateGet(this, _stream).moveCursor(0, -1);
      }
      __privateGet(this, _stream).clearLine(1);
    }
    if (__privateGet(this, _indent) || this.lastIndent !== __privateGet(this, _indent)) {
      __privateGet(this, _stream).cursorTo(__privateGet(this, _indent));
    }
    this.lastIndent = __privateGet(this, _indent);
    __privateSet(this, _linesToClear, 0);
    return this;
  }
  render() {
    if (__privateGet(this, _isSilent)) {
      return this;
    }
    this.clear();
    __privateGet(this, _stream).write(this.frame());
    __privateSet(this, _linesToClear, __privateGet(this, _lineCount));
    return this;
  }
  start(text) {
    if (text) {
      this.text = text;
    }
    if (__privateGet(this, _isSilent)) {
      return this;
    }
    if (!__privateGet(this, _isEnabled)) {
      if (this.text) {
        __privateGet(this, _stream).write(`- ${this.text}
`);
      }
      return this;
    }
    if (this.isSpinning) {
      return this;
    }
    if (__privateGet(this, _options).hideCursor) {
      cli_cursor_default.hide(__privateGet(this, _stream));
    }
    if (__privateGet(this, _options).discardStdin && import_node_process6.default.stdin.isTTY) {
      __privateSet(this, _isDiscardingStdin, true);
      stdin_discarder_default.start();
    }
    this.render();
    __privateSet(this, _id, setInterval(this.render.bind(this), this.interval));
    return this;
  }
  stop() {
    if (!__privateGet(this, _isEnabled)) {
      return this;
    }
    clearInterval(__privateGet(this, _id));
    __privateSet(this, _id, void 0);
    __privateSet(this, _frameIndex, 0);
    this.clear();
    if (__privateGet(this, _options).hideCursor) {
      cli_cursor_default.show(__privateGet(this, _stream));
    }
    if (__privateGet(this, _options).discardStdin && import_node_process6.default.stdin.isTTY && __privateGet(this, _isDiscardingStdin)) {
      stdin_discarder_default.stop();
      __privateSet(this, _isDiscardingStdin, false);
    }
    return this;
  }
  succeed(text) {
    return this.stopAndPersist({ symbol: browser_default2.success, text });
  }
  fail(text) {
    return this.stopAndPersist({ symbol: browser_default2.error, text });
  }
  warn(text) {
    return this.stopAndPersist({ symbol: browser_default2.warning, text });
  }
  info(text) {
    return this.stopAndPersist({ symbol: browser_default2.info, text });
  }
  stopAndPersist(options3 = {}) {
    if (__privateGet(this, _isSilent)) {
      return this;
    }
    const prefixText = options3.prefixText ?? __privateGet(this, _prefixText);
    const fullPrefixText = this.getFullPrefixText(prefixText, " ");
    const symbolText = options3.symbol ?? " ";
    const text = options3.text ?? this.text;
    const fullText = typeof text === "string" ? " " + text : "";
    const suffixText = options3.suffixText ?? __privateGet(this, _suffixText);
    const fullSuffixText = this.getFullSuffixText(suffixText, " ");
    const textToWrite = fullPrefixText + symbolText + fullText + fullSuffixText + "\n";
    this.stop();
    __privateGet(this, _stream).write(textToWrite);
    return this;
  }
};
_linesToClear = new WeakMap();
_isDiscardingStdin = new WeakMap();
_lineCount = new WeakMap();
_frameIndex = new WeakMap();
_options = new WeakMap();
_spinner = new WeakMap();
_stream = new WeakMap();
_id = new WeakMap();
_initialInterval = new WeakMap();
_isEnabled = new WeakMap();
_isSilent = new WeakMap();
_indent = new WeakMap();
_text = new WeakMap();
_prefixText = new WeakMap();
_suffixText = new WeakMap();
function ora(options3) {
  return new Ora(options3);
}

// node_modules/.pnpm/@vuepress+utils@2.0.0-beta.61/node_modules/@vuepress/utils/dist/index.js
var import_picocolors = __toESM(require_picocolors_browser());
var import_upath = __toESM(require_upath());
var import_url = __toESM(require_url());
var import_upath2 = __toESM(require_upath());
var import_url2 = __toESM(require_url());
var import_upath3 = __toESM(require_upath());
var import_picocolors2 = __toESM(require_picocolors_browser());
var import_process = __toESM(require_process());
var importFile = (filePath) => import((0, import_url2.pathToFileURL)(filePath).toString());
var importFileDefault = (filePath) => importFile(filePath).then((m) => m.default);
var formatMs = (ms3) => {
  if (ms3 < 1e3)
    return `${ms3}ms`;
  return `${(ms3 / 1e3).toFixed(2)}s`;
};
var isChildPath = (child, parent) => {
  const childPath = import_upath3.default.normalize(child);
  const parentPath = import_upath3.default.normalize(parent);
  if (!import_upath3.default.win32.isAbsolute(childPath) || !import_upath3.default.win32.isAbsolute(parentPath)) {
    return false;
  }
  const relativePath = import_upath3.default.relative(parentPath, childPath);
  return relativePath === "" || !relativePath.startsWith("..");
};
var info = (...args) => {
  console.log(import_picocolors2.default.cyan("info"), ...args);
};
var tip = (...args) => {
  console.log(import_picocolors2.default.blue("tip"), ...args);
};
var success = (...args) => {
  console.log(import_picocolors2.default.green("success"), ...args);
};
var warn = (...args) => {
  console.warn(import_picocolors2.default.yellow("warning"), ...args);
};
var error = (...args) => {
  console.error(import_picocolors2.default.red("error"), ...args);
};
var createError = (message) => {
  error(message);
  return new Error(message);
};
var logger = {
  info,
  tip,
  success,
  warn,
  error,
  createError
};
var renderHeadAttrs = (attrs) => Object.entries(attrs).filter((item) => item[1] !== false).map(
  ([key, value2]) => value2 === true ? ` ${key}` : ` ${key}="${attrs[key]}"`
).join("");
var renderHead = ([
  tag,
  attrs,
  innerHTML = ""
]) => {
  const openTag = `<${tag}${renderHeadAttrs(attrs)}>`;
  if (tag === "link" || tag === "meta" || tag === "base") {
    return openTag;
  }
  return `${openTag}${innerHTML}</${tag}>`;
};
var INVALID_CHAR_REGEX = /[\x00-\x1F\x7F<>*#"{}|^[\]`;?:&=+$,]/g;
var DRIVE_LETTER_REGEX = /^[a-z]:/i;
var sanitizeFileName = (name2) => {
  var _a;
  const driveLetter = ((_a = DRIVE_LETTER_REGEX.exec(name2)) == null ? void 0 : _a[0]) || "";
  return driveLetter + name2.substring(driveLetter.length).replace(INVALID_CHAR_REGEX, "_").replace(/^_+/, "");
};
var withSpinner = (msg) => async (target) => {
  if (import_process.default.env.DEBUG) {
    return target();
  }
  const start = Date.now();
  const spinner = ora();
  try {
    spinner.start(msg);
    const result = await target(spinner);
    spinner.succeed(`${msg} - done in ${formatMs(Date.now() - start)}`);
    return result;
  } catch (e3) {
    spinner.fail(`${msg} - failed in ${formatMs(Date.now() - start)}`);
    throw e3;
  }
};

// node_modules/.pnpm/vite@4.1.4/node_modules/vite/dist/node/chunks/dep-ca21228b.js
var import_node_fs4 = __toESM(require_node_fs(), 1);
var import_node_path4 = __toESM(require_node_path(), 1);
var import_node_url3 = __toESM(require_node_url(), 1);
var import_node_perf_hooks = __toESM(require_node_perf_hooks(), 1);
var import_node_module = __toESM(require_node_module(), 1);
var import_tty = __toESM(require_tty(), 1);
var import_esbuild = __toESM(require_main(), 1);
var import_path = __toESM(require_path(), 1);
var require$$0$2 = __toESM(require_fs(), 1);
var import_fs = __toESM(require_fs(), 1);
var import_events = __toESM(require_events(), 1);
var import_assert = __toESM(require_assert(), 1);
var import_util = __toESM(require_util(), 1);
var import_net = __toESM(require_net(), 1);
var import_url3 = __toESM(require_url(), 1);
var import_http = __toESM(require_http(), 1);
var import_stream = __toESM(require_stream(), 1);
var import_os = __toESM(require_os(), 1);
var import_child_process = __toESM(require_child_process(), 1);
var import_node_os = __toESM(require_node_os(), 1);
var import_node_crypto = __toESM(require_node_crypto(), 1);
var import_node_util = __toESM(require_node_util(), 1);
var import_node_dns = __toESM(require_node_dns(), 1);
var import_resolve = __toESM(require_resolve(), 1);

// node_modules/.pnpm/vite@4.1.4/node_modules/vite/dist/node/constants.js
var import_node_path3 = __toESM(require_node_path(), 1);
var import_node_url2 = __toESM(require_node_url(), 1);
var import_node_fs3 = __toESM(require_node_fs(), 1);
var { version } = JSON.parse((0, import_node_fs3.readFileSync)(new URL("../../package.json", import.meta.url)).toString());
var VERSION = version;
var DEFAULT_MAIN_FIELDS = [
  "module",
  "jsnext:main",
  "jsnext"
];
var ESBUILD_MODULES_TARGET = [
  "es2020",
  "edge88",
  "firefox78",
  "chrome87",
  "safari14"
];
var DEFAULT_EXTENSIONS = [
  ".mjs",
  ".js",
  ".mts",
  ".ts",
  ".jsx",
  ".tsx",
  ".json"
];
var DEFAULT_CONFIG_FILES = [
  "vite.config.js",
  "vite.config.mjs",
  "vite.config.ts",
  "vite.config.cjs",
  "vite.config.mts",
  "vite.config.cts"
];
var JS_TYPES_RE = /\.(?:j|t)sx?$|\.mjs$/;
var CSS_LANGS_RE = /\.(css|less|sass|scss|styl|stylus|pcss|postcss|sss)(?:$|\?)/;
var OPTIMIZABLE_ENTRY_RE = /\.[cm]?[jt]s$/;
var SPECIAL_QUERY_RE = /[?&](?:worker|sharedworker|raw|url)\b/;
var FS_PREFIX = `/@fs/`;
var VALID_ID_PREFIX = `/@id/`;
var NULL_BYTE_PLACEHOLDER = `__x00__`;
var CLIENT_PUBLIC_PATH = `/@vite/client`;
var ENV_PUBLIC_PATH = `/@vite/env`;
var VITE_PACKAGE_DIR = (0, import_node_path3.resolve)(
  // import.meta.url is `dist/node/constants.js` after bundle
  (0, import_node_url2.fileURLToPath)(import.meta.url),
  "../../.."
);
var CLIENT_ENTRY = (0, import_node_path3.resolve)(VITE_PACKAGE_DIR, "dist/client/client.mjs");
var ENV_ENTRY = (0, import_node_path3.resolve)(VITE_PACKAGE_DIR, "dist/client/env.mjs");
var CLIENT_DIR = import_node_path3.default.dirname(CLIENT_ENTRY);
var KNOWN_ASSET_TYPES = [
  // images
  "png",
  "jpe?g",
  "jfif",
  "pjpeg",
  "pjp",
  "gif",
  "svg",
  "ico",
  "webp",
  "avif",
  // media
  "mp4",
  "webm",
  "ogg",
  "mp3",
  "wav",
  "flac",
  "aac",
  // fonts
  "woff2?",
  "eot",
  "ttf",
  "otf",
  // other
  "webmanifest",
  "pdf",
  "txt"
];
var DEFAULT_ASSETS_RE = new RegExp(`\\.(` + KNOWN_ASSET_TYPES.join("|") + `)(\\?.*)?$`);
var DEP_VERSION_RE = /[?&](v=[\w.-]+)\b/;
var loopbackHosts = /* @__PURE__ */ new Set([
  "localhost",
  "127.0.0.1",
  "::1",
  "0000:0000:0000:0000:0000:0000:0000:0001"
]);
var wildcardHosts = /* @__PURE__ */ new Set([
  "0.0.0.0",
  "::",
  "0000:0000:0000:0000:0000:0000:0000:0000"
]);
var DEFAULT_DEV_PORT = 5173;
var DEFAULT_PREVIEW_PORT = 4173;

// node_modules/.pnpm/vite@4.1.4/node_modules/vite/dist/node/chunks/dep-ca21228b.js
var import_crypto = __toESM(require_crypto(), 1);
var import_node_buffer = __toESM(require_node_buffer(), 1);
var import_module = __toESM(require_module(), 1);
var import_node_assert = __toESM(require_node_assert(), 1);
var import_node_process7 = __toESM(require_node_process(), 1);
var import_node_v8 = __toESM(require_node_v8(), 1);
var import_worker_threads = __toESM(require_worker_threads(), 1);
var import_zlib = __toESM(require_zlib(), 1);
var import_buffer = __toESM(require_buffer(), 1);
var import_https = __toESM(require_https(), 1);
var import_tls = __toESM(require_tls(), 1);
var import_node_http = __toESM(require_node_http(), 1);
var import_node_https = __toESM(require_node_https(), 1);
var qs = __toESM(require_querystring(), 1);
var import_node_child_process = __toESM(require_node_child_process(), 1);
var import_node_readline2 = __toESM(require_node_readline(), 1);
var import_node_zlib = __toESM(require_node_zlib(), 1);
var import_node_url4 = __toESM(require_node_url(), 1);
var import_node_path5 = __toESM(require_node_path(), 1);
var import_node_module2 = __toESM(require_node_module(), 1);
var __filename2 = (0, import_node_url4.fileURLToPath)(import.meta.url);
var __dirname2 = (0, import_node_path5.dirname)(__filename2);
var require2 = (0, import_node_module2.createRequire)(import.meta.url);
var __require2 = require2;
var picocolorsExports = {};
var picocolors = {
  get exports() {
    return picocolorsExports;
  },
  set exports(v) {
    picocolorsExports = v;
  }
};
var tty = import_tty.default;
var isColorSupported = !("NO_COLOR" in process.env || process.argv.includes("--no-color")) && ("FORCE_COLOR" in process.env || process.argv.includes("--color") || process.platform === "win32" || tty.isatty(1) && process.env.TERM !== "dumb" || "CI" in process.env);
var formatter = (open2, close2, replace = open2) => (input) => {
  let string3 = "" + input;
  let index2 = string3.indexOf(close2, open2.length);
  return ~index2 ? open2 + replaceClose(string3, close2, replace, index2) + close2 : open2 + string3 + close2;
};
var replaceClose = (string3, close2, replace, index2) => {
  let start = string3.substring(0, index2) + replace;
  let end = string3.substring(index2 + close2.length);
  let nextIndex2 = end.indexOf(close2);
  return ~nextIndex2 ? start + replaceClose(end, close2, replace, nextIndex2) : start + end;
};
var createColors = (enabled = isColorSupported) => ({
  isColorSupported: enabled,
  reset: enabled ? (s2) => `\x1B[0m${s2}\x1B[0m` : String,
  bold: enabled ? formatter("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m") : String,
  dim: enabled ? formatter("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m") : String,
  italic: enabled ? formatter("\x1B[3m", "\x1B[23m") : String,
  underline: enabled ? formatter("\x1B[4m", "\x1B[24m") : String,
  inverse: enabled ? formatter("\x1B[7m", "\x1B[27m") : String,
  hidden: enabled ? formatter("\x1B[8m", "\x1B[28m") : String,
  strikethrough: enabled ? formatter("\x1B[9m", "\x1B[29m") : String,
  black: enabled ? formatter("\x1B[30m", "\x1B[39m") : String,
  red: enabled ? formatter("\x1B[31m", "\x1B[39m") : String,
  green: enabled ? formatter("\x1B[32m", "\x1B[39m") : String,
  yellow: enabled ? formatter("\x1B[33m", "\x1B[39m") : String,
  blue: enabled ? formatter("\x1B[34m", "\x1B[39m") : String,
  magenta: enabled ? formatter("\x1B[35m", "\x1B[39m") : String,
  cyan: enabled ? formatter("\x1B[36m", "\x1B[39m") : String,
  white: enabled ? formatter("\x1B[37m", "\x1B[39m") : String,
  gray: enabled ? formatter("\x1B[90m", "\x1B[39m") : String,
  bgBlack: enabled ? formatter("\x1B[40m", "\x1B[49m") : String,
  bgRed: enabled ? formatter("\x1B[41m", "\x1B[49m") : String,
  bgGreen: enabled ? formatter("\x1B[42m", "\x1B[49m") : String,
  bgYellow: enabled ? formatter("\x1B[43m", "\x1B[49m") : String,
  bgBlue: enabled ? formatter("\x1B[44m", "\x1B[49m") : String,
  bgMagenta: enabled ? formatter("\x1B[45m", "\x1B[49m") : String,
  bgCyan: enabled ? formatter("\x1B[46m", "\x1B[49m") : String,
  bgWhite: enabled ? formatter("\x1B[47m", "\x1B[49m") : String
});
picocolors.exports = createColors();
picocolorsExports.createColors = createColors;
function matches$1(pattern2, importee) {
  if (pattern2 instanceof RegExp) {
    return pattern2.test(importee);
  }
  if (importee.length < pattern2.length) {
    return false;
  }
  if (importee === pattern2) {
    return true;
  }
  return importee.startsWith(pattern2 + "/");
}
function getEntries({ entries, customResolver }) {
  if (!entries) {
    return [];
  }
  const resolverFunctionFromOptions = resolveCustomResolver(customResolver);
  if (Array.isArray(entries)) {
    return entries.map((entry2) => {
      return {
        find: entry2.find,
        replacement: entry2.replacement,
        resolverFunction: resolveCustomResolver(entry2.customResolver) || resolverFunctionFromOptions
      };
    });
  }
  return Object.entries(entries).map(([key, value2]) => {
    return { find: key, replacement: value2, resolverFunction: resolverFunctionFromOptions };
  });
}
function getHookFunction(hook) {
  if (typeof hook === "function") {
    return hook;
  }
  if (hook && "handler" in hook && typeof hook.handler === "function") {
    return hook.handler;
  }
  return null;
}
function resolveCustomResolver(customResolver) {
  if (typeof customResolver === "function") {
    return customResolver;
  }
  if (customResolver) {
    return getHookFunction(customResolver.resolveId);
  }
  return null;
}
function alias$1(options3 = {}) {
  const entries = getEntries(options3);
  if (entries.length === 0) {
    return {
      name: "alias",
      resolveId: () => null
    };
  }
  return {
    name: "alias",
    async buildStart(inputOptions) {
      await Promise.all([...Array.isArray(options3.entries) ? options3.entries : [], options3].map(({ customResolver }) => {
        var _a;
        return customResolver && ((_a = getHookFunction(customResolver.buildStart)) === null || _a === void 0 ? void 0 : _a.call(this, inputOptions));
      }));
    },
    resolveId(importee, importer, resolveOptions) {
      if (!importer) {
        return null;
      }
      const matchedEntry = entries.find((entry2) => matches$1(entry2.find, importee));
      if (!matchedEntry) {
        return null;
      }
      const updatedId = importee.replace(matchedEntry.find, matchedEntry.replacement);
      if (matchedEntry.resolverFunction) {
        return matchedEntry.resolverFunction.call(this, updatedId, importer, resolveOptions);
      }
      return this.resolve(updatedId, importer, Object.assign({ skipSelf: true }, resolveOptions)).then((resolved) => resolved || { id: updatedId });
    }
  };
}
var WalkerBase$1 = class WalkerBase {
  constructor() {
    this.should_skip = false;
    this.should_remove = false;
    this.replacement = null;
    this.context = {
      skip: () => this.should_skip = true,
      remove: () => this.should_remove = true,
      replace: (node3) => this.replacement = node3
    };
  }
  /**
   *
   * @param {any} parent
   * @param {string} prop
   * @param {number} index
   * @param {BaseNode} node
   */
  replace(parent, prop, index2, node3) {
    if (parent) {
      if (index2 !== null) {
        parent[prop][index2] = node3;
      } else {
        parent[prop] = node3;
      }
    }
  }
  /**
   *
   * @param {any} parent
   * @param {string} prop
   * @param {number} index
   */
  remove(parent, prop, index2) {
    if (parent) {
      if (index2 !== null) {
        parent[prop].splice(index2, 1);
      } else {
        delete parent[prop];
      }
    }
  }
};
var SyncWalker$1 = class SyncWalker extends WalkerBase$1 {
  /**
   *
   * @param {SyncHandler} enter
   * @param {SyncHandler} leave
   */
  constructor(enter, leave) {
    super();
    this.enter = enter;
    this.leave = leave;
  }
  /**
   *
   * @param {BaseNode} node
   * @param {BaseNode} parent
   * @param {string} [prop]
   * @param {number} [index]
   * @returns {BaseNode}
   */
  visit(node3, parent, prop, index2) {
    if (node3) {
      if (this.enter) {
        const _should_skip = this.should_skip;
        const _should_remove = this.should_remove;
        const _replacement = this.replacement;
        this.should_skip = false;
        this.should_remove = false;
        this.replacement = null;
        this.enter.call(this.context, node3, parent, prop, index2);
        if (this.replacement) {
          node3 = this.replacement;
          this.replace(parent, prop, index2, node3);
        }
        if (this.should_remove) {
          this.remove(parent, prop, index2);
        }
        const skipped = this.should_skip;
        const removed = this.should_remove;
        this.should_skip = _should_skip;
        this.should_remove = _should_remove;
        this.replacement = _replacement;
        if (skipped)
          return node3;
        if (removed)
          return null;
      }
      for (const key in node3) {
        const value2 = node3[key];
        if (typeof value2 !== "object") {
          continue;
        } else if (Array.isArray(value2)) {
          for (let i2 = 0; i2 < value2.length; i2 += 1) {
            if (value2[i2] !== null && typeof value2[i2].type === "string") {
              if (!this.visit(value2[i2], node3, key, i2)) {
                i2--;
              }
            }
          }
        } else if (value2 !== null && typeof value2.type === "string") {
          this.visit(value2, node3, key, null);
        }
      }
      if (this.leave) {
        const _replacement = this.replacement;
        const _should_remove = this.should_remove;
        this.replacement = null;
        this.should_remove = false;
        this.leave.call(this.context, node3, parent, prop, index2);
        if (this.replacement) {
          node3 = this.replacement;
          this.replace(parent, prop, index2, node3);
        }
        if (this.should_remove) {
          this.remove(parent, prop, index2);
        }
        const removed = this.should_remove;
        this.replacement = _replacement;
        this.should_remove = _should_remove;
        if (removed)
          return null;
      }
    }
    return node3;
  }
};
function walk$3(ast, { enter, leave }) {
  const instance = new SyncWalker$1(enter, leave);
  return instance.visit(ast, null);
}
var picomatchExports = {};
var picomatch$5 = {
  get exports() {
    return picomatchExports;
  },
  set exports(v) {
    picomatchExports = v;
  }
};
var utils$k = {};
var path$n = import_path.default;
var WIN_SLASH = "\\\\/";
var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
var DOT_LITERAL = "\\.";
var PLUS_LITERAL = "\\+";
var QMARK_LITERAL = "\\?";
var SLASH_LITERAL = "\\/";
var ONE_CHAR = "(?=.)";
var QMARK = "[^/]";
var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
var NO_DOT = `(?!${DOT_LITERAL})`;
var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
var STAR$1 = `${QMARK}*?`;
var POSIX_CHARS = {
  DOT_LITERAL,
  PLUS_LITERAL,
  QMARK_LITERAL,
  SLASH_LITERAL,
  ONE_CHAR,
  QMARK,
  END_ANCHOR,
  DOTS_SLASH,
  NO_DOT,
  NO_DOTS,
  NO_DOT_SLASH,
  NO_DOTS_SLASH,
  QMARK_NO_DOT,
  STAR: STAR$1,
  START_ANCHOR
};
var WINDOWS_CHARS = {
  ...POSIX_CHARS,
  SLASH_LITERAL: `[${WIN_SLASH}]`,
  QMARK: WIN_NO_SLASH,
  STAR: `${WIN_NO_SLASH}*?`,
  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
  NO_DOT: `(?!${DOT_LITERAL})`,
  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
};
var POSIX_REGEX_SOURCE$1 = {
  alnum: "a-zA-Z0-9",
  alpha: "a-zA-Z",
  ascii: "\\x00-\\x7F",
  blank: " \\t",
  cntrl: "\\x00-\\x1F\\x7F",
  digit: "0-9",
  graph: "\\x21-\\x7E",
  lower: "a-z",
  print: "\\x20-\\x7E ",
  punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
  space: " \\t\\r\\n\\v\\f",
  upper: "A-Z",
  word: "A-Za-z0-9_",
  xdigit: "A-Fa-f0-9"
};
var constants$6 = {
  MAX_LENGTH: 1024 * 64,
  POSIX_REGEX_SOURCE: POSIX_REGEX_SOURCE$1,
  // regular expressions
  REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
  REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
  REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
  REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
  // Replace globs with equivalent patterns to reduce parsing time.
  REPLACEMENTS: {
    "***": "*",
    "**/**": "**",
    "**/**/**": "**"
  },
  // Digits
  CHAR_0: 48,
  /* 0 */
  CHAR_9: 57,
  /* 9 */
  // Alphabet chars.
  CHAR_UPPERCASE_A: 65,
  /* A */
  CHAR_LOWERCASE_A: 97,
  /* a */
  CHAR_UPPERCASE_Z: 90,
  /* Z */
  CHAR_LOWERCASE_Z: 122,
  /* z */
  CHAR_LEFT_PARENTHESES: 40,
  /* ( */
  CHAR_RIGHT_PARENTHESES: 41,
  /* ) */
  CHAR_ASTERISK: 42,
  /* * */
  // Non-alphabetic chars.
  CHAR_AMPERSAND: 38,
  /* & */
  CHAR_AT: 64,
  /* @ */
  CHAR_BACKWARD_SLASH: 92,
  /* \ */
  CHAR_CARRIAGE_RETURN: 13,
  /* \r */
  CHAR_CIRCUMFLEX_ACCENT: 94,
  /* ^ */
  CHAR_COLON: 58,
  /* : */
  CHAR_COMMA: 44,
  /* , */
  CHAR_DOT: 46,
  /* . */
  CHAR_DOUBLE_QUOTE: 34,
  /* " */
  CHAR_EQUAL: 61,
  /* = */
  CHAR_EXCLAMATION_MARK: 33,
  /* ! */
  CHAR_FORM_FEED: 12,
  /* \f */
  CHAR_FORWARD_SLASH: 47,
  /* / */
  CHAR_GRAVE_ACCENT: 96,
  /* ` */
  CHAR_HASH: 35,
  /* # */
  CHAR_HYPHEN_MINUS: 45,
  /* - */
  CHAR_LEFT_ANGLE_BRACKET: 60,
  /* < */
  CHAR_LEFT_CURLY_BRACE: 123,
  /* { */
  CHAR_LEFT_SQUARE_BRACKET: 91,
  /* [ */
  CHAR_LINE_FEED: 10,
  /* \n */
  CHAR_NO_BREAK_SPACE: 160,
  /* \u00A0 */
  CHAR_PERCENT: 37,
  /* % */
  CHAR_PLUS: 43,
  /* + */
  CHAR_QUESTION_MARK: 63,
  /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: 62,
  /* > */
  CHAR_RIGHT_CURLY_BRACE: 125,
  /* } */
  CHAR_RIGHT_SQUARE_BRACKET: 93,
  /* ] */
  CHAR_SEMICOLON: 59,
  /* ; */
  CHAR_SINGLE_QUOTE: 39,
  /* ' */
  CHAR_SPACE: 32,
  /*   */
  CHAR_TAB: 9,
  /* \t */
  CHAR_UNDERSCORE: 95,
  /* _ */
  CHAR_VERTICAL_LINE: 124,
  /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
  /* \uFEFF */
  SEP: path$n.sep,
  /**
   * Create EXTGLOB_CHARS
   */
  extglobChars(chars3) {
    return {
      "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars3.STAR})` },
      "?": { type: "qmark", open: "(?:", close: ")?" },
      "+": { type: "plus", open: "(?:", close: ")+" },
      "*": { type: "star", open: "(?:", close: ")*" },
      "@": { type: "at", open: "(?:", close: ")" }
    };
  },
  /**
   * Create GLOB_CHARS
   */
  globChars(win322) {
    return win322 === true ? WINDOWS_CHARS : POSIX_CHARS;
  }
};
(function(exports3) {
  const path8 = import_path.default;
  const win322 = process.platform === "win32";
  const {
    REGEX_BACKSLASH,
    REGEX_REMOVE_BACKSLASH,
    REGEX_SPECIAL_CHARS,
    REGEX_SPECIAL_CHARS_GLOBAL
  } = constants$6;
  exports3.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
  exports3.hasRegexChars = (str2) => REGEX_SPECIAL_CHARS.test(str2);
  exports3.isRegexChar = (str2) => str2.length === 1 && exports3.hasRegexChars(str2);
  exports3.escapeRegex = (str2) => str2.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
  exports3.toPosixSlashes = (str2) => str2.replace(REGEX_BACKSLASH, "/");
  exports3.removeBackslashes = (str2) => {
    return str2.replace(REGEX_REMOVE_BACKSLASH, (match) => {
      return match === "\\" ? "" : match;
    });
  };
  exports3.supportsLookbehinds = () => {
    const segs = process.version.slice(1).split(".").map(Number);
    if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
      return true;
    }
    return false;
  };
  exports3.isWindows = (options3) => {
    if (options3 && typeof options3.windows === "boolean") {
      return options3.windows;
    }
    return win322 === true || path8.sep === "\\";
  };
  exports3.escapeLast = (input, char, lastIdx) => {
    const idx = input.lastIndexOf(char, lastIdx);
    if (idx === -1)
      return input;
    if (input[idx - 1] === "\\")
      return exports3.escapeLast(input, char, idx - 1);
    return `${input.slice(0, idx)}\\${input.slice(idx)}`;
  };
  exports3.removePrefix = (input, state = {}) => {
    let output = input;
    if (output.startsWith("./")) {
      output = output.slice(2);
      state.prefix = "./";
    }
    return output;
  };
  exports3.wrapOutput = (input, state = {}, options3 = {}) => {
    const prepend = options3.contains ? "" : "^";
    const append2 = options3.contains ? "" : "$";
    let output = `${prepend}(?:${input})${append2}`;
    if (state.negated === true) {
      output = `(?:^(?!${output}).*$)`;
    }
    return output;
  };
})(utils$k);
var utils$j = utils$k;
var {
  CHAR_ASTERISK,
  /* * */
  CHAR_AT,
  /* @ */
  CHAR_BACKWARD_SLASH,
  /* \ */
  CHAR_COMMA: CHAR_COMMA$1,
  /* , */
  CHAR_DOT: CHAR_DOT$1,
  /* . */
  CHAR_EXCLAMATION_MARK,
  /* ! */
  CHAR_FORWARD_SLASH,
  /* / */
  CHAR_LEFT_CURLY_BRACE: CHAR_LEFT_CURLY_BRACE$1,
  /* { */
  CHAR_LEFT_PARENTHESES: CHAR_LEFT_PARENTHESES$1,
  /* ( */
  CHAR_LEFT_SQUARE_BRACKET: CHAR_LEFT_SQUARE_BRACKET$1,
  /* [ */
  CHAR_PLUS,
  /* + */
  CHAR_QUESTION_MARK,
  /* ? */
  CHAR_RIGHT_CURLY_BRACE: CHAR_RIGHT_CURLY_BRACE$1,
  /* } */
  CHAR_RIGHT_PARENTHESES: CHAR_RIGHT_PARENTHESES$1,
  /* ) */
  CHAR_RIGHT_SQUARE_BRACKET: CHAR_RIGHT_SQUARE_BRACKET$1
  /* ] */
} = constants$6;
var isPathSeparator = (code) => {
  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
};
var depth = (token) => {
  if (token.isPrefix !== true) {
    token.depth = token.isGlobstar ? Infinity : 1;
  }
};
var scan$2 = (input, options3) => {
  const opts = options3 || {};
  const length = input.length - 1;
  const scanToEnd = opts.parts === true || opts.scanToEnd === true;
  const slashes = [];
  const tokens = [];
  const parts = [];
  let str2 = input;
  let index2 = -1;
  let start = 0;
  let lastIndex = 0;
  let isBrace = false;
  let isBracket = false;
  let isGlob3 = false;
  let isExtglob3 = false;
  let isGlobstar = false;
  let braceEscaped = false;
  let backslashes = false;
  let negated = false;
  let negatedExtglob = false;
  let finished = false;
  let braces2 = 0;
  let prev;
  let code;
  let token = { value: "", depth: 0, isGlob: false };
  const eos = () => index2 >= length;
  const peek = () => str2.charCodeAt(index2 + 1);
  const advance2 = () => {
    prev = code;
    return str2.charCodeAt(++index2);
  };
  while (index2 < length) {
    code = advance2();
    let next;
    if (code === CHAR_BACKWARD_SLASH) {
      backslashes = token.backslashes = true;
      code = advance2();
      if (code === CHAR_LEFT_CURLY_BRACE$1) {
        braceEscaped = true;
      }
      continue;
    }
    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE$1) {
      braces2++;
      while (eos() !== true && (code = advance2())) {
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          advance2();
          continue;
        }
        if (code === CHAR_LEFT_CURLY_BRACE$1) {
          braces2++;
          continue;
        }
        if (braceEscaped !== true && code === CHAR_DOT$1 && (code = advance2()) === CHAR_DOT$1) {
          isBrace = token.isBrace = true;
          isGlob3 = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (braceEscaped !== true && code === CHAR_COMMA$1) {
          isBrace = token.isBrace = true;
          isGlob3 = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_RIGHT_CURLY_BRACE$1) {
          braces2--;
          if (braces2 === 0) {
            braceEscaped = false;
            isBrace = token.isBrace = true;
            finished = true;
            break;
          }
        }
      }
      if (scanToEnd === true) {
        continue;
      }
      break;
    }
    if (code === CHAR_FORWARD_SLASH) {
      slashes.push(index2);
      tokens.push(token);
      token = { value: "", depth: 0, isGlob: false };
      if (finished === true)
        continue;
      if (prev === CHAR_DOT$1 && index2 === start + 1) {
        start += 2;
        continue;
      }
      lastIndex = index2 + 1;
      continue;
    }
    if (opts.noext !== true) {
      const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES$1) {
        isGlob3 = token.isGlob = true;
        isExtglob3 = token.isExtglob = true;
        finished = true;
        if (code === CHAR_EXCLAMATION_MARK && index2 === start) {
          negatedExtglob = true;
        }
        if (scanToEnd === true) {
          while (eos() !== true && (code = advance2())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              code = advance2();
              continue;
            }
            if (code === CHAR_RIGHT_PARENTHESES$1) {
              isGlob3 = token.isGlob = true;
              finished = true;
              break;
            }
          }
          continue;
        }
        break;
      }
    }
    if (code === CHAR_ASTERISK) {
      if (prev === CHAR_ASTERISK)
        isGlobstar = token.isGlobstar = true;
      isGlob3 = token.isGlob = true;
      finished = true;
      if (scanToEnd === true) {
        continue;
      }
      break;
    }
    if (code === CHAR_QUESTION_MARK) {
      isGlob3 = token.isGlob = true;
      finished = true;
      if (scanToEnd === true) {
        continue;
      }
      break;
    }
    if (code === CHAR_LEFT_SQUARE_BRACKET$1) {
      while (eos() !== true && (next = advance2())) {
        if (next === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          advance2();
          continue;
        }
        if (next === CHAR_RIGHT_SQUARE_BRACKET$1) {
          isBracket = token.isBracket = true;
          isGlob3 = token.isGlob = true;
          finished = true;
          break;
        }
      }
      if (scanToEnd === true) {
        continue;
      }
      break;
    }
    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index2 === start) {
      negated = token.negated = true;
      start++;
      continue;
    }
    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES$1) {
      isGlob3 = token.isGlob = true;
      if (scanToEnd === true) {
        while (eos() !== true && (code = advance2())) {
          if (code === CHAR_LEFT_PARENTHESES$1) {
            backslashes = token.backslashes = true;
            code = advance2();
            continue;
          }
          if (code === CHAR_RIGHT_PARENTHESES$1) {
            finished = true;
            break;
          }
        }
        continue;
      }
      break;
    }
    if (isGlob3 === true) {
      finished = true;
      if (scanToEnd === true) {
        continue;
      }
      break;
    }
  }
  if (opts.noext === true) {
    isExtglob3 = false;
    isGlob3 = false;
  }
  let base2 = str2;
  let prefix = "";
  let glob2 = "";
  if (start > 0) {
    prefix = str2.slice(0, start);
    str2 = str2.slice(start);
    lastIndex -= start;
  }
  if (base2 && isGlob3 === true && lastIndex > 0) {
    base2 = str2.slice(0, lastIndex);
    glob2 = str2.slice(lastIndex);
  } else if (isGlob3 === true) {
    base2 = "";
    glob2 = str2;
  } else {
    base2 = str2;
  }
  if (base2 && base2 !== "" && base2 !== "/" && base2 !== str2) {
    if (isPathSeparator(base2.charCodeAt(base2.length - 1))) {
      base2 = base2.slice(0, -1);
    }
  }
  if (opts.unescape === true) {
    if (glob2)
      glob2 = utils$j.removeBackslashes(glob2);
    if (base2 && backslashes === true) {
      base2 = utils$j.removeBackslashes(base2);
    }
  }
  const state = {
    prefix,
    input,
    start,
    base: base2,
    glob: glob2,
    isBrace,
    isBracket,
    isGlob: isGlob3,
    isExtglob: isExtglob3,
    isGlobstar,
    negated,
    negatedExtglob
  };
  if (opts.tokens === true) {
    state.maxDepth = 0;
    if (!isPathSeparator(code)) {
      tokens.push(token);
    }
    state.tokens = tokens;
  }
  if (opts.parts === true || opts.tokens === true) {
    let prevIndex;
    for (let idx = 0; idx < slashes.length; idx++) {
      const n3 = prevIndex ? prevIndex + 1 : start;
      const i2 = slashes[idx];
      const value2 = input.slice(n3, i2);
      if (opts.tokens) {
        if (idx === 0 && start !== 0) {
          tokens[idx].isPrefix = true;
          tokens[idx].value = prefix;
        } else {
          tokens[idx].value = value2;
        }
        depth(tokens[idx]);
        state.maxDepth += tokens[idx].depth;
      }
      if (idx !== 0 || value2 !== "") {
        parts.push(value2);
      }
      prevIndex = i2;
    }
    if (prevIndex && prevIndex + 1 < input.length) {
      const value2 = input.slice(prevIndex + 1);
      parts.push(value2);
      if (opts.tokens) {
        tokens[tokens.length - 1].value = value2;
        depth(tokens[tokens.length - 1]);
        state.maxDepth += tokens[tokens.length - 1].depth;
      }
    }
    state.slashes = slashes;
    state.parts = parts;
  }
  return state;
};
var scan_1 = scan$2;
var constants$5 = constants$6;
var utils$i = utils$k;
var {
  MAX_LENGTH: MAX_LENGTH$1,
  POSIX_REGEX_SOURCE,
  REGEX_NON_SPECIAL_CHARS,
  REGEX_SPECIAL_CHARS_BACKREF,
  REPLACEMENTS
} = constants$5;
var expandRange = (args, options3) => {
  if (typeof options3.expandRange === "function") {
    return options3.expandRange(...args, options3);
  }
  args.sort();
  const value2 = `[${args.join("-")}]`;
  return value2;
};
var syntaxError = (type, char) => {
  return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
};
var parse$h = (input, options3) => {
  if (typeof input !== "string") {
    throw new TypeError("Expected a string");
  }
  input = REPLACEMENTS[input] || input;
  const opts = { ...options3 };
  const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH$1, opts.maxLength) : MAX_LENGTH$1;
  let len = input.length;
  if (len > max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }
  const bos = { type: "bos", value: "", output: opts.prepend || "" };
  const tokens = [bos];
  const capture = opts.capture ? "" : "?:";
  const win322 = utils$i.isWindows(options3);
  const PLATFORM_CHARS = constants$5.globChars(win322);
  const EXTGLOB_CHARS = constants$5.extglobChars(PLATFORM_CHARS);
  const {
    DOT_LITERAL: DOT_LITERAL2,
    PLUS_LITERAL: PLUS_LITERAL2,
    SLASH_LITERAL: SLASH_LITERAL2,
    ONE_CHAR: ONE_CHAR2,
    DOTS_SLASH: DOTS_SLASH2,
    NO_DOT: NO_DOT2,
    NO_DOT_SLASH: NO_DOT_SLASH2,
    NO_DOTS_SLASH: NO_DOTS_SLASH2,
    QMARK: QMARK2,
    QMARK_NO_DOT: QMARK_NO_DOT2,
    STAR: STAR2,
    START_ANCHOR: START_ANCHOR2
  } = PLATFORM_CHARS;
  const globstar = (opts2) => {
    return `(${capture}(?:(?!${START_ANCHOR2}${opts2.dot ? DOTS_SLASH2 : DOT_LITERAL2}).)*?)`;
  };
  const nodot = opts.dot ? "" : NO_DOT2;
  const qmarkNoDot = opts.dot ? QMARK2 : QMARK_NO_DOT2;
  let star2 = opts.bash === true ? globstar(opts) : STAR2;
  if (opts.capture) {
    star2 = `(${star2})`;
  }
  if (typeof opts.noext === "boolean") {
    opts.noextglob = opts.noext;
  }
  const state = {
    input,
    index: -1,
    start: 0,
    dot: opts.dot === true,
    consumed: "",
    output: "",
    prefix: "",
    backtrack: false,
    negated: false,
    brackets: 0,
    braces: 0,
    parens: 0,
    quotes: 0,
    globstar: false,
    tokens
  };
  input = utils$i.removePrefix(input, state);
  len = input.length;
  const extglobs = [];
  const braces2 = [];
  const stack = [];
  let prev = bos;
  let value2;
  const eos = () => state.index === len - 1;
  const peek = state.peek = (n3 = 1) => input[state.index + n3];
  const advance2 = state.advance = () => input[++state.index] || "";
  const remaining = () => input.slice(state.index + 1);
  const consume = (value3 = "", num = 0) => {
    state.consumed += value3;
    state.index += num;
  };
  const append2 = (token) => {
    state.output += token.output != null ? token.output : token.value;
    consume(token.value);
  };
  const negate = () => {
    let count = 1;
    while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
      advance2();
      state.start++;
      count++;
    }
    if (count % 2 === 0) {
      return false;
    }
    state.negated = true;
    state.start++;
    return true;
  };
  const increment = (type) => {
    state[type]++;
    stack.push(type);
  };
  const decrement = (type) => {
    state[type]--;
    stack.pop();
  };
  const push2 = (tok) => {
    if (prev.type === "globstar") {
      const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
      const isExtglob3 = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
      if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob3) {
        state.output = state.output.slice(0, -prev.output.length);
        prev.type = "star";
        prev.value = "*";
        prev.output = star2;
        state.output += prev.output;
      }
    }
    if (extglobs.length && tok.type !== "paren") {
      extglobs[extglobs.length - 1].inner += tok.value;
    }
    if (tok.value || tok.output)
      append2(tok);
    if (prev && prev.type === "text" && tok.type === "text") {
      prev.value += tok.value;
      prev.output = (prev.output || "") + tok.value;
      return;
    }
    tok.prev = prev;
    tokens.push(tok);
    prev = tok;
  };
  const extglobOpen = (type, value3) => {
    const token = { ...EXTGLOB_CHARS[value3], conditions: 1, inner: "" };
    token.prev = prev;
    token.parens = state.parens;
    token.output = state.output;
    const output = (opts.capture ? "(" : "") + token.open;
    increment("parens");
    push2({ type, value: value3, output: state.output ? "" : ONE_CHAR2 });
    push2({ type: "paren", extglob: true, value: advance2(), output });
    extglobs.push(token);
  };
  const extglobClose = (token) => {
    let output = token.close + (opts.capture ? ")" : "");
    let rest;
    if (token.type === "negate") {
      let extglobStar = star2;
      if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
        extglobStar = globstar(opts);
      }
      if (extglobStar !== star2 || eos() || /^\)+$/.test(remaining())) {
        output = token.close = `)$))${extglobStar}`;
      }
      if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
        const expression = parse$h(rest, { ...options3, fastpaths: false }).output;
        output = token.close = `)${expression})${extglobStar})`;
      }
      if (token.prev.type === "bos") {
        state.negatedExtglob = true;
      }
    }
    push2({ type: "paren", extglob: true, value: value2, output });
    decrement("parens");
  };
  if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
    let backslashes = false;
    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars3, first2, rest, index2) => {
      if (first2 === "\\") {
        backslashes = true;
        return m;
      }
      if (first2 === "?") {
        if (esc) {
          return esc + first2 + (rest ? QMARK2.repeat(rest.length) : "");
        }
        if (index2 === 0) {
          return qmarkNoDot + (rest ? QMARK2.repeat(rest.length) : "");
        }
        return QMARK2.repeat(chars3.length);
      }
      if (first2 === ".") {
        return DOT_LITERAL2.repeat(chars3.length);
      }
      if (first2 === "*") {
        if (esc) {
          return esc + first2 + (rest ? star2 : "");
        }
        return star2;
      }
      return esc ? m : `\\${m}`;
    });
    if (backslashes === true) {
      if (opts.unescape === true) {
        output = output.replace(/\\/g, "");
      } else {
        output = output.replace(/\\+/g, (m) => {
          return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
        });
      }
    }
    if (output === input && opts.contains === true) {
      state.output = input;
      return state;
    }
    state.output = utils$i.wrapOutput(output, state, options3);
    return state;
  }
  while (!eos()) {
    value2 = advance2();
    if (value2 === "\0") {
      continue;
    }
    if (value2 === "\\") {
      const next = peek();
      if (next === "/" && opts.bash !== true) {
        continue;
      }
      if (next === "." || next === ";") {
        continue;
      }
      if (!next) {
        value2 += "\\";
        push2({ type: "text", value: value2 });
        continue;
      }
      const match = /^\\+/.exec(remaining());
      let slashes = 0;
      if (match && match[0].length > 2) {
        slashes = match[0].length;
        state.index += slashes;
        if (slashes % 2 !== 0) {
          value2 += "\\";
        }
      }
      if (opts.unescape === true) {
        value2 = advance2();
      } else {
        value2 += advance2();
      }
      if (state.brackets === 0) {
        push2({ type: "text", value: value2 });
        continue;
      }
    }
    if (state.brackets > 0 && (value2 !== "]" || prev.value === "[" || prev.value === "[^")) {
      if (opts.posix !== false && value2 === ":") {
        const inner = prev.value.slice(1);
        if (inner.includes("[")) {
          prev.posix = true;
          if (inner.includes(":")) {
            const idx = prev.value.lastIndexOf("[");
            const pre = prev.value.slice(0, idx);
            const rest2 = prev.value.slice(idx + 2);
            const posix2 = POSIX_REGEX_SOURCE[rest2];
            if (posix2) {
              prev.value = pre + posix2;
              state.backtrack = true;
              advance2();
              if (!bos.output && tokens.indexOf(prev) === 1) {
                bos.output = ONE_CHAR2;
              }
              continue;
            }
          }
        }
      }
      if (value2 === "[" && peek() !== ":" || value2 === "-" && peek() === "]") {
        value2 = `\\${value2}`;
      }
      if (value2 === "]" && (prev.value === "[" || prev.value === "[^")) {
        value2 = `\\${value2}`;
      }
      if (opts.posix === true && value2 === "!" && prev.value === "[") {
        value2 = "^";
      }
      prev.value += value2;
      append2({ value: value2 });
      continue;
    }
    if (state.quotes === 1 && value2 !== '"') {
      value2 = utils$i.escapeRegex(value2);
      prev.value += value2;
      append2({ value: value2 });
      continue;
    }
    if (value2 === '"') {
      state.quotes = state.quotes === 1 ? 0 : 1;
      if (opts.keepQuotes === true) {
        push2({ type: "text", value: value2 });
      }
      continue;
    }
    if (value2 === "(") {
      increment("parens");
      push2({ type: "paren", value: value2 });
      continue;
    }
    if (value2 === ")") {
      if (state.parens === 0 && opts.strictBrackets === true) {
        throw new SyntaxError(syntaxError("opening", "("));
      }
      const extglob = extglobs[extglobs.length - 1];
      if (extglob && state.parens === extglob.parens + 1) {
        extglobClose(extglobs.pop());
        continue;
      }
      push2({ type: "paren", value: value2, output: state.parens ? ")" : "\\)" });
      decrement("parens");
      continue;
    }
    if (value2 === "[") {
      if (opts.nobracket === true || !remaining().includes("]")) {
        if (opts.nobracket !== true && opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError("closing", "]"));
        }
        value2 = `\\${value2}`;
      } else {
        increment("brackets");
      }
      push2({ type: "bracket", value: value2 });
      continue;
    }
    if (value2 === "]") {
      if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
        push2({ type: "text", value: value2, output: `\\${value2}` });
        continue;
      }
      if (state.brackets === 0) {
        if (opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError("opening", "["));
        }
        push2({ type: "text", value: value2, output: `\\${value2}` });
        continue;
      }
      decrement("brackets");
      const prevValue = prev.value.slice(1);
      if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
        value2 = `/${value2}`;
      }
      prev.value += value2;
      append2({ value: value2 });
      if (opts.literalBrackets === false || utils$i.hasRegexChars(prevValue)) {
        continue;
      }
      const escaped2 = utils$i.escapeRegex(prev.value);
      state.output = state.output.slice(0, -prev.value.length);
      if (opts.literalBrackets === true) {
        state.output += escaped2;
        prev.value = escaped2;
        continue;
      }
      prev.value = `(${capture}${escaped2}|${prev.value})`;
      state.output += prev.value;
      continue;
    }
    if (value2 === "{" && opts.nobrace !== true) {
      increment("braces");
      const open2 = {
        type: "brace",
        value: value2,
        output: "(",
        outputIndex: state.output.length,
        tokensIndex: state.tokens.length
      };
      braces2.push(open2);
      push2(open2);
      continue;
    }
    if (value2 === "}") {
      const brace = braces2[braces2.length - 1];
      if (opts.nobrace === true || !brace) {
        push2({ type: "text", value: value2, output: value2 });
        continue;
      }
      let output = ")";
      if (brace.dots === true) {
        const arr = tokens.slice();
        const range2 = [];
        for (let i2 = arr.length - 1; i2 >= 0; i2--) {
          tokens.pop();
          if (arr[i2].type === "brace") {
            break;
          }
          if (arr[i2].type !== "dots") {
            range2.unshift(arr[i2].value);
          }
        }
        output = expandRange(range2, opts);
        state.backtrack = true;
      }
      if (brace.comma !== true && brace.dots !== true) {
        const out2 = state.output.slice(0, brace.outputIndex);
        const toks = state.tokens.slice(brace.tokensIndex);
        brace.value = brace.output = "\\{";
        value2 = output = "\\}";
        state.output = out2;
        for (const t3 of toks) {
          state.output += t3.output || t3.value;
        }
      }
      push2({ type: "brace", value: value2, output });
      decrement("braces");
      braces2.pop();
      continue;
    }
    if (value2 === "|") {
      if (extglobs.length > 0) {
        extglobs[extglobs.length - 1].conditions++;
      }
      push2({ type: "text", value: value2 });
      continue;
    }
    if (value2 === ",") {
      let output = value2;
      const brace = braces2[braces2.length - 1];
      if (brace && stack[stack.length - 1] === "braces") {
        brace.comma = true;
        output = "|";
      }
      push2({ type: "comma", value: value2, output });
      continue;
    }
    if (value2 === "/") {
      if (prev.type === "dot" && state.index === state.start + 1) {
        state.start = state.index + 1;
        state.consumed = "";
        state.output = "";
        tokens.pop();
        prev = bos;
        continue;
      }
      push2({ type: "slash", value: value2, output: SLASH_LITERAL2 });
      continue;
    }
    if (value2 === ".") {
      if (state.braces > 0 && prev.type === "dot") {
        if (prev.value === ".")
          prev.output = DOT_LITERAL2;
        const brace = braces2[braces2.length - 1];
        prev.type = "dots";
        prev.output += value2;
        prev.value += value2;
        brace.dots = true;
        continue;
      }
      if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
        push2({ type: "text", value: value2, output: DOT_LITERAL2 });
        continue;
      }
      push2({ type: "dot", value: value2, output: DOT_LITERAL2 });
      continue;
    }
    if (value2 === "?") {
      const isGroup = prev && prev.value === "(";
      if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
        extglobOpen("qmark", value2);
        continue;
      }
      if (prev && prev.type === "paren") {
        const next = peek();
        let output = value2;
        if (next === "<" && !utils$i.supportsLookbehinds()) {
          throw new Error("Node.js v10 or higher is required for regex lookbehinds");
        }
        if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
          output = `\\${value2}`;
        }
        push2({ type: "text", value: value2, output });
        continue;
      }
      if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
        push2({ type: "qmark", value: value2, output: QMARK_NO_DOT2 });
        continue;
      }
      push2({ type: "qmark", value: value2, output: QMARK2 });
      continue;
    }
    if (value2 === "!") {
      if (opts.noextglob !== true && peek() === "(") {
        if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
          extglobOpen("negate", value2);
          continue;
        }
      }
      if (opts.nonegate !== true && state.index === 0) {
        negate();
        continue;
      }
    }
    if (value2 === "+") {
      if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
        extglobOpen("plus", value2);
        continue;
      }
      if (prev && prev.value === "(" || opts.regex === false) {
        push2({ type: "plus", value: value2, output: PLUS_LITERAL2 });
        continue;
      }
      if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
        push2({ type: "plus", value: value2 });
        continue;
      }
      push2({ type: "plus", value: PLUS_LITERAL2 });
      continue;
    }
    if (value2 === "@") {
      if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
        push2({ type: "at", extglob: true, value: value2, output: "" });
        continue;
      }
      push2({ type: "text", value: value2 });
      continue;
    }
    if (value2 !== "*") {
      if (value2 === "$" || value2 === "^") {
        value2 = `\\${value2}`;
      }
      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
      if (match) {
        value2 += match[0];
        state.index += match[0].length;
      }
      push2({ type: "text", value: value2 });
      continue;
    }
    if (prev && (prev.type === "globstar" || prev.star === true)) {
      prev.type = "star";
      prev.star = true;
      prev.value += value2;
      prev.output = star2;
      state.backtrack = true;
      state.globstar = true;
      consume(value2);
      continue;
    }
    let rest = remaining();
    if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
      extglobOpen("star", value2);
      continue;
    }
    if (prev.type === "star") {
      if (opts.noglobstar === true) {
        consume(value2);
        continue;
      }
      const prior = prev.prev;
      const before = prior.prev;
      const isStart = prior.type === "slash" || prior.type === "bos";
      const afterStar = before && (before.type === "star" || before.type === "globstar");
      if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
        push2({ type: "star", value: value2, output: "" });
        continue;
      }
      const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
      const isExtglob3 = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
      if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob3) {
        push2({ type: "star", value: value2, output: "" });
        continue;
      }
      while (rest.slice(0, 3) === "/**") {
        const after = input[state.index + 4];
        if (after && after !== "/") {
          break;
        }
        rest = rest.slice(3);
        consume("/**", 3);
      }
      if (prior.type === "bos" && eos()) {
        prev.type = "globstar";
        prev.value += value2;
        prev.output = globstar(opts);
        state.output = prev.output;
        state.globstar = true;
        consume(value2);
        continue;
      }
      if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = `(?:${prior.output}`;
        prev.type = "globstar";
        prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
        prev.value += value2;
        state.globstar = true;
        state.output += prior.output + prev.output;
        consume(value2);
        continue;
      }
      if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
        const end = rest[1] !== void 0 ? "|$" : "";
        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = `(?:${prior.output}`;
        prev.type = "globstar";
        prev.output = `${globstar(opts)}${SLASH_LITERAL2}|${SLASH_LITERAL2}${end})`;
        prev.value += value2;
        state.output += prior.output + prev.output;
        state.globstar = true;
        consume(value2 + advance2());
        push2({ type: "slash", value: "/", output: "" });
        continue;
      }
      if (prior.type === "bos" && rest[0] === "/") {
        prev.type = "globstar";
        prev.value += value2;
        prev.output = `(?:^|${SLASH_LITERAL2}|${globstar(opts)}${SLASH_LITERAL2})`;
        state.output = prev.output;
        state.globstar = true;
        consume(value2 + advance2());
        push2({ type: "slash", value: "/", output: "" });
        continue;
      }
      state.output = state.output.slice(0, -prev.output.length);
      prev.type = "globstar";
      prev.output = globstar(opts);
      prev.value += value2;
      state.output += prev.output;
      state.globstar = true;
      consume(value2);
      continue;
    }
    const token = { type: "star", value: value2, output: star2 };
    if (opts.bash === true) {
      token.output = ".*?";
      if (prev.type === "bos" || prev.type === "slash") {
        token.output = nodot + token.output;
      }
      push2(token);
      continue;
    }
    if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
      token.output = value2;
      push2(token);
      continue;
    }
    if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
      if (prev.type === "dot") {
        state.output += NO_DOT_SLASH2;
        prev.output += NO_DOT_SLASH2;
      } else if (opts.dot === true) {
        state.output += NO_DOTS_SLASH2;
        prev.output += NO_DOTS_SLASH2;
      } else {
        state.output += nodot;
        prev.output += nodot;
      }
      if (peek() !== "*") {
        state.output += ONE_CHAR2;
        prev.output += ONE_CHAR2;
      }
    }
    push2(token);
  }
  while (state.brackets > 0) {
    if (opts.strictBrackets === true)
      throw new SyntaxError(syntaxError("closing", "]"));
    state.output = utils$i.escapeLast(state.output, "[");
    decrement("brackets");
  }
  while (state.parens > 0) {
    if (opts.strictBrackets === true)
      throw new SyntaxError(syntaxError("closing", ")"));
    state.output = utils$i.escapeLast(state.output, "(");
    decrement("parens");
  }
  while (state.braces > 0) {
    if (opts.strictBrackets === true)
      throw new SyntaxError(syntaxError("closing", "}"));
    state.output = utils$i.escapeLast(state.output, "{");
    decrement("braces");
  }
  if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
    push2({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL2}?` });
  }
  if (state.backtrack === true) {
    state.output = "";
    for (const token of state.tokens) {
      state.output += token.output != null ? token.output : token.value;
      if (token.suffix) {
        state.output += token.suffix;
      }
    }
  }
  return state;
};
parse$h.fastpaths = (input, options3) => {
  const opts = { ...options3 };
  const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH$1, opts.maxLength) : MAX_LENGTH$1;
  const len = input.length;
  if (len > max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }
  input = REPLACEMENTS[input] || input;
  const win322 = utils$i.isWindows(options3);
  const {
    DOT_LITERAL: DOT_LITERAL2,
    SLASH_LITERAL: SLASH_LITERAL2,
    ONE_CHAR: ONE_CHAR2,
    DOTS_SLASH: DOTS_SLASH2,
    NO_DOT: NO_DOT2,
    NO_DOTS: NO_DOTS2,
    NO_DOTS_SLASH: NO_DOTS_SLASH2,
    STAR: STAR2,
    START_ANCHOR: START_ANCHOR2
  } = constants$5.globChars(win322);
  const nodot = opts.dot ? NO_DOTS2 : NO_DOT2;
  const slashDot = opts.dot ? NO_DOTS_SLASH2 : NO_DOT2;
  const capture = opts.capture ? "" : "?:";
  const state = { negated: false, prefix: "" };
  let star2 = opts.bash === true ? ".*?" : STAR2;
  if (opts.capture) {
    star2 = `(${star2})`;
  }
  const globstar = (opts2) => {
    if (opts2.noglobstar === true)
      return star2;
    return `(${capture}(?:(?!${START_ANCHOR2}${opts2.dot ? DOTS_SLASH2 : DOT_LITERAL2}).)*?)`;
  };
  const create = (str2) => {
    switch (str2) {
      case "*":
        return `${nodot}${ONE_CHAR2}${star2}`;
      case ".*":
        return `${DOT_LITERAL2}${ONE_CHAR2}${star2}`;
      case "*.*":
        return `${nodot}${star2}${DOT_LITERAL2}${ONE_CHAR2}${star2}`;
      case "*/*":
        return `${nodot}${star2}${SLASH_LITERAL2}${ONE_CHAR2}${slashDot}${star2}`;
      case "**":
        return nodot + globstar(opts);
      case "**/*":
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL2})?${slashDot}${ONE_CHAR2}${star2}`;
      case "**/*.*":
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL2})?${slashDot}${star2}${DOT_LITERAL2}${ONE_CHAR2}${star2}`;
      case "**/.*":
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL2})?${DOT_LITERAL2}${ONE_CHAR2}${star2}`;
      default: {
        const match = /^(.*?)\.(\w+)$/.exec(str2);
        if (!match)
          return;
        const source2 = create(match[1]);
        if (!source2)
          return;
        return source2 + DOT_LITERAL2 + match[2];
      }
    }
  };
  const output = utils$i.removePrefix(input, state);
  let source = create(output);
  if (source && opts.strictSlashes !== true) {
    source += `${SLASH_LITERAL2}?`;
  }
  return source;
};
var parse_1$3 = parse$h;
var path$m = import_path.default;
var scan$1 = scan_1;
var parse$g = parse_1$3;
var utils$h = utils$k;
var constants$4 = constants$6;
var isObject$3 = (val) => val && typeof val === "object" && !Array.isArray(val);
var picomatch$4 = (glob2, options3, returnState = false) => {
  if (Array.isArray(glob2)) {
    const fns = glob2.map((input) => picomatch$4(input, options3, returnState));
    const arrayMatcher = (str2) => {
      for (const isMatch2 of fns) {
        const state2 = isMatch2(str2);
        if (state2)
          return state2;
      }
      return false;
    };
    return arrayMatcher;
  }
  const isState = isObject$3(glob2) && glob2.tokens && glob2.input;
  if (glob2 === "" || typeof glob2 !== "string" && !isState) {
    throw new TypeError("Expected pattern to be a non-empty string");
  }
  const opts = options3 || {};
  const posix2 = utils$h.isWindows(options3);
  const regex = isState ? picomatch$4.compileRe(glob2, options3) : picomatch$4.makeRe(glob2, options3, false, true);
  const state = regex.state;
  delete regex.state;
  let isIgnored2 = () => false;
  if (opts.ignore) {
    const ignoreOpts = { ...options3, ignore: null, onMatch: null, onResult: null };
    isIgnored2 = picomatch$4(opts.ignore, ignoreOpts, returnState);
  }
  const matcher2 = (input, returnObject = false) => {
    const { isMatch: isMatch2, match, output } = picomatch$4.test(input, regex, options3, { glob: glob2, posix: posix2 });
    const result = { glob: glob2, state, regex, posix: posix2, input, output, match, isMatch: isMatch2 };
    if (typeof opts.onResult === "function") {
      opts.onResult(result);
    }
    if (isMatch2 === false) {
      result.isMatch = false;
      return returnObject ? result : false;
    }
    if (isIgnored2(input)) {
      if (typeof opts.onIgnore === "function") {
        opts.onIgnore(result);
      }
      result.isMatch = false;
      return returnObject ? result : false;
    }
    if (typeof opts.onMatch === "function") {
      opts.onMatch(result);
    }
    return returnObject ? result : true;
  };
  if (returnState) {
    matcher2.state = state;
  }
  return matcher2;
};
picomatch$4.test = (input, regex, options3, { glob: glob2, posix: posix2 } = {}) => {
  if (typeof input !== "string") {
    throw new TypeError("Expected input to be a string");
  }
  if (input === "") {
    return { isMatch: false, output: "" };
  }
  const opts = options3 || {};
  const format2 = opts.format || (posix2 ? utils$h.toPosixSlashes : null);
  let match = input === glob2;
  let output = match && format2 ? format2(input) : input;
  if (match === false) {
    output = format2 ? format2(input) : input;
    match = output === glob2;
  }
  if (match === false || opts.capture === true) {
    if (opts.matchBase === true || opts.basename === true) {
      match = picomatch$4.matchBase(input, regex, options3, posix2);
    } else {
      match = regex.exec(output);
    }
  }
  return { isMatch: Boolean(match), match, output };
};
picomatch$4.matchBase = (input, glob2, options3, posix2 = utils$h.isWindows(options3)) => {
  const regex = glob2 instanceof RegExp ? glob2 : picomatch$4.makeRe(glob2, options3);
  return regex.test(path$m.basename(input));
};
picomatch$4.isMatch = (str2, patterns2, options3) => picomatch$4(patterns2, options3)(str2);
picomatch$4.parse = (pattern2, options3) => {
  if (Array.isArray(pattern2))
    return pattern2.map((p2) => picomatch$4.parse(p2, options3));
  return parse$g(pattern2, { ...options3, fastpaths: false });
};
picomatch$4.scan = (input, options3) => scan$1(input, options3);
picomatch$4.compileRe = (state, options3, returnOutput = false, returnState = false) => {
  if (returnOutput === true) {
    return state.output;
  }
  const opts = options3 || {};
  const prepend = opts.contains ? "" : "^";
  const append2 = opts.contains ? "" : "$";
  let source = `${prepend}(?:${state.output})${append2}`;
  if (state && state.negated === true) {
    source = `^(?!${source}).*$`;
  }
  const regex = picomatch$4.toRegex(source, options3);
  if (returnState === true) {
    regex.state = state;
  }
  return regex;
};
picomatch$4.makeRe = (input, options3 = {}, returnOutput = false, returnState = false) => {
  if (!input || typeof input !== "string") {
    throw new TypeError("Expected a non-empty string");
  }
  let parsed = { negated: false, fastpaths: true };
  if (options3.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
    parsed.output = parse$g.fastpaths(input, options3);
  }
  if (!parsed.output) {
    parsed = parse$g(input, options3);
  }
  return picomatch$4.compileRe(parsed, options3, returnOutput, returnState);
};
picomatch$4.toRegex = (source, options3) => {
  try {
    const opts = options3 || {};
    return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
  } catch (err2) {
    if (options3 && options3.debug === true)
      throw err2;
    return /$^/;
  }
};
picomatch$4.constants = constants$4;
var picomatch_1 = picomatch$4;
(function(module2) {
  module2.exports = picomatch_1;
})(picomatch$5);
var picomatch$3 = getDefaultExportFromCjs(picomatchExports);
var extractors = {
  ArrayPattern(names, param) {
    for (const element of param.elements) {
      if (element)
        extractors[element.type](names, element);
    }
  },
  AssignmentPattern(names, param) {
    extractors[param.left.type](names, param.left);
  },
  Identifier(names, param) {
    names.push(param.name);
  },
  MemberExpression() {
  },
  ObjectPattern(names, param) {
    for (const prop of param.properties) {
      if (prop.type === "RestElement") {
        extractors.RestElement(names, prop);
      } else {
        extractors[prop.value.type](names, prop.value);
      }
    }
  },
  RestElement(names, param) {
    extractors[param.argument.type](names, param.argument);
  }
};
var extractAssignedNames = function extractAssignedNames2(param) {
  const names = [];
  extractors[param.type](names, param);
  return names;
};
var blockDeclarations = {
  const: true,
  let: true
};
var Scope$1 = class Scope {
  constructor(options3 = {}) {
    this.parent = options3.parent;
    this.isBlockScope = !!options3.block;
    this.declarations = /* @__PURE__ */ Object.create(null);
    if (options3.params) {
      options3.params.forEach((param) => {
        extractAssignedNames(param).forEach((name2) => {
          this.declarations[name2] = true;
        });
      });
    }
  }
  addDeclaration(node3, isBlockDeclaration, isVar) {
    if (!isBlockDeclaration && this.isBlockScope) {
      this.parent.addDeclaration(node3, isBlockDeclaration, isVar);
    } else if (node3.id) {
      extractAssignedNames(node3.id).forEach((name2) => {
        this.declarations[name2] = true;
      });
    }
  }
  contains(name2) {
    return this.declarations[name2] || (this.parent ? this.parent.contains(name2) : false);
  }
};
var attachScopes = function attachScopes2(ast, propertyName = "scope") {
  let scope = new Scope$1();
  walk$3(ast, {
    enter(n3, parent) {
      const node3 = n3;
      if (/(Function|Class)Declaration/.test(node3.type)) {
        scope.addDeclaration(node3, false, false);
      }
      if (node3.type === "VariableDeclaration") {
        const { kind } = node3;
        const isBlockDeclaration = blockDeclarations[kind];
        node3.declarations.forEach((declaration2) => {
          scope.addDeclaration(declaration2, isBlockDeclaration, true);
        });
      }
      let newScope;
      if (/Function/.test(node3.type)) {
        const func = node3;
        newScope = new Scope$1({
          parent: scope,
          block: false,
          params: func.params
        });
        if (func.type === "FunctionExpression" && func.id) {
          newScope.addDeclaration(func, false, false);
        }
      }
      if (/For(In|Of)?Statement/.test(node3.type)) {
        newScope = new Scope$1({
          parent: scope,
          block: true
        });
      }
      if (node3.type === "BlockStatement" && !/Function/.test(parent.type)) {
        newScope = new Scope$1({
          parent: scope,
          block: true
        });
      }
      if (node3.type === "CatchClause") {
        newScope = new Scope$1({
          parent: scope,
          params: node3.param ? [node3.param] : [],
          block: true
        });
      }
      if (newScope) {
        Object.defineProperty(node3, propertyName, {
          value: newScope,
          configurable: true
        });
        scope = newScope;
      }
    },
    leave(n3) {
      const node3 = n3;
      if (node3[propertyName])
        scope = scope.parent;
    }
  });
  return scope;
};
function isArray$2(arg) {
  return Array.isArray(arg);
}
function ensureArray(thing) {
  if (isArray$2(thing))
    return thing;
  if (thing == null)
    return [];
  return [thing];
}
var normalizePath$5 = function normalizePath(filename) {
  return filename.split(import_path.win32.sep).join(import_path.posix.sep);
};
function getMatcherString(id, resolutionBase) {
  if (resolutionBase === false || (0, import_path.isAbsolute)(id) || id.startsWith("*")) {
    return normalizePath$5(id);
  }
  const basePath = normalizePath$5((0, import_path.resolve)(resolutionBase || "")).replace(/[-^$*+?.()|[\]{}]/g, "\\$&");
  return import_path.posix.join(basePath, normalizePath$5(id));
}
var createFilter$1 = function createFilter(include, exclude, options3) {
  const resolutionBase = options3 && options3.resolve;
  const getMatcher = (id) => id instanceof RegExp ? id : {
    test: (what) => {
      const pattern2 = getMatcherString(id, resolutionBase);
      const fn = picomatch$3(pattern2, { dot: true });
      const result = fn(what);
      return result;
    }
  };
  const includeMatchers = ensureArray(include).map(getMatcher);
  const excludeMatchers = ensureArray(exclude).map(getMatcher);
  return function result(id) {
    if (typeof id !== "string")
      return false;
    if (/\0/.test(id))
      return false;
    const pathId = normalizePath$5(id);
    for (let i2 = 0; i2 < excludeMatchers.length; ++i2) {
      const matcher2 = excludeMatchers[i2];
      if (matcher2.test(pathId))
        return false;
    }
    for (let i2 = 0; i2 < includeMatchers.length; ++i2) {
      const matcher2 = includeMatchers[i2];
      if (matcher2.test(pathId))
        return true;
    }
    return !includeMatchers.length;
  };
};
var reservedWords$1 = "break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public";
var builtins$1 = "arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl";
var forbiddenIdentifiers = new Set(`${reservedWords$1} ${builtins$1}`.split(" "));
forbiddenIdentifiers.add("");
var makeLegalIdentifier = function makeLegalIdentifier2(str2) {
  let identifier = str2.replace(/-(\w)/g, (_, letter) => letter.toUpperCase()).replace(/[^$_a-zA-Z0-9]/g, "_");
  if (/\d/.test(identifier[0]) || forbiddenIdentifiers.has(identifier)) {
    identifier = `_${identifier}`;
  }
  return identifier || "_";
};
function stringify$8(obj) {
  return (JSON.stringify(obj) || "undefined").replace(/[\u2028\u2029]/g, (char) => `\\u${`000${char.charCodeAt(0).toString(16)}`.slice(-4)}`);
}
function serializeArray(arr, indent, baseIndent) {
  let output = "[";
  const separator = indent ? `
${baseIndent}${indent}` : "";
  for (let i2 = 0; i2 < arr.length; i2++) {
    const key = arr[i2];
    output += `${i2 > 0 ? "," : ""}${separator}${serialize(key, indent, baseIndent + indent)}`;
  }
  return `${output}${indent ? `
${baseIndent}` : ""}]`;
}
function serializeObject(obj, indent, baseIndent) {
  let output = "{";
  const separator = indent ? `
${baseIndent}${indent}` : "";
  const entries = Object.entries(obj);
  for (let i2 = 0; i2 < entries.length; i2++) {
    const [key, value2] = entries[i2];
    const stringKey = makeLegalIdentifier(key) === key ? key : stringify$8(key);
    output += `${i2 > 0 ? "," : ""}${separator}${stringKey}:${indent ? " " : ""}${serialize(value2, indent, baseIndent + indent)}`;
  }
  return `${output}${indent ? `
${baseIndent}` : ""}}`;
}
function serialize(obj, indent, baseIndent) {
  if (typeof obj === "object" && obj !== null) {
    if (Array.isArray(obj))
      return serializeArray(obj, indent, baseIndent);
    if (obj instanceof Date)
      return `new Date(${obj.getTime()})`;
    if (obj instanceof RegExp)
      return obj.toString();
    return serializeObject(obj, indent, baseIndent);
  }
  if (typeof obj === "number") {
    if (obj === Infinity)
      return "Infinity";
    if (obj === -Infinity)
      return "-Infinity";
    if (obj === 0)
      return 1 / obj === Infinity ? "0" : "-0";
    if (obj !== obj)
      return "NaN";
  }
  if (typeof obj === "symbol") {
    const key = Symbol.keyFor(obj);
    if (key !== void 0)
      return `Symbol.for(${stringify$8(key)})`;
  }
  if (typeof obj === "bigint")
    return `${obj}n`;
  return stringify$8(obj);
}
var dataToEsm = function dataToEsm2(data2, options3 = {}) {
  const t3 = options3.compact ? "" : "indent" in options3 ? options3.indent : "	";
  const _ = options3.compact ? "" : " ";
  const n3 = options3.compact ? "" : "\n";
  const declarationType = options3.preferConst ? "const" : "var";
  if (options3.namedExports === false || typeof data2 !== "object" || Array.isArray(data2) || data2 instanceof Date || data2 instanceof RegExp || data2 === null) {
    const code = serialize(data2, options3.compact ? null : t3, "");
    const magic = _ || (/^[{[\-\/]/.test(code) ? "" : " ");
    return `export default${magic}${code};`;
  }
  let namedExportCode = "";
  const defaultExportRows = [];
  for (const [key, value2] of Object.entries(data2)) {
    if (key === makeLegalIdentifier(key)) {
      if (options3.objectShorthand)
        defaultExportRows.push(key);
      else
        defaultExportRows.push(`${key}:${_}${key}`);
      namedExportCode += `export ${declarationType} ${key}${_}=${_}${serialize(value2, options3.compact ? null : t3, "")};${n3}`;
    } else {
      defaultExportRows.push(`${stringify$8(key)}:${_}${serialize(value2, options3.compact ? null : t3, "")}`);
    }
  }
  return `${namedExportCode}export default${_}{${n3}${t3}${defaultExportRows.join(`,${n3}${t3}`)}${n3}};${n3}`;
};
var path$l = import_path.default;
var commondir = function(basedir, relfiles) {
  if (relfiles) {
    var files = relfiles.map(function(r3) {
      return path$l.resolve(basedir, r3);
    });
  } else {
    var files = basedir;
  }
  var res = files.slice(1).reduce(function(ps, file) {
    if (!file.match(/^([A-Za-z]:)?\/|\\/)) {
      throw new Error("relative path without a basedir");
    }
    var xs = file.split(/\/+|\\+/);
    for (var i2 = 0; ps[i2] === xs[i2] && i2 < Math.min(ps.length, xs.length); i2++)
      ;
    return ps.slice(0, i2);
  }, files[0].split(/\/+|\\+/));
  return res.length > 1 ? res.join("/") : "/";
};
var old$1 = {};
var pathModule = import_path.default;
var isWindows$6 = process.platform === "win32";
var fs$k = import_fs.default;
var DEBUG$1 = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
function rethrow() {
  var callback;
  if (DEBUG$1) {
    var backtrace = new Error();
    callback = debugCallback;
  } else
    callback = missingCallback;
  return callback;
  function debugCallback(err2) {
    if (err2) {
      backtrace.message = err2.message;
      err2 = backtrace;
      missingCallback(err2);
    }
  }
  function missingCallback(err2) {
    if (err2) {
      if (process.throwDeprecation)
        throw err2;
      else if (!process.noDeprecation) {
        var msg = "fs: missing callback " + (err2.stack || err2.message);
        if (process.traceDeprecation)
          console.trace(msg);
        else
          console.error(msg);
      }
    }
  }
}
function maybeCallback(cb) {
  return typeof cb === "function" ? cb : rethrow();
}
if (isWindows$6) {
  nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
} else {
  nextPartRe = /(.*?)(?:[\/]+|$)/g;
}
var nextPartRe;
if (isWindows$6) {
  splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
} else {
  splitRootRe = /^[\/]*/;
}
var splitRootRe;
old$1.realpathSync = function realpathSync(p2, cache2) {
  p2 = pathModule.resolve(p2);
  if (cache2 && Object.prototype.hasOwnProperty.call(cache2, p2)) {
    return cache2[p2];
  }
  var original = p2, seenLinks = {}, knownHard = {};
  var pos;
  var current2;
  var base2;
  var previous;
  start();
  function start() {
    var m = splitRootRe.exec(p2);
    pos = m[0].length;
    current2 = m[0];
    base2 = m[0];
    previous = "";
    if (isWindows$6 && !knownHard[base2]) {
      fs$k.lstatSync(base2);
      knownHard[base2] = true;
    }
  }
  while (pos < p2.length) {
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p2);
    previous = current2;
    current2 += result[0];
    base2 = previous + result[1];
    pos = nextPartRe.lastIndex;
    if (knownHard[base2] || cache2 && cache2[base2] === base2) {
      continue;
    }
    var resolvedLink;
    if (cache2 && Object.prototype.hasOwnProperty.call(cache2, base2)) {
      resolvedLink = cache2[base2];
    } else {
      var stat2 = fs$k.lstatSync(base2);
      if (!stat2.isSymbolicLink()) {
        knownHard[base2] = true;
        if (cache2)
          cache2[base2] = base2;
        continue;
      }
      var linkTarget = null;
      if (!isWindows$6) {
        var id = stat2.dev.toString(32) + ":" + stat2.ino.toString(32);
        if (seenLinks.hasOwnProperty(id)) {
          linkTarget = seenLinks[id];
        }
      }
      if (linkTarget === null) {
        fs$k.statSync(base2);
        linkTarget = fs$k.readlinkSync(base2);
      }
      resolvedLink = pathModule.resolve(previous, linkTarget);
      if (cache2)
        cache2[base2] = resolvedLink;
      if (!isWindows$6)
        seenLinks[id] = linkTarget;
    }
    p2 = pathModule.resolve(resolvedLink, p2.slice(pos));
    start();
  }
  if (cache2)
    cache2[original] = p2;
  return p2;
};
old$1.realpath = function realpath(p2, cache2, cb) {
  if (typeof cb !== "function") {
    cb = maybeCallback(cache2);
    cache2 = null;
  }
  p2 = pathModule.resolve(p2);
  if (cache2 && Object.prototype.hasOwnProperty.call(cache2, p2)) {
    return process.nextTick(cb.bind(null, null, cache2[p2]));
  }
  var original = p2, seenLinks = {}, knownHard = {};
  var pos;
  var current2;
  var base2;
  var previous;
  start();
  function start() {
    var m = splitRootRe.exec(p2);
    pos = m[0].length;
    current2 = m[0];
    base2 = m[0];
    previous = "";
    if (isWindows$6 && !knownHard[base2]) {
      fs$k.lstat(base2, function(err2) {
        if (err2)
          return cb(err2);
        knownHard[base2] = true;
        LOOP();
      });
    } else {
      process.nextTick(LOOP);
    }
  }
  function LOOP() {
    if (pos >= p2.length) {
      if (cache2)
        cache2[original] = p2;
      return cb(null, p2);
    }
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p2);
    previous = current2;
    current2 += result[0];
    base2 = previous + result[1];
    pos = nextPartRe.lastIndex;
    if (knownHard[base2] || cache2 && cache2[base2] === base2) {
      return process.nextTick(LOOP);
    }
    if (cache2 && Object.prototype.hasOwnProperty.call(cache2, base2)) {
      return gotResolvedLink(cache2[base2]);
    }
    return fs$k.lstat(base2, gotStat);
  }
  function gotStat(err2, stat2) {
    if (err2)
      return cb(err2);
    if (!stat2.isSymbolicLink()) {
      knownHard[base2] = true;
      if (cache2)
        cache2[base2] = base2;
      return process.nextTick(LOOP);
    }
    if (!isWindows$6) {
      var id = stat2.dev.toString(32) + ":" + stat2.ino.toString(32);
      if (seenLinks.hasOwnProperty(id)) {
        return gotTarget(null, seenLinks[id], base2);
      }
    }
    fs$k.stat(base2, function(err3) {
      if (err3)
        return cb(err3);
      fs$k.readlink(base2, function(err4, target) {
        if (!isWindows$6)
          seenLinks[id] = target;
        gotTarget(err4, target);
      });
    });
  }
  function gotTarget(err2, target, base3) {
    if (err2)
      return cb(err2);
    var resolvedLink = pathModule.resolve(previous, target);
    if (cache2)
      cache2[base3] = resolvedLink;
    gotResolvedLink(resolvedLink);
  }
  function gotResolvedLink(resolvedLink) {
    p2 = pathModule.resolve(resolvedLink, p2.slice(pos));
    start();
  }
};
var fs_realpath = realpath$2;
realpath$2.realpath = realpath$2;
realpath$2.sync = realpathSync2;
realpath$2.realpathSync = realpathSync2;
realpath$2.monkeypatch = monkeypatch;
realpath$2.unmonkeypatch = unmonkeypatch;
var fs$j = import_fs.default;
var origRealpath = fs$j.realpath;
var origRealpathSync = fs$j.realpathSync;
var version$4 = process.version;
var ok = /^v[0-5]\./.test(version$4);
var old = old$1;
function newError(er) {
  return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
}
function realpath$2(p2, cache2, cb) {
  if (ok) {
    return origRealpath(p2, cache2, cb);
  }
  if (typeof cache2 === "function") {
    cb = cache2;
    cache2 = null;
  }
  origRealpath(p2, cache2, function(er, result) {
    if (newError(er)) {
      old.realpath(p2, cache2, cb);
    } else {
      cb(er, result);
    }
  });
}
function realpathSync2(p2, cache2) {
  if (ok) {
    return origRealpathSync(p2, cache2);
  }
  try {
    return origRealpathSync(p2, cache2);
  } catch (er) {
    if (newError(er)) {
      return old.realpathSync(p2, cache2);
    } else {
      throw er;
    }
  }
}
function monkeypatch() {
  fs$j.realpath = realpath$2;
  fs$j.realpathSync = realpathSync2;
}
function unmonkeypatch() {
  fs$j.realpath = origRealpath;
  fs$j.realpathSync = origRealpathSync;
}
var isWindows$5 = typeof process === "object" && process && process.platform === "win32";
var path$k = isWindows$5 ? { sep: "\\" } : { sep: "/" };
var balancedMatch = balanced$1;
function balanced$1(a2, b, str2) {
  if (a2 instanceof RegExp)
    a2 = maybeMatch(a2, str2);
  if (b instanceof RegExp)
    b = maybeMatch(b, str2);
  var r3 = range$1(a2, b, str2);
  return r3 && {
    start: r3[0],
    end: r3[1],
    pre: str2.slice(0, r3[0]),
    body: str2.slice(r3[0] + a2.length, r3[1]),
    post: str2.slice(r3[1] + b.length)
  };
}
function maybeMatch(reg, str2) {
  var m = str2.match(reg);
  return m ? m[0] : null;
}
balanced$1.range = range$1;
function range$1(a2, b, str2) {
  var begs, beg, left, right, result;
  var ai = str2.indexOf(a2);
  var bi = str2.indexOf(b, ai + 1);
  var i2 = ai;
  if (ai >= 0 && bi > 0) {
    if (a2 === b) {
      return [ai, bi];
    }
    begs = [];
    left = str2.length;
    while (i2 >= 0 && !result) {
      if (i2 == ai) {
        begs.push(i2);
        ai = str2.indexOf(a2, i2 + 1);
      } else if (begs.length == 1) {
        result = [begs.pop(), bi];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }
        bi = str2.indexOf(b, i2 + 1);
      }
      i2 = ai < bi && ai >= 0 ? ai : bi;
    }
    if (begs.length) {
      result = [left, right];
    }
  }
  return result;
}
var balanced = balancedMatch;
var braceExpansion = expandTop;
var escSlash = "\0SLASH" + Math.random() + "\0";
var escOpen = "\0OPEN" + Math.random() + "\0";
var escClose = "\0CLOSE" + Math.random() + "\0";
var escComma = "\0COMMA" + Math.random() + "\0";
var escPeriod = "\0PERIOD" + Math.random() + "\0";
function numeric(str2) {
  return parseInt(str2, 10) == str2 ? parseInt(str2, 10) : str2.charCodeAt(0);
}
function escapeBraces(str2) {
  return str2.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
}
function unescapeBraces(str2) {
  return str2.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
}
function parseCommaParts(str2) {
  if (!str2)
    return [""];
  var parts = [];
  var m = balanced("{", "}", str2);
  if (!m)
    return str2.split(",");
  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p2 = pre.split(",");
  p2[p2.length - 1] += "{" + body + "}";
  var postParts = parseCommaParts(post);
  if (post.length) {
    p2[p2.length - 1] += postParts.shift();
    p2.push.apply(p2, postParts);
  }
  parts.push.apply(parts, p2);
  return parts;
}
function expandTop(str2) {
  if (!str2)
    return [];
  if (str2.substr(0, 2) === "{}") {
    str2 = "\\{\\}" + str2.substr(2);
  }
  return expand$4(escapeBraces(str2), true).map(unescapeBraces);
}
function embrace(str2) {
  return "{" + str2 + "}";
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}
function lte(i2, y) {
  return i2 <= y;
}
function gte(i2, y) {
  return i2 >= y;
}
function expand$4(str2, isTop) {
  var expansions = [];
  var m = balanced("{", "}", str2);
  if (!m)
    return [str2];
  var pre = m.pre;
  var post = m.post.length ? expand$4(m.post, false) : [""];
  if (/\$$/.test(m.pre)) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + "{" + m.body + "}" + post[k];
      expansions.push(expansion);
    }
  } else {
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
    var isSequence = isNumericSequence || isAlphaSequence;
    var isOptions = m.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions) {
      if (m.post.match(/,.*\}/)) {
        str2 = m.pre + "{" + m.body + escClose + m.post;
        return expand$4(str2);
      }
      return [str2];
    }
    var n3;
    if (isSequence) {
      n3 = m.body.split(/\.\./);
    } else {
      n3 = parseCommaParts(m.body);
      if (n3.length === 1) {
        n3 = expand$4(n3[0], false).map(embrace);
        if (n3.length === 1) {
          return post.map(function(p2) {
            return m.pre + n3[0] + p2;
          });
        }
      }
    }
    var N;
    if (isSequence) {
      var x = numeric(n3[0]);
      var y = numeric(n3[1]);
      var width = Math.max(n3[0].length, n3[1].length);
      var incr = n3.length == 3 ? Math.abs(numeric(n3[2])) : 1;
      var test = lte;
      var reverse = y < x;
      if (reverse) {
        incr *= -1;
        test = gte;
      }
      var pad2 = n3.some(isPadded);
      N = [];
      for (var i2 = x; test(i2, y); i2 += incr) {
        var c2;
        if (isAlphaSequence) {
          c2 = String.fromCharCode(i2);
          if (c2 === "\\")
            c2 = "";
        } else {
          c2 = String(i2);
          if (pad2) {
            var need = width - c2.length;
            if (need > 0) {
              var z = new Array(need + 1).join("0");
              if (i2 < 0)
                c2 = "-" + z + c2.slice(1);
              else
                c2 = z + c2;
            }
          }
        }
        N.push(c2);
      }
    } else {
      N = [];
      for (var j = 0; j < n3.length; j++) {
        N.push.apply(N, expand$4(n3[j], false));
      }
    }
    for (var j = 0; j < N.length; j++) {
      for (var k = 0; k < post.length; k++) {
        var expansion = pre + N[j] + post[k];
        if (!isTop || isSequence || expansion)
          expansions.push(expansion);
      }
    }
  }
  return expansions;
}
var minimatch$1 = minimatch_1 = (p2, pattern2, options3 = {}) => {
  assertValidPattern(pattern2);
  if (!options3.nocomment && pattern2.charAt(0) === "#") {
    return false;
  }
  return new Minimatch$1(pattern2, options3).match(p2);
};
var minimatch_1 = minimatch$1;
var path$j = path$k;
minimatch$1.sep = path$j.sep;
var GLOBSTAR$2 = Symbol("globstar **");
minimatch$1.GLOBSTAR = GLOBSTAR$2;
var expand$3 = braceExpansion;
var plTypes = {
  "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
  "?": { open: "(?:", close: ")?" },
  "+": { open: "(?:", close: ")+" },
  "*": { open: "(?:", close: ")*" },
  "@": { open: "(?:", close: ")" }
};
var qmark = "[^/]";
var star = qmark + "*?";
var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
var charSet = (s2) => s2.split("").reduce((set3, c2) => {
  set3[c2] = true;
  return set3;
}, {});
var reSpecials = charSet("().*{}+?[]^$\\!");
var addPatternStartSet = charSet("[.(");
var slashSplit = /\/+/;
minimatch$1.filter = (pattern2, options3 = {}) => (p2, i2, list) => minimatch$1(p2, pattern2, options3);
var ext = (a2, b = {}) => {
  const t3 = {};
  Object.keys(a2).forEach((k) => t3[k] = a2[k]);
  Object.keys(b).forEach((k) => t3[k] = b[k]);
  return t3;
};
minimatch$1.defaults = (def) => {
  if (!def || typeof def !== "object" || !Object.keys(def).length) {
    return minimatch$1;
  }
  const orig = minimatch$1;
  const m = (p2, pattern2, options3) => orig(p2, pattern2, ext(def, options3));
  m.Minimatch = class Minimatch extends orig.Minimatch {
    constructor(pattern2, options3) {
      super(pattern2, ext(def, options3));
    }
  };
  m.Minimatch.defaults = (options3) => orig.defaults(ext(def, options3)).Minimatch;
  m.filter = (pattern2, options3) => orig.filter(pattern2, ext(def, options3));
  m.defaults = (options3) => orig.defaults(ext(def, options3));
  m.makeRe = (pattern2, options3) => orig.makeRe(pattern2, ext(def, options3));
  m.braceExpand = (pattern2, options3) => orig.braceExpand(pattern2, ext(def, options3));
  m.match = (list, pattern2, options3) => orig.match(list, pattern2, ext(def, options3));
  return m;
};
minimatch$1.braceExpand = (pattern2, options3) => braceExpand(pattern2, options3);
var braceExpand = (pattern2, options3 = {}) => {
  assertValidPattern(pattern2);
  if (options3.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern2)) {
    return [pattern2];
  }
  return expand$3(pattern2);
};
var MAX_PATTERN_LENGTH = 1024 * 64;
var assertValidPattern = (pattern2) => {
  if (typeof pattern2 !== "string") {
    throw new TypeError("invalid pattern");
  }
  if (pattern2.length > MAX_PATTERN_LENGTH) {
    throw new TypeError("pattern is too long");
  }
};
var SUBPARSE = Symbol("subparse");
minimatch$1.makeRe = (pattern2, options3) => new Minimatch$1(pattern2, options3 || {}).makeRe();
minimatch$1.match = (list, pattern2, options3 = {}) => {
  const mm = new Minimatch$1(pattern2, options3);
  list = list.filter((f2) => mm.match(f2));
  if (mm.options.nonull && !list.length) {
    list.push(pattern2);
  }
  return list;
};
var globUnescape = (s2) => s2.replace(/\\(.)/g, "$1");
var regExpEscape = (s2) => s2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
var Minimatch$1 = class Minimatch {
  constructor(pattern2, options3) {
    assertValidPattern(pattern2);
    if (!options3)
      options3 = {};
    this.options = options3;
    this.set = [];
    this.pattern = pattern2;
    this.windowsPathsNoEscape = !!options3.windowsPathsNoEscape || options3.allowWindowsEscape === false;
    if (this.windowsPathsNoEscape) {
      this.pattern = this.pattern.replace(/\\/g, "/");
    }
    this.regexp = null;
    this.negate = false;
    this.comment = false;
    this.empty = false;
    this.partial = !!options3.partial;
    this.make();
  }
  debug() {
  }
  make() {
    const pattern2 = this.pattern;
    const options3 = this.options;
    if (!options3.nocomment && pattern2.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern2) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    let set3 = this.globSet = this.braceExpand();
    if (options3.debug)
      this.debug = (...args) => console.error(...args);
    this.debug(this.pattern, set3);
    set3 = this.globParts = set3.map((s2) => s2.split(slashSplit));
    this.debug(this.pattern, set3);
    set3 = set3.map((s2, si, set4) => s2.map(this.parse, this));
    this.debug(this.pattern, set3);
    set3 = set3.filter((s2) => s2.indexOf(false) === -1);
    this.debug(this.pattern, set3);
    this.set = set3;
  }
  parseNegate() {
    if (this.options.nonegate)
      return;
    const pattern2 = this.pattern;
    let negate = false;
    let negateOffset = 0;
    for (let i2 = 0; i2 < pattern2.length && pattern2.charAt(i2) === "!"; i2++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern2.substr(negateOffset);
    this.negate = negate;
  }
  // set partial to true to test if, for example,
  // "/a/b" matches the start of "/*/b/*/d"
  // Partial means, if you run out of file before you run
  // out of pattern, then that's fine, as long as all
  // the parts match.
  matchOne(file, pattern2, partial2) {
    var options3 = this.options;
    this.debug(
      "matchOne",
      { "this": this, file, pattern: pattern2 }
    );
    this.debug("matchOne", file.length, pattern2.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern2.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p2 = pattern2[pi];
      var f2 = file[fi];
      this.debug(pattern2, p2, f2);
      if (p2 === false)
        return false;
      if (p2 === GLOBSTAR$2) {
        this.debug("GLOBSTAR", [pattern2, p2, f2]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (; fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options3.dot && file[fi].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug("\nglobstar while", file, fr, pattern2, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern2.slice(pr), partial2)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options3.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern2, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial2) {
          this.debug("\n>>> no match, partial?", file, fr, pattern2, pr);
          if (fr === fl)
            return true;
        }
        return false;
      }
      var hit;
      if (typeof p2 === "string") {
        hit = f2 === p2;
        this.debug("string match", p2, f2, hit);
      } else {
        hit = f2.match(p2);
        this.debug("pattern match", p2, f2, hit);
      }
      if (!hit)
        return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial2;
    } else if (pi === pl) {
      return fi === fl - 1 && file[fi] === "";
    }
    throw new Error("wtf?");
  }
  braceExpand() {
    return braceExpand(this.pattern, this.options);
  }
  parse(pattern2, isSub) {
    assertValidPattern(pattern2);
    const options3 = this.options;
    if (pattern2 === "**") {
      if (!options3.noglobstar)
        return GLOBSTAR$2;
      else
        pattern2 = "*";
    }
    if (pattern2 === "")
      return "";
    let re = "";
    let hasMagic = !!options3.nocase;
    let escaping = false;
    const patternListStack = [];
    const negativeLists = [];
    let stateChar;
    let inClass = false;
    let reClassStart = -1;
    let classStart = -1;
    let cs;
    let pl;
    let sp;
    const patternStart = pattern2.charAt(0) === "." ? "" : options3.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
    const clearStateChar = () => {
      if (stateChar) {
        switch (stateChar) {
          case "*":
            re += star;
            hasMagic = true;
            break;
          case "?":
            re += qmark;
            hasMagic = true;
            break;
          default:
            re += "\\" + stateChar;
            break;
        }
        this.debug("clearStateChar %j %j", stateChar, re);
        stateChar = false;
      }
    };
    for (let i2 = 0, c2; i2 < pattern2.length && (c2 = pattern2.charAt(i2)); i2++) {
      this.debug("%s	%s %s %j", pattern2, i2, re, c2);
      if (escaping) {
        if (c2 === "/") {
          return false;
        }
        if (reSpecials[c2]) {
          re += "\\";
        }
        re += c2;
        escaping = false;
        continue;
      }
      switch (c2) {
        case "/": {
          return false;
        }
        case "\\":
          clearStateChar();
          escaping = true;
          continue;
        case "?":
        case "*":
        case "+":
        case "@":
        case "!":
          this.debug("%s	%s %s %j <-- stateChar", pattern2, i2, re, c2);
          if (inClass) {
            this.debug("  in class");
            if (c2 === "!" && i2 === classStart + 1)
              c2 = "^";
            re += c2;
            continue;
          }
          this.debug("call clearStateChar %j", stateChar);
          clearStateChar();
          stateChar = c2;
          if (options3.noext)
            clearStateChar();
          continue;
        case "(":
          if (inClass) {
            re += "(";
            continue;
          }
          if (!stateChar) {
            re += "\\(";
            continue;
          }
          patternListStack.push({
            type: stateChar,
            start: i2 - 1,
            reStart: re.length,
            open: plTypes[stateChar].open,
            close: plTypes[stateChar].close
          });
          re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
          this.debug("plType %j %j", stateChar, re);
          stateChar = false;
          continue;
        case ")":
          if (inClass || !patternListStack.length) {
            re += "\\)";
            continue;
          }
          clearStateChar();
          hasMagic = true;
          pl = patternListStack.pop();
          re += pl.close;
          if (pl.type === "!") {
            negativeLists.push(pl);
          }
          pl.reEnd = re.length;
          continue;
        case "|":
          if (inClass || !patternListStack.length) {
            re += "\\|";
            continue;
          }
          clearStateChar();
          re += "|";
          continue;
        case "[":
          clearStateChar();
          if (inClass) {
            re += "\\" + c2;
            continue;
          }
          inClass = true;
          classStart = i2;
          reClassStart = re.length;
          re += c2;
          continue;
        case "]":
          if (i2 === classStart + 1 || !inClass) {
            re += "\\" + c2;
            continue;
          }
          cs = pattern2.substring(classStart + 1, i2);
          hasMagic = true;
          inClass = false;
          re += c2;
          continue;
        default:
          clearStateChar();
          if (reSpecials[c2] && !(c2 === "^" && inClass)) {
            re += "\\";
          }
          re += c2;
          break;
      }
    }
    if (inClass) {
      cs = pattern2.substr(classStart + 1);
      sp = this.parse(cs, SUBPARSE);
      re = re.substr(0, reClassStart) + "\\[" + sp[0];
      hasMagic = hasMagic || sp[1];
    }
    for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
      let tail;
      tail = re.slice(pl.reStart + pl.open.length);
      this.debug("setting tail", re, pl);
      tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_, $1, $2) => {
        if (!$2) {
          $2 = "\\";
        }
        return $1 + $1 + $2 + "|";
      });
      this.debug("tail=%j\n   %s", tail, tail, pl, re);
      const t3 = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
      hasMagic = true;
      re = re.slice(0, pl.reStart) + t3 + "\\(" + tail;
    }
    clearStateChar();
    if (escaping) {
      re += "\\\\";
    }
    const addPatternStart = addPatternStartSet[re.charAt(0)];
    for (let n3 = negativeLists.length - 1; n3 > -1; n3--) {
      const nl = negativeLists[n3];
      const nlBefore = re.slice(0, nl.reStart);
      const nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
      let nlAfter = re.slice(nl.reEnd);
      const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter;
      const openParensBefore = nlBefore.split("(").length - 1;
      let cleanAfter = nlAfter;
      for (let i2 = 0; i2 < openParensBefore; i2++) {
        cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
      }
      nlAfter = cleanAfter;
      const dollar = nlAfter === "" && isSub !== SUBPARSE ? "$" : "";
      re = nlBefore + nlFirst + nlAfter + dollar + nlLast;
    }
    if (re !== "" && hasMagic) {
      re = "(?=.)" + re;
    }
    if (addPatternStart) {
      re = patternStart + re;
    }
    if (isSub === SUBPARSE) {
      return [re, hasMagic];
    }
    if (!hasMagic) {
      return globUnescape(pattern2);
    }
    const flags = options3.nocase ? "i" : "";
    try {
      return Object.assign(new RegExp("^" + re + "$", flags), {
        _glob: pattern2,
        _src: re
      });
    } catch (er) {
      return new RegExp("$.");
    }
  }
  makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    const set3 = this.set;
    if (!set3.length) {
      this.regexp = false;
      return this.regexp;
    }
    const options3 = this.options;
    const twoStar = options3.noglobstar ? star : options3.dot ? twoStarDot : twoStarNoDot;
    const flags = options3.nocase ? "i" : "";
    let re = set3.map((pattern2) => {
      pattern2 = pattern2.map(
        (p2) => typeof p2 === "string" ? regExpEscape(p2) : p2 === GLOBSTAR$2 ? GLOBSTAR$2 : p2._src
      ).reduce((set4, p2) => {
        if (!(set4[set4.length - 1] === GLOBSTAR$2 && p2 === GLOBSTAR$2)) {
          set4.push(p2);
        }
        return set4;
      }, []);
      pattern2.forEach((p2, i2) => {
        if (p2 !== GLOBSTAR$2 || pattern2[i2 - 1] === GLOBSTAR$2) {
          return;
        }
        if (i2 === 0) {
          if (pattern2.length > 1) {
            pattern2[i2 + 1] = "(?:\\/|" + twoStar + "\\/)?" + pattern2[i2 + 1];
          } else {
            pattern2[i2] = twoStar;
          }
        } else if (i2 === pattern2.length - 1) {
          pattern2[i2 - 1] += "(?:\\/|" + twoStar + ")?";
        } else {
          pattern2[i2 - 1] += "(?:\\/|\\/" + twoStar + "\\/)" + pattern2[i2 + 1];
          pattern2[i2 + 1] = GLOBSTAR$2;
        }
      });
      return pattern2.filter((p2) => p2 !== GLOBSTAR$2).join("/");
    }).join("|");
    re = "^(?:" + re + ")$";
    if (this.negate)
      re = "^(?!" + re + ").*$";
    try {
      this.regexp = new RegExp(re, flags);
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  match(f2, partial2 = this.partial) {
    this.debug("match", f2, this.pattern);
    if (this.comment)
      return false;
    if (this.empty)
      return f2 === "";
    if (f2 === "/" && partial2)
      return true;
    const options3 = this.options;
    if (path$j.sep !== "/") {
      f2 = f2.split(path$j.sep).join("/");
    }
    f2 = f2.split(slashSplit);
    this.debug(this.pattern, "split", f2);
    const set3 = this.set;
    this.debug(this.pattern, "set", set3);
    let filename;
    for (let i2 = f2.length - 1; i2 >= 0; i2--) {
      filename = f2[i2];
      if (filename)
        break;
    }
    for (let i2 = 0; i2 < set3.length; i2++) {
      const pattern2 = set3[i2];
      let file = f2;
      if (options3.matchBase && pattern2.length === 1) {
        file = [filename];
      }
      const hit = this.matchOne(file, pattern2, partial2);
      if (hit) {
        if (options3.flipNegate)
          return true;
        return !this.negate;
      }
    }
    if (options3.flipNegate)
      return false;
    return this.negate;
  }
  static defaults(def) {
    return minimatch$1.defaults(def).Minimatch;
  }
};
minimatch$1.Minimatch = Minimatch$1;
var inheritsExports = {};
var inherits = {
  get exports() {
    return inheritsExports;
  },
  set exports(v) {
    inheritsExports = v;
  }
};
var inherits_browserExports = {};
var inherits_browser = {
  get exports() {
    return inherits_browserExports;
  },
  set exports(v) {
    inherits_browserExports = v;
  }
};
var hasRequiredInherits_browser;
function requireInherits_browser() {
  if (hasRequiredInherits_browser)
    return inherits_browserExports;
  hasRequiredInherits_browser = 1;
  if (typeof Object.create === "function") {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return inherits_browserExports;
}
(function(module2) {
  try {
    var util2 = require2("util");
    if (typeof util2.inherits !== "function")
      throw "";
    module2.exports = util2.inherits;
  } catch (e3) {
    module2.exports = requireInherits_browser();
  }
})(inherits);
var common$c = {};
common$c.setopts = setopts;
common$c.ownProp = ownProp;
common$c.makeAbs = makeAbs;
common$c.finish = finish;
common$c.mark = mark;
common$c.isIgnored = isIgnored;
common$c.childrenIgnored = childrenIgnored;
function ownProp(obj, field) {
  return Object.prototype.hasOwnProperty.call(obj, field);
}
var fs$i = import_fs.default;
var path$i = import_path.default;
var minimatch = minimatch_1;
var isAbsolute = import_path.default.isAbsolute;
var Minimatch2 = minimatch.Minimatch;
function alphasort(a2, b) {
  return a2.localeCompare(b, "en");
}
function setupIgnores(self2, options3) {
  self2.ignore = options3.ignore || [];
  if (!Array.isArray(self2.ignore))
    self2.ignore = [self2.ignore];
  if (self2.ignore.length) {
    self2.ignore = self2.ignore.map(ignoreMap);
  }
}
function ignoreMap(pattern2) {
  var gmatcher = null;
  if (pattern2.slice(-3) === "/**") {
    var gpattern = pattern2.replace(/(\/\*\*)+$/, "");
    gmatcher = new Minimatch2(gpattern, { dot: true });
  }
  return {
    matcher: new Minimatch2(pattern2, { dot: true }),
    gmatcher
  };
}
function setopts(self2, pattern2, options3) {
  if (!options3)
    options3 = {};
  if (options3.matchBase && -1 === pattern2.indexOf("/")) {
    if (options3.noglobstar) {
      throw new Error("base matching requires globstar");
    }
    pattern2 = "**/" + pattern2;
  }
  self2.silent = !!options3.silent;
  self2.pattern = pattern2;
  self2.strict = options3.strict !== false;
  self2.realpath = !!options3.realpath;
  self2.realpathCache = options3.realpathCache || /* @__PURE__ */ Object.create(null);
  self2.follow = !!options3.follow;
  self2.dot = !!options3.dot;
  self2.mark = !!options3.mark;
  self2.nodir = !!options3.nodir;
  if (self2.nodir)
    self2.mark = true;
  self2.sync = !!options3.sync;
  self2.nounique = !!options3.nounique;
  self2.nonull = !!options3.nonull;
  self2.nosort = !!options3.nosort;
  self2.nocase = !!options3.nocase;
  self2.stat = !!options3.stat;
  self2.noprocess = !!options3.noprocess;
  self2.absolute = !!options3.absolute;
  self2.fs = options3.fs || fs$i;
  self2.maxLength = options3.maxLength || Infinity;
  self2.cache = options3.cache || /* @__PURE__ */ Object.create(null);
  self2.statCache = options3.statCache || /* @__PURE__ */ Object.create(null);
  self2.symlinks = options3.symlinks || /* @__PURE__ */ Object.create(null);
  setupIgnores(self2, options3);
  self2.changedCwd = false;
  var cwd = process.cwd();
  if (!ownProp(options3, "cwd"))
    self2.cwd = path$i.resolve(cwd);
  else {
    self2.cwd = path$i.resolve(options3.cwd);
    self2.changedCwd = self2.cwd !== cwd;
  }
  self2.root = options3.root || path$i.resolve(self2.cwd, "/");
  self2.root = path$i.resolve(self2.root);
  self2.cwdAbs = isAbsolute(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
  self2.nomount = !!options3.nomount;
  if (process.platform === "win32") {
    self2.root = self2.root.replace(/\\/g, "/");
    self2.cwd = self2.cwd.replace(/\\/g, "/");
    self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
  }
  options3.nonegate = true;
  options3.nocomment = true;
  options3.allowWindowsEscape = true;
  self2.minimatch = new Minimatch2(pattern2, options3);
  self2.options = self2.minimatch.options;
}
function finish(self2) {
  var nou = self2.nounique;
  var all = nou ? [] : /* @__PURE__ */ Object.create(null);
  for (var i2 = 0, l2 = self2.matches.length; i2 < l2; i2++) {
    var matches2 = self2.matches[i2];
    if (!matches2 || Object.keys(matches2).length === 0) {
      if (self2.nonull) {
        var literal2 = self2.minimatch.globSet[i2];
        if (nou)
          all.push(literal2);
        else
          all[literal2] = true;
      }
    } else {
      var m = Object.keys(matches2);
      if (nou)
        all.push.apply(all, m);
      else
        m.forEach(function(m2) {
          all[m2] = true;
        });
    }
  }
  if (!nou)
    all = Object.keys(all);
  if (!self2.nosort)
    all = all.sort(alphasort);
  if (self2.mark) {
    for (var i2 = 0; i2 < all.length; i2++) {
      all[i2] = self2._mark(all[i2]);
    }
    if (self2.nodir) {
      all = all.filter(function(e3) {
        var notDir = !/\/$/.test(e3);
        var c2 = self2.cache[e3] || self2.cache[makeAbs(self2, e3)];
        if (notDir && c2)
          notDir = c2 !== "DIR" && !Array.isArray(c2);
        return notDir;
      });
    }
  }
  if (self2.ignore.length)
    all = all.filter(function(m2) {
      return !isIgnored(self2, m2);
    });
  self2.found = all;
}
function mark(self2, p2) {
  var abs = makeAbs(self2, p2);
  var c2 = self2.cache[abs];
  var m = p2;
  if (c2) {
    var isDir = c2 === "DIR" || Array.isArray(c2);
    var slash4 = p2.slice(-1) === "/";
    if (isDir && !slash4)
      m += "/";
    else if (!isDir && slash4)
      m = m.slice(0, -1);
    if (m !== p2) {
      var mabs = makeAbs(self2, m);
      self2.statCache[mabs] = self2.statCache[abs];
      self2.cache[mabs] = self2.cache[abs];
    }
  }
  return m;
}
function makeAbs(self2, f2) {
  var abs = f2;
  if (f2.charAt(0) === "/") {
    abs = path$i.join(self2.root, f2);
  } else if (isAbsolute(f2) || f2 === "") {
    abs = f2;
  } else if (self2.changedCwd) {
    abs = path$i.resolve(self2.cwd, f2);
  } else {
    abs = path$i.resolve(f2);
  }
  if (process.platform === "win32")
    abs = abs.replace(/\\/g, "/");
  return abs;
}
function isIgnored(self2, path8) {
  if (!self2.ignore.length)
    return false;
  return self2.ignore.some(function(item) {
    return item.matcher.match(path8) || !!(item.gmatcher && item.gmatcher.match(path8));
  });
}
function childrenIgnored(self2, path8) {
  if (!self2.ignore.length)
    return false;
  return self2.ignore.some(function(item) {
    return !!(item.gmatcher && item.gmatcher.match(path8));
  });
}
var sync$9;
var hasRequiredSync;
function requireSync() {
  if (hasRequiredSync)
    return sync$9;
  hasRequiredSync = 1;
  sync$9 = globSync;
  globSync.GlobSync = GlobSync;
  var rp = fs_realpath;
  var minimatch2 = minimatch_1;
  requireGlob().Glob;
  var path8 = import_path.default;
  var assert2 = import_assert.default;
  var isAbsolute2 = import_path.default.isAbsolute;
  var common3 = common$c;
  var setopts2 = common3.setopts;
  var ownProp2 = common3.ownProp;
  var childrenIgnored2 = common3.childrenIgnored;
  var isIgnored2 = common3.isIgnored;
  function globSync(pattern2, options3) {
    if (typeof options3 === "function" || arguments.length === 3)
      throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
    return new GlobSync(pattern2, options3).found;
  }
  function GlobSync(pattern2, options3) {
    if (!pattern2)
      throw new Error("must provide pattern");
    if (typeof options3 === "function" || arguments.length === 3)
      throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
    if (!(this instanceof GlobSync))
      return new GlobSync(pattern2, options3);
    setopts2(this, pattern2, options3);
    if (this.noprocess)
      return this;
    var n3 = this.minimatch.set.length;
    this.matches = new Array(n3);
    for (var i2 = 0; i2 < n3; i2++) {
      this._process(this.minimatch.set[i2], i2, false);
    }
    this._finish();
  }
  GlobSync.prototype._finish = function() {
    assert2.ok(this instanceof GlobSync);
    if (this.realpath) {
      var self2 = this;
      this.matches.forEach(function(matchset, index2) {
        var set3 = self2.matches[index2] = /* @__PURE__ */ Object.create(null);
        for (var p2 in matchset) {
          try {
            p2 = self2._makeAbs(p2);
            var real = rp.realpathSync(p2, self2.realpathCache);
            set3[real] = true;
          } catch (er) {
            if (er.syscall === "stat")
              set3[self2._makeAbs(p2)] = true;
            else
              throw er;
          }
        }
      });
    }
    common3.finish(this);
  };
  GlobSync.prototype._process = function(pattern2, index2, inGlobStar) {
    assert2.ok(this instanceof GlobSync);
    var n3 = 0;
    while (typeof pattern2[n3] === "string") {
      n3++;
    }
    var prefix;
    switch (n3) {
      case pattern2.length:
        this._processSimple(pattern2.join("/"), index2);
        return;
      case 0:
        prefix = null;
        break;
      default:
        prefix = pattern2.slice(0, n3).join("/");
        break;
    }
    var remain = pattern2.slice(n3);
    var read2;
    if (prefix === null)
      read2 = ".";
    else if (isAbsolute2(prefix) || isAbsolute2(pattern2.map(function(p2) {
      return typeof p2 === "string" ? p2 : "[*]";
    }).join("/"))) {
      if (!prefix || !isAbsolute2(prefix))
        prefix = "/" + prefix;
      read2 = prefix;
    } else
      read2 = prefix;
    var abs = this._makeAbs(read2);
    if (childrenIgnored2(this, read2))
      return;
    var isGlobStar = remain[0] === minimatch2.GLOBSTAR;
    if (isGlobStar)
      this._processGlobStar(prefix, read2, abs, remain, index2, inGlobStar);
    else
      this._processReaddir(prefix, read2, abs, remain, index2, inGlobStar);
  };
  GlobSync.prototype._processReaddir = function(prefix, read2, abs, remain, index2, inGlobStar) {
    var entries = this._readdir(abs, inGlobStar);
    if (!entries)
      return;
    var pn = remain[0];
    var negate = !!this.minimatch.negate;
    var rawGlob = pn._glob;
    var dotOk = this.dot || rawGlob.charAt(0) === ".";
    var matchedEntries = [];
    for (var i2 = 0; i2 < entries.length; i2++) {
      var e3 = entries[i2];
      if (e3.charAt(0) !== "." || dotOk) {
        var m;
        if (negate && !prefix) {
          m = !e3.match(pn);
        } else {
          m = e3.match(pn);
        }
        if (m)
          matchedEntries.push(e3);
      }
    }
    var len = matchedEntries.length;
    if (len === 0)
      return;
    if (remain.length === 1 && !this.mark && !this.stat) {
      if (!this.matches[index2])
        this.matches[index2] = /* @__PURE__ */ Object.create(null);
      for (var i2 = 0; i2 < len; i2++) {
        var e3 = matchedEntries[i2];
        if (prefix) {
          if (prefix.slice(-1) !== "/")
            e3 = prefix + "/" + e3;
          else
            e3 = prefix + e3;
        }
        if (e3.charAt(0) === "/" && !this.nomount) {
          e3 = path8.join(this.root, e3);
        }
        this._emitMatch(index2, e3);
      }
      return;
    }
    remain.shift();
    for (var i2 = 0; i2 < len; i2++) {
      var e3 = matchedEntries[i2];
      var newPattern;
      if (prefix)
        newPattern = [prefix, e3];
      else
        newPattern = [e3];
      this._process(newPattern.concat(remain), index2, inGlobStar);
    }
  };
  GlobSync.prototype._emitMatch = function(index2, e3) {
    if (isIgnored2(this, e3))
      return;
    var abs = this._makeAbs(e3);
    if (this.mark)
      e3 = this._mark(e3);
    if (this.absolute) {
      e3 = abs;
    }
    if (this.matches[index2][e3])
      return;
    if (this.nodir) {
      var c2 = this.cache[abs];
      if (c2 === "DIR" || Array.isArray(c2))
        return;
    }
    this.matches[index2][e3] = true;
    if (this.stat)
      this._stat(e3);
  };
  GlobSync.prototype._readdirInGlobStar = function(abs) {
    if (this.follow)
      return this._readdir(abs, false);
    var entries;
    var lstat2;
    try {
      lstat2 = this.fs.lstatSync(abs);
    } catch (er) {
      if (er.code === "ENOENT") {
        return null;
      }
    }
    var isSym = lstat2 && lstat2.isSymbolicLink();
    this.symlinks[abs] = isSym;
    if (!isSym && lstat2 && !lstat2.isDirectory())
      this.cache[abs] = "FILE";
    else
      entries = this._readdir(abs, false);
    return entries;
  };
  GlobSync.prototype._readdir = function(abs, inGlobStar) {
    if (inGlobStar && !ownProp2(this.symlinks, abs))
      return this._readdirInGlobStar(abs);
    if (ownProp2(this.cache, abs)) {
      var c2 = this.cache[abs];
      if (!c2 || c2 === "FILE")
        return null;
      if (Array.isArray(c2))
        return c2;
    }
    try {
      return this._readdirEntries(abs, this.fs.readdirSync(abs));
    } catch (er) {
      this._readdirError(abs, er);
      return null;
    }
  };
  GlobSync.prototype._readdirEntries = function(abs, entries) {
    if (!this.mark && !this.stat) {
      for (var i2 = 0; i2 < entries.length; i2++) {
        var e3 = entries[i2];
        if (abs === "/")
          e3 = abs + e3;
        else
          e3 = abs + "/" + e3;
        this.cache[e3] = true;
      }
    }
    this.cache[abs] = entries;
    return entries;
  };
  GlobSync.prototype._readdirError = function(f2, er) {
    switch (er.code) {
      case "ENOTSUP":
      case "ENOTDIR":
        var abs = this._makeAbs(f2);
        this.cache[abs] = "FILE";
        if (abs === this.cwdAbs) {
          var error3 = new Error(er.code + " invalid cwd " + this.cwd);
          error3.path = this.cwd;
          error3.code = er.code;
          throw error3;
        }
        break;
      case "ENOENT":
      case "ELOOP":
      case "ENAMETOOLONG":
      case "UNKNOWN":
        this.cache[this._makeAbs(f2)] = false;
        break;
      default:
        this.cache[this._makeAbs(f2)] = false;
        if (this.strict)
          throw er;
        if (!this.silent)
          console.error("glob error", er);
        break;
    }
  };
  GlobSync.prototype._processGlobStar = function(prefix, read2, abs, remain, index2, inGlobStar) {
    var entries = this._readdir(abs, inGlobStar);
    if (!entries)
      return;
    var remainWithoutGlobStar = remain.slice(1);
    var gspref = prefix ? [prefix] : [];
    var noGlobStar = gspref.concat(remainWithoutGlobStar);
    this._process(noGlobStar, index2, false);
    var len = entries.length;
    var isSym = this.symlinks[abs];
    if (isSym && inGlobStar)
      return;
    for (var i2 = 0; i2 < len; i2++) {
      var e3 = entries[i2];
      if (e3.charAt(0) === "." && !this.dot)
        continue;
      var instead = gspref.concat(entries[i2], remainWithoutGlobStar);
      this._process(instead, index2, true);
      var below = gspref.concat(entries[i2], remain);
      this._process(below, index2, true);
    }
  };
  GlobSync.prototype._processSimple = function(prefix, index2) {
    var exists = this._stat(prefix);
    if (!this.matches[index2])
      this.matches[index2] = /* @__PURE__ */ Object.create(null);
    if (!exists)
      return;
    if (prefix && isAbsolute2(prefix) && !this.nomount) {
      var trail = /[\/\\]$/.test(prefix);
      if (prefix.charAt(0) === "/") {
        prefix = path8.join(this.root, prefix);
      } else {
        prefix = path8.resolve(this.root, prefix);
        if (trail)
          prefix += "/";
      }
    }
    if (process.platform === "win32")
      prefix = prefix.replace(/\\/g, "/");
    this._emitMatch(index2, prefix);
  };
  GlobSync.prototype._stat = function(f2) {
    var abs = this._makeAbs(f2);
    var needDir = f2.slice(-1) === "/";
    if (f2.length > this.maxLength)
      return false;
    if (!this.stat && ownProp2(this.cache, abs)) {
      var c2 = this.cache[abs];
      if (Array.isArray(c2))
        c2 = "DIR";
      if (!needDir || c2 === "DIR")
        return c2;
      if (needDir && c2 === "FILE")
        return false;
    }
    var stat2 = this.statCache[abs];
    if (!stat2) {
      var lstat2;
      try {
        lstat2 = this.fs.lstatSync(abs);
      } catch (er) {
        if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
          this.statCache[abs] = false;
          return false;
        }
      }
      if (lstat2 && lstat2.isSymbolicLink()) {
        try {
          stat2 = this.fs.statSync(abs);
        } catch (er) {
          stat2 = lstat2;
        }
      } else {
        stat2 = lstat2;
      }
    }
    this.statCache[abs] = stat2;
    var c2 = true;
    if (stat2)
      c2 = stat2.isDirectory() ? "DIR" : "FILE";
    this.cache[abs] = this.cache[abs] || c2;
    if (needDir && c2 === "FILE")
      return false;
    return c2;
  };
  GlobSync.prototype._mark = function(p2) {
    return common3.mark(this, p2);
  };
  GlobSync.prototype._makeAbs = function(f2) {
    return common3.makeAbs(this, f2);
  };
  return sync$9;
}
var wrappy_1 = wrappy$2;
function wrappy$2(fn, cb) {
  if (fn && cb)
    return wrappy$2(fn)(cb);
  if (typeof fn !== "function")
    throw new TypeError("need wrapper function");
  Object.keys(fn).forEach(function(k) {
    wrapper[k] = fn[k];
  });
  return wrapper;
  function wrapper() {
    var args = new Array(arguments.length);
    for (var i2 = 0; i2 < args.length; i2++) {
      args[i2] = arguments[i2];
    }
    var ret = fn.apply(this, args);
    var cb2 = args[args.length - 1];
    if (typeof ret === "function" && ret !== cb2) {
      Object.keys(cb2).forEach(function(k) {
        ret[k] = cb2[k];
      });
    }
    return ret;
  }
}
var onceExports = {};
var once$2 = {
  get exports() {
    return onceExports;
  },
  set exports(v) {
    onceExports = v;
  }
};
var wrappy$1 = wrappy_1;
once$2.exports = wrappy$1(once$1);
onceExports.strict = wrappy$1(onceStrict);
once$1.proto = once$1(function() {
  Object.defineProperty(Function.prototype, "once", {
    value: function() {
      return once$1(this);
    },
    configurable: true
  });
  Object.defineProperty(Function.prototype, "onceStrict", {
    value: function() {
      return onceStrict(this);
    },
    configurable: true
  });
});
function once$1(fn) {
  var f2 = function() {
    if (f2.called)
      return f2.value;
    f2.called = true;
    return f2.value = fn.apply(this, arguments);
  };
  f2.called = false;
  return f2;
}
function onceStrict(fn) {
  var f2 = function() {
    if (f2.called)
      throw new Error(f2.onceError);
    f2.called = true;
    return f2.value = fn.apply(this, arguments);
  };
  var name2 = fn.name || "Function wrapped with `once`";
  f2.onceError = name2 + " shouldn't be called more than once";
  f2.called = false;
  return f2;
}
var wrappy = wrappy_1;
var reqs = /* @__PURE__ */ Object.create(null);
var once = onceExports;
var inflight_1 = wrappy(inflight);
function inflight(key, cb) {
  if (reqs[key]) {
    reqs[key].push(cb);
    return null;
  } else {
    reqs[key] = [cb];
    return makeres(key);
  }
}
function makeres(key) {
  return once(function RES() {
    var cbs = reqs[key];
    var len = cbs.length;
    var args = slice$1(arguments);
    try {
      for (var i2 = 0; i2 < len; i2++) {
        cbs[i2].apply(null, args);
      }
    } finally {
      if (cbs.length > len) {
        cbs.splice(0, len);
        process.nextTick(function() {
          RES.apply(null, args);
        });
      } else {
        delete reqs[key];
      }
    }
  });
}
function slice$1(args) {
  var length = args.length;
  var array2 = [];
  for (var i2 = 0; i2 < length; i2++)
    array2[i2] = args[i2];
  return array2;
}
var glob_1;
var hasRequiredGlob;
function requireGlob() {
  if (hasRequiredGlob)
    return glob_1;
  hasRequiredGlob = 1;
  glob_1 = glob2;
  var rp = fs_realpath;
  var minimatch2 = minimatch_1;
  var inherits2 = inheritsExports;
  var EE = import_events.default.EventEmitter;
  var path8 = import_path.default;
  var assert2 = import_assert.default;
  var isAbsolute2 = import_path.default.isAbsolute;
  var globSync = requireSync();
  var common3 = common$c;
  var setopts2 = common3.setopts;
  var ownProp2 = common3.ownProp;
  var inflight2 = inflight_1;
  var childrenIgnored2 = common3.childrenIgnored;
  var isIgnored2 = common3.isIgnored;
  var once2 = onceExports;
  function glob2(pattern2, options3, cb) {
    if (typeof options3 === "function")
      cb = options3, options3 = {};
    if (!options3)
      options3 = {};
    if (options3.sync) {
      if (cb)
        throw new TypeError("callback provided to sync glob");
      return globSync(pattern2, options3);
    }
    return new Glob(pattern2, options3, cb);
  }
  glob2.sync = globSync;
  var GlobSync = glob2.GlobSync = globSync.GlobSync;
  glob2.glob = glob2;
  function extend2(origin, add) {
    if (add === null || typeof add !== "object") {
      return origin;
    }
    var keys = Object.keys(add);
    var i2 = keys.length;
    while (i2--) {
      origin[keys[i2]] = add[keys[i2]];
    }
    return origin;
  }
  glob2.hasMagic = function(pattern2, options_) {
    var options3 = extend2({}, options_);
    options3.noprocess = true;
    var g = new Glob(pattern2, options3);
    var set3 = g.minimatch.set;
    if (!pattern2)
      return false;
    if (set3.length > 1)
      return true;
    for (var j = 0; j < set3[0].length; j++) {
      if (typeof set3[0][j] !== "string")
        return true;
    }
    return false;
  };
  glob2.Glob = Glob;
  inherits2(Glob, EE);
  function Glob(pattern2, options3, cb) {
    if (typeof options3 === "function") {
      cb = options3;
      options3 = null;
    }
    if (options3 && options3.sync) {
      if (cb)
        throw new TypeError("callback provided to sync glob");
      return new GlobSync(pattern2, options3);
    }
    if (!(this instanceof Glob))
      return new Glob(pattern2, options3, cb);
    setopts2(this, pattern2, options3);
    this._didRealPath = false;
    var n3 = this.minimatch.set.length;
    this.matches = new Array(n3);
    if (typeof cb === "function") {
      cb = once2(cb);
      this.on("error", cb);
      this.on("end", function(matches2) {
        cb(null, matches2);
      });
    }
    var self2 = this;
    this._processing = 0;
    this._emitQueue = [];
    this._processQueue = [];
    this.paused = false;
    if (this.noprocess)
      return this;
    if (n3 === 0)
      return done();
    var sync2 = true;
    for (var i2 = 0; i2 < n3; i2++) {
      this._process(this.minimatch.set[i2], i2, false, done);
    }
    sync2 = false;
    function done() {
      --self2._processing;
      if (self2._processing <= 0) {
        if (sync2) {
          process.nextTick(function() {
            self2._finish();
          });
        } else {
          self2._finish();
        }
      }
    }
  }
  Glob.prototype._finish = function() {
    assert2(this instanceof Glob);
    if (this.aborted)
      return;
    if (this.realpath && !this._didRealpath)
      return this._realpath();
    common3.finish(this);
    this.emit("end", this.found);
  };
  Glob.prototype._realpath = function() {
    if (this._didRealpath)
      return;
    this._didRealpath = true;
    var n3 = this.matches.length;
    if (n3 === 0)
      return this._finish();
    var self2 = this;
    for (var i2 = 0; i2 < this.matches.length; i2++)
      this._realpathSet(i2, next);
    function next() {
      if (--n3 === 0)
        self2._finish();
    }
  };
  Glob.prototype._realpathSet = function(index2, cb) {
    var matchset = this.matches[index2];
    if (!matchset)
      return cb();
    var found2 = Object.keys(matchset);
    var self2 = this;
    var n3 = found2.length;
    if (n3 === 0)
      return cb();
    var set3 = this.matches[index2] = /* @__PURE__ */ Object.create(null);
    found2.forEach(function(p2, i2) {
      p2 = self2._makeAbs(p2);
      rp.realpath(p2, self2.realpathCache, function(er, real) {
        if (!er)
          set3[real] = true;
        else if (er.syscall === "stat")
          set3[p2] = true;
        else
          self2.emit("error", er);
        if (--n3 === 0) {
          self2.matches[index2] = set3;
          cb();
        }
      });
    });
  };
  Glob.prototype._mark = function(p2) {
    return common3.mark(this, p2);
  };
  Glob.prototype._makeAbs = function(f2) {
    return common3.makeAbs(this, f2);
  };
  Glob.prototype.abort = function() {
    this.aborted = true;
    this.emit("abort");
  };
  Glob.prototype.pause = function() {
    if (!this.paused) {
      this.paused = true;
      this.emit("pause");
    }
  };
  Glob.prototype.resume = function() {
    if (this.paused) {
      this.emit("resume");
      this.paused = false;
      if (this._emitQueue.length) {
        var eq = this._emitQueue.slice(0);
        this._emitQueue.length = 0;
        for (var i2 = 0; i2 < eq.length; i2++) {
          var e3 = eq[i2];
          this._emitMatch(e3[0], e3[1]);
        }
      }
      if (this._processQueue.length) {
        var pq = this._processQueue.slice(0);
        this._processQueue.length = 0;
        for (var i2 = 0; i2 < pq.length; i2++) {
          var p2 = pq[i2];
          this._processing--;
          this._process(p2[0], p2[1], p2[2], p2[3]);
        }
      }
    }
  };
  Glob.prototype._process = function(pattern2, index2, inGlobStar, cb) {
    assert2(this instanceof Glob);
    assert2(typeof cb === "function");
    if (this.aborted)
      return;
    this._processing++;
    if (this.paused) {
      this._processQueue.push([pattern2, index2, inGlobStar, cb]);
      return;
    }
    var n3 = 0;
    while (typeof pattern2[n3] === "string") {
      n3++;
    }
    var prefix;
    switch (n3) {
      case pattern2.length:
        this._processSimple(pattern2.join("/"), index2, cb);
        return;
      case 0:
        prefix = null;
        break;
      default:
        prefix = pattern2.slice(0, n3).join("/");
        break;
    }
    var remain = pattern2.slice(n3);
    var read2;
    if (prefix === null)
      read2 = ".";
    else if (isAbsolute2(prefix) || isAbsolute2(pattern2.map(function(p2) {
      return typeof p2 === "string" ? p2 : "[*]";
    }).join("/"))) {
      if (!prefix || !isAbsolute2(prefix))
        prefix = "/" + prefix;
      read2 = prefix;
    } else
      read2 = prefix;
    var abs = this._makeAbs(read2);
    if (childrenIgnored2(this, read2))
      return cb();
    var isGlobStar = remain[0] === minimatch2.GLOBSTAR;
    if (isGlobStar)
      this._processGlobStar(prefix, read2, abs, remain, index2, inGlobStar, cb);
    else
      this._processReaddir(prefix, read2, abs, remain, index2, inGlobStar, cb);
  };
  Glob.prototype._processReaddir = function(prefix, read2, abs, remain, index2, inGlobStar, cb) {
    var self2 = this;
    this._readdir(abs, inGlobStar, function(er, entries) {
      return self2._processReaddir2(prefix, read2, abs, remain, index2, inGlobStar, entries, cb);
    });
  };
  Glob.prototype._processReaddir2 = function(prefix, read2, abs, remain, index2, inGlobStar, entries, cb) {
    if (!entries)
      return cb();
    var pn = remain[0];
    var negate = !!this.minimatch.negate;
    var rawGlob = pn._glob;
    var dotOk = this.dot || rawGlob.charAt(0) === ".";
    var matchedEntries = [];
    for (var i2 = 0; i2 < entries.length; i2++) {
      var e3 = entries[i2];
      if (e3.charAt(0) !== "." || dotOk) {
        var m;
        if (negate && !prefix) {
          m = !e3.match(pn);
        } else {
          m = e3.match(pn);
        }
        if (m)
          matchedEntries.push(e3);
      }
    }
    var len = matchedEntries.length;
    if (len === 0)
      return cb();
    if (remain.length === 1 && !this.mark && !this.stat) {
      if (!this.matches[index2])
        this.matches[index2] = /* @__PURE__ */ Object.create(null);
      for (var i2 = 0; i2 < len; i2++) {
        var e3 = matchedEntries[i2];
        if (prefix) {
          if (prefix !== "/")
            e3 = prefix + "/" + e3;
          else
            e3 = prefix + e3;
        }
        if (e3.charAt(0) === "/" && !this.nomount) {
          e3 = path8.join(this.root, e3);
        }
        this._emitMatch(index2, e3);
      }
      return cb();
    }
    remain.shift();
    for (var i2 = 0; i2 < len; i2++) {
      var e3 = matchedEntries[i2];
      if (prefix) {
        if (prefix !== "/")
          e3 = prefix + "/" + e3;
        else
          e3 = prefix + e3;
      }
      this._process([e3].concat(remain), index2, inGlobStar, cb);
    }
    cb();
  };
  Glob.prototype._emitMatch = function(index2, e3) {
    if (this.aborted)
      return;
    if (isIgnored2(this, e3))
      return;
    if (this.paused) {
      this._emitQueue.push([index2, e3]);
      return;
    }
    var abs = isAbsolute2(e3) ? e3 : this._makeAbs(e3);
    if (this.mark)
      e3 = this._mark(e3);
    if (this.absolute)
      e3 = abs;
    if (this.matches[index2][e3])
      return;
    if (this.nodir) {
      var c2 = this.cache[abs];
      if (c2 === "DIR" || Array.isArray(c2))
        return;
    }
    this.matches[index2][e3] = true;
    var st = this.statCache[abs];
    if (st)
      this.emit("stat", e3, st);
    this.emit("match", e3);
  };
  Glob.prototype._readdirInGlobStar = function(abs, cb) {
    if (this.aborted)
      return;
    if (this.follow)
      return this._readdir(abs, false, cb);
    var lstatkey = "lstat\0" + abs;
    var self2 = this;
    var lstatcb = inflight2(lstatkey, lstatcb_);
    if (lstatcb)
      self2.fs.lstat(abs, lstatcb);
    function lstatcb_(er, lstat2) {
      if (er && er.code === "ENOENT")
        return cb();
      var isSym = lstat2 && lstat2.isSymbolicLink();
      self2.symlinks[abs] = isSym;
      if (!isSym && lstat2 && !lstat2.isDirectory()) {
        self2.cache[abs] = "FILE";
        cb();
      } else
        self2._readdir(abs, false, cb);
    }
  };
  Glob.prototype._readdir = function(abs, inGlobStar, cb) {
    if (this.aborted)
      return;
    cb = inflight2("readdir\0" + abs + "\0" + inGlobStar, cb);
    if (!cb)
      return;
    if (inGlobStar && !ownProp2(this.symlinks, abs))
      return this._readdirInGlobStar(abs, cb);
    if (ownProp2(this.cache, abs)) {
      var c2 = this.cache[abs];
      if (!c2 || c2 === "FILE")
        return cb();
      if (Array.isArray(c2))
        return cb(null, c2);
    }
    var self2 = this;
    self2.fs.readdir(abs, readdirCb(this, abs, cb));
  };
  function readdirCb(self2, abs, cb) {
    return function(er, entries) {
      if (er)
        self2._readdirError(abs, er, cb);
      else
        self2._readdirEntries(abs, entries, cb);
    };
  }
  Glob.prototype._readdirEntries = function(abs, entries, cb) {
    if (this.aborted)
      return;
    if (!this.mark && !this.stat) {
      for (var i2 = 0; i2 < entries.length; i2++) {
        var e3 = entries[i2];
        if (abs === "/")
          e3 = abs + e3;
        else
          e3 = abs + "/" + e3;
        this.cache[e3] = true;
      }
    }
    this.cache[abs] = entries;
    return cb(null, entries);
  };
  Glob.prototype._readdirError = function(f2, er, cb) {
    if (this.aborted)
      return;
    switch (er.code) {
      case "ENOTSUP":
      case "ENOTDIR":
        var abs = this._makeAbs(f2);
        this.cache[abs] = "FILE";
        if (abs === this.cwdAbs) {
          var error3 = new Error(er.code + " invalid cwd " + this.cwd);
          error3.path = this.cwd;
          error3.code = er.code;
          this.emit("error", error3);
          this.abort();
        }
        break;
      case "ENOENT":
      case "ELOOP":
      case "ENAMETOOLONG":
      case "UNKNOWN":
        this.cache[this._makeAbs(f2)] = false;
        break;
      default:
        this.cache[this._makeAbs(f2)] = false;
        if (this.strict) {
          this.emit("error", er);
          this.abort();
        }
        if (!this.silent)
          console.error("glob error", er);
        break;
    }
    return cb();
  };
  Glob.prototype._processGlobStar = function(prefix, read2, abs, remain, index2, inGlobStar, cb) {
    var self2 = this;
    this._readdir(abs, inGlobStar, function(er, entries) {
      self2._processGlobStar2(prefix, read2, abs, remain, index2, inGlobStar, entries, cb);
    });
  };
  Glob.prototype._processGlobStar2 = function(prefix, read2, abs, remain, index2, inGlobStar, entries, cb) {
    if (!entries)
      return cb();
    var remainWithoutGlobStar = remain.slice(1);
    var gspref = prefix ? [prefix] : [];
    var noGlobStar = gspref.concat(remainWithoutGlobStar);
    this._process(noGlobStar, index2, false, cb);
    var isSym = this.symlinks[abs];
    var len = entries.length;
    if (isSym && inGlobStar)
      return cb();
    for (var i2 = 0; i2 < len; i2++) {
      var e3 = entries[i2];
      if (e3.charAt(0) === "." && !this.dot)
        continue;
      var instead = gspref.concat(entries[i2], remainWithoutGlobStar);
      this._process(instead, index2, true, cb);
      var below = gspref.concat(entries[i2], remain);
      this._process(below, index2, true, cb);
    }
    cb();
  };
  Glob.prototype._processSimple = function(prefix, index2, cb) {
    var self2 = this;
    this._stat(prefix, function(er, exists) {
      self2._processSimple2(prefix, index2, er, exists, cb);
    });
  };
  Glob.prototype._processSimple2 = function(prefix, index2, er, exists, cb) {
    if (!this.matches[index2])
      this.matches[index2] = /* @__PURE__ */ Object.create(null);
    if (!exists)
      return cb();
    if (prefix && isAbsolute2(prefix) && !this.nomount) {
      var trail = /[\/\\]$/.test(prefix);
      if (prefix.charAt(0) === "/") {
        prefix = path8.join(this.root, prefix);
      } else {
        prefix = path8.resolve(this.root, prefix);
        if (trail)
          prefix += "/";
      }
    }
    if (process.platform === "win32")
      prefix = prefix.replace(/\\/g, "/");
    this._emitMatch(index2, prefix);
    cb();
  };
  Glob.prototype._stat = function(f2, cb) {
    var abs = this._makeAbs(f2);
    var needDir = f2.slice(-1) === "/";
    if (f2.length > this.maxLength)
      return cb();
    if (!this.stat && ownProp2(this.cache, abs)) {
      var c2 = this.cache[abs];
      if (Array.isArray(c2))
        c2 = "DIR";
      if (!needDir || c2 === "DIR")
        return cb(null, c2);
      if (needDir && c2 === "FILE")
        return cb();
    }
    var stat2 = this.statCache[abs];
    if (stat2 !== void 0) {
      if (stat2 === false)
        return cb(null, stat2);
      else {
        var type = stat2.isDirectory() ? "DIR" : "FILE";
        if (needDir && type === "FILE")
          return cb();
        else
          return cb(null, type, stat2);
      }
    }
    var self2 = this;
    var statcb = inflight2("stat\0" + abs, lstatcb_);
    if (statcb)
      self2.fs.lstat(abs, statcb);
    function lstatcb_(er, lstat2) {
      if (lstat2 && lstat2.isSymbolicLink()) {
        return self2.fs.stat(abs, function(er2, stat3) {
          if (er2)
            self2._stat2(f2, abs, null, lstat2, cb);
          else
            self2._stat2(f2, abs, er2, stat3, cb);
        });
      } else {
        self2._stat2(f2, abs, er, lstat2, cb);
      }
    }
  };
  Glob.prototype._stat2 = function(f2, abs, er, stat2, cb) {
    if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
      this.statCache[abs] = false;
      return cb();
    }
    var needDir = f2.slice(-1) === "/";
    this.statCache[abs] = stat2;
    if (abs.slice(-1) === "/" && stat2 && !stat2.isDirectory())
      return cb(null, false, stat2);
    var c2 = true;
    if (stat2)
      c2 = stat2.isDirectory() ? "DIR" : "FILE";
    this.cache[abs] = this.cache[abs] || c2;
    if (needDir && c2 === "FILE")
      return cb();
    return cb(null, c2, stat2);
  };
  return glob_1;
}
var globExports = requireGlob();
var glob = getDefaultExportFromCjs(globExports);
var comma = ",".charCodeAt(0);
var semicolon = ";".charCodeAt(0);
var chars$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var intToChar = new Uint8Array(64);
var charToInt = new Uint8Array(128);
for (let i2 = 0; i2 < chars$1.length; i2++) {
  const c2 = chars$1.charCodeAt(i2);
  intToChar[i2] = c2;
  charToInt[c2] = i2;
}
var td = typeof TextDecoder !== "undefined" ? new TextDecoder() : typeof Buffer !== "undefined" ? {
  decode(buf) {
    const out2 = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
    return out2.toString();
  }
} : {
  decode(buf) {
    let out2 = "";
    for (let i2 = 0; i2 < buf.length; i2++) {
      out2 += String.fromCharCode(buf[i2]);
    }
    return out2;
  }
};
function decode(mappings) {
  const state = new Int32Array(5);
  const decoded = [];
  let index2 = 0;
  do {
    const semi = indexOf(mappings, index2);
    const line = [];
    let sorted = true;
    let lastCol = 0;
    state[0] = 0;
    for (let i2 = index2; i2 < semi; i2++) {
      let seg;
      i2 = decodeInteger(mappings, i2, state, 0);
      const col = state[0];
      if (col < lastCol)
        sorted = false;
      lastCol = col;
      if (hasMoreVlq(mappings, i2, semi)) {
        i2 = decodeInteger(mappings, i2, state, 1);
        i2 = decodeInteger(mappings, i2, state, 2);
        i2 = decodeInteger(mappings, i2, state, 3);
        if (hasMoreVlq(mappings, i2, semi)) {
          i2 = decodeInteger(mappings, i2, state, 4);
          seg = [col, state[1], state[2], state[3], state[4]];
        } else {
          seg = [col, state[1], state[2], state[3]];
        }
      } else {
        seg = [col];
      }
      line.push(seg);
    }
    if (!sorted)
      sort(line);
    decoded.push(line);
    index2 = semi + 1;
  } while (index2 <= mappings.length);
  return decoded;
}
function indexOf(mappings, index2) {
  const idx = mappings.indexOf(";", index2);
  return idx === -1 ? mappings.length : idx;
}
function decodeInteger(mappings, pos, state, j) {
  let value2 = 0;
  let shift = 0;
  let integer = 0;
  do {
    const c2 = mappings.charCodeAt(pos++);
    integer = charToInt[c2];
    value2 |= (integer & 31) << shift;
    shift += 5;
  } while (integer & 32);
  const shouldNegate = value2 & 1;
  value2 >>>= 1;
  if (shouldNegate) {
    value2 = -2147483648 | -value2;
  }
  state[j] += value2;
  return pos;
}
function hasMoreVlq(mappings, i2, length) {
  if (i2 >= length)
    return false;
  return mappings.charCodeAt(i2) !== comma;
}
function sort(line) {
  line.sort(sortComparator$1);
}
function sortComparator$1(a2, b) {
  return a2[0] - b[0];
}
function encode$1(decoded) {
  const state = new Int32Array(5);
  const bufLength = 1024 * 16;
  const subLength = bufLength - 36;
  const buf = new Uint8Array(bufLength);
  const sub = buf.subarray(0, subLength);
  let pos = 0;
  let out2 = "";
  for (let i2 = 0; i2 < decoded.length; i2++) {
    const line = decoded[i2];
    if (i2 > 0) {
      if (pos === bufLength) {
        out2 += td.decode(buf);
        pos = 0;
      }
      buf[pos++] = semicolon;
    }
    if (line.length === 0)
      continue;
    state[0] = 0;
    for (let j = 0; j < line.length; j++) {
      const segment = line[j];
      if (pos > subLength) {
        out2 += td.decode(sub);
        buf.copyWithin(0, subLength, pos);
        pos -= subLength;
      }
      if (j > 0)
        buf[pos++] = comma;
      pos = encodeInteger(buf, pos, state, segment, 0);
      if (segment.length === 1)
        continue;
      pos = encodeInteger(buf, pos, state, segment, 1);
      pos = encodeInteger(buf, pos, state, segment, 2);
      pos = encodeInteger(buf, pos, state, segment, 3);
      if (segment.length === 4)
        continue;
      pos = encodeInteger(buf, pos, state, segment, 4);
    }
  }
  return out2 + td.decode(buf.subarray(0, pos));
}
function encodeInteger(buf, pos, state, segment, j) {
  const next = segment[j];
  let num = next - state[j];
  state[j] = next;
  num = num < 0 ? -num << 1 | 1 : num << 1;
  do {
    let clamped = num & 31;
    num >>>= 5;
    if (num > 0)
      clamped |= 32;
    buf[pos++] = intToChar[clamped];
  } while (num > 0);
  return pos;
}
var BitSet = class {
  constructor(arg) {
    this.bits = arg instanceof BitSet ? arg.bits.slice() : [];
  }
  add(n3) {
    this.bits[n3 >> 5] |= 1 << (n3 & 31);
  }
  has(n3) {
    return !!(this.bits[n3 >> 5] & 1 << (n3 & 31));
  }
};
var Chunk = class {
  constructor(start, end, content) {
    this.start = start;
    this.end = end;
    this.original = content;
    this.intro = "";
    this.outro = "";
    this.content = content;
    this.storeName = false;
    this.edited = false;
    {
      this.previous = null;
      this.next = null;
    }
  }
  appendLeft(content) {
    this.outro += content;
  }
  appendRight(content) {
    this.intro = this.intro + content;
  }
  clone() {
    const chunk = new Chunk(this.start, this.end, this.original);
    chunk.intro = this.intro;
    chunk.outro = this.outro;
    chunk.content = this.content;
    chunk.storeName = this.storeName;
    chunk.edited = this.edited;
    return chunk;
  }
  contains(index2) {
    return this.start < index2 && index2 < this.end;
  }
  eachNext(fn) {
    let chunk = this;
    while (chunk) {
      fn(chunk);
      chunk = chunk.next;
    }
  }
  eachPrevious(fn) {
    let chunk = this;
    while (chunk) {
      fn(chunk);
      chunk = chunk.previous;
    }
  }
  edit(content, storeName, contentOnly) {
    this.content = content;
    if (!contentOnly) {
      this.intro = "";
      this.outro = "";
    }
    this.storeName = storeName;
    this.edited = true;
    return this;
  }
  prependLeft(content) {
    this.outro = content + this.outro;
  }
  prependRight(content) {
    this.intro = content + this.intro;
  }
  split(index2) {
    const sliceIndex = index2 - this.start;
    const originalBefore = this.original.slice(0, sliceIndex);
    const originalAfter = this.original.slice(sliceIndex);
    this.original = originalBefore;
    const newChunk = new Chunk(index2, this.end, originalAfter);
    newChunk.outro = this.outro;
    this.outro = "";
    this.end = index2;
    if (this.edited) {
      newChunk.edit("", false);
      this.content = "";
    } else {
      this.content = originalBefore;
    }
    newChunk.next = this.next;
    if (newChunk.next)
      newChunk.next.previous = newChunk;
    newChunk.previous = this;
    this.next = newChunk;
    return newChunk;
  }
  toString() {
    return this.intro + this.content + this.outro;
  }
  trimEnd(rx) {
    this.outro = this.outro.replace(rx, "");
    if (this.outro.length)
      return true;
    const trimmed = this.content.replace(rx, "");
    if (trimmed.length) {
      if (trimmed !== this.content) {
        this.split(this.start + trimmed.length).edit("", void 0, true);
      }
      return true;
    } else {
      this.edit("", void 0, true);
      this.intro = this.intro.replace(rx, "");
      if (this.intro.length)
        return true;
    }
  }
  trimStart(rx) {
    this.intro = this.intro.replace(rx, "");
    if (this.intro.length)
      return true;
    const trimmed = this.content.replace(rx, "");
    if (trimmed.length) {
      if (trimmed !== this.content) {
        this.split(this.end - trimmed.length);
        this.edit("", void 0, true);
      }
      return true;
    } else {
      this.edit("", void 0, true);
      this.outro = this.outro.replace(rx, "");
      if (this.outro.length)
        return true;
    }
  }
};
function getBtoa() {
  if (typeof window !== "undefined" && typeof window.btoa === "function") {
    return (str2) => window.btoa(unescape(encodeURIComponent(str2)));
  } else if (typeof Buffer === "function") {
    return (str2) => Buffer.from(str2, "utf-8").toString("base64");
  } else {
    return () => {
      throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
    };
  }
}
var btoa$1 = getBtoa();
var SourceMap$1 = class SourceMap {
  constructor(properties) {
    this.version = 3;
    this.file = properties.file;
    this.sources = properties.sources;
    this.sourcesContent = properties.sourcesContent;
    this.names = properties.names;
    this.mappings = encode$1(properties.mappings);
  }
  toString() {
    return JSON.stringify(this);
  }
  toUrl() {
    return "data:application/json;charset=utf-8;base64," + btoa$1(this.toString());
  }
};
function guessIndent(code) {
  const lines = code.split("\n");
  const tabbed = lines.filter((line) => /^\t+/.test(line));
  const spaced = lines.filter((line) => /^ {2,}/.test(line));
  if (tabbed.length === 0 && spaced.length === 0) {
    return null;
  }
  if (tabbed.length >= spaced.length) {
    return "	";
  }
  const min2 = spaced.reduce((previous, current2) => {
    const numSpaces = /^ +/.exec(current2)[0].length;
    return Math.min(numSpaces, previous);
  }, Infinity);
  return new Array(min2 + 1).join(" ");
}
function getRelativePath(from, to) {
  const fromParts = from.split(/[/\\]/);
  const toParts = to.split(/[/\\]/);
  fromParts.pop();
  while (fromParts[0] === toParts[0]) {
    fromParts.shift();
    toParts.shift();
  }
  if (fromParts.length) {
    let i2 = fromParts.length;
    while (i2--)
      fromParts[i2] = "..";
  }
  return fromParts.concat(toParts).join("/");
}
var toString$2 = Object.prototype.toString;
function isObject$2(thing) {
  return toString$2.call(thing) === "[object Object]";
}
function getLocator(source) {
  const originalLines = source.split("\n");
  const lineOffsets = [];
  for (let i2 = 0, pos = 0; i2 < originalLines.length; i2++) {
    lineOffsets.push(pos);
    pos += originalLines[i2].length + 1;
  }
  return function locate(index2) {
    let i2 = 0;
    let j = lineOffsets.length;
    while (i2 < j) {
      const m = i2 + j >> 1;
      if (index2 < lineOffsets[m]) {
        j = m;
      } else {
        i2 = m + 1;
      }
    }
    const line = i2 - 1;
    const column = index2 - lineOffsets[line];
    return { line, column };
  };
}
var Mappings = class {
  constructor(hires) {
    this.hires = hires;
    this.generatedCodeLine = 0;
    this.generatedCodeColumn = 0;
    this.raw = [];
    this.rawSegments = this.raw[this.generatedCodeLine] = [];
    this.pending = null;
  }
  addEdit(sourceIndex, content, loc, nameIndex) {
    if (content.length) {
      const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
      if (nameIndex >= 0) {
        segment.push(nameIndex);
      }
      this.rawSegments.push(segment);
    } else if (this.pending) {
      this.rawSegments.push(this.pending);
    }
    this.advance(content);
    this.pending = null;
  }
  addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {
    let originalCharIndex = chunk.start;
    let first2 = true;
    while (originalCharIndex < chunk.end) {
      if (this.hires || first2 || sourcemapLocations.has(originalCharIndex)) {
        this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);
      }
      if (original[originalCharIndex] === "\n") {
        loc.line += 1;
        loc.column = 0;
        this.generatedCodeLine += 1;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
        this.generatedCodeColumn = 0;
        first2 = true;
      } else {
        loc.column += 1;
        this.generatedCodeColumn += 1;
        first2 = false;
      }
      originalCharIndex += 1;
    }
    this.pending = null;
  }
  advance(str2) {
    if (!str2)
      return;
    const lines = str2.split("\n");
    if (lines.length > 1) {
      for (let i2 = 0; i2 < lines.length - 1; i2++) {
        this.generatedCodeLine++;
        this.raw[this.generatedCodeLine] = this.rawSegments = [];
      }
      this.generatedCodeColumn = 0;
    }
    this.generatedCodeColumn += lines[lines.length - 1].length;
  }
};
var n$1 = "\n";
var warned = {
  insertLeft: false,
  insertRight: false,
  storeName: false
};
var MagicString = class {
  constructor(string3, options3 = {}) {
    const chunk = new Chunk(0, string3.length, string3);
    Object.defineProperties(this, {
      original: { writable: true, value: string3 },
      outro: { writable: true, value: "" },
      intro: { writable: true, value: "" },
      firstChunk: { writable: true, value: chunk },
      lastChunk: { writable: true, value: chunk },
      lastSearchedChunk: { writable: true, value: chunk },
      byStart: { writable: true, value: {} },
      byEnd: { writable: true, value: {} },
      filename: { writable: true, value: options3.filename },
      indentExclusionRanges: { writable: true, value: options3.indentExclusionRanges },
      sourcemapLocations: { writable: true, value: new BitSet() },
      storedNames: { writable: true, value: {} },
      indentStr: { writable: true, value: void 0 }
    });
    this.byStart[0] = chunk;
    this.byEnd[string3.length] = chunk;
  }
  addSourcemapLocation(char) {
    this.sourcemapLocations.add(char);
  }
  append(content) {
    if (typeof content !== "string")
      throw new TypeError("outro content must be a string");
    this.outro += content;
    return this;
  }
  appendLeft(index2, content) {
    if (typeof content !== "string")
      throw new TypeError("inserted content must be a string");
    this._split(index2);
    const chunk = this.byEnd[index2];
    if (chunk) {
      chunk.appendLeft(content);
    } else {
      this.intro += content;
    }
    return this;
  }
  appendRight(index2, content) {
    if (typeof content !== "string")
      throw new TypeError("inserted content must be a string");
    this._split(index2);
    const chunk = this.byStart[index2];
    if (chunk) {
      chunk.appendRight(content);
    } else {
      this.outro += content;
    }
    return this;
  }
  clone() {
    const cloned = new MagicString(this.original, { filename: this.filename });
    let originalChunk = this.firstChunk;
    let clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();
    while (originalChunk) {
      cloned.byStart[clonedChunk.start] = clonedChunk;
      cloned.byEnd[clonedChunk.end] = clonedChunk;
      const nextOriginalChunk = originalChunk.next;
      const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();
      if (nextClonedChunk) {
        clonedChunk.next = nextClonedChunk;
        nextClonedChunk.previous = clonedChunk;
        clonedChunk = nextClonedChunk;
      }
      originalChunk = nextOriginalChunk;
    }
    cloned.lastChunk = clonedChunk;
    if (this.indentExclusionRanges) {
      cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
    }
    cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);
    cloned.intro = this.intro;
    cloned.outro = this.outro;
    return cloned;
  }
  generateDecodedMap(options3) {
    options3 = options3 || {};
    const sourceIndex = 0;
    const names = Object.keys(this.storedNames);
    const mappings = new Mappings(options3.hires);
    const locate = getLocator(this.original);
    if (this.intro) {
      mappings.advance(this.intro);
    }
    this.firstChunk.eachNext((chunk) => {
      const loc = locate(chunk.start);
      if (chunk.intro.length)
        mappings.advance(chunk.intro);
      if (chunk.edited) {
        mappings.addEdit(
          sourceIndex,
          chunk.content,
          loc,
          chunk.storeName ? names.indexOf(chunk.original) : -1
        );
      } else {
        mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);
      }
      if (chunk.outro.length)
        mappings.advance(chunk.outro);
    });
    return {
      file: options3.file ? options3.file.split(/[/\\]/).pop() : null,
      sources: [options3.source ? getRelativePath(options3.file || "", options3.source) : null],
      sourcesContent: options3.includeContent ? [this.original] : [null],
      names,
      mappings: mappings.raw
    };
  }
  generateMap(options3) {
    return new SourceMap$1(this.generateDecodedMap(options3));
  }
  _ensureindentStr() {
    if (this.indentStr === void 0) {
      this.indentStr = guessIndent(this.original);
    }
  }
  _getRawIndentString() {
    this._ensureindentStr();
    return this.indentStr;
  }
  getIndentString() {
    this._ensureindentStr();
    return this.indentStr === null ? "	" : this.indentStr;
  }
  indent(indentStr, options3) {
    const pattern2 = /^[^\r\n]/gm;
    if (isObject$2(indentStr)) {
      options3 = indentStr;
      indentStr = void 0;
    }
    if (indentStr === void 0) {
      this._ensureindentStr();
      indentStr = this.indentStr || "	";
    }
    if (indentStr === "")
      return this;
    options3 = options3 || {};
    const isExcluded = {};
    if (options3.exclude) {
      const exclusions = typeof options3.exclude[0] === "number" ? [options3.exclude] : options3.exclude;
      exclusions.forEach((exclusion) => {
        for (let i2 = exclusion[0]; i2 < exclusion[1]; i2 += 1) {
          isExcluded[i2] = true;
        }
      });
    }
    let shouldIndentNextCharacter = options3.indentStart !== false;
    const replacer = (match) => {
      if (shouldIndentNextCharacter)
        return `${indentStr}${match}`;
      shouldIndentNextCharacter = true;
      return match;
    };
    this.intro = this.intro.replace(pattern2, replacer);
    let charIndex = 0;
    let chunk = this.firstChunk;
    while (chunk) {
      const end = chunk.end;
      if (chunk.edited) {
        if (!isExcluded[charIndex]) {
          chunk.content = chunk.content.replace(pattern2, replacer);
          if (chunk.content.length) {
            shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === "\n";
          }
        }
      } else {
        charIndex = chunk.start;
        while (charIndex < end) {
          if (!isExcluded[charIndex]) {
            const char = this.original[charIndex];
            if (char === "\n") {
              shouldIndentNextCharacter = true;
            } else if (char !== "\r" && shouldIndentNextCharacter) {
              shouldIndentNextCharacter = false;
              if (charIndex === chunk.start) {
                chunk.prependRight(indentStr);
              } else {
                this._splitChunk(chunk, charIndex);
                chunk = chunk.next;
                chunk.prependRight(indentStr);
              }
            }
          }
          charIndex += 1;
        }
      }
      charIndex = chunk.end;
      chunk = chunk.next;
    }
    this.outro = this.outro.replace(pattern2, replacer);
    return this;
  }
  insert() {
    throw new Error(
      "magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)"
    );
  }
  insertLeft(index2, content) {
    if (!warned.insertLeft) {
      console.warn(
        "magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead"
      );
      warned.insertLeft = true;
    }
    return this.appendLeft(index2, content);
  }
  insertRight(index2, content) {
    if (!warned.insertRight) {
      console.warn(
        "magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead"
      );
      warned.insertRight = true;
    }
    return this.prependRight(index2, content);
  }
  move(start, end, index2) {
    if (index2 >= start && index2 <= end)
      throw new Error("Cannot move a selection inside itself");
    this._split(start);
    this._split(end);
    this._split(index2);
    const first2 = this.byStart[start];
    const last = this.byEnd[end];
    const oldLeft = first2.previous;
    const oldRight = last.next;
    const newRight = this.byStart[index2];
    if (!newRight && last === this.lastChunk)
      return this;
    const newLeft = newRight ? newRight.previous : this.lastChunk;
    if (oldLeft)
      oldLeft.next = oldRight;
    if (oldRight)
      oldRight.previous = oldLeft;
    if (newLeft)
      newLeft.next = first2;
    if (newRight)
      newRight.previous = last;
    if (!first2.previous)
      this.firstChunk = last.next;
    if (!last.next) {
      this.lastChunk = first2.previous;
      this.lastChunk.next = null;
    }
    first2.previous = newLeft;
    last.next = newRight || null;
    if (!newLeft)
      this.firstChunk = first2;
    if (!newRight)
      this.lastChunk = last;
    return this;
  }
  overwrite(start, end, content, options3) {
    options3 = options3 || {};
    return this.update(start, end, content, { ...options3, overwrite: !options3.contentOnly });
  }
  update(start, end, content, options3) {
    if (typeof content !== "string")
      throw new TypeError("replacement content must be a string");
    while (start < 0)
      start += this.original.length;
    while (end < 0)
      end += this.original.length;
    if (end > this.original.length)
      throw new Error("end is out of bounds");
    if (start === end)
      throw new Error(
        "Cannot overwrite a zero-length range – use appendLeft or prependRight instead"
      );
    this._split(start);
    this._split(end);
    if (options3 === true) {
      if (!warned.storeName) {
        console.warn(
          "The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string"
        );
        warned.storeName = true;
      }
      options3 = { storeName: true };
    }
    const storeName = options3 !== void 0 ? options3.storeName : false;
    const overwrite = options3 !== void 0 ? options3.overwrite : false;
    if (storeName) {
      const original = this.original.slice(start, end);
      Object.defineProperty(this.storedNames, original, {
        writable: true,
        value: true,
        enumerable: true
      });
    }
    const first2 = this.byStart[start];
    const last = this.byEnd[end];
    if (first2) {
      let chunk = first2;
      while (chunk !== last) {
        if (chunk.next !== this.byStart[chunk.end]) {
          throw new Error("Cannot overwrite across a split point");
        }
        chunk = chunk.next;
        chunk.edit("", false);
      }
      first2.edit(content, storeName, !overwrite);
    } else {
      const newChunk = new Chunk(start, end, "").edit(content, storeName);
      last.next = newChunk;
      newChunk.previous = last;
    }
    return this;
  }
  prepend(content) {
    if (typeof content !== "string")
      throw new TypeError("outro content must be a string");
    this.intro = content + this.intro;
    return this;
  }
  prependLeft(index2, content) {
    if (typeof content !== "string")
      throw new TypeError("inserted content must be a string");
    this._split(index2);
    const chunk = this.byEnd[index2];
    if (chunk) {
      chunk.prependLeft(content);
    } else {
      this.intro = content + this.intro;
    }
    return this;
  }
  prependRight(index2, content) {
    if (typeof content !== "string")
      throw new TypeError("inserted content must be a string");
    this._split(index2);
    const chunk = this.byStart[index2];
    if (chunk) {
      chunk.prependRight(content);
    } else {
      this.outro = content + this.outro;
    }
    return this;
  }
  remove(start, end) {
    while (start < 0)
      start += this.original.length;
    while (end < 0)
      end += this.original.length;
    if (start === end)
      return this;
    if (start < 0 || end > this.original.length)
      throw new Error("Character is out of bounds");
    if (start > end)
      throw new Error("end must be greater than start");
    this._split(start);
    this._split(end);
    let chunk = this.byStart[start];
    while (chunk) {
      chunk.intro = "";
      chunk.outro = "";
      chunk.edit("");
      chunk = end > chunk.end ? this.byStart[chunk.end] : null;
    }
    return this;
  }
  lastChar() {
    if (this.outro.length)
      return this.outro[this.outro.length - 1];
    let chunk = this.lastChunk;
    do {
      if (chunk.outro.length)
        return chunk.outro[chunk.outro.length - 1];
      if (chunk.content.length)
        return chunk.content[chunk.content.length - 1];
      if (chunk.intro.length)
        return chunk.intro[chunk.intro.length - 1];
    } while (chunk = chunk.previous);
    if (this.intro.length)
      return this.intro[this.intro.length - 1];
    return "";
  }
  lastLine() {
    let lineIndex = this.outro.lastIndexOf(n$1);
    if (lineIndex !== -1)
      return this.outro.substr(lineIndex + 1);
    let lineStr = this.outro;
    let chunk = this.lastChunk;
    do {
      if (chunk.outro.length > 0) {
        lineIndex = chunk.outro.lastIndexOf(n$1);
        if (lineIndex !== -1)
          return chunk.outro.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.outro + lineStr;
      }
      if (chunk.content.length > 0) {
        lineIndex = chunk.content.lastIndexOf(n$1);
        if (lineIndex !== -1)
          return chunk.content.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.content + lineStr;
      }
      if (chunk.intro.length > 0) {
        lineIndex = chunk.intro.lastIndexOf(n$1);
        if (lineIndex !== -1)
          return chunk.intro.substr(lineIndex + 1) + lineStr;
        lineStr = chunk.intro + lineStr;
      }
    } while (chunk = chunk.previous);
    lineIndex = this.intro.lastIndexOf(n$1);
    if (lineIndex !== -1)
      return this.intro.substr(lineIndex + 1) + lineStr;
    return this.intro + lineStr;
  }
  slice(start = 0, end = this.original.length) {
    while (start < 0)
      start += this.original.length;
    while (end < 0)
      end += this.original.length;
    let result = "";
    let chunk = this.firstChunk;
    while (chunk && (chunk.start > start || chunk.end <= start)) {
      if (chunk.start < end && chunk.end >= end) {
        return result;
      }
      chunk = chunk.next;
    }
    if (chunk && chunk.edited && chunk.start !== start)
      throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);
    const startChunk = chunk;
    while (chunk) {
      if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
        result += chunk.intro;
      }
      const containsEnd = chunk.start < end && chunk.end >= end;
      if (containsEnd && chunk.edited && chunk.end !== end)
        throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);
      const sliceStart = startChunk === chunk ? start - chunk.start : 0;
      const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;
      result += chunk.content.slice(sliceStart, sliceEnd);
      if (chunk.outro && (!containsEnd || chunk.end === end)) {
        result += chunk.outro;
      }
      if (containsEnd) {
        break;
      }
      chunk = chunk.next;
    }
    return result;
  }
  // TODO deprecate this? not really very useful
  snip(start, end) {
    const clone = this.clone();
    clone.remove(0, start);
    clone.remove(end, clone.original.length);
    return clone;
  }
  _split(index2) {
    if (this.byStart[index2] || this.byEnd[index2])
      return;
    let chunk = this.lastSearchedChunk;
    const searchForward = index2 > chunk.end;
    while (chunk) {
      if (chunk.contains(index2))
        return this._splitChunk(chunk, index2);
      chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
    }
  }
  _splitChunk(chunk, index2) {
    if (chunk.edited && chunk.content.length) {
      const loc = getLocator(this.original)(index2);
      throw new Error(
        `Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – "${chunk.original}")`
      );
    }
    const newChunk = chunk.split(index2);
    this.byEnd[index2] = chunk;
    this.byStart[index2] = newChunk;
    this.byEnd[newChunk.end] = newChunk;
    if (chunk === this.lastChunk)
      this.lastChunk = newChunk;
    this.lastSearchedChunk = chunk;
    return true;
  }
  toString() {
    let str2 = this.intro;
    let chunk = this.firstChunk;
    while (chunk) {
      str2 += chunk.toString();
      chunk = chunk.next;
    }
    return str2 + this.outro;
  }
  isEmpty() {
    let chunk = this.firstChunk;
    do {
      if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim())
        return false;
    } while (chunk = chunk.next);
    return true;
  }
  length() {
    let chunk = this.firstChunk;
    let length = 0;
    do {
      length += chunk.intro.length + chunk.content.length + chunk.outro.length;
    } while (chunk = chunk.next);
    return length;
  }
  trimLines() {
    return this.trim("[\\r\\n]");
  }
  trim(charType) {
    return this.trimStart(charType).trimEnd(charType);
  }
  trimEndAborted(charType) {
    const rx = new RegExp((charType || "\\s") + "+$");
    this.outro = this.outro.replace(rx, "");
    if (this.outro.length)
      return true;
    let chunk = this.lastChunk;
    do {
      const end = chunk.end;
      const aborted = chunk.trimEnd(rx);
      if (chunk.end !== end) {
        if (this.lastChunk === chunk) {
          this.lastChunk = chunk.next;
        }
        this.byEnd[chunk.end] = chunk;
        this.byStart[chunk.next.start] = chunk.next;
        this.byEnd[chunk.next.end] = chunk.next;
      }
      if (aborted)
        return true;
      chunk = chunk.previous;
    } while (chunk);
    return false;
  }
  trimEnd(charType) {
    this.trimEndAborted(charType);
    return this;
  }
  trimStartAborted(charType) {
    const rx = new RegExp("^" + (charType || "\\s") + "+");
    this.intro = this.intro.replace(rx, "");
    if (this.intro.length)
      return true;
    let chunk = this.firstChunk;
    do {
      const end = chunk.end;
      const aborted = chunk.trimStart(rx);
      if (chunk.end !== end) {
        if (chunk === this.lastChunk)
          this.lastChunk = chunk.next;
        this.byEnd[chunk.end] = chunk;
        this.byStart[chunk.next.start] = chunk.next;
        this.byEnd[chunk.next.end] = chunk.next;
      }
      if (aborted)
        return true;
      chunk = chunk.next;
    } while (chunk);
    return false;
  }
  trimStart(charType) {
    this.trimStartAborted(charType);
    return this;
  }
  hasChanged() {
    return this.original !== this.toString();
  }
  _replaceRegexp(searchValue, replacement) {
    function getReplacement(match, str2) {
      if (typeof replacement === "string") {
        return replacement.replace(/\$(\$|&|\d+)/g, (_, i2) => {
          if (i2 === "$")
            return "$";
          if (i2 === "&")
            return match[0];
          const num = +i2;
          if (num < match.length)
            return match[+i2];
          return `$${i2}`;
        });
      } else {
        return replacement(...match, match.index, str2, match.groups);
      }
    }
    function matchAll2(re, str2) {
      let match;
      const matches2 = [];
      while (match = re.exec(str2)) {
        matches2.push(match);
      }
      return matches2;
    }
    if (searchValue.global) {
      const matches2 = matchAll2(searchValue, this.original);
      matches2.forEach((match) => {
        if (match.index != null)
          this.overwrite(
            match.index,
            match.index + match[0].length,
            getReplacement(match, this.original)
          );
      });
    } else {
      const match = this.original.match(searchValue);
      if (match && match.index != null)
        this.overwrite(
          match.index,
          match.index + match[0].length,
          getReplacement(match, this.original)
        );
    }
    return this;
  }
  _replaceString(string3, replacement) {
    const { original } = this;
    const index2 = original.indexOf(string3);
    if (index2 !== -1) {
      this.overwrite(index2, index2 + string3.length, replacement);
    }
    return this;
  }
  replace(searchValue, replacement) {
    if (typeof searchValue === "string") {
      return this._replaceString(searchValue, replacement);
    }
    return this._replaceRegexp(searchValue, replacement);
  }
  _replaceAllString(string3, replacement) {
    const { original } = this;
    const stringLength = string3.length;
    for (let index2 = original.indexOf(string3); index2 !== -1; index2 = original.indexOf(string3, index2 + stringLength)) {
      this.overwrite(index2, index2 + stringLength, replacement);
    }
    return this;
  }
  replaceAll(searchValue, replacement) {
    if (typeof searchValue === "string") {
      return this._replaceAllString(searchValue, replacement);
    }
    if (!searchValue.global) {
      throw new TypeError(
        "MagicString.prototype.replaceAll called with a non-global RegExp argument"
      );
    }
    return this._replaceRegexp(searchValue, replacement);
  }
};
function isReference(node3, parent) {
  if (node3.type === "MemberExpression") {
    return !node3.computed && isReference(node3.object, node3);
  }
  if (node3.type === "Identifier") {
    if (!parent)
      return true;
    switch (parent.type) {
      case "MemberExpression":
        return parent.computed || node3 === parent.object;
      case "MethodDefinition":
        return parent.computed;
      case "FieldDefinition":
        return parent.computed || node3 === parent.value;
      case "Property":
        return parent.computed || node3 === parent.value;
      case "ExportSpecifier":
      case "ImportSpecifier":
        return node3 === parent.local;
      case "LabeledStatement":
      case "BreakStatement":
      case "ContinueStatement":
        return false;
      default:
        return true;
    }
  }
  return false;
}
var version$3 = "24.0.1";
var peerDependencies = {
  rollup: "^2.68.0||^3.0.0"
};
function tryParse(parse7, code, id) {
  try {
    return parse7(code, { allowReturnOutsideFunction: true });
  } catch (err2) {
    err2.message += ` in ${id}`;
    throw err2;
  }
}
var firstpassGlobal = /\b(?:require|module|exports|global)\b/;
var firstpassNoGlobal = /\b(?:require|module|exports)\b/;
function hasCjsKeywords(code, ignoreGlobal) {
  const firstpass = ignoreGlobal ? firstpassNoGlobal : firstpassGlobal;
  return firstpass.test(code);
}
function analyzeTopLevelStatements(parse7, code, id) {
  const ast = tryParse(parse7, code, id);
  let isEsModule = false;
  let hasDefaultExport = false;
  let hasNamedExports = false;
  for (const node3 of ast.body) {
    switch (node3.type) {
      case "ExportDefaultDeclaration":
        isEsModule = true;
        hasDefaultExport = true;
        break;
      case "ExportNamedDeclaration":
        isEsModule = true;
        if (node3.declaration) {
          hasNamedExports = true;
        } else {
          for (const specifier of node3.specifiers) {
            if (specifier.exported.name === "default") {
              hasDefaultExport = true;
            } else {
              hasNamedExports = true;
            }
          }
        }
        break;
      case "ExportAllDeclaration":
        isEsModule = true;
        if (node3.exported && node3.exported.name === "default") {
          hasDefaultExport = true;
        } else {
          hasNamedExports = true;
        }
        break;
      case "ImportDeclaration":
        isEsModule = true;
        break;
    }
  }
  return { isEsModule, hasDefaultExport, hasNamedExports, ast };
}
function deconflict(scopes, globals, identifier) {
  let i2 = 1;
  let deconflicted = makeLegalIdentifier(identifier);
  const hasConflicts = () => scopes.some((scope) => scope.contains(deconflicted)) || globals.has(deconflicted);
  while (hasConflicts()) {
    deconflicted = makeLegalIdentifier(`${identifier}_${i2}`);
    i2 += 1;
  }
  for (const scope of scopes) {
    scope.declarations[deconflicted] = true;
  }
  return deconflicted;
}
function getName(id) {
  const name2 = makeLegalIdentifier((0, import_path.basename)(id, (0, import_path.extname)(id)));
  if (name2 !== "index") {
    return name2;
  }
  return makeLegalIdentifier((0, import_path.basename)((0, import_path.dirname)(id)));
}
function normalizePathSlashes(path8) {
  return path8.replace(/\\/g, "/");
}
var getVirtualPathForDynamicRequirePath = (path8, commonDir) => `/${normalizePathSlashes((0, import_path.relative)(commonDir, path8))}`;
function capitalize(name2) {
  return name2[0].toUpperCase() + name2.slice(1);
}
function getStrictRequiresFilter({ strictRequires }) {
  switch (strictRequires) {
    case true:
      return { strictRequiresFilter: () => true, detectCyclesAndConditional: false };
    case void 0:
    case "auto":
    case "debug":
    case null:
      return { strictRequiresFilter: () => false, detectCyclesAndConditional: true };
    case false:
      return { strictRequiresFilter: () => false, detectCyclesAndConditional: false };
    default:
      if (typeof strictRequires === "string" || Array.isArray(strictRequires)) {
        return {
          strictRequiresFilter: createFilter$1(strictRequires),
          detectCyclesAndConditional: false
        };
      }
      throw new Error('Unexpected value for "strictRequires" option.');
  }
}
function getPackageEntryPoint(dirPath) {
  let entryPoint = "index.js";
  try {
    if ((0, import_fs.existsSync)((0, import_path.join)(dirPath, "package.json"))) {
      entryPoint = JSON.parse((0, import_fs.readFileSync)((0, import_path.join)(dirPath, "package.json"), { encoding: "utf8" })).main || entryPoint;
    }
  } catch (ignored) {
  }
  return entryPoint;
}
function isDirectory(path8) {
  try {
    if ((0, import_fs.statSync)(path8).isDirectory())
      return true;
  } catch (ignored) {
  }
  return false;
}
function getDynamicRequireModules(patterns2, dynamicRequireRoot) {
  const dynamicRequireModules = /* @__PURE__ */ new Map();
  const dirNames = /* @__PURE__ */ new Set();
  for (const pattern2 of !patterns2 || Array.isArray(patterns2) ? patterns2 || [] : [patterns2]) {
    const isNegated = pattern2.startsWith("!");
    const modifyMap = (targetPath, resolvedPath) => isNegated ? dynamicRequireModules.delete(targetPath) : dynamicRequireModules.set(targetPath, resolvedPath);
    for (const path8 of glob.sync(isNegated ? pattern2.substr(1) : pattern2)) {
      const resolvedPath = (0, import_path.resolve)(path8);
      const requirePath = normalizePathSlashes(resolvedPath);
      if (isDirectory(resolvedPath)) {
        dirNames.add(resolvedPath);
        const modulePath = (0, import_path.resolve)((0, import_path.join)(resolvedPath, getPackageEntryPoint(path8)));
        modifyMap(requirePath, modulePath);
        modifyMap(normalizePathSlashes(modulePath), modulePath);
      } else {
        dirNames.add((0, import_path.dirname)(resolvedPath));
        modifyMap(requirePath, resolvedPath);
      }
    }
  }
  return {
    commonDir: dirNames.size ? commondir([...dirNames, dynamicRequireRoot]) : null,
    dynamicRequireModules
  };
}
var FAILED_REQUIRE_ERROR = `throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');`;
var COMMONJS_REQUIRE_EXPORT = "commonjsRequire";
var CREATE_COMMONJS_REQUIRE_EXPORT = "createCommonjsRequire";
function getDynamicModuleRegistry(isDynamicRequireModulesEnabled, dynamicRequireModules, commonDir, ignoreDynamicRequires) {
  if (!isDynamicRequireModulesEnabled) {
    return `export function ${COMMONJS_REQUIRE_EXPORT}(path) {
	${FAILED_REQUIRE_ERROR}
}`;
  }
  const dynamicModuleImports = [...dynamicRequireModules.values()].map(
    (id, index2) => `import ${id.endsWith(".json") ? `json${index2}` : `{ __require as require${index2} }`} from ${JSON.stringify(id)};`
  ).join("\n");
  const dynamicModuleProps = [...dynamicRequireModules.keys()].map(
    (id, index2) => `		${JSON.stringify(getVirtualPathForDynamicRequirePath(id, commonDir))}: ${id.endsWith(".json") ? `function () { return json${index2}; }` : `require${index2}`}`
  ).join(",\n");
  return `${dynamicModuleImports}

var dynamicModules;

function getDynamicModules() {
	return dynamicModules || (dynamicModules = {
${dynamicModuleProps}
	});
}

export function ${CREATE_COMMONJS_REQUIRE_EXPORT}(originalModuleDir) {
	function handleRequire(path) {
		var resolvedPath = commonjsResolve(path, originalModuleDir);
		if (resolvedPath !== null) {
			return getDynamicModules()[resolvedPath]();
		}
		${ignoreDynamicRequires ? "return require(path);" : FAILED_REQUIRE_ERROR}
	}
	handleRequire.resolve = function (path) {
		var resolvedPath = commonjsResolve(path, originalModuleDir);
		if (resolvedPath !== null) {
			return resolvedPath;
		}
		return require.resolve(path);
	}
	return handleRequire;
}

function commonjsResolve (path, originalModuleDir) {
	var shouldTryNodeModules = isPossibleNodeModulesPath(path);
	path = normalize(path);
	var relPath;
	if (path[0] === '/') {
		originalModuleDir = '';
	}
	var modules = getDynamicModules();
	var checkedExtensions = ['', '.js', '.json'];
	while (true) {
		if (!shouldTryNodeModules) {
			relPath = normalize(originalModuleDir + '/' + path);
		} else {
			relPath = normalize(originalModuleDir + '/node_modules/' + path);
		}

		if (relPath.endsWith('/..')) {
			break; // Travelled too far up, avoid infinite loop
		}

		for (var extensionIndex = 0; extensionIndex < checkedExtensions.length; extensionIndex++) {
			var resolvedPath = relPath + checkedExtensions[extensionIndex];
			if (modules[resolvedPath]) {
				return resolvedPath;
			}
		}
		if (!shouldTryNodeModules) break;
		var nextDir = normalize(originalModuleDir + '/..');
		if (nextDir === originalModuleDir) break;
		originalModuleDir = nextDir;
	}
	return null;
}

function isPossibleNodeModulesPath (modulePath) {
	var c0 = modulePath[0];
	if (c0 === '/' || c0 === '\\\\') return false;
	var c1 = modulePath[1], c2 = modulePath[2];
	if ((c0 === '.' && (!c1 || c1 === '/' || c1 === '\\\\')) ||
		(c0 === '.' && c1 === '.' && (!c2 || c2 === '/' || c2 === '\\\\'))) return false;
	if (c1 === ':' && (c2 === '/' || c2 === '\\\\')) return false;
	return true;
}

function normalize (path) {
	path = path.replace(/\\\\/g, '/');
	var parts = path.split('/');
	var slashed = parts[0] === '';
	for (var i = 1; i < parts.length; i++) {
		if (parts[i] === '.' || parts[i] === '') {
			parts.splice(i--, 1);
		}
	}
	for (var i = 1; i < parts.length; i++) {
		if (parts[i] !== '..') continue;
		if (i > 0 && parts[i - 1] !== '..' && parts[i - 1] !== '.') {
			parts.splice(--i, 2);
			i--;
		}
	}
	path = parts.join('/');
	if (slashed && path[0] !== '/') path = '/' + path;
	else if (path.length === 0) path = '.';
	return path;
}`;
}
var isWrappedId = (id, suffix) => id.endsWith(suffix);
var wrapId$1 = (id, suffix) => `\0${id}${suffix}`;
var unwrapId$1 = (wrappedId, suffix) => wrappedId.slice(1, -suffix.length);
var PROXY_SUFFIX = "?commonjs-proxy";
var WRAPPED_SUFFIX = "?commonjs-wrapped";
var EXTERNAL_SUFFIX = "?commonjs-external";
var EXPORTS_SUFFIX = "?commonjs-exports";
var MODULE_SUFFIX = "?commonjs-module";
var ENTRY_SUFFIX = "?commonjs-entry";
var ES_IMPORT_SUFFIX = "?commonjs-es-import";
var DYNAMIC_MODULES_ID = "\0commonjs-dynamic-modules";
var HELPERS_ID = "\0commonjsHelpers.js";
var IS_WRAPPED_COMMONJS = "withRequireFunction";
var HELPERS = `
export var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

export function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

export function getDefaultExportFromNamespaceIfPresent (n) {
	return n && Object.prototype.hasOwnProperty.call(n, 'default') ? n['default'] : n;
}

export function getDefaultExportFromNamespaceIfNotNamed (n) {
	return n && Object.prototype.hasOwnProperty.call(n, 'default') && Object.keys(n).length === 1 ? n['default'] : n;
}

export function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			if (this instanceof a) {
				var args = [null];
				args.push.apply(args, arguments);
				var Ctor = Function.bind.apply(f, args);
				return new Ctor();
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}
`;
function getHelpersModule() {
  return HELPERS;
}
function getUnknownRequireProxy(id, requireReturnsDefault) {
  if (requireReturnsDefault === true || id.endsWith(".json")) {
    return `export { default } from ${JSON.stringify(id)};`;
  }
  const name2 = getName(id);
  const exported = requireReturnsDefault === "auto" ? `import { getDefaultExportFromNamespaceIfNotNamed } from "${HELPERS_ID}"; export default /*@__PURE__*/getDefaultExportFromNamespaceIfNotNamed(${name2});` : requireReturnsDefault === "preferred" ? `import { getDefaultExportFromNamespaceIfPresent } from "${HELPERS_ID}"; export default /*@__PURE__*/getDefaultExportFromNamespaceIfPresent(${name2});` : !requireReturnsDefault ? `import { getAugmentedNamespace } from "${HELPERS_ID}"; export default /*@__PURE__*/getAugmentedNamespace(${name2});` : `export default ${name2};`;
  return `import * as ${name2} from ${JSON.stringify(id)}; ${exported}`;
}
async function getStaticRequireProxy(id, requireReturnsDefault, loadModule) {
  const name2 = getName(id);
  const {
    meta: { commonjs: commonjsMeta }
  } = await loadModule({ id });
  if (!commonjsMeta) {
    return getUnknownRequireProxy(id, requireReturnsDefault);
  } else if (commonjsMeta.isCommonJS) {
    return `export { __moduleExports as default } from ${JSON.stringify(id)};`;
  } else if (!requireReturnsDefault) {
    return `import { getAugmentedNamespace } from "${HELPERS_ID}"; import * as ${name2} from ${JSON.stringify(
      id
    )}; export default /*@__PURE__*/getAugmentedNamespace(${name2});`;
  } else if (requireReturnsDefault !== true && (requireReturnsDefault === "namespace" || !commonjsMeta.hasDefaultExport || requireReturnsDefault === "auto" && commonjsMeta.hasNamedExports)) {
    return `import * as ${name2} from ${JSON.stringify(id)}; export default ${name2};`;
  }
  return `export { default } from ${JSON.stringify(id)};`;
}
function getEntryProxy(id, defaultIsModuleExports, getModuleInfo) {
  const {
    meta: { commonjs: commonjsMeta },
    hasDefaultExport
  } = getModuleInfo(id);
  if (!commonjsMeta || commonjsMeta.isCommonJS !== IS_WRAPPED_COMMONJS) {
    const stringifiedId = JSON.stringify(id);
    let code = `export * from ${stringifiedId};`;
    if (hasDefaultExport) {
      code += `export { default } from ${stringifiedId};`;
    }
    return code;
  }
  return getEsImportProxy(id, defaultIsModuleExports);
}
function getEsImportProxy(id, defaultIsModuleExports) {
  const name2 = getName(id);
  const exportsName = `${name2}Exports`;
  const requireModule = `require${capitalize(name2)}`;
  let code = `import { getDefaultExportFromCjs } from "${HELPERS_ID}";
import { __require as ${requireModule} } from ${JSON.stringify(id)};
var ${exportsName} = ${requireModule}();
export { ${exportsName} as __moduleExports };`;
  if (defaultIsModuleExports === true) {
    code += `
export { ${exportsName} as default };`;
  } else {
    code += `export default /*@__PURE__*/getDefaultExportFromCjs(${exportsName});`;
  }
  return {
    code,
    syntheticNamedExports: "__moduleExports"
  };
}
function getCandidatesForExtension(resolved, extension2) {
  return [resolved + extension2, `${resolved}${import_path.sep}index${extension2}`];
}
function getCandidates(resolved, extensions2) {
  return extensions2.reduce(
    (paths, extension2) => paths.concat(getCandidatesForExtension(resolved, extension2)),
    [resolved]
  );
}
function resolveExtensions(importee, importer, extensions2) {
  if (importee[0] !== "." || !importer)
    return void 0;
  const resolved = (0, import_path.resolve)((0, import_path.dirname)(importer), importee);
  const candidates = getCandidates(resolved, extensions2);
  for (let i2 = 0; i2 < candidates.length; i2 += 1) {
    try {
      const stats = (0, import_fs.statSync)(candidates[i2]);
      if (stats.isFile())
        return { id: candidates[i2] };
    } catch (err2) {
    }
  }
  return void 0;
}
function getResolveId(extensions2, isPossibleCjsId) {
  const currentlyResolving = /* @__PURE__ */ new Map();
  return {
    /**
     * This is a Maps of importers to Sets of require sources being resolved at
     * the moment by resolveRequireSourcesAndUpdateMeta
     */
    currentlyResolving,
    async resolveId(importee, importer, resolveOptions) {
      const customOptions = resolveOptions.custom;
      if (customOptions && customOptions["node-resolve"] && customOptions["node-resolve"].isRequire) {
        return null;
      }
      const currentlyResolvingForParent = currentlyResolving.get(importer);
      if (currentlyResolvingForParent && currentlyResolvingForParent.has(importee)) {
        this.warn({
          code: "THIS_RESOLVE_WITHOUT_OPTIONS",
          message: 'It appears a plugin has implemented a "resolveId" hook that uses "this.resolve" without forwarding the third "options" parameter of "resolveId". This is problematic as it can lead to wrong module resolutions especially for the node-resolve plugin and in certain cases cause early exit errors for the commonjs plugin.\nIn rare cases, this warning can appear if the same file is both imported and required from the same mixed ES/CommonJS module, in which case it can be ignored.',
          url: "https://rollupjs.org/guide/en/#resolveid"
        });
        return null;
      }
      if (isWrappedId(importee, WRAPPED_SUFFIX)) {
        return unwrapId$1(importee, WRAPPED_SUFFIX);
      }
      if (importee.endsWith(ENTRY_SUFFIX) || isWrappedId(importee, MODULE_SUFFIX) || isWrappedId(importee, EXPORTS_SUFFIX) || isWrappedId(importee, PROXY_SUFFIX) || isWrappedId(importee, ES_IMPORT_SUFFIX) || isWrappedId(importee, EXTERNAL_SUFFIX) || importee.startsWith(HELPERS_ID) || importee === DYNAMIC_MODULES_ID) {
        return importee;
      }
      if (importer) {
        if (importer === DYNAMIC_MODULES_ID || // Proxies are only importing resolved ids, no need to resolve again
        isWrappedId(importer, PROXY_SUFFIX) || isWrappedId(importer, ES_IMPORT_SUFFIX) || importer.endsWith(ENTRY_SUFFIX)) {
          return importee;
        }
        if (isWrappedId(importer, EXTERNAL_SUFFIX)) {
          if (!await this.resolve(
            importee,
            importer,
            Object.assign({ skipSelf: true }, resolveOptions)
          )) {
            return null;
          }
          return { id: importee, external: true };
        }
      }
      if (importee.startsWith("\0")) {
        return null;
      }
      const resolved = await this.resolve(
        importee,
        importer,
        Object.assign({ skipSelf: true }, resolveOptions)
      ) || resolveExtensions(importee, importer, extensions2);
      if (!resolved || resolved.external || resolved.id.endsWith(ENTRY_SUFFIX) || isWrappedId(resolved.id, ES_IMPORT_SUFFIX) || !isPossibleCjsId(resolved.id)) {
        return resolved;
      }
      const moduleInfo = await this.load(resolved);
      const {
        meta: { commonjs: commonjsMeta }
      } = moduleInfo;
      if (commonjsMeta) {
        const { isCommonJS } = commonjsMeta;
        if (isCommonJS) {
          if (resolveOptions.isEntry) {
            moduleInfo.moduleSideEffects = true;
            return resolved.id + ENTRY_SUFFIX;
          }
          if (isCommonJS === IS_WRAPPED_COMMONJS) {
            return { id: wrapId$1(resolved.id, ES_IMPORT_SUFFIX), meta: { commonjs: { resolved } } };
          }
        }
      }
      return resolved;
    }
  };
}
function getRequireResolver(extensions2, detectCyclesAndConditional, currentlyResolving) {
  const knownCjsModuleTypes = /* @__PURE__ */ Object.create(null);
  const requiredIds = /* @__PURE__ */ Object.create(null);
  const unconditionallyRequiredIds = /* @__PURE__ */ Object.create(null);
  const dependencies = /* @__PURE__ */ Object.create(null);
  const getDependencies = (id) => dependencies[id] || (dependencies[id] = /* @__PURE__ */ new Set());
  const isCyclic = (id) => {
    const dependenciesToCheck = new Set(getDependencies(id));
    for (const dependency of dependenciesToCheck) {
      if (dependency === id) {
        return true;
      }
      for (const childDependency of getDependencies(dependency)) {
        dependenciesToCheck.add(childDependency);
      }
    }
    return false;
  };
  const fullyAnalyzedModules = /* @__PURE__ */ Object.create(null);
  const getTypeForFullyAnalyzedModule = (id) => {
    const knownType = knownCjsModuleTypes[id];
    if (knownType !== true || !detectCyclesAndConditional || fullyAnalyzedModules[id]) {
      return knownType;
    }
    if (isCyclic(id)) {
      return knownCjsModuleTypes[id] = IS_WRAPPED_COMMONJS;
    }
    return knownType;
  };
  const setInitialParentType = (id, initialCommonJSType) => {
    if (fullyAnalyzedModules[id]) {
      return;
    }
    knownCjsModuleTypes[id] = initialCommonJSType;
    if (detectCyclesAndConditional && knownCjsModuleTypes[id] === true && requiredIds[id] && !unconditionallyRequiredIds[id]) {
      knownCjsModuleTypes[id] = IS_WRAPPED_COMMONJS;
    }
  };
  const analyzeRequiredModule = async (parentId, resolved, isConditional, loadModule) => {
    const childId = resolved.id;
    requiredIds[childId] = true;
    if (!(isConditional || knownCjsModuleTypes[parentId] === IS_WRAPPED_COMMONJS)) {
      unconditionallyRequiredIds[childId] = true;
    }
    getDependencies(parentId).add(childId);
    if (!isCyclic(childId)) {
      await loadModule(resolved);
    }
  };
  const getTypeForImportedModule = async (resolved, loadModule) => {
    if (resolved.id in knownCjsModuleTypes) {
      return knownCjsModuleTypes[resolved.id];
    }
    const {
      meta: { commonjs: commonjs2 }
    } = await loadModule(resolved);
    return commonjs2 && commonjs2.isCommonJS || false;
  };
  return {
    getWrappedIds: () => Object.keys(knownCjsModuleTypes).filter(
      (id) => knownCjsModuleTypes[id] === IS_WRAPPED_COMMONJS
    ),
    isRequiredId: (id) => requiredIds[id],
    async shouldTransformCachedModule({
      id: parentId,
      resolvedSources,
      meta: { commonjs: parentMeta }
    }) {
      if (!(parentMeta && parentMeta.isCommonJS))
        knownCjsModuleTypes[parentId] = false;
      if (isWrappedId(parentId, ES_IMPORT_SUFFIX))
        return false;
      const parentRequires = parentMeta && parentMeta.requires;
      if (parentRequires) {
        setInitialParentType(parentId, parentMeta.initialCommonJSType);
        await Promise.all(
          parentRequires.map(
            ({ resolved, isConditional }) => analyzeRequiredModule(parentId, resolved, isConditional, this.load)
          )
        );
        if (getTypeForFullyAnalyzedModule(parentId) !== parentMeta.isCommonJS) {
          return true;
        }
        for (const {
          resolved: { id }
        } of parentRequires) {
          if (getTypeForFullyAnalyzedModule(id) !== parentMeta.isRequiredCommonJS[id]) {
            return true;
          }
        }
        fullyAnalyzedModules[parentId] = true;
        for (const {
          resolved: { id }
        } of parentRequires) {
          fullyAnalyzedModules[id] = true;
        }
      }
      const parentRequireSet = new Set((parentRequires || []).map(({ resolved: { id } }) => id));
      return (await Promise.all(
        Object.keys(resolvedSources).map((source) => resolvedSources[source]).filter(({ id, external }) => !(external || parentRequireSet.has(id))).map(async (resolved) => {
          if (isWrappedId(resolved.id, ES_IMPORT_SUFFIX)) {
            return await getTypeForImportedModule(
              (await this.load({ id: resolved.id })).meta.commonjs.resolved,
              this.load
            ) !== IS_WRAPPED_COMMONJS;
          }
          return await getTypeForImportedModule(resolved, this.load) === IS_WRAPPED_COMMONJS;
        })
      )).some((shouldTransform) => shouldTransform);
    },
    /* eslint-disable no-param-reassign */
    resolveRequireSourcesAndUpdateMeta: (rollupContext) => async (parentId, isParentCommonJS, parentMeta, sources) => {
      parentMeta.initialCommonJSType = isParentCommonJS;
      parentMeta.requires = [];
      parentMeta.isRequiredCommonJS = /* @__PURE__ */ Object.create(null);
      setInitialParentType(parentId, isParentCommonJS);
      const currentlyResolvingForParent = currentlyResolving.get(parentId) || /* @__PURE__ */ new Set();
      currentlyResolving.set(parentId, currentlyResolvingForParent);
      const requireTargets = await Promise.all(
        sources.map(async ({ source, isConditional }) => {
          if (source.startsWith("\0")) {
            return { id: source, allowProxy: false };
          }
          currentlyResolvingForParent.add(source);
          const resolved = await rollupContext.resolve(source, parentId, {
            custom: { "node-resolve": { isRequire: true } }
          }) || resolveExtensions(source, parentId, extensions2);
          currentlyResolvingForParent.delete(source);
          if (!resolved) {
            return { id: wrapId$1(source, EXTERNAL_SUFFIX), allowProxy: false };
          }
          const childId = resolved.id;
          if (resolved.external) {
            return { id: wrapId$1(childId, EXTERNAL_SUFFIX), allowProxy: false };
          }
          parentMeta.requires.push({ resolved, isConditional });
          await analyzeRequiredModule(parentId, resolved, isConditional, rollupContext.load);
          return { id: childId, allowProxy: true };
        })
      );
      parentMeta.isCommonJS = getTypeForFullyAnalyzedModule(parentId);
      fullyAnalyzedModules[parentId] = true;
      return requireTargets.map(({ id: dependencyId, allowProxy }, index2) => {
        const isCommonJS = parentMeta.isRequiredCommonJS[dependencyId] = getTypeForFullyAnalyzedModule(dependencyId);
        fullyAnalyzedModules[dependencyId] = true;
        return {
          source: sources[index2].source,
          id: allowProxy ? isCommonJS === IS_WRAPPED_COMMONJS ? wrapId$1(dependencyId, WRAPPED_SUFFIX) : wrapId$1(dependencyId, PROXY_SUFFIX) : dependencyId,
          isCommonJS
        };
      });
    },
    isCurrentlyResolving(source, parentId) {
      const currentlyResolvingForParent = currentlyResolving.get(parentId);
      return currentlyResolvingForParent && currentlyResolvingForParent.has(source);
    }
  };
}
function validateVersion(actualVersion, peerDependencyVersion, name2) {
  const versionRegexp = /\^(\d+\.\d+\.\d+)/g;
  let minMajor = Infinity;
  let minMinor = Infinity;
  let minPatch = Infinity;
  let foundVersion;
  while (foundVersion = versionRegexp.exec(peerDependencyVersion)) {
    const [foundMajor, foundMinor, foundPatch] = foundVersion[1].split(".").map(Number);
    if (foundMajor < minMajor) {
      minMajor = foundMajor;
      minMinor = foundMinor;
      minPatch = foundPatch;
    }
  }
  if (!actualVersion) {
    throw new Error(
      `Insufficient ${name2} version: "@rollup/plugin-commonjs" requires at least ${name2}@${minMajor}.${minMinor}.${minPatch}.`
    );
  }
  const [major, minor, patch] = actualVersion.split(".").map(Number);
  if (major < minMajor || major === minMajor && (minor < minMinor || minor === minMinor && patch < minPatch)) {
    throw new Error(
      `Insufficient ${name2} version: "@rollup/plugin-commonjs" requires at least ${name2}@${minMajor}.${minMinor}.${minPatch} but found ${name2}@${actualVersion}.`
    );
  }
}
var operators = {
  "==": (x) => equals(x.left, x.right, false),
  "!=": (x) => not(operators["=="](x)),
  "===": (x) => equals(x.left, x.right, true),
  "!==": (x) => not(operators["==="](x)),
  "!": (x) => isFalsy(x.argument),
  "&&": (x) => isTruthy(x.left) && isTruthy(x.right),
  "||": (x) => isTruthy(x.left) || isTruthy(x.right)
};
function not(value2) {
  return value2 === null ? value2 : !value2;
}
function equals(a2, b, strict) {
  if (a2.type !== b.type)
    return null;
  if (a2.type === "Literal")
    return strict ? a2.value === b.value : a2.value == b.value;
  return null;
}
function isTruthy(node3) {
  if (!node3)
    return false;
  if (node3.type === "Literal")
    return !!node3.value;
  if (node3.type === "ParenthesizedExpression")
    return isTruthy(node3.expression);
  if (node3.operator in operators)
    return operators[node3.operator](node3);
  return null;
}
function isFalsy(node3) {
  return not(isTruthy(node3));
}
function getKeypath(node3) {
  const parts = [];
  while (node3.type === "MemberExpression") {
    if (node3.computed)
      return null;
    parts.unshift(node3.property.name);
    node3 = node3.object;
  }
  if (node3.type !== "Identifier")
    return null;
  const { name: name2 } = node3;
  parts.unshift(name2);
  return { name: name2, keypath: parts.join(".") };
}
var KEY_COMPILED_ESM = "__esModule";
function isDefineCompiledEsm(node3) {
  const definedProperty = getDefinePropertyCallName(node3, "exports") || getDefinePropertyCallName(node3, "module.exports");
  if (definedProperty && definedProperty.key === KEY_COMPILED_ESM) {
    return isTruthy(definedProperty.value);
  }
  return false;
}
function getDefinePropertyCallName(node3, targetName) {
  const {
    callee: { object, property }
  } = node3;
  if (!object || object.type !== "Identifier" || object.name !== "Object")
    return;
  if (!property || property.type !== "Identifier" || property.name !== "defineProperty")
    return;
  if (node3.arguments.length !== 3)
    return;
  const targetNames = targetName.split(".");
  const [target, key, value2] = node3.arguments;
  if (targetNames.length === 1) {
    if (target.type !== "Identifier" || target.name !== targetNames[0]) {
      return;
    }
  }
  if (targetNames.length === 2) {
    if (target.type !== "MemberExpression" || target.object.name !== targetNames[0] || target.property.name !== targetNames[1]) {
      return;
    }
  }
  if (value2.type !== "ObjectExpression" || !value2.properties)
    return;
  const valueProperty = value2.properties.find((p2) => p2.key && p2.key.name === "value");
  if (!valueProperty || !valueProperty.value)
    return;
  return { key: key.value, value: valueProperty.value };
}
function isShorthandProperty(parent) {
  return parent && parent.type === "Property" && parent.shorthand;
}
function hasDefineEsmProperty(node3) {
  return node3.properties.some((property) => {
    if (property.type === "Property" && property.key.type === "Identifier" && property.key.name === "__esModule" && isTruthy(property.value)) {
      return true;
    }
    return false;
  });
}
function wrapCode(magicString, uses, moduleName, exportsName, indentExclusionRanges) {
  const args = [];
  const passedArgs = [];
  if (uses.module) {
    args.push("module");
    passedArgs.push(moduleName);
  }
  if (uses.exports) {
    args.push("exports");
    passedArgs.push(exportsName);
  }
  magicString.trim().indent("	", { exclude: indentExclusionRanges }).prepend(`(function (${args.join(", ")}) {
`).append(`
} (${passedArgs.join(", ")}));`);
}
function rewriteExportsAndGetExportsBlock(magicString, moduleName, exportsName, wrapped, moduleExportsAssignments, firstTopLevelModuleExportsAssignment, exportsAssignmentsByName, topLevelAssignments, defineCompiledEsmExpressions, deconflictedExportNames, code, HELPERS_NAME, exportMode, detectWrappedDefault, defaultIsModuleExports, usesRequireWrapper, requireName) {
  const exports3 = [];
  const exportDeclarations = [];
  if (usesRequireWrapper) {
    getExportsWhenUsingRequireWrapper(
      magicString,
      wrapped,
      exportMode,
      exports3,
      moduleExportsAssignments,
      exportsAssignmentsByName,
      moduleName,
      exportsName,
      requireName,
      defineCompiledEsmExpressions
    );
  } else if (exportMode === "replace") {
    getExportsForReplacedModuleExports(
      magicString,
      exports3,
      exportDeclarations,
      moduleExportsAssignments,
      firstTopLevelModuleExportsAssignment,
      exportsName
    );
  } else {
    exports3.push(`${exportsName} as __moduleExports`);
    if (wrapped) {
      getExportsWhenWrapping(
        exportDeclarations,
        exportsName,
        detectWrappedDefault,
        HELPERS_NAME,
        defaultIsModuleExports
      );
    } else {
      getExports(
        magicString,
        exports3,
        exportDeclarations,
        moduleExportsAssignments,
        exportsAssignmentsByName,
        deconflictedExportNames,
        topLevelAssignments,
        moduleName,
        exportsName,
        defineCompiledEsmExpressions,
        HELPERS_NAME,
        defaultIsModuleExports
      );
    }
  }
  if (exports3.length) {
    exportDeclarations.push(`export { ${exports3.join(", ")} };`);
  }
  return `

${exportDeclarations.join("\n")}`;
}
function getExportsWhenUsingRequireWrapper(magicString, wrapped, exportMode, exports3, moduleExportsAssignments, exportsAssignmentsByName, moduleName, exportsName, requireName, defineCompiledEsmExpressions) {
  if (!wrapped) {
    if (exportMode === "replace") {
      for (const { left } of moduleExportsAssignments) {
        magicString.overwrite(left.start, left.end, exportsName);
      }
    } else {
      for (const { left } of moduleExportsAssignments) {
        magicString.overwrite(left.start, left.end, `${moduleName}.exports`);
      }
      for (const [exportName, { nodes }] of exportsAssignmentsByName) {
        for (const node3 of nodes) {
          magicString.overwrite(node3.start, node3.left.end, `${exportsName}.${exportName}`);
        }
      }
      for (const expression of defineCompiledEsmExpressions) {
        const moduleExportsExpression = expression.type === "CallExpression" ? expression.arguments[0] : expression.left.object;
        magicString.overwrite(
          moduleExportsExpression.start,
          moduleExportsExpression.end,
          exportsName
        );
      }
    }
  }
  exports3.push(`${requireName} as __require`);
}
function getExportsForReplacedModuleExports(magicString, exports3, exportDeclarations, moduleExportsAssignments, firstTopLevelModuleExportsAssignment, exportsName) {
  for (const { left } of moduleExportsAssignments) {
    magicString.overwrite(left.start, left.end, exportsName);
  }
  magicString.prependRight(firstTopLevelModuleExportsAssignment.left.start, "var ");
  exports3.push(`${exportsName} as __moduleExports`);
  exportDeclarations.push(`export default ${exportsName};`);
}
function getExportsWhenWrapping(exportDeclarations, exportsName, detectWrappedDefault, HELPERS_NAME, defaultIsModuleExports) {
  exportDeclarations.push(
    `export default ${detectWrappedDefault && defaultIsModuleExports === "auto" ? `/*@__PURE__*/${HELPERS_NAME}.getDefaultExportFromCjs(${exportsName})` : defaultIsModuleExports === false ? `${exportsName}.default` : exportsName};`
  );
}
function getExports(magicString, exports3, exportDeclarations, moduleExportsAssignments, exportsAssignmentsByName, deconflictedExportNames, topLevelAssignments, moduleName, exportsName, defineCompiledEsmExpressions, HELPERS_NAME, defaultIsModuleExports) {
  let deconflictedDefaultExportName;
  for (const { left } of moduleExportsAssignments) {
    magicString.overwrite(left.start, left.end, `${moduleName}.exports`);
  }
  for (const [exportName, { nodes }] of exportsAssignmentsByName) {
    const deconflicted = deconflictedExportNames[exportName];
    let needsDeclaration = true;
    for (const node3 of nodes) {
      let replacement = `${deconflicted} = ${exportsName}.${exportName}`;
      if (needsDeclaration && topLevelAssignments.has(node3)) {
        replacement = `var ${replacement}`;
        needsDeclaration = false;
      }
      magicString.overwrite(node3.start, node3.left.end, replacement);
    }
    if (needsDeclaration) {
      magicString.prepend(`var ${deconflicted};
`);
    }
    if (exportName === "default") {
      deconflictedDefaultExportName = deconflicted;
    } else {
      exports3.push(exportName === deconflicted ? exportName : `${deconflicted} as ${exportName}`);
    }
  }
  let isRestorableCompiledEsm = false;
  for (const expression of defineCompiledEsmExpressions) {
    isRestorableCompiledEsm = true;
    const moduleExportsExpression = expression.type === "CallExpression" ? expression.arguments[0] : expression.left.object;
    magicString.overwrite(moduleExportsExpression.start, moduleExportsExpression.end, exportsName);
  }
  if (!isRestorableCompiledEsm || defaultIsModuleExports === true) {
    exports3.push(`${exportsName} as default`);
  } else if (moduleExportsAssignments.length === 0 || defaultIsModuleExports === false) {
    exports3.push(`${deconflictedDefaultExportName || exportsName} as default`);
  } else {
    exportDeclarations.push(
      `export default /*@__PURE__*/${HELPERS_NAME}.getDefaultExportFromCjs(${exportsName});`
    );
  }
}
function isRequireExpression(node3, scope) {
  if (!node3)
    return false;
  if (node3.type !== "CallExpression")
    return false;
  if (node3.arguments.length === 0)
    return false;
  return isRequire(node3.callee, scope);
}
function isRequire(node3, scope) {
  return node3.type === "Identifier" && node3.name === "require" && !scope.contains("require") || node3.type === "MemberExpression" && isModuleRequire(node3, scope);
}
function isModuleRequire({ object, property }, scope) {
  return object.type === "Identifier" && object.name === "module" && property.type === "Identifier" && property.name === "require" && !scope.contains("module");
}
function hasDynamicArguments(node3) {
  return node3.arguments.length > 1 || node3.arguments[0].type !== "Literal" && (node3.arguments[0].type !== "TemplateLiteral" || node3.arguments[0].expressions.length > 0);
}
var reservedMethod = { resolve: true, cache: true, main: true };
function isNodeRequirePropertyAccess(parent) {
  return parent && parent.property && reservedMethod[parent.property.name];
}
function getRequireStringArg(node3) {
  return node3.arguments[0].type === "Literal" ? node3.arguments[0].value : node3.arguments[0].quasis[0].value.cooked;
}
function getRequireHandlers() {
  const requireExpressions = [];
  function addRequireExpression(sourceId, node3, scope, usesReturnValue, isInsideTryBlock, isInsideConditional, toBeRemoved) {
    requireExpressions.push({
      sourceId,
      node: node3,
      scope,
      usesReturnValue,
      isInsideTryBlock,
      isInsideConditional,
      toBeRemoved
    });
  }
  async function rewriteRequireExpressionsAndGetImportBlock(magicString, topLevelDeclarations, reassignedNames, helpersName, dynamicRequireName, moduleName, exportsName, id, exportMode, resolveRequireSourcesAndUpdateMeta, needsRequireWrapper, isEsModule, isDynamicRequireModulesEnabled, getIgnoreTryCatchRequireStatementMode, commonjsMeta) {
    const imports = [];
    imports.push(`import * as ${helpersName} from "${HELPERS_ID}";`);
    if (dynamicRequireName) {
      imports.push(
        `import { ${isDynamicRequireModulesEnabled ? CREATE_COMMONJS_REQUIRE_EXPORT : COMMONJS_REQUIRE_EXPORT} as ${dynamicRequireName} } from "${DYNAMIC_MODULES_ID}";`
      );
    }
    if (exportMode === "module") {
      imports.push(
        `import { __module as ${moduleName}, exports as ${exportsName} } from ${JSON.stringify(
          wrapId$1(id, MODULE_SUFFIX)
        )}`
      );
    } else if (exportMode === "exports") {
      imports.push(
        `import { __exports as ${exportsName} } from ${JSON.stringify(wrapId$1(id, EXPORTS_SUFFIX))}`
      );
    }
    const requiresBySource = collectSources(requireExpressions);
    const requireTargets = await resolveRequireSourcesAndUpdateMeta(
      id,
      needsRequireWrapper ? IS_WRAPPED_COMMONJS : !isEsModule,
      commonjsMeta,
      Object.keys(requiresBySource).map((source) => {
        return {
          source,
          isConditional: requiresBySource[source].every((require5) => require5.isInsideConditional)
        };
      })
    );
    processRequireExpressions(
      imports,
      requireTargets,
      requiresBySource,
      getIgnoreTryCatchRequireStatementMode,
      magicString
    );
    return imports.length ? `${imports.join("\n")}

` : "";
  }
  return {
    addRequireExpression,
    rewriteRequireExpressionsAndGetImportBlock
  };
}
function collectSources(requireExpressions) {
  const requiresBySource = /* @__PURE__ */ Object.create(null);
  for (const requireExpression of requireExpressions) {
    const { sourceId } = requireExpression;
    if (!requiresBySource[sourceId]) {
      requiresBySource[sourceId] = [];
    }
    const requires = requiresBySource[sourceId];
    requires.push(requireExpression);
  }
  return requiresBySource;
}
function processRequireExpressions(imports, requireTargets, requiresBySource, getIgnoreTryCatchRequireStatementMode, magicString) {
  const generateRequireName = getGenerateRequireName();
  for (const { source, id: resolvedId, isCommonJS } of requireTargets) {
    const requires = requiresBySource[source];
    const name2 = generateRequireName(requires);
    let usesRequired = false;
    let needsImport = false;
    for (const { node: node3, usesReturnValue, toBeRemoved, isInsideTryBlock } of requires) {
      const { canConvertRequire, shouldRemoveRequire } = isInsideTryBlock && isWrappedId(resolvedId, EXTERNAL_SUFFIX) ? getIgnoreTryCatchRequireStatementMode(source) : { canConvertRequire: true, shouldRemoveRequire: false };
      if (shouldRemoveRequire) {
        if (usesReturnValue) {
          magicString.overwrite(node3.start, node3.end, "undefined");
        } else {
          magicString.remove(toBeRemoved.start, toBeRemoved.end);
        }
      } else if (canConvertRequire) {
        needsImport = true;
        if (isCommonJS === IS_WRAPPED_COMMONJS) {
          magicString.overwrite(node3.start, node3.end, `${name2}()`);
        } else if (usesReturnValue) {
          usesRequired = true;
          magicString.overwrite(node3.start, node3.end, name2);
        } else {
          magicString.remove(toBeRemoved.start, toBeRemoved.end);
        }
      }
    }
    if (needsImport) {
      if (isCommonJS === IS_WRAPPED_COMMONJS) {
        imports.push(`import { __require as ${name2} } from ${JSON.stringify(resolvedId)};`);
      } else {
        imports.push(`import ${usesRequired ? `${name2} from ` : ""}${JSON.stringify(resolvedId)};`);
      }
    }
  }
}
function getGenerateRequireName() {
  let uid = 0;
  return (requires) => {
    let name2;
    const hasNameConflict = ({ scope }) => scope.contains(name2);
    do {
      name2 = `require$$${uid}`;
      uid += 1;
    } while (requires.some(hasNameConflict));
    return name2;
  };
}
var exportsPattern = /^(?:module\.)?exports(?:\.([a-zA-Z_$][a-zA-Z_$0-9]*))?$/;
var functionType = /^(?:FunctionDeclaration|FunctionExpression|ArrowFunctionExpression)$/;
async function transformCommonjs(parse7, code, id, isEsModule, ignoreGlobal, ignoreRequire, ignoreDynamicRequires, getIgnoreTryCatchRequireStatementMode, sourceMap, isDynamicRequireModulesEnabled, dynamicRequireModules, commonDir, astCache, defaultIsModuleExports, needsRequireWrapper, resolveRequireSourcesAndUpdateMeta, isRequired, checkDynamicRequire, commonjsMeta) {
  const ast = astCache || tryParse(parse7, code, id);
  const magicString = new MagicString(code);
  const uses = {
    module: false,
    exports: false,
    global: false,
    require: false
  };
  const virtualDynamicRequirePath = isDynamicRequireModulesEnabled && getVirtualPathForDynamicRequirePath((0, import_path.dirname)(id), commonDir);
  let scope = attachScopes(ast, "scope");
  let lexicalDepth = 0;
  let programDepth = 0;
  let currentTryBlockEnd = null;
  let shouldWrap = false;
  let reexports = false;
  const globals = /* @__PURE__ */ new Set();
  let currentConditionalNodeEnd = null;
  const conditionalNodes = /* @__PURE__ */ new Set();
  const { addRequireExpression, rewriteRequireExpressionsAndGetImportBlock } = getRequireHandlers();
  const reassignedNames = /* @__PURE__ */ new Set();
  const topLevelDeclarations = [];
  const skippedNodes = /* @__PURE__ */ new Set();
  const moduleAccessScopes = /* @__PURE__ */ new Set([scope]);
  const exportsAccessScopes = /* @__PURE__ */ new Set([scope]);
  const moduleExportsAssignments = [];
  let firstTopLevelModuleExportsAssignment = null;
  const exportsAssignmentsByName = /* @__PURE__ */ new Map();
  const topLevelAssignments = /* @__PURE__ */ new Set();
  const topLevelDefineCompiledEsmExpressions = [];
  const replacedGlobal = [];
  const replacedDynamicRequires = [];
  const importedVariables = /* @__PURE__ */ new Set();
  const indentExclusionRanges = [];
  walk$3(ast, {
    enter(node3, parent) {
      if (skippedNodes.has(node3)) {
        this.skip();
        return;
      }
      if (currentTryBlockEnd !== null && node3.start > currentTryBlockEnd) {
        currentTryBlockEnd = null;
      }
      if (currentConditionalNodeEnd !== null && node3.start > currentConditionalNodeEnd) {
        currentConditionalNodeEnd = null;
      }
      if (currentConditionalNodeEnd === null && conditionalNodes.has(node3)) {
        currentConditionalNodeEnd = node3.end;
      }
      programDepth += 1;
      if (node3.scope)
        ({ scope } = node3);
      if (functionType.test(node3.type))
        lexicalDepth += 1;
      if (sourceMap) {
        magicString.addSourcemapLocation(node3.start);
        magicString.addSourcemapLocation(node3.end);
      }
      switch (node3.type) {
        case "AssignmentExpression":
          if (node3.left.type === "MemberExpression") {
            const flattened = getKeypath(node3.left);
            if (!flattened || scope.contains(flattened.name))
              return;
            const exportsPatternMatch = exportsPattern.exec(flattened.keypath);
            if (!exportsPatternMatch || flattened.keypath === "exports")
              return;
            const [, exportName] = exportsPatternMatch;
            uses[flattened.name] = true;
            if (flattened.keypath === "module.exports") {
              moduleExportsAssignments.push(node3);
              if (programDepth > 3) {
                moduleAccessScopes.add(scope);
              } else if (!firstTopLevelModuleExportsAssignment) {
                firstTopLevelModuleExportsAssignment = node3;
              }
              if (defaultIsModuleExports === false) {
                shouldWrap = true;
              } else if (defaultIsModuleExports === "auto") {
                if (node3.right.type === "ObjectExpression") {
                  if (hasDefineEsmProperty(node3.right)) {
                    shouldWrap = true;
                  }
                } else if (isRequireExpression(node3.right, scope)) {
                  shouldWrap = true;
                  reexports = true;
                }
              }
            } else if (exportName === KEY_COMPILED_ESM) {
              if (programDepth > 3) {
                shouldWrap = true;
              } else {
                topLevelDefineCompiledEsmExpressions.push(node3);
              }
            } else {
              const exportsAssignments = exportsAssignmentsByName.get(exportName) || {
                nodes: [],
                scopes: /* @__PURE__ */ new Set()
              };
              exportsAssignments.nodes.push(node3);
              exportsAssignments.scopes.add(scope);
              exportsAccessScopes.add(scope);
              exportsAssignmentsByName.set(exportName, exportsAssignments);
              if (programDepth <= 3) {
                topLevelAssignments.add(node3);
              }
            }
            skippedNodes.add(node3.left);
          } else {
            for (const name2 of extractAssignedNames(node3.left)) {
              reassignedNames.add(name2);
            }
          }
          return;
        case "CallExpression": {
          if (isDefineCompiledEsm(node3)) {
            if (programDepth === 3 && parent.type === "ExpressionStatement") {
              skippedNodes.add(node3.arguments[0]);
              topLevelDefineCompiledEsmExpressions.push(node3);
            } else {
              shouldWrap = true;
            }
            return;
          }
          if (isDynamicRequireModulesEnabled && node3.callee.object && isRequire(node3.callee.object, scope) && node3.callee.property.name === "resolve") {
            checkDynamicRequire(node3.start);
            uses.require = true;
            const requireNode3 = node3.callee.object;
            replacedDynamicRequires.push(requireNode3);
            return;
          }
          if (!isRequireExpression(node3, scope)) {
            const keypath = getKeypath(node3.callee);
            if (keypath && importedVariables.has(keypath.name)) {
              currentConditionalNodeEnd = Infinity;
            }
            return;
          }
          skippedNodes.add(node3.callee);
          uses.require = true;
          if (hasDynamicArguments(node3)) {
            if (isDynamicRequireModulesEnabled) {
              checkDynamicRequire(node3.start);
            }
            if (!ignoreDynamicRequires) {
              replacedDynamicRequires.push(node3.callee);
            }
            return;
          }
          const requireStringArg = getRequireStringArg(node3);
          if (!ignoreRequire(requireStringArg)) {
            const usesReturnValue = parent.type !== "ExpressionStatement";
            const toBeRemoved = parent.type === "ExpressionStatement" && (!currentConditionalNodeEnd || // We should completely remove requires directly in a try-catch
            // so that Rollup can remove up the try-catch
            currentTryBlockEnd !== null && currentTryBlockEnd < currentConditionalNodeEnd) ? parent : node3;
            addRequireExpression(
              requireStringArg,
              node3,
              scope,
              usesReturnValue,
              currentTryBlockEnd !== null,
              currentConditionalNodeEnd !== null,
              toBeRemoved
            );
            if (parent.type === "VariableDeclarator" && parent.id.type === "Identifier") {
              for (const name2 of extractAssignedNames(parent.id)) {
                importedVariables.add(name2);
              }
            }
          }
          return;
        }
        case "ConditionalExpression":
        case "IfStatement":
          if (isFalsy(node3.test)) {
            skippedNodes.add(node3.consequent);
          } else if (isTruthy(node3.test)) {
            if (node3.alternate) {
              skippedNodes.add(node3.alternate);
            }
          } else {
            conditionalNodes.add(node3.consequent);
            if (node3.alternate) {
              conditionalNodes.add(node3.alternate);
            }
          }
          return;
        case "ArrowFunctionExpression":
        case "FunctionDeclaration":
        case "FunctionExpression":
          if (currentConditionalNodeEnd === null && !(parent.type === "CallExpression" && parent.callee === node3)) {
            currentConditionalNodeEnd = node3.end;
          }
          return;
        case "Identifier": {
          const { name: name2 } = node3;
          if (!isReference(node3, parent) || scope.contains(name2))
            return;
          switch (name2) {
            case "require":
              uses.require = true;
              if (isNodeRequirePropertyAccess(parent)) {
                return;
              }
              if (!ignoreDynamicRequires) {
                if (isShorthandProperty(parent)) {
                  magicString.prependRight(node3.start, "require: ");
                }
                replacedDynamicRequires.push(node3);
              }
              return;
            case "module":
            case "exports":
              shouldWrap = true;
              uses[name2] = true;
              return;
            case "global":
              uses.global = true;
              if (!ignoreGlobal) {
                replacedGlobal.push(node3);
              }
              return;
            case "define":
              magicString.overwrite(node3.start, node3.end, "undefined", {
                storeName: true
              });
              return;
            default:
              globals.add(name2);
              return;
          }
        }
        case "LogicalExpression":
          if (node3.operator === "&&") {
            if (isFalsy(node3.left)) {
              skippedNodes.add(node3.right);
            } else if (!isTruthy(node3.left)) {
              conditionalNodes.add(node3.right);
            }
          } else if (node3.operator === "||") {
            if (isTruthy(node3.left)) {
              skippedNodes.add(node3.right);
            } else if (!isFalsy(node3.left)) {
              conditionalNodes.add(node3.right);
            }
          }
          return;
        case "MemberExpression":
          if (!isDynamicRequireModulesEnabled && isModuleRequire(node3, scope)) {
            uses.require = true;
            replacedDynamicRequires.push(node3);
            skippedNodes.add(node3.object);
            skippedNodes.add(node3.property);
          }
          return;
        case "ReturnStatement":
          if (lexicalDepth === 0) {
            shouldWrap = true;
          }
          return;
        case "ThisExpression":
          if (lexicalDepth === 0) {
            uses.global = true;
            if (!ignoreGlobal) {
              replacedGlobal.push(node3);
            }
          }
          return;
        case "TryStatement":
          if (currentTryBlockEnd === null) {
            currentTryBlockEnd = node3.block.end;
          }
          if (currentConditionalNodeEnd === null) {
            currentConditionalNodeEnd = node3.end;
          }
          return;
        case "UnaryExpression":
          if (node3.operator === "typeof") {
            const flattened = getKeypath(node3.argument);
            if (!flattened)
              return;
            if (scope.contains(flattened.name))
              return;
            if (!isEsModule && (flattened.keypath === "module.exports" || flattened.keypath === "module" || flattened.keypath === "exports")) {
              magicString.overwrite(node3.start, node3.end, `'object'`, {
                storeName: false
              });
            }
          }
          return;
        case "VariableDeclaration":
          if (!scope.parent) {
            topLevelDeclarations.push(node3);
          }
          return;
        case "TemplateElement":
          if (node3.value.raw.includes("\n")) {
            indentExclusionRanges.push([node3.start, node3.end]);
          }
      }
    },
    leave(node3) {
      programDepth -= 1;
      if (node3.scope)
        scope = scope.parent;
      if (functionType.test(node3.type))
        lexicalDepth -= 1;
    }
  });
  const nameBase = getName(id);
  const exportsName = deconflict([...exportsAccessScopes], globals, nameBase);
  const moduleName = deconflict([...moduleAccessScopes], globals, `${nameBase}Module`);
  const requireName = deconflict([scope], globals, `require${capitalize(nameBase)}`);
  const isRequiredName = deconflict([scope], globals, `hasRequired${capitalize(nameBase)}`);
  const helpersName = deconflict([scope], globals, "commonjsHelpers");
  const dynamicRequireName = replacedDynamicRequires.length > 0 && deconflict(
    [scope],
    globals,
    isDynamicRequireModulesEnabled ? CREATE_COMMONJS_REQUIRE_EXPORT : COMMONJS_REQUIRE_EXPORT
  );
  const deconflictedExportNames = /* @__PURE__ */ Object.create(null);
  for (const [exportName, { scopes }] of exportsAssignmentsByName) {
    deconflictedExportNames[exportName] = deconflict([...scopes], globals, exportName);
  }
  for (const node3 of replacedGlobal) {
    magicString.overwrite(node3.start, node3.end, `${helpersName}.commonjsGlobal`, {
      storeName: true
    });
  }
  for (const node3 of replacedDynamicRequires) {
    magicString.overwrite(
      node3.start,
      node3.end,
      isDynamicRequireModulesEnabled ? `${dynamicRequireName}(${JSON.stringify(virtualDynamicRequirePath)})` : dynamicRequireName,
      {
        contentOnly: true,
        storeName: true
      }
    );
  }
  shouldWrap = !isEsModule && (shouldWrap || uses.exports && moduleExportsAssignments.length > 0);
  const detectWrappedDefault = shouldWrap && (reexports || topLevelDefineCompiledEsmExpressions.length > 0 || code.indexOf("__esModule") >= 0);
  if (!(shouldWrap || isRequired || needsRequireWrapper || uses.module || uses.exports || uses.require || topLevelDefineCompiledEsmExpressions.length > 0) && (ignoreGlobal || !uses.global)) {
    return { meta: { commonjs: { isCommonJS: false } } };
  }
  let leadingComment = "";
  if (code.startsWith("/*")) {
    const commentEnd = code.indexOf("*/", 2) + 2;
    leadingComment = `${code.slice(0, commentEnd)}
`;
    magicString.remove(0, commentEnd).trim();
  }
  const exportMode = isEsModule ? "none" : shouldWrap ? uses.module ? "module" : "exports" : firstTopLevelModuleExportsAssignment ? exportsAssignmentsByName.size === 0 && topLevelDefineCompiledEsmExpressions.length === 0 ? "replace" : "module" : moduleExportsAssignments.length === 0 ? "exports" : "module";
  const importBlock = await rewriteRequireExpressionsAndGetImportBlock(
    magicString,
    topLevelDeclarations,
    reassignedNames,
    helpersName,
    dynamicRequireName,
    moduleName,
    exportsName,
    id,
    exportMode,
    resolveRequireSourcesAndUpdateMeta,
    needsRequireWrapper,
    isEsModule,
    isDynamicRequireModulesEnabled,
    getIgnoreTryCatchRequireStatementMode,
    commonjsMeta
  );
  const usesRequireWrapper = commonjsMeta.isCommonJS === IS_WRAPPED_COMMONJS;
  const exportBlock = isEsModule ? "" : rewriteExportsAndGetExportsBlock(
    magicString,
    moduleName,
    exportsName,
    shouldWrap,
    moduleExportsAssignments,
    firstTopLevelModuleExportsAssignment,
    exportsAssignmentsByName,
    topLevelAssignments,
    topLevelDefineCompiledEsmExpressions,
    deconflictedExportNames,
    code,
    helpersName,
    exportMode,
    detectWrappedDefault,
    defaultIsModuleExports,
    usesRequireWrapper,
    requireName
  );
  if (shouldWrap) {
    wrapCode(magicString, uses, moduleName, exportsName, indentExclusionRanges);
  }
  if (usesRequireWrapper) {
    magicString.trim().indent("	", {
      exclude: indentExclusionRanges
    });
    magicString.prepend(
      `var ${isRequiredName};

function ${requireName} () {
	if (${isRequiredName}) return ${exportsName};
	${isRequiredName} = 1;
`
    ).append(`
	return ${exportsName};
}`);
    if (exportMode === "replace") {
      magicString.prepend(`var ${exportsName};
`);
    }
  }
  magicString.trim().prepend(leadingComment + importBlock).append(exportBlock);
  return {
    code: magicString.toString(),
    map: sourceMap ? magicString.generateMap() : null,
    syntheticNamedExports: isEsModule || usesRequireWrapper ? false : "__moduleExports",
    meta: { commonjs: commonjsMeta }
  };
}
var PLUGIN_NAME = "commonjs";
function commonjs(options3 = {}) {
  const {
    ignoreGlobal,
    ignoreDynamicRequires,
    requireReturnsDefault: requireReturnsDefaultOption,
    defaultIsModuleExports: defaultIsModuleExportsOption,
    esmExternals
  } = options3;
  const extensions2 = options3.extensions || [".js"];
  const filter2 = createFilter$1(options3.include, options3.exclude);
  const isPossibleCjsId = (id) => {
    const extName = (0, import_path.extname)(id);
    return extName === ".cjs" || extensions2.includes(extName) && filter2(id);
  };
  const { strictRequiresFilter, detectCyclesAndConditional } = getStrictRequiresFilter(options3);
  const getRequireReturnsDefault = typeof requireReturnsDefaultOption === "function" ? requireReturnsDefaultOption : () => requireReturnsDefaultOption;
  let esmExternalIds;
  const isEsmExternal = typeof esmExternals === "function" ? esmExternals : Array.isArray(esmExternals) ? (esmExternalIds = new Set(esmExternals), (id) => esmExternalIds.has(id)) : () => esmExternals;
  const getDefaultIsModuleExports = typeof defaultIsModuleExportsOption === "function" ? defaultIsModuleExportsOption : () => typeof defaultIsModuleExportsOption === "boolean" ? defaultIsModuleExportsOption : "auto";
  const dynamicRequireRoot = typeof options3.dynamicRequireRoot === "string" ? (0, import_path.resolve)(options3.dynamicRequireRoot) : process.cwd();
  const { commonDir, dynamicRequireModules } = getDynamicRequireModules(
    options3.dynamicRequireTargets,
    dynamicRequireRoot
  );
  const isDynamicRequireModulesEnabled = dynamicRequireModules.size > 0;
  const ignoreRequire = typeof options3.ignore === "function" ? options3.ignore : Array.isArray(options3.ignore) ? (id) => options3.ignore.includes(id) : () => false;
  const getIgnoreTryCatchRequireStatementMode = (id) => {
    const mode2 = typeof options3.ignoreTryCatch === "function" ? options3.ignoreTryCatch(id) : Array.isArray(options3.ignoreTryCatch) ? options3.ignoreTryCatch.includes(id) : typeof options3.ignoreTryCatch !== "undefined" ? options3.ignoreTryCatch : true;
    return {
      canConvertRequire: mode2 !== "remove" && mode2 !== true,
      shouldRemoveRequire: mode2 === "remove"
    };
  };
  const { currentlyResolving, resolveId } = getResolveId(extensions2, isPossibleCjsId);
  const sourceMap = options3.sourceMap !== false;
  let requireResolver;
  function transformAndCheckExports(code, id) {
    const { isEsModule, hasDefaultExport, hasNamedExports, ast } = analyzeTopLevelStatements(
      this.parse,
      code,
      id
    );
    const commonjsMeta = this.getModuleInfo(id).meta.commonjs || {};
    if (hasDefaultExport) {
      commonjsMeta.hasDefaultExport = true;
    }
    if (hasNamedExports) {
      commonjsMeta.hasNamedExports = true;
    }
    if (!dynamicRequireModules.has(normalizePathSlashes(id)) && (!(hasCjsKeywords(code, ignoreGlobal) || requireResolver.isRequiredId(id)) || isEsModule && !options3.transformMixedEsModules)) {
      commonjsMeta.isCommonJS = false;
      return { meta: { commonjs: commonjsMeta } };
    }
    const needsRequireWrapper = !isEsModule && (dynamicRequireModules.has(normalizePathSlashes(id)) || strictRequiresFilter(id));
    const checkDynamicRequire = (position) => {
      if (id.indexOf(dynamicRequireRoot) !== 0) {
        this.error(
          {
            code: "DYNAMIC_REQUIRE_OUTSIDE_ROOT",
            id,
            dynamicRequireRoot,
            message: `"${id}" contains dynamic require statements but it is not within the current dynamicRequireRoot "${dynamicRequireRoot}". You should set dynamicRequireRoot to "${(0, import_path.dirname)(
              id
            )}" or one of its parent directories.`
          },
          position
        );
      }
    };
    return transformCommonjs(
      this.parse,
      code,
      id,
      isEsModule,
      ignoreGlobal || isEsModule,
      ignoreRequire,
      ignoreDynamicRequires && !isDynamicRequireModulesEnabled,
      getIgnoreTryCatchRequireStatementMode,
      sourceMap,
      isDynamicRequireModulesEnabled,
      dynamicRequireModules,
      commonDir,
      ast,
      getDefaultIsModuleExports(id),
      needsRequireWrapper,
      requireResolver.resolveRequireSourcesAndUpdateMeta(this),
      requireResolver.isRequiredId(id),
      checkDynamicRequire,
      commonjsMeta
    );
  }
  return {
    name: PLUGIN_NAME,
    version: version$3,
    options(rawOptions) {
      const plugins2 = Array.isArray(rawOptions.plugins) ? [...rawOptions.plugins] : rawOptions.plugins ? [rawOptions.plugins] : [];
      plugins2.unshift({
        name: "commonjs--resolver",
        resolveId
      });
      return { ...rawOptions, plugins: plugins2 };
    },
    buildStart({ plugins: plugins2 }) {
      validateVersion(this.meta.rollupVersion, peerDependencies.rollup, "rollup");
      const nodeResolve = plugins2.find(({ name: name2 }) => name2 === "node-resolve");
      if (nodeResolve) {
        validateVersion(nodeResolve.version, "^13.0.6", "@rollup/plugin-node-resolve");
      }
      if (options3.namedExports != null) {
        this.warn(
          'The namedExports option from "@rollup/plugin-commonjs" is deprecated. Named exports are now handled automatically.'
        );
      }
      requireResolver = getRequireResolver(
        extensions2,
        detectCyclesAndConditional,
        currentlyResolving
      );
    },
    buildEnd() {
      if (options3.strictRequires === "debug") {
        const wrappedIds = requireResolver.getWrappedIds();
        if (wrappedIds.length) {
          this.warn({
            code: "WRAPPED_IDS",
            ids: wrappedIds,
            message: `The commonjs plugin automatically wrapped the following files:
[
${wrappedIds.map((id) => `	${JSON.stringify((0, import_path.relative)(process.cwd(), id))}`).join(",\n")}
]`
          });
        } else {
          this.warn({
            code: "WRAPPED_IDS",
            ids: wrappedIds,
            message: "The commonjs plugin did not wrap any files."
          });
        }
      }
    },
    load(id) {
      if (id === HELPERS_ID) {
        return getHelpersModule();
      }
      if (isWrappedId(id, MODULE_SUFFIX)) {
        const module2 = getName(unwrapId$1(id, MODULE_SUFFIX));
        const moduleExports = `${module2}Exports`;
        return {
          code: `var ${moduleExports} = {};
var ${module2} = {
  get exports(){ return ${moduleExports}; },
  set exports(v){ ${moduleExports} = v; },
};
export {${module2} as __module, ${moduleExports} as exports}`,
          meta: { commonjs: { isCommonJS: false } }
        };
      }
      if (isWrappedId(id, EXPORTS_SUFFIX)) {
        const name2 = getName(unwrapId$1(id, EXPORTS_SUFFIX));
        return {
          code: `var ${name2} = {}; export {${name2} as __exports}`,
          meta: { commonjs: { isCommonJS: false } }
        };
      }
      if (isWrappedId(id, EXTERNAL_SUFFIX)) {
        const actualId = unwrapId$1(id, EXTERNAL_SUFFIX);
        return getUnknownRequireProxy(
          actualId,
          isEsmExternal(actualId) ? getRequireReturnsDefault(actualId) : true
        );
      }
      if (id.endsWith(ENTRY_SUFFIX)) {
        const acutalId = id.slice(0, -ENTRY_SUFFIX.length);
        return getEntryProxy(acutalId, getDefaultIsModuleExports(acutalId), this.getModuleInfo);
      }
      if (isWrappedId(id, ES_IMPORT_SUFFIX)) {
        const actualId = unwrapId$1(id, ES_IMPORT_SUFFIX);
        return getEsImportProxy(actualId, getDefaultIsModuleExports(actualId));
      }
      if (id === DYNAMIC_MODULES_ID) {
        return getDynamicModuleRegistry(
          isDynamicRequireModulesEnabled,
          dynamicRequireModules,
          commonDir,
          ignoreDynamicRequires
        );
      }
      if (isWrappedId(id, PROXY_SUFFIX)) {
        const actualId = unwrapId$1(id, PROXY_SUFFIX);
        return getStaticRequireProxy(actualId, getRequireReturnsDefault(actualId), this.load);
      }
      return null;
    },
    shouldTransformCachedModule(...args) {
      return requireResolver.shouldTransformCachedModule.call(this, ...args);
    },
    transform(code, id) {
      if (!isPossibleCjsId(id))
        return null;
      try {
        return transformAndCheckExports.call(this, code, id);
      } catch (err2) {
        return this.error(err2, err2.loc);
      }
    }
  };
}
var schemeRegex = /^[\w+.-]+:\/\//;
var urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
var fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
var UrlType;
(function(UrlType3) {
  UrlType3[UrlType3["Empty"] = 1] = "Empty";
  UrlType3[UrlType3["Hash"] = 2] = "Hash";
  UrlType3[UrlType3["Query"] = 3] = "Query";
  UrlType3[UrlType3["RelativePath"] = 4] = "RelativePath";
  UrlType3[UrlType3["AbsolutePath"] = 5] = "AbsolutePath";
  UrlType3[UrlType3["SchemeRelative"] = 6] = "SchemeRelative";
  UrlType3[UrlType3["Absolute"] = 7] = "Absolute";
})(UrlType || (UrlType = {}));
function isAbsoluteUrl(input) {
  return schemeRegex.test(input);
}
function isSchemeRelativeUrl(input) {
  return input.startsWith("//");
}
function isAbsolutePath(input) {
  return input.startsWith("/");
}
function isFileUrl(input) {
  return input.startsWith("file:");
}
function isRelative(input) {
  return /^[.?#]/.test(input);
}
function parseAbsoluteUrl(input) {
  const match = urlRegex.exec(input);
  return makeUrl(match[1], match[2] || "", match[3], match[4] || "", match[5] || "/", match[6] || "", match[7] || "");
}
function parseFileUrl(input) {
  const match = fileRegex.exec(input);
  const path8 = match[2];
  return makeUrl("file:", "", match[1] || "", "", isAbsolutePath(path8) ? path8 : "/" + path8, match[3] || "", match[4] || "");
}
function makeUrl(scheme, user, host, port, path8, query, hash2) {
  return {
    scheme,
    user,
    host,
    port,
    path: path8,
    query,
    hash: hash2,
    type: UrlType.Absolute
  };
}
function parseUrl$2(input) {
  if (isSchemeRelativeUrl(input)) {
    const url3 = parseAbsoluteUrl("http:" + input);
    url3.scheme = "";
    url3.type = UrlType.SchemeRelative;
    return url3;
  }
  if (isAbsolutePath(input)) {
    const url3 = parseAbsoluteUrl("http://foo.com" + input);
    url3.scheme = "";
    url3.host = "";
    url3.type = UrlType.AbsolutePath;
    return url3;
  }
  if (isFileUrl(input))
    return parseFileUrl(input);
  if (isAbsoluteUrl(input))
    return parseAbsoluteUrl(input);
  const url2 = parseAbsoluteUrl("http://foo.com/" + input);
  url2.scheme = "";
  url2.host = "";
  url2.type = input ? input.startsWith("?") ? UrlType.Query : input.startsWith("#") ? UrlType.Hash : UrlType.RelativePath : UrlType.Empty;
  return url2;
}
function stripPathFilename(path8) {
  if (path8.endsWith("/.."))
    return path8;
  const index2 = path8.lastIndexOf("/");
  return path8.slice(0, index2 + 1);
}
function mergePaths(url2, base2) {
  normalizePath$4(base2, base2.type);
  if (url2.path === "/") {
    url2.path = base2.path;
  } else {
    url2.path = stripPathFilename(base2.path) + url2.path;
  }
}
function normalizePath$4(url2, type) {
  const rel = type <= UrlType.RelativePath;
  const pieces = url2.path.split("/");
  let pointer = 1;
  let positive = 0;
  let addTrailingSlash = false;
  for (let i2 = 1; i2 < pieces.length; i2++) {
    const piece = pieces[i2];
    if (!piece) {
      addTrailingSlash = true;
      continue;
    }
    addTrailingSlash = false;
    if (piece === ".")
      continue;
    if (piece === "..") {
      if (positive) {
        addTrailingSlash = true;
        positive--;
        pointer--;
      } else if (rel) {
        pieces[pointer++] = piece;
      }
      continue;
    }
    pieces[pointer++] = piece;
    positive++;
  }
  let path8 = "";
  for (let i2 = 1; i2 < pointer; i2++) {
    path8 += "/" + pieces[i2];
  }
  if (!path8 || addTrailingSlash && !path8.endsWith("/..")) {
    path8 += "/";
  }
  url2.path = path8;
}
function resolve$2(input, base2) {
  if (!input && !base2)
    return "";
  const url2 = parseUrl$2(input);
  let inputType = url2.type;
  if (base2 && inputType !== UrlType.Absolute) {
    const baseUrl = parseUrl$2(base2);
    const baseType = baseUrl.type;
    switch (inputType) {
      case UrlType.Empty:
        url2.hash = baseUrl.hash;
      case UrlType.Hash:
        url2.query = baseUrl.query;
      case UrlType.Query:
      case UrlType.RelativePath:
        mergePaths(url2, baseUrl);
      case UrlType.AbsolutePath:
        url2.user = baseUrl.user;
        url2.host = baseUrl.host;
        url2.port = baseUrl.port;
      case UrlType.SchemeRelative:
        url2.scheme = baseUrl.scheme;
    }
    if (baseType > inputType)
      inputType = baseType;
  }
  normalizePath$4(url2, inputType);
  const queryHash = url2.query + url2.hash;
  switch (inputType) {
    case UrlType.Hash:
    case UrlType.Query:
      return queryHash;
    case UrlType.RelativePath: {
      const path8 = url2.path.slice(1);
      if (!path8)
        return queryHash || ".";
      if (isRelative(base2 || input) && !isRelative(path8)) {
        return "./" + path8 + queryHash;
      }
      return path8 + queryHash;
    }
    case UrlType.AbsolutePath:
      return url2.path + queryHash;
    default:
      return url2.scheme + "//" + url2.user + url2.host + url2.port + url2.path + queryHash;
  }
}
function resolve$1(input, base2) {
  if (base2 && !base2.endsWith("/"))
    base2 += "/";
  return resolve$2(input, base2);
}
function stripFilename(path8) {
  if (!path8)
    return "";
  const index2 = path8.lastIndexOf("/");
  return path8.slice(0, index2 + 1);
}
var COLUMN = 0;
var SOURCES_INDEX = 1;
var SOURCE_LINE = 2;
var SOURCE_COLUMN = 3;
var NAMES_INDEX = 4;
function maybeSort(mappings, owned) {
  const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
  if (unsortedIndex === mappings.length)
    return mappings;
  if (!owned)
    mappings = mappings.slice();
  for (let i2 = unsortedIndex; i2 < mappings.length; i2 = nextUnsortedSegmentLine(mappings, i2 + 1)) {
    mappings[i2] = sortSegments(mappings[i2], owned);
  }
  return mappings;
}
function nextUnsortedSegmentLine(mappings, start) {
  for (let i2 = start; i2 < mappings.length; i2++) {
    if (!isSorted(mappings[i2]))
      return i2;
  }
  return mappings.length;
}
function isSorted(line) {
  for (let j = 1; j < line.length; j++) {
    if (line[j][COLUMN] < line[j - 1][COLUMN]) {
      return false;
    }
  }
  return true;
}
function sortSegments(line, owned) {
  if (!owned)
    line = line.slice();
  return line.sort(sortComparator);
}
function sortComparator(a2, b) {
  return a2[COLUMN] - b[COLUMN];
}
var found = false;
function binarySearch(haystack, needle, low, high) {
  while (low <= high) {
    const mid = low + (high - low >> 1);
    const cmp = haystack[mid][COLUMN] - needle;
    if (cmp === 0) {
      found = true;
      return mid;
    }
    if (cmp < 0) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  found = false;
  return low - 1;
}
function upperBound(haystack, needle, index2) {
  for (let i2 = index2 + 1; i2 < haystack.length; index2 = i2++) {
    if (haystack[i2][COLUMN] !== needle)
      break;
  }
  return index2;
}
function lowerBound(haystack, needle, index2) {
  for (let i2 = index2 - 1; i2 >= 0; index2 = i2--) {
    if (haystack[i2][COLUMN] !== needle)
      break;
  }
  return index2;
}
function memoizedState() {
  return {
    lastKey: -1,
    lastNeedle: -1,
    lastIndex: -1
  };
}
function memoizedBinarySearch(haystack, needle, state, key) {
  const { lastKey, lastNeedle, lastIndex } = state;
  let low = 0;
  let high = haystack.length - 1;
  if (key === lastKey) {
    if (needle === lastNeedle) {
      found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
      return lastIndex;
    }
    if (needle >= lastNeedle) {
      low = lastIndex === -1 ? 0 : lastIndex;
    } else {
      high = lastIndex;
    }
  }
  state.lastKey = key;
  state.lastNeedle = needle;
  return state.lastIndex = binarySearch(haystack, needle, low, high);
}
var LINE_GTR_ZERO = "`line` must be greater than 0 (lines start at line 1)";
var COL_GTR_EQ_ZERO = "`column` must be greater than or equal to 0 (columns start at column 0)";
var LEAST_UPPER_BOUND = -1;
var GREATEST_LOWER_BOUND = 1;
var decodedMappings;
var traceSegment;
var originalPositionFor$1;
var TraceMap = class {
  constructor(map3, mapUrl) {
    const isString3 = typeof map3 === "string";
    if (!isString3 && map3._decodedMemo)
      return map3;
    const parsed = isString3 ? JSON.parse(map3) : map3;
    const { version: version4, file, names, sourceRoot, sources, sourcesContent } = parsed;
    this.version = version4;
    this.file = file;
    this.names = names;
    this.sourceRoot = sourceRoot;
    this.sources = sources;
    this.sourcesContent = sourcesContent;
    const from = resolve$1(sourceRoot || "", stripFilename(mapUrl));
    this.resolvedSources = sources.map((s2) => resolve$1(s2 || "", from));
    const { mappings } = parsed;
    if (typeof mappings === "string") {
      this._encoded = mappings;
      this._decoded = void 0;
    } else {
      this._encoded = void 0;
      this._decoded = maybeSort(mappings, isString3);
    }
    this._decodedMemo = memoizedState();
    this._bySources = void 0;
    this._bySourceMemos = void 0;
  }
};
(() => {
  decodedMappings = (map3) => {
    return map3._decoded || (map3._decoded = decode(map3._encoded));
  };
  traceSegment = (map3, line, column) => {
    const decoded = decodedMappings(map3);
    if (line >= decoded.length)
      return null;
    const segments = decoded[line];
    const index2 = traceSegmentInternal(segments, map3._decodedMemo, line, column, GREATEST_LOWER_BOUND);
    return index2 === -1 ? null : segments[index2];
  };
  originalPositionFor$1 = (map3, { line, column, bias }) => {
    line--;
    if (line < 0)
      throw new Error(LINE_GTR_ZERO);
    if (column < 0)
      throw new Error(COL_GTR_EQ_ZERO);
    const decoded = decodedMappings(map3);
    if (line >= decoded.length)
      return OMapping(null, null, null, null);
    const segments = decoded[line];
    const index2 = traceSegmentInternal(segments, map3._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);
    if (index2 === -1)
      return OMapping(null, null, null, null);
    const segment = segments[index2];
    if (segment.length === 1)
      return OMapping(null, null, null, null);
    const { names, resolvedSources } = map3;
    return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);
  };
})();
function OMapping(source, line, column, name2) {
  return { source, line, column, name: name2 };
}
function traceSegmentInternal(segments, memo, line, column, bias) {
  let index2 = memoizedBinarySearch(segments, column, memo, line);
  if (found) {
    index2 = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index2);
  } else if (bias === LEAST_UPPER_BOUND)
    index2++;
  if (index2 === -1 || index2 === segments.length)
    return -1;
  return index2;
}
var get;
var put;
var SetArray = class {
  constructor() {
    this._indexes = { __proto__: null };
    this.array = [];
  }
};
(() => {
  get = (strarr, key) => strarr._indexes[key];
  put = (strarr, key) => {
    const index2 = get(strarr, key);
    if (index2 !== void 0)
      return index2;
    const { array: array2, _indexes: indexes } = strarr;
    return indexes[key] = array2.push(key) - 1;
  };
})();
var addSegment;
var setSourceContent;
var decodedMap;
var encodedMap;
var GenMapping = class {
  constructor({ file, sourceRoot } = {}) {
    this._names = new SetArray();
    this._sources = new SetArray();
    this._sourcesContent = [];
    this._mappings = [];
    this.file = file;
    this.sourceRoot = sourceRoot;
  }
};
(() => {
  addSegment = (map3, genLine, genColumn, source, sourceLine, sourceColumn, name2) => {
    const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = map3;
    const line = getLine(mappings, genLine);
    if (source == null) {
      const seg2 = [genColumn];
      const index3 = getColumnIndex(line, genColumn, seg2);
      return insert(line, index3, seg2);
    }
    const sourcesIndex = put(sources, source);
    const seg = name2 ? [genColumn, sourcesIndex, sourceLine, sourceColumn, put(names, name2)] : [genColumn, sourcesIndex, sourceLine, sourceColumn];
    const index2 = getColumnIndex(line, genColumn, seg);
    if (sourcesIndex === sourcesContent.length)
      sourcesContent[sourcesIndex] = null;
    insert(line, index2, seg);
  };
  setSourceContent = (map3, source, content) => {
    const { _sources: sources, _sourcesContent: sourcesContent } = map3;
    sourcesContent[put(sources, source)] = content;
  };
  decodedMap = (map3) => {
    const { file, sourceRoot, _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = map3;
    return {
      version: 3,
      file,
      names: names.array,
      sourceRoot: sourceRoot || void 0,
      sources: sources.array,
      sourcesContent,
      mappings
    };
  };
  encodedMap = (map3) => {
    const decoded = decodedMap(map3);
    return Object.assign(Object.assign({}, decoded), { mappings: encode$1(decoded.mappings) });
  };
})();
function getLine(mappings, index2) {
  for (let i2 = mappings.length; i2 <= index2; i2++) {
    mappings[i2] = [];
  }
  return mappings[index2];
}
function getColumnIndex(line, column, seg) {
  let index2 = line.length;
  for (let i2 = index2 - 1; i2 >= 0; i2--, index2--) {
    const current2 = line[i2];
    const col = current2[0];
    if (col > column)
      continue;
    if (col < column)
      break;
    const cmp = compare$1(current2, seg);
    if (cmp === 0)
      return index2;
    if (cmp < 0)
      break;
  }
  return index2;
}
function compare$1(a2, b) {
  let cmp = compareNum(a2.length, b.length);
  if (cmp !== 0)
    return cmp;
  if (a2.length === 1)
    return 0;
  cmp = compareNum(a2[1], b[1]);
  if (cmp !== 0)
    return cmp;
  cmp = compareNum(a2[2], b[2]);
  if (cmp !== 0)
    return cmp;
  cmp = compareNum(a2[3], b[3]);
  if (cmp !== 0)
    return cmp;
  if (a2.length === 4)
    return 0;
  return compareNum(a2[4], b[4]);
}
function compareNum(a2, b) {
  return a2 - b;
}
function insert(array2, index2, value2) {
  if (index2 === -1)
    return;
  for (let i2 = array2.length; i2 > index2; i2--) {
    array2[i2] = array2[i2 - 1];
  }
  array2[index2] = value2;
}
var SOURCELESS_MAPPING = {
  source: null,
  column: null,
  line: null,
  name: null,
  content: null
};
var EMPTY_SOURCES = [];
function Source(map3, sources, source, content) {
  return {
    map: map3,
    sources,
    source,
    content
  };
}
function MapSource(map3, sources) {
  return Source(map3, sources, "", null);
}
function OriginalSource(source, content) {
  return Source(null, EMPTY_SOURCES, source, content);
}
function traceMappings(tree) {
  const gen = new GenMapping({ file: tree.map.file });
  const { sources: rootSources, map: map3 } = tree;
  const rootNames = map3.names;
  const rootMappings = decodedMappings(map3);
  for (let i2 = 0; i2 < rootMappings.length; i2++) {
    const segments = rootMappings[i2];
    let lastSource = null;
    let lastSourceLine = null;
    let lastSourceColumn = null;
    for (let j = 0; j < segments.length; j++) {
      const segment = segments[j];
      const genCol = segment[0];
      let traced = SOURCELESS_MAPPING;
      if (segment.length !== 1) {
        const source2 = rootSources[segment[1]];
        traced = originalPositionFor(source2, segment[2], segment[3], segment.length === 5 ? rootNames[segment[4]] : "");
        if (traced == null)
          continue;
      }
      const { column, line, name: name2, content, source } = traced;
      if (line === lastSourceLine && column === lastSourceColumn && source === lastSource) {
        continue;
      }
      lastSourceLine = line;
      lastSourceColumn = column;
      lastSource = source;
      addSegment(gen, i2, genCol, source, line, column, name2);
      if (content != null)
        setSourceContent(gen, source, content);
    }
  }
  return gen;
}
function originalPositionFor(source, line, column, name2) {
  if (!source.map) {
    return { column, line, name: name2, source: source.source, content: source.content };
  }
  const segment = traceSegment(source.map, line, column);
  if (segment == null)
    return null;
  if (segment.length === 1)
    return SOURCELESS_MAPPING;
  return originalPositionFor(source.sources[segment[1]], segment[2], segment[3], segment.length === 5 ? source.map.names[segment[4]] : name2);
}
function asArray(value2) {
  if (Array.isArray(value2))
    return value2;
  return [value2];
}
function buildSourceMapTree(input, loader) {
  const maps = asArray(input).map((m) => new TraceMap(m, ""));
  const map3 = maps.pop();
  for (let i2 = 0; i2 < maps.length; i2++) {
    if (maps[i2].sources.length > 1) {
      throw new Error(`Transformation map ${i2} must have exactly one source file.
Did you specify these with the most recent transformation maps first?`);
    }
  }
  let tree = build$2(map3, loader, "", 0);
  for (let i2 = maps.length - 1; i2 >= 0; i2--) {
    tree = MapSource(maps[i2], [tree]);
  }
  return tree;
}
function build$2(map3, loader, importer, importerDepth) {
  const { resolvedSources, sourcesContent } = map3;
  const depth2 = importerDepth + 1;
  const children = resolvedSources.map((sourceFile, i2) => {
    const ctx2 = {
      importer,
      depth: depth2,
      source: sourceFile || "",
      content: void 0
    };
    const sourceMap = loader(ctx2.source, ctx2);
    const { source, content } = ctx2;
    if (sourceMap)
      return build$2(new TraceMap(sourceMap, source), loader, source, depth2);
    const sourceContent = content !== void 0 ? content : sourcesContent ? sourcesContent[i2] : null;
    return OriginalSource(source, sourceContent);
  });
  return MapSource(map3, children);
}
var SourceMap2 = class {
  constructor(map3, options3) {
    const out2 = options3.decodedMappings ? decodedMap(map3) : encodedMap(map3);
    this.version = out2.version;
    this.file = out2.file;
    this.mappings = out2.mappings;
    this.names = out2.names;
    this.sourceRoot = out2.sourceRoot;
    this.sources = out2.sources;
    if (!options3.excludeContent) {
      this.sourcesContent = out2.sourcesContent;
    }
  }
  toString() {
    return JSON.stringify(this);
  }
};
function remapping(input, loader, options3) {
  const opts = typeof options3 === "object" ? options3 : { excludeContent: !!options3, decodedMappings: false };
  const tree = buildSourceMapTree(input, loader);
  return new SourceMap2(traceMappings(tree), opts);
}
var srcExports$1 = {};
var src$2 = {
  get exports() {
    return srcExports$1;
  },
  set exports(v) {
    srcExports$1 = v;
  }
};
var browserExports$1 = {};
var browser$2 = {
  get exports() {
    return browserExports$1;
  },
  set exports(v) {
    browserExports$1 = v;
  }
};
var ms$1;
var hasRequiredMs$1;
function requireMs$1() {
  if (hasRequiredMs$1)
    return ms$1;
  hasRequiredMs$1 = 1;
  var s2 = 1e3;
  var m = s2 * 60;
  var h = m * 60;
  var d2 = h * 24;
  var w = d2 * 7;
  var y = d2 * 365.25;
  ms$1 = function(val, options3) {
    options3 = options3 || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse7(val);
    } else if (type === "number" && isFinite(val)) {
      return options3.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse7(str2) {
    str2 = String(str2);
    if (str2.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str2
    );
    if (!match) {
      return;
    }
    var n3 = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n3 * y;
      case "weeks":
      case "week":
      case "w":
        return n3 * w;
      case "days":
      case "day":
      case "d":
        return n3 * d2;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n3 * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n3 * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n3 * s2;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n3;
      default:
        return void 0;
    }
  }
  function fmtShort(ms3) {
    var msAbs = Math.abs(ms3);
    if (msAbs >= d2) {
      return Math.round(ms3 / d2) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms3 / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms3 / m) + "m";
    }
    if (msAbs >= s2) {
      return Math.round(ms3 / s2) + "s";
    }
    return ms3 + "ms";
  }
  function fmtLong(ms3) {
    var msAbs = Math.abs(ms3);
    if (msAbs >= d2) {
      return plural(ms3, msAbs, d2, "day");
    }
    if (msAbs >= h) {
      return plural(ms3, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms3, msAbs, m, "minute");
    }
    if (msAbs >= s2) {
      return plural(ms3, msAbs, s2, "second");
    }
    return ms3 + " ms";
  }
  function plural(ms3, msAbs, n3, name2) {
    var isPlural = msAbs >= n3 * 1.5;
    return Math.round(ms3 / n3) + " " + name2 + (isPlural ? "s" : "");
  }
  return ms$1;
}
var common$b;
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon)
    return common$b;
  hasRequiredCommon = 1;
  function setup(env2) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs$1();
    createDebug.destroy = destroy;
    Object.keys(env2).forEach((key) => {
      createDebug[key] = env2[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash2 = 0;
      for (let i2 = 0; i2 < namespace.length; i2++) {
        hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i2);
        hash2 |= 0;
      }
      return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug4(...args) {
        if (!debug4.enabled) {
          return;
        }
        const self2 = debug4;
        const curr = Number(new Date());
        const ms3 = curr - (prevTime || curr);
        self2.diff = ms3;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
          if (match === "%%") {
            return "%";
          }
          index2++;
          const formatter2 = createDebug.formatters[format2];
          if (typeof formatter2 === "function") {
            const val = args[index2];
            match = formatter2.call(self2, val);
            args.splice(index2, 1);
            index2--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug4.namespace = namespace;
      debug4.useColors = createDebug.useColors();
      debug4.color = createDebug.selectColor(namespace);
      debug4.extend = extend2;
      debug4.destroy = createDebug.destroy;
      Object.defineProperty(debug4, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug4);
      }
      return debug4;
    }
    function extend2(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i2;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i2 = 0; i2 < len; i2++) {
        if (!split[i2]) {
          continue;
        }
        namespaces = split[i2].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name2) {
      if (name2[name2.length - 1] === "*") {
        return true;
      }
      let i2;
      let len;
      for (i2 = 0, len = createDebug.skips.length; i2 < len; i2++) {
        if (createDebug.skips[i2].test(name2)) {
          return false;
        }
      }
      for (i2 = 0, len = createDebug.names.length; i2 < len; i2++) {
        if (createDebug.names[i2].test(name2)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common$b = setup;
  return common$b;
}
var hasRequiredBrowser$1;
function requireBrowser$1() {
  if (hasRequiredBrowser$1)
    return browserExports$1;
  hasRequiredBrowser$1 = 1;
  (function(module2, exports3) {
    exports3.formatArgs = formatArgs;
    exports3.save = save;
    exports3.load = load2;
    exports3.useColors = useColors;
    exports3.storage = localstorage();
    exports3.destroy = (() => {
      let warned2 = false;
      return () => {
        if (!warned2) {
          warned2 = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports3.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c2 = "color: " + this.color;
      args.splice(1, 0, c2, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index2++;
        if (match === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c2);
    }
    exports3.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports3.storage.setItem("debug", namespaces);
        } else {
          exports3.storage.removeItem("debug");
        }
      } catch (error3) {
      }
    }
    function load2() {
      let r3;
      try {
        r3 = exports3.storage.getItem("debug");
      } catch (error3) {
      }
      if (!r3 && typeof process !== "undefined" && "env" in process) {
        r3 = process.env.DEBUG;
      }
      return r3;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error3) {
      }
    }
    module2.exports = requireCommon()(exports3);
    const { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error3) {
        return "[UnexpectedJSONParseError]: " + error3.message;
      }
    };
  })(browser$2, browserExports$1);
  return browserExports$1;
}
var nodeExports$1 = {};
var node$1 = {
  get exports() {
    return nodeExports$1;
  },
  set exports(v) {
    nodeExports$1 = v;
  }
};
var hasRequiredNode$1;
function requireNode$1() {
  if (hasRequiredNode$1)
    return nodeExports$1;
  hasRequiredNode$1 = 1;
  (function(module2, exports3) {
    const tty2 = import_tty.default;
    const util2 = import_util.default;
    exports3.init = init2;
    exports3.log = log8;
    exports3.formatArgs = formatArgs;
    exports3.save = save;
    exports3.load = load2;
    exports3.useColors = useColors;
    exports3.destroy = util2.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports3.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor2 = require2("supports-color");
      if (supportsColor2 && (supportsColor2.stderr || supportsColor2).level >= 2) {
        exports3.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error3) {
    }
    exports3.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports3.inspectOpts ? Boolean(exports3.inspectOpts.colors) : tty2.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name2, useColors: useColors2 } = this;
      if (useColors2) {
        const c2 = this.color;
        const colorCode = "\x1B[3" + (c2 < 8 ? c2 : "8;5;" + c2);
        const prefix = `  ${colorCode};1m${name2} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name2 + " " + args[0];
      }
    }
    function getDate() {
      if (exports3.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    function log8(...args) {
      return process.stderr.write(util2.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load2() {
      return process.env.DEBUG;
    }
    function init2(debug4) {
      debug4.inspectOpts = {};
      const keys = Object.keys(exports3.inspectOpts);
      for (let i2 = 0; i2 < keys.length; i2++) {
        debug4.inspectOpts[keys[i2]] = exports3.inspectOpts[keys[i2]];
      }
    }
    module2.exports = requireCommon()(exports3);
    const { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map((str2) => str2.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
  })(node$1, nodeExports$1);
  return nodeExports$1;
}
(function(module2) {
  if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
    module2.exports = requireBrowser$1();
  } else {
    module2.exports = requireNode$1();
  }
})(src$2);
var _debug = getDefaultExportFromCjs(srcExports$1);
var createFilter2 = createFilter$1;
function slash$1(p2) {
  return p2.replace(/\\/g, "/");
}
function wrapId(id) {
  return id.startsWith(VALID_ID_PREFIX) ? id : VALID_ID_PREFIX + id.replace("\0", NULL_BYTE_PLACEHOLDER);
}
function unwrapId(id) {
  return id.startsWith(VALID_ID_PREFIX) ? id.slice(VALID_ID_PREFIX.length).replace(NULL_BYTE_PLACEHOLDER, "\0") : id;
}
var flattenId = (id) => id.replace(/[/:]/g, "_").replace(/\./g, "__").replace(/(\s*>\s*)/g, "___");
var normalizeId = (id) => id.replace(/(\s*>\s*)/g, " > ");
var builtins = /* @__PURE__ */ new Set([
  ...import_node_module.builtinModules,
  "assert/strict",
  "diagnostics_channel",
  "dns/promises",
  "fs/promises",
  "path/posix",
  "path/win32",
  "readline/promises",
  "stream/consumers",
  "stream/promises",
  "stream/web",
  "timers/promises",
  "util/types",
  "wasi"
]);
function isBuiltin(id) {
  return builtins.has(id.replace(/^node:/, ""));
}
function moduleListContains(moduleList, id) {
  return moduleList == null ? void 0 : moduleList.some((m) => m === id || id.startsWith(m + "/"));
}
function isOptimizable(id, optimizeDeps2) {
  const { extensions: extensions2 } = optimizeDeps2;
  return OPTIMIZABLE_ENTRY_RE.test(id) || ((extensions2 == null ? void 0 : extensions2.some((ext2) => id.endsWith(ext2))) ?? false);
}
var bareImportRE = /^[\w@](?!.*:\/\/)/;
var isRunningWithYarnPnp;
var _require$3 = (0, import_node_module.createRequire)(import.meta.url);
try {
  isRunningWithYarnPnp = Boolean(_require$3("pnpapi"));
} catch {
}
var ssrExtensions = [".js", ".cjs", ".json", ".node"];
function resolveFrom(id, basedir, preserveSymlinks = false, ssr = false) {
  return import_resolve.default.sync(id, {
    basedir,
    paths: [],
    extensions: ssr ? ssrExtensions : DEFAULT_EXTENSIONS,
    // necessary to work with pnpm
    preserveSymlinks: preserveSymlinks || isRunningWithYarnPnp || false
  });
}
function nestedResolveFrom(id, basedir, preserveSymlinks = false) {
  const pkgs = id.split(">").map((pkg) => pkg.trim());
  try {
    for (const pkg of pkgs) {
      basedir = resolveFrom(pkg, basedir, preserveSymlinks);
    }
  } catch {
  }
  return basedir;
}
var filter = process.env.VITE_DEBUG_FILTER;
var DEBUG = process.env.DEBUG;
function createDebugger(namespace, options3 = {}) {
  const log8 = _debug(namespace);
  const { onlyWhenFocused } = options3;
  const focus = typeof onlyWhenFocused === "string" ? onlyWhenFocused : namespace;
  return (msg, ...args) => {
    if (filter && !msg.includes(filter)) {
      return;
    }
    if (onlyWhenFocused && !(DEBUG == null ? void 0 : DEBUG.includes(focus))) {
      return;
    }
    log8(msg, ...args);
  };
}
function testCaseInsensitiveFS() {
  if (!CLIENT_ENTRY.endsWith("client.mjs")) {
    throw new Error(`cannot test case insensitive FS, CLIENT_ENTRY const doesn't contain client.mjs`);
  }
  if (!import_node_fs4.default.existsSync(CLIENT_ENTRY)) {
    throw new Error("cannot test case insensitive FS, CLIENT_ENTRY does not point to an existing file: " + CLIENT_ENTRY);
  }
  return import_node_fs4.default.existsSync(CLIENT_ENTRY.replace("client.mjs", "cLiEnT.mjs"));
}
var isCaseInsensitiveFS = testCaseInsensitiveFS();
var isWindows$4 = import_node_os.default.platform() === "win32";
var VOLUME_RE = /^[A-Z]:/i;
function normalizePath$3(id) {
  return import_node_path4.default.posix.normalize(isWindows$4 ? slash$1(id) : id);
}
function fsPathFromId(id) {
  const fsPath = normalizePath$3(id.startsWith(FS_PREFIX) ? id.slice(FS_PREFIX.length) : id);
  return fsPath.startsWith("/") || fsPath.match(VOLUME_RE) ? fsPath : `/${fsPath}`;
}
function fsPathFromUrl(url2) {
  return fsPathFromId(cleanUrl(url2));
}
function isParentDirectory(dir, file) {
  if (!dir.endsWith("/")) {
    dir = `${dir}/`;
  }
  return file.startsWith(dir) || isCaseInsensitiveFS && file.toLowerCase().startsWith(dir.toLowerCase());
}
function ensureVolumeInPath(file) {
  return isWindows$4 ? import_node_path4.default.resolve(file) : file;
}
var queryRE = /\?.*$/s;
var hashRE = /#.*$/s;
var cleanUrl = (url2) => url2.replace(hashRE, "").replace(queryRE, "");
var externalRE = /^(https?:)?\/\//;
var isExternalUrl = (url2) => externalRE.test(url2);
var dataUrlRE = /^\s*data:/i;
var isDataUrl = (url2) => dataUrlRE.test(url2);
var virtualModuleRE = /^virtual-module:.*/;
var virtualModulePrefix = "virtual-module:";
var knownJsSrcRE = /\.(?:[jt]sx?|m[jt]s|vue|marko|svelte|astro|imba)(?:$|\?)/;
var isJSRequest = (url2) => {
  url2 = cleanUrl(url2);
  if (knownJsSrcRE.test(url2)) {
    return true;
  }
  if (!import_node_path4.default.extname(url2) && !url2.endsWith("/")) {
    return true;
  }
  return false;
};
var knownTsRE = /\.(?:ts|mts|cts|tsx)$/;
var knownTsOutputRE = /\.(?:js|mjs|cjs|jsx)$/;
var isTsRequest = (url2) => knownTsRE.test(url2);
var isPossibleTsOutput = (url2) => knownTsOutputRE.test(cleanUrl(url2));
function getPotentialTsSrcPaths(filePath) {
  const [name2, type, query = ""] = filePath.split(/(\.(?:[cm]?js|jsx))(\?.*)?$/);
  const paths = [name2 + type.replace("js", "ts") + query];
  if (!type.endsWith("x")) {
    paths.push(name2 + type.replace("js", "tsx") + query);
  }
  return paths;
}
var importQueryRE = /(\?|&)import=?(?:&|$)/;
var directRequestRE$1 = /(\?|&)direct=?(?:&|$)/;
var internalPrefixes = [
  FS_PREFIX,
  VALID_ID_PREFIX,
  CLIENT_PUBLIC_PATH,
  ENV_PUBLIC_PATH
];
var InternalPrefixRE = new RegExp(`^(?:${internalPrefixes.join("|")})`);
var trailingSeparatorRE = /[?&]$/;
var isImportRequest = (url2) => importQueryRE.test(url2);
var isInternalRequest = (url2) => InternalPrefixRE.test(url2);
function removeImportQuery(url2) {
  return url2.replace(importQueryRE, "$1").replace(trailingSeparatorRE, "");
}
function removeDirectQuery(url2) {
  return url2.replace(directRequestRE$1, "$1").replace(trailingSeparatorRE, "");
}
function injectQuery(url2, queryToInject) {
  const resolvedUrl = new import_node_url3.URL(url2.replace(/%/g, "%25"), "relative:///");
  const { search, hash: hash2 } = resolvedUrl;
  let pathname = cleanUrl(url2);
  pathname = isWindows$4 ? slash$1(pathname) : pathname;
  return `${pathname}?${queryToInject}${search ? `&` + search.slice(1) : ""}${hash2 ?? ""}`;
}
var timestampRE = /\bt=\d{13}&?\b/;
function removeTimestampQuery(url2) {
  return url2.replace(timestampRE, "").replace(trailingSeparatorRE, "");
}
async function asyncReplace(input, re, replacer) {
  let match;
  let remaining = input;
  let rewritten = "";
  while (match = re.exec(remaining)) {
    rewritten += remaining.slice(0, match.index);
    rewritten += await replacer(match);
    remaining = remaining.slice(match.index + match[0].length);
  }
  rewritten += remaining;
  return rewritten;
}
function timeFrom(start, subtract = 0) {
  const time = import_node_perf_hooks.performance.now() - start - subtract;
  const timeString = (time.toFixed(2) + `ms`).padEnd(5, " ");
  if (time < 10) {
    return picocolorsExports.green(timeString);
  } else if (time < 50) {
    return picocolorsExports.yellow(timeString);
  } else {
    return picocolorsExports.red(timeString);
  }
}
function prettifyUrl(url2, root) {
  url2 = removeTimestampQuery(url2);
  const isAbsoluteFile = url2.startsWith(root);
  if (isAbsoluteFile || url2.startsWith(FS_PREFIX)) {
    let file = import_node_path4.default.relative(root, isAbsoluteFile ? url2 : fsPathFromId(url2));
    const seg = file.split("/");
    const npmIndex = seg.indexOf(`node_modules`);
    const isSourceMap = file.endsWith(".map");
    if (npmIndex > 0) {
      file = seg[npmIndex + 1];
      if (file.startsWith("@")) {
        file = `${file}/${seg[npmIndex + 2]}`;
      }
      file = `npm: ${picocolorsExports.dim(file)}${isSourceMap ? ` (source map)` : ``}`;
    }
    return picocolorsExports.dim(file);
  } else {
    return picocolorsExports.dim(url2);
  }
}
function isObject$1(value2) {
  return Object.prototype.toString.call(value2) === "[object Object]";
}
function isDefined(value2) {
  return value2 != null;
}
function lookupFile(dir, formats, options3) {
  for (const format2 of formats) {
    const fullPath = import_node_path4.default.join(dir, format2);
    if (import_node_fs4.default.existsSync(fullPath) && import_node_fs4.default.statSync(fullPath).isFile()) {
      const result = (options3 == null ? void 0 : options3.pathOnly) ? fullPath : import_node_fs4.default.readFileSync(fullPath, "utf-8");
      if (!(options3 == null ? void 0 : options3.predicate) || options3.predicate(result)) {
        return result;
      }
    }
  }
  const parentDir = import_node_path4.default.dirname(dir);
  if (parentDir !== dir && (!(options3 == null ? void 0 : options3.rootDir) || parentDir.startsWith(options3 == null ? void 0 : options3.rootDir))) {
    return lookupFile(parentDir, formats, options3);
  }
}
var splitRE = /\r?\n/;
var range = 2;
function pad$1(source, n3 = 2) {
  const lines = source.split(splitRE);
  return lines.map((l2) => ` `.repeat(n3) + l2).join(`
`);
}
function posToNumber(source, pos) {
  if (typeof pos === "number")
    return pos;
  const lines = source.split(splitRE);
  const { line, column } = pos;
  let start = 0;
  for (let i2 = 0; i2 < line - 1 && i2 < lines.length; i2++) {
    start += lines[i2].length + 1;
  }
  return start + column;
}
function numberToPos(source, offset3) {
  if (typeof offset3 !== "number")
    return offset3;
  if (offset3 > source.length) {
    throw new Error(`offset is longer than source length! offset ${offset3} > length ${source.length}`);
  }
  const lines = source.split(splitRE);
  let counted = 0;
  let line = 0;
  let column = 0;
  for (; line < lines.length; line++) {
    const lineLength = lines[line].length + 1;
    if (counted + lineLength >= offset3) {
      column = offset3 - counted + 1;
      break;
    }
    counted += lineLength;
  }
  return { line: line + 1, column };
}
function generateCodeFrame(source, start = 0, end) {
  start = posToNumber(source, start);
  end = end || start;
  const lines = source.split(splitRE);
  let count = 0;
  const res = [];
  for (let i2 = 0; i2 < lines.length; i2++) {
    count += lines[i2].length + 1;
    if (count >= start) {
      for (let j = i2 - range; j <= i2 + range || end > count; j++) {
        if (j < 0 || j >= lines.length)
          continue;
        const line = j + 1;
        res.push(`${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
        const lineLength = lines[j].length;
        if (j === i2) {
          const pad2 = Math.max(start - (count - lineLength) + 1, 0);
          const length = Math.max(1, end > count ? lineLength - pad2 : end - start);
          res.push(`   |  ` + " ".repeat(pad2) + "^".repeat(length));
        } else if (j > i2) {
          if (end > count) {
            const length = Math.max(Math.min(end - count, lineLength), 1);
            res.push(`   |  ` + "^".repeat(length));
          }
          count += lineLength + 1;
        }
      }
      break;
    }
  }
  return res.join("\n");
}
function writeFile(filename, content) {
  const dir = import_node_path4.default.dirname(filename);
  if (!import_node_fs4.default.existsSync(dir)) {
    import_node_fs4.default.mkdirSync(dir, { recursive: true });
  }
  import_node_fs4.default.writeFileSync(filename, content);
}
function isFileReadable(filename) {
  try {
    import_node_fs4.default.accessSync(filename, import_node_fs4.default.constants.R_OK);
    return true;
  } catch {
    return false;
  }
}
var splitFirstDirRE = /(.+?)[\\/](.+)/;
function emptyDir(dir, skip) {
  const skipInDir = [];
  let nested = null;
  if (skip == null ? void 0 : skip.length) {
    for (const file of skip) {
      if (import_node_path4.default.dirname(file) !== ".") {
        const matched = file.match(splitFirstDirRE);
        if (matched) {
          nested ?? (nested = /* @__PURE__ */ new Map());
          const [, nestedDir, skipPath] = matched;
          let nestedSkip = nested.get(nestedDir);
          if (!nestedSkip) {
            nestedSkip = [];
            nested.set(nestedDir, nestedSkip);
          }
          if (!nestedSkip.includes(skipPath)) {
            nestedSkip.push(skipPath);
          }
        }
      } else {
        skipInDir.push(file);
      }
    }
  }
  for (const file of import_node_fs4.default.readdirSync(dir)) {
    if (skipInDir.includes(file)) {
      continue;
    }
    if (nested == null ? void 0 : nested.has(file)) {
      emptyDir(import_node_path4.default.resolve(dir, file), nested.get(file));
    } else {
      import_node_fs4.default.rmSync(import_node_path4.default.resolve(dir, file), { recursive: true, force: true });
    }
  }
}
function copyDir(srcDir, destDir) {
  import_node_fs4.default.mkdirSync(destDir, { recursive: true });
  for (const file of import_node_fs4.default.readdirSync(srcDir)) {
    const srcFile = import_node_path4.default.resolve(srcDir, file);
    if (srcFile === destDir) {
      continue;
    }
    const destFile = import_node_path4.default.resolve(destDir, file);
    const stat2 = import_node_fs4.default.statSync(srcFile);
    if (stat2.isDirectory()) {
      copyDir(srcFile, destFile);
    } else {
      import_node_fs4.default.copyFileSync(srcFile, destFile);
    }
  }
}
var removeDir = isWindows$4 ? (0, import_node_util.promisify)(gracefulRemoveDir) : function removeDirSync(dir) {
  if (import_node_fs4.default.existsSync(dir)) {
    import_node_fs4.default.rmSync(dir, { recursive: true, force: true });
  }
};
var renameDir = isWindows$4 ? (0, import_node_util.promisify)(gracefulRename) : import_node_fs4.default.renameSync;
function ensureWatchedFile(watcher, file, root) {
  if (file && // only need to watch if out of root
  !file.startsWith(root + "/") && // some rollup plugins use null bytes for private resolved Ids
  !file.includes("\0") && import_node_fs4.default.existsSync(file)) {
    watcher.add(import_node_path4.default.resolve(file));
  }
}
var escapedSpaceCharacters = /( |\\t|\\n|\\f|\\r)+/g;
var imageSetUrlRE = /^(?:[\w\-]+\(.*?\)|'.*?'|".*?"|\S*)/;
function reduceSrcset(ret) {
  return ret.reduce((prev, { url: url2, descriptor }, index2) => {
    descriptor ?? (descriptor = "");
    return prev += url2 + ` ${descriptor}${index2 === ret.length - 1 ? "" : ", "}`;
  }, "");
}
function splitSrcSetDescriptor(srcs) {
  return splitSrcSet(srcs).map((s2) => {
    const src3 = s2.replace(escapedSpaceCharacters, " ").trim();
    const [url2] = imageSetUrlRE.exec(src3) || [""];
    return {
      url: url2,
      descriptor: src3 == null ? void 0 : src3.slice(url2.length).trim()
    };
  }).filter(({ url: url2 }) => !!url2);
}
function processSrcSet(srcs, replacer) {
  return Promise.all(splitSrcSetDescriptor(srcs).map(async ({ url: url2, descriptor }) => ({
    url: await replacer({ url: url2, descriptor }),
    descriptor
  }))).then((ret) => reduceSrcset(ret));
}
function processSrcSetSync(srcs, replacer) {
  return reduceSrcset(splitSrcSetDescriptor(srcs).map(({ url: url2, descriptor }) => ({
    url: replacer({ url: url2, descriptor }),
    descriptor
  })));
}
function splitSrcSet(srcs) {
  const parts = [];
  const cleanedSrcs = srcs.replace(new RegExp(`(?:url|image|gradient|cross-fade)\\([^)]*\\)|"([^"]|(?<=\\\\)")*"|'([^']|(?<=\\\\)')*'`, "g"), blankReplacer);
  let startIndex = 0;
  let splitIndex;
  do {
    splitIndex = cleanedSrcs.indexOf(",", startIndex);
    parts.push(srcs.slice(startIndex, splitIndex !== -1 ? splitIndex : void 0));
    startIndex = splitIndex + 1;
  } while (splitIndex !== -1);
  return parts;
}
function escapeToLinuxLikePath(path8) {
  if (/^[A-Z]:/.test(path8)) {
    return path8.replace(/^([A-Z]):\//, "/windows/$1/");
  }
  if (/^\/[^/]/.test(path8)) {
    return `/linux${path8}`;
  }
  return path8;
}
function unescapeToLinuxLikePath(path8) {
  if (path8.startsWith("/linux/")) {
    return path8.slice("/linux".length);
  }
  if (path8.startsWith("/windows/")) {
    return path8.replace(/^\/windows\/([A-Z])\//, "$1:/");
  }
  return path8;
}
var nullSourceMap = {
  names: [],
  sources: [],
  mappings: "",
  version: 3
};
function combineSourcemaps(filename, sourcemapList, excludeContent = true) {
  if (sourcemapList.length === 0 || sourcemapList.every((m) => m.sources.length === 0)) {
    return { ...nullSourceMap };
  }
  sourcemapList = sourcemapList.map((sourcemap) => {
    const newSourcemaps = { ...sourcemap };
    newSourcemaps.sources = sourcemap.sources.map((source) => source ? escapeToLinuxLikePath(source) : null);
    if (sourcemap.sourceRoot) {
      newSourcemaps.sourceRoot = escapeToLinuxLikePath(sourcemap.sourceRoot);
    }
    return newSourcemaps;
  });
  const escapedFilename = escapeToLinuxLikePath(filename);
  let map3;
  let mapIndex = 1;
  const useArrayInterface = sourcemapList.slice(0, -1).find((m) => m.sources.length !== 1) === void 0;
  if (useArrayInterface) {
    map3 = remapping(sourcemapList, () => null, excludeContent);
  } else {
    map3 = remapping(sourcemapList[0], function loader(sourcefile) {
      if (sourcefile === escapedFilename && sourcemapList[mapIndex]) {
        return sourcemapList[mapIndex++];
      } else {
        return null;
      }
    }, excludeContent);
  }
  if (!map3.file) {
    delete map3.file;
  }
  map3.sources = map3.sources.map((source) => source ? unescapeToLinuxLikePath(source) : source);
  map3.file = filename;
  return map3;
}
function unique(arr) {
  return Array.from(new Set(arr));
}
async function getLocalhostAddressIfDiffersFromDNS() {
  const [nodeResult, dnsResult] = await Promise.all([
    import_node_dns.promises.lookup("localhost"),
    import_node_dns.promises.lookup("localhost", { verbatim: true })
  ]);
  const isSame = nodeResult.family === dnsResult.family && nodeResult.address === dnsResult.address;
  return isSame ? void 0 : nodeResult.address;
}
async function resolveHostname(optionsHost) {
  let host;
  if (optionsHost === void 0 || optionsHost === false) {
    host = "localhost";
  } else if (optionsHost === true) {
    host = void 0;
  } else {
    host = optionsHost;
  }
  let name2 = host === void 0 || wildcardHosts.has(host) ? "localhost" : host;
  if (host === "localhost") {
    const localhostAddr = await getLocalhostAddressIfDiffersFromDNS();
    if (localhostAddr) {
      name2 = localhostAddr;
    }
  }
  return { host, name: name2 };
}
async function resolveServerUrls(server2, options3, config2) {
  const address = server2.address();
  const isAddressInfo = (x) => x == null ? void 0 : x.address;
  if (!isAddressInfo(address)) {
    return { local: [], network: [] };
  }
  const local = [];
  const network = [];
  const hostname = await resolveHostname(options3.host);
  const protocol = options3.https ? "https" : "http";
  const port = address.port;
  const base2 = config2.rawBase === "./" || config2.rawBase === "" ? "/" : config2.rawBase;
  if (hostname.host && loopbackHosts.has(hostname.host)) {
    let hostnameName = hostname.name;
    if (hostnameName.includes(":")) {
      hostnameName = `[${hostnameName}]`;
    }
    local.push(`${protocol}://${hostnameName}:${port}${base2}`);
  } else {
    Object.values(import_node_os.default.networkInterfaces()).flatMap((nInterface) => nInterface ?? []).filter((detail) => detail && detail.address && (typeof detail.family === "string" && detail.family === "IPv4" || // @ts-expect-error Node 18.0 - 18.3 returns number
    typeof detail.family === "number" && detail.family === 4)).forEach((detail) => {
      let host = detail.address.replace("127.0.0.1", hostname.name);
      if (host.includes(":")) {
        host = `[${host}]`;
      }
      const url2 = `${protocol}://${host}:${port}${base2}`;
      if (detail.address.includes("127.0.0.1")) {
        local.push(url2);
      } else {
        network.push(url2);
      }
    });
  }
  return { local, network };
}
function arraify(target) {
  return Array.isArray(target) ? target : [target];
}
function toUpperCaseDriveLetter(pathName) {
  return pathName.replace(/^\w:/, (letter) => letter.toUpperCase());
}
var multilineCommentsRE$1 = /\/\*[^*]*\*+(?:[^/*][^*]*\*+)*\//g;
var singlelineCommentsRE$1 = /\/\/.*/g;
var requestQuerySplitRE = /\?(?!.*[/|}])/;
var usingDynamicImport = typeof jest === "undefined";
var dynamicImport = usingDynamicImport ? new Function("file", "return import(file)") : _require$3;
function parseRequest(id) {
  const [_, search] = id.split(requestQuerySplitRE, 2);
  if (!search) {
    return null;
  }
  return Object.fromEntries(new import_node_url3.URLSearchParams(search));
}
var blankReplacer = (match) => " ".repeat(match.length);
function getHash(text) {
  return (0, import_node_crypto.createHash)("sha256").update(text).digest("hex").substring(0, 8);
}
var requireResolveFromRootWithFallback = (root, id) => {
  var _a, _b;
  const paths = ((_b = (_a = _require$3.resolve).paths) == null ? void 0 : _b.call(_a, id)) || [];
  paths.unshift(root);
  import_resolve.default.sync(id, { basedir: root, paths });
  return _require$3.resolve(id, { paths });
};
var GRACEFUL_RENAME_TIMEOUT = 5e3;
function gracefulRename(from, to, cb) {
  const start = Date.now();
  let backoff = 0;
  import_node_fs4.default.rename(from, to, function CB(er) {
    if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < GRACEFUL_RENAME_TIMEOUT) {
      setTimeout(function() {
        import_node_fs4.default.stat(to, function(stater, st) {
          if (stater && stater.code === "ENOENT")
            import_node_fs4.default.rename(from, to, CB);
          else
            CB(er);
        });
      }, backoff);
      if (backoff < 100)
        backoff += 10;
      return;
    }
    if (cb)
      cb(er);
  });
}
var GRACEFUL_REMOVE_DIR_TIMEOUT = 5e3;
function gracefulRemoveDir(dir, cb) {
  const start = Date.now();
  let backoff = 0;
  import_node_fs4.default.rm(dir, { recursive: true }, function CB(er) {
    if (er) {
      if ((er.code === "ENOTEMPTY" || er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < GRACEFUL_REMOVE_DIR_TIMEOUT) {
        setTimeout(function() {
          import_node_fs4.default.rm(dir, { recursive: true }, CB);
        }, backoff);
        if (backoff < 100)
          backoff += 10;
        return;
      }
      if (er.code === "ENOENT") {
        er = null;
      }
    }
    if (cb)
      cb(er);
  });
}
function emptyCssComments(raw) {
  return raw.replace(multilineCommentsRE$1, (s2) => " ".repeat(s2.length));
}
function removeComments(raw) {
  return raw.replace(multilineCommentsRE$1, "").replace(singlelineCommentsRE$1, "");
}
function mergeConfigRecursively(defaults, overrides, rootPath) {
  const merged = { ...defaults };
  for (const key in overrides) {
    const value2 = overrides[key];
    if (value2 == null) {
      continue;
    }
    const existing = merged[key];
    if (existing == null) {
      merged[key] = value2;
      continue;
    }
    if (key === "alias" && (rootPath === "resolve" || rootPath === "")) {
      merged[key] = mergeAlias(existing, value2);
      continue;
    } else if (key === "assetsInclude" && rootPath === "") {
      merged[key] = [].concat(existing, value2);
      continue;
    } else if (key === "noExternal" && rootPath === "ssr" && (existing === true || value2 === true)) {
      merged[key] = true;
      continue;
    }
    if (Array.isArray(existing) || Array.isArray(value2)) {
      merged[key] = [...arraify(existing ?? []), ...arraify(value2 ?? [])];
      continue;
    }
    if (isObject$1(existing) && isObject$1(value2)) {
      merged[key] = mergeConfigRecursively(existing, value2, rootPath ? `${rootPath}.${key}` : key);
      continue;
    }
    merged[key] = value2;
  }
  return merged;
}
function mergeConfig(defaults, overrides, isRoot = true) {
  return mergeConfigRecursively(defaults, overrides, isRoot ? "" : ".");
}
function mergeAlias(a2, b) {
  if (!a2)
    return b;
  if (!b)
    return a2;
  if (isObject$1(a2) && isObject$1(b)) {
    return { ...a2, ...b };
  }
  return [...normalizeAlias(b), ...normalizeAlias(a2)];
}
function normalizeAlias(o3 = []) {
  return Array.isArray(o3) ? o3.map(normalizeSingleAlias) : Object.keys(o3).map((find2) => normalizeSingleAlias({
    find: find2,
    replacement: o3[find2]
  }));
}
function normalizeSingleAlias({ find: find2, replacement, customResolver }) {
  if (typeof find2 === "string" && find2.endsWith("/") && replacement.endsWith("/")) {
    find2 = find2.slice(0, find2.length - 1);
    replacement = replacement.slice(0, replacement.length - 1);
  }
  const alias2 = {
    find: find2,
    replacement
  };
  if (customResolver) {
    alias2.customResolver = customResolver;
  }
  return alias2;
}
function transformStableResult(s2, id, config2) {
  return {
    code: s2.toString(),
    map: config2.command === "build" && config2.build.sourcemap ? s2.generateMap({ hires: true, source: id }) : null
  };
}
async function asyncFlatten(arr) {
  do {
    arr = (await Promise.all(arr)).flat(Infinity);
  } while (arr.some((v) => v == null ? void 0 : v.then));
  return arr;
}
function stripBomTag(content) {
  if (content.charCodeAt(0) === 65279) {
    return content.slice(1);
  }
  return content;
}
var windowsDrivePathPrefixRE = /^[A-Za-z]:[/\\]/;
var isNonDriveRelativeAbsolutePath = (p2) => {
  if (!isWindows$4)
    return p2.startsWith("/");
  return windowsDrivePathPrefixRE.test(p2);
};
function shouldServeFile(filePath, root) {
  if (!isCaseInsensitiveFS)
    return true;
  return hasCorrectCase(filePath, root);
}
function hasCorrectCase(file, assets) {
  if (file === assets)
    return true;
  const parent = import_node_path4.default.dirname(file);
  if (import_node_fs4.default.readdirSync(parent).includes(import_node_path4.default.basename(file))) {
    return hasCorrectCase(parent, assets);
  }
  return false;
}
function joinUrlSegments(a2, b) {
  if (!a2 || !b) {
    return a2 || b || "";
  }
  if (a2.endsWith("/")) {
    a2 = a2.substring(0, a2.length - 1);
  }
  if (!b.startsWith("/")) {
    b = "/" + b;
  }
  return a2 + b;
}
function stripBase(path8, base2) {
  if (path8 === base2) {
    return "/";
  }
  const devBase = base2.endsWith("/") ? base2 : base2 + "/";
  return path8.replace(RegExp("^" + devBase), "/");
}
function arrayEqual(a2, b) {
  if (a2 === b)
    return true;
  if (a2.length !== b.length)
    return false;
  for (let i2 = 0; i2 < a2.length; i2++) {
    if (a2[i2] !== b[i2])
      return false;
  }
  return true;
}
function evalValue(rawValue) {
  const fn = new Function(`
    var console, exports, global, module, process, require
    return (
${rawValue}
)
  `);
  return fn();
}
var LogLevels = {
  silent: 0,
  error: 1,
  warn: 2,
  info: 3
};
var lastType;
var lastMsg;
var sameCount = 0;
function clearScreen() {
  const repeatCount = process.stdout.rows - 2;
  const blank = repeatCount > 0 ? "\n".repeat(repeatCount) : "";
  console.log(blank);
  import_node_readline2.default.cursorTo(process.stdout, 0, 0);
  import_node_readline2.default.clearScreenDown(process.stdout);
}
function createLogger(level3 = "info", options3 = {}) {
  if (options3.customLogger) {
    return options3.customLogger;
  }
  const loggedErrors = /* @__PURE__ */ new WeakSet();
  const { prefix = "[vite]", allowClearScreen = true } = options3;
  const thresh = LogLevels[level3];
  const canClearScreen = allowClearScreen && process.stdout.isTTY && !process.env.CI;
  const clear = canClearScreen ? clearScreen : () => {
  };
  function output(type, msg, options4 = {}) {
    if (thresh >= LogLevels[type]) {
      const method = type === "info" ? "log" : type;
      const format2 = () => {
        if (options4.timestamp) {
          const tag = type === "info" ? picocolorsExports.cyan(picocolorsExports.bold(prefix)) : type === "warn" ? picocolorsExports.yellow(picocolorsExports.bold(prefix)) : picocolorsExports.red(picocolorsExports.bold(prefix));
          return `${picocolorsExports.dim(new Date().toLocaleTimeString())} ${tag} ${msg}`;
        } else {
          return msg;
        }
      };
      if (options4.error) {
        loggedErrors.add(options4.error);
      }
      if (canClearScreen) {
        if (type === lastType && msg === lastMsg) {
          sameCount++;
          clear();
          console[method](format2(), picocolorsExports.yellow(`(x${sameCount + 1})`));
        } else {
          sameCount = 0;
          lastMsg = msg;
          lastType = type;
          if (options4.clear) {
            clear();
          }
          console[method](format2());
        }
      } else {
        console[method](format2());
      }
    }
  }
  const warnedMessages = /* @__PURE__ */ new Set();
  const logger2 = {
    hasWarned: false,
    info(msg, opts) {
      output("info", msg, opts);
    },
    warn(msg, opts) {
      logger2.hasWarned = true;
      output("warn", msg, opts);
    },
    warnOnce(msg, opts) {
      if (warnedMessages.has(msg))
        return;
      logger2.hasWarned = true;
      output("warn", msg, opts);
      warnedMessages.add(msg);
    },
    error(msg, opts) {
      logger2.hasWarned = true;
      output("error", msg, opts);
    },
    clearScreen(type) {
      if (thresh >= LogLevels[type]) {
        clear();
      }
    },
    hasErrorLogged(error3) {
      return loggedErrors.has(error3);
    }
  };
  return logger2;
}
function printServerUrls(urls, optionsHost, info3) {
  const colorUrl = (url2) => picocolorsExports.cyan(url2.replace(/:(\d+)\//, (_, port) => `:${picocolorsExports.bold(port)}/`));
  for (const url2 of urls.local) {
    info3(`  ${picocolorsExports.green("➜")}  ${picocolorsExports.bold("Local")}:   ${colorUrl(url2)}`);
  }
  for (const url2 of urls.network) {
    info3(`  ${picocolorsExports.green("➜")}  ${picocolorsExports.bold("Network")}: ${colorUrl(url2)}`);
  }
  if (urls.network.length === 0 && optionsHost === void 0) {
    info3(picocolorsExports.dim(`  ${picocolorsExports.green("➜")}  ${picocolorsExports.bold("Network")}: use `) + picocolorsExports.bold("--host") + picocolorsExports.dim(" to expose"));
  }
}
var groups = [
  { name: "Assets", color: picocolorsExports.green },
  { name: "CSS", color: picocolorsExports.magenta },
  { name: "JS", color: picocolorsExports.cyan }
];
function buildReporterPlugin(config2) {
  const compress = (0, import_node_util.promisify)(import_node_zlib.gzip);
  const chunkLimit = config2.build.chunkSizeWarningLimit;
  const tty2 = process.stdout.isTTY && !process.env.CI;
  const shouldLogInfo = LogLevels[config2.logLevel || "info"] >= LogLevels.info;
  let hasTransformed = false;
  let hasRenderedChunk = false;
  let hasCompressChunk = false;
  let transformedCount = 0;
  let chunkCount = 0;
  let compressedCount = 0;
  async function getCompressedSize(code) {
    if (config2.build.ssr || !config2.build.reportCompressedSize) {
      return null;
    }
    if (shouldLogInfo && !hasCompressChunk) {
      if (!tty2) {
        config2.logger.info("computing gzip size...");
      } else {
        writeLine("computing gzip size (0)...");
      }
      hasCompressChunk = true;
    }
    const compressed = await compress(typeof code === "string" ? code : Buffer.from(code));
    compressedCount++;
    if (shouldLogInfo && tty2) {
      writeLine(`computing gzip size (${compressedCount})...`);
    }
    return compressed.length;
  }
  const logTransform = throttle((id) => {
    writeLine(`transforming (${transformedCount}) ${picocolorsExports.dim(import_node_path4.default.relative(config2.root, id))}`);
  });
  return {
    name: "vite:reporter",
    transform(_, id) {
      transformedCount++;
      if (shouldLogInfo) {
        if (!tty2) {
          if (!hasTransformed) {
            config2.logger.info(`transforming...`);
          }
        } else {
          if (id.includes(`?`))
            return;
          logTransform(id);
        }
        hasTransformed = true;
      }
      return null;
    },
    buildEnd() {
      if (shouldLogInfo) {
        if (tty2) {
          process.stdout.clearLine(0);
          process.stdout.cursorTo(0);
        }
        config2.logger.info(`${picocolorsExports.green(`✓`)} ${transformedCount} modules transformed.`);
      }
    },
    renderStart() {
      chunkCount = 0;
      compressedCount = 0;
    },
    renderChunk() {
      chunkCount++;
      if (shouldLogInfo) {
        if (!tty2) {
          if (!hasRenderedChunk) {
            config2.logger.info("rendering chunks...");
          }
        } else {
          writeLine(`rendering chunks (${chunkCount})...`);
        }
        hasRenderedChunk = true;
      }
      return null;
    },
    generateBundle() {
      if (shouldLogInfo && tty2)
        clearLine();
    },
    async writeBundle({ dir: outDir }, output) {
      let hasLargeChunks = false;
      if (shouldLogInfo) {
        const entries = (await Promise.all(Object.values(output).map(async (chunk) => {
          if (chunk.type === "chunk") {
            return {
              name: chunk.fileName,
              group: "JS",
              size: chunk.code.length,
              compressedSize: await getCompressedSize(chunk.code),
              mapSize: chunk.map ? chunk.map.toString().length : null
            };
          } else {
            if (chunk.fileName.endsWith(".map"))
              return null;
            const isCSS = chunk.fileName.endsWith(".css");
            return {
              name: chunk.fileName,
              group: isCSS ? "CSS" : "Assets",
              size: chunk.source.length,
              mapSize: null,
              compressedSize: isCSS ? await getCompressedSize(chunk.source) : null
            };
          }
        }))).filter(isDefined);
        if (tty2)
          clearLine();
        let longest = 0;
        let biggestSize = 0;
        let biggestMap = 0;
        let biggestCompressSize = 0;
        for (const entry2 of entries) {
          if (entry2.name.length > longest)
            longest = entry2.name.length;
          if (entry2.size > biggestSize)
            biggestSize = entry2.size;
          if (entry2.mapSize && entry2.mapSize > biggestMap) {
            biggestMap = entry2.mapSize;
          }
          if (entry2.compressedSize && entry2.compressedSize > biggestCompressSize) {
            biggestCompressSize = entry2.compressedSize;
          }
        }
        const sizePad = displaySize(biggestSize).length;
        const mapPad = displaySize(biggestMap).length;
        const compressPad = displaySize(biggestCompressSize).length;
        const relativeOutDir = normalizePath$3(import_node_path4.default.relative(config2.root, import_node_path4.default.resolve(config2.root, outDir ?? config2.build.outDir)));
        const assetsDir = `${config2.build.assetsDir}/`;
        for (const group of groups) {
          const filtered = entries.filter((e3) => e3.group === group.name);
          if (!filtered.length)
            continue;
          for (const entry2 of filtered.sort((a2, z) => a2.size - z.size)) {
            const isLarge = group.name === "JS" && entry2.size / 1e3 > chunkLimit;
            if (isLarge)
              hasLargeChunks = true;
            const sizeColor = isLarge ? picocolorsExports.yellow : picocolorsExports.dim;
            let log8 = picocolorsExports.dim(relativeOutDir + "/");
            log8 += entry2.name.startsWith(assetsDir) ? picocolorsExports.dim(assetsDir) + group.color(entry2.name.slice(assetsDir.length).padEnd(longest + 2 - assetsDir.length)) : group.color(entry2.name.padEnd(longest + 2));
            log8 += picocolorsExports.bold(sizeColor(displaySize(entry2.size).padStart(sizePad)));
            if (entry2.compressedSize) {
              log8 += picocolorsExports.dim(` │ gzip: ${displaySize(entry2.compressedSize).padStart(compressPad)}`);
            }
            if (entry2.mapSize) {
              log8 += picocolorsExports.dim(` │ map: ${displaySize(entry2.mapSize).padStart(mapPad)}`);
            }
            config2.logger.info(log8);
          }
        }
      } else {
        hasLargeChunks = Object.values(output).some((chunk) => {
          return chunk.type === "chunk" && chunk.code.length / 1e3 > chunkLimit;
        });
      }
      if (hasLargeChunks && config2.build.minify && !config2.build.lib && !config2.build.ssr) {
        config2.logger.warn(picocolorsExports.yellow(`
(!) Some chunks are larger than ${chunkLimit} kBs after minification. Consider:
- Using dynamic import() to code-split the application
- Use build.rollupOptions.output.manualChunks to improve chunking: https://rollupjs.org/configuration-options/#output-manualchunks
- Adjust chunk size limit for this warning via build.chunkSizeWarningLimit.`));
      }
    }
  };
}
function writeLine(output) {
  clearLine();
  if (output.length < process.stdout.columns) {
    process.stdout.write(output);
  } else {
    process.stdout.write(output.substring(0, process.stdout.columns - 1));
  }
}
function clearLine() {
  process.stdout.clearLine(0);
  process.stdout.cursorTo(0);
}
function throttle(fn) {
  let timerHandle = null;
  return (...args) => {
    if (timerHandle)
      return;
    fn(...args);
    timerHandle = setTimeout(() => {
      timerHandle = null;
    }, 100);
  };
}
function displaySize(bytes) {
  return `${(bytes / 1e3).toLocaleString("en", {
    maximumFractionDigits: 2,
    minimumFractionDigits: 2
  })} kB`;
}
async function find(filename, options3) {
  let dir = import_path.default.dirname(import_path.default.resolve(filename));
  const root = (options3 == null ? void 0 : options3.root) ? import_path.default.resolve(options3.root) : null;
  while (dir) {
    const tsconfig = await tsconfigInDir(dir, options3);
    if (tsconfig) {
      return tsconfig;
    } else {
      if (root === dir) {
        break;
      }
      const parent = import_path.default.dirname(dir);
      if (parent === dir) {
        break;
      } else {
        dir = parent;
      }
    }
  }
  throw new Error(`no tsconfig file found for ${filename}`);
}
async function tsconfigInDir(dir, options3) {
  const tsconfig = import_path.default.join(dir, "tsconfig.json");
  if (options3 == null ? void 0 : options3.tsConfigPaths) {
    return options3.tsConfigPaths.has(tsconfig) ? tsconfig : void 0;
  }
  try {
    const stat2 = await import_fs.promises.stat(tsconfig);
    if (stat2.isFile() || stat2.isFIFO()) {
      return tsconfig;
    }
  } catch (e3) {
    if (e3.code !== "ENOENT") {
      throw e3;
    }
  }
}
async function findAll(dir, options3) {
  const files = [];
  for await (const tsconfigFile of findTSConfig(import_path.default.resolve(dir), options3)) {
    files.push(tsconfigFile);
  }
  return files;
}
async function* findTSConfig(dir, options3, visited = /* @__PURE__ */ new Set()) {
  if (!visited.has(dir)) {
    visited.add(dir);
    try {
      const dirents = await import_fs.promises.readdir(dir, { withFileTypes: true });
      for (const dirent of dirents) {
        if (dirent.isDirectory() && (!(options3 == null ? void 0 : options3.skip) || !options3.skip(dirent.name))) {
          yield* findTSConfig(import_path.default.resolve(dir, dirent.name), options3, visited);
        } else if (dirent.isFile() && dirent.name === "tsconfig.json") {
          yield import_path.default.resolve(dir, dirent.name);
        }
      }
    } catch (e3) {
      if (e3.code === "EACCES" || e3.code === "ENOENT") {
        return;
      }
      throw e3;
    }
  }
}
function toJson(tsconfigJson) {
  const stripped = stripDanglingComma(stripJsonComments(stripBom(tsconfigJson)));
  if (stripped.trim() === "") {
    return "{}";
  } else {
    return stripped;
  }
}
function stripDanglingComma(pseudoJson) {
  let insideString = false;
  let offset3 = 0;
  let result = "";
  let danglingCommaPos = null;
  for (let i2 = 0; i2 < pseudoJson.length; i2++) {
    const currentCharacter = pseudoJson[i2];
    if (currentCharacter === '"') {
      const escaped2 = isEscaped(pseudoJson, i2);
      if (!escaped2) {
        insideString = !insideString;
      }
    }
    if (insideString) {
      danglingCommaPos = null;
      continue;
    }
    if (currentCharacter === ",") {
      danglingCommaPos = i2;
      continue;
    }
    if (danglingCommaPos) {
      if (currentCharacter === "}" || currentCharacter === "]") {
        result += pseudoJson.slice(offset3, danglingCommaPos) + " ";
        offset3 = danglingCommaPos + 1;
        danglingCommaPos = null;
      } else if (!currentCharacter.match(/\s/)) {
        danglingCommaPos = null;
      }
    }
  }
  return result + pseudoJson.substring(offset3);
}
function isEscaped(jsonString, quotePosition) {
  let index2 = quotePosition - 1;
  let backslashCount = 0;
  while (jsonString[index2] === "\\") {
    index2 -= 1;
    backslashCount += 1;
  }
  return Boolean(backslashCount % 2);
}
function strip(string3, start, end) {
  return string3.slice(start, end).replace(/\S/g, " ");
}
var singleComment = Symbol("singleComment");
var multiComment = Symbol("multiComment");
function stripJsonComments(jsonString) {
  let isInsideString = false;
  let isInsideComment = false;
  let offset3 = 0;
  let result = "";
  for (let index2 = 0; index2 < jsonString.length; index2++) {
    const currentCharacter = jsonString[index2];
    const nextCharacter = jsonString[index2 + 1];
    if (!isInsideComment && currentCharacter === '"') {
      const escaped2 = isEscaped(jsonString, index2);
      if (!escaped2) {
        isInsideString = !isInsideString;
      }
    }
    if (isInsideString) {
      continue;
    }
    if (!isInsideComment && currentCharacter + nextCharacter === "//") {
      result += jsonString.slice(offset3, index2);
      offset3 = index2;
      isInsideComment = singleComment;
      index2++;
    } else if (isInsideComment === singleComment && currentCharacter + nextCharacter === "\r\n") {
      index2++;
      isInsideComment = false;
      result += strip(jsonString, offset3, index2);
      offset3 = index2;
    } else if (isInsideComment === singleComment && currentCharacter === "\n") {
      isInsideComment = false;
      result += strip(jsonString, offset3, index2);
      offset3 = index2;
    } else if (!isInsideComment && currentCharacter + nextCharacter === "/*") {
      result += jsonString.slice(offset3, index2);
      offset3 = index2;
      isInsideComment = multiComment;
      index2++;
    } else if (isInsideComment === multiComment && currentCharacter + nextCharacter === "*/") {
      index2++;
      isInsideComment = false;
      result += strip(jsonString, offset3, index2 + 1);
      offset3 = index2 + 1;
    }
  }
  return result + (isInsideComment ? strip(jsonString.slice(offset3)) : jsonString.slice(offset3));
}
function stripBom(string3) {
  if (string3.charCodeAt(0) === 65279) {
    return string3.slice(1);
  }
  return string3;
}
var POSIX_SEP_RE = new RegExp("\\" + import_path.default.posix.sep, "g");
var NATIVE_SEP_RE = new RegExp("\\" + import_path.default.sep, "g");
var PATTERN_REGEX_CACHE = /* @__PURE__ */ new Map();
var GLOB_ALL_PATTERN = `**/*`;
var DEFAULT_EXTENSIONS2 = [".ts", ".tsx", ".mts", ".cts"];
var DEFAULT_EXTENSIONS_RE_GROUP = `\\.(?:${DEFAULT_EXTENSIONS2.map((ext2) => ext2.substring(1)).join(
  "|"
)})`;
new Function("path", "return import(path).then(m => m.default)");
async function resolveTSConfig(filename) {
  if (import_path.default.extname(filename) !== ".json") {
    return;
  }
  const tsconfig = import_path.default.resolve(filename);
  try {
    const stat2 = await import_fs.promises.stat(tsconfig);
    if (stat2.isFile() || stat2.isFIFO()) {
      return tsconfig;
    }
  } catch (e3) {
    if (e3.code !== "ENOENT") {
      throw e3;
    }
  }
  throw new Error(`no tsconfig file found for ${filename}`);
}
function posix2native(filename) {
  return import_path.default.posix.sep !== import_path.default.sep && filename.includes(import_path.default.posix.sep) ? filename.replace(POSIX_SEP_RE, import_path.default.sep) : filename;
}
function native2posix(filename) {
  return import_path.default.posix.sep !== import_path.default.sep && filename.includes(import_path.default.sep) ? filename.replace(NATIVE_SEP_RE, import_path.default.posix.sep) : filename;
}
function resolve2posix(dir, filename) {
  if (import_path.default.sep === import_path.default.posix.sep) {
    return dir ? import_path.default.resolve(dir, filename) : import_path.default.resolve(filename);
  }
  return native2posix(
    dir ? import_path.default.resolve(posix2native(dir), posix2native(filename)) : import_path.default.resolve(posix2native(filename))
  );
}
function resolveReferencedTSConfigFiles(result) {
  const dir = import_path.default.dirname(result.tsconfigFile);
  return result.tsconfig.references.map((ref2) => {
    const refPath = ref2.path.endsWith(".json") ? ref2.path : import_path.default.join(ref2.path, "tsconfig.json");
    return resolve2posix(dir, refPath);
  });
}
function resolveSolutionTSConfig(filename, result) {
  if (result.referenced && DEFAULT_EXTENSIONS2.some((ext2) => filename.endsWith(ext2)) && !isIncluded(filename, result)) {
    const solutionTSConfig = result.referenced.find(
      (referenced) => isIncluded(filename, referenced)
    );
    if (solutionTSConfig) {
      return {
        ...solutionTSConfig,
        solution: result
      };
    }
  }
  return result;
}
function isIncluded(filename, result) {
  const dir = native2posix(import_path.default.dirname(result.tsconfigFile));
  const files = (result.tsconfig.files || []).map((file) => resolve2posix(dir, file));
  const absoluteFilename = resolve2posix(null, filename);
  if (files.includes(filename)) {
    return true;
  }
  const isIncluded2 = isGlobMatch(
    absoluteFilename,
    dir,
    result.tsconfig.include || (result.tsconfig.files ? [] : [GLOB_ALL_PATTERN])
  );
  if (isIncluded2) {
    const isExcluded = isGlobMatch(absoluteFilename, dir, result.tsconfig.exclude || []);
    return !isExcluded;
  }
  return false;
}
function isGlobMatch(filename, dir, patterns2) {
  return patterns2.some((pattern2) => {
    let lastWildcardIndex = pattern2.length;
    let hasWildcard = false;
    for (let i2 = pattern2.length - 1; i2 > -1; i2--) {
      if (pattern2[i2] === "*" || pattern2[i2] === "?") {
        lastWildcardIndex = i2;
        hasWildcard = true;
        break;
      }
    }
    if (lastWildcardIndex < pattern2.length - 1 && !filename.endsWith(pattern2.slice(lastWildcardIndex + 1))) {
      return false;
    }
    if (pattern2.endsWith("*") && !DEFAULT_EXTENSIONS2.some((ext2) => filename.endsWith(ext2))) {
      return false;
    }
    if (pattern2 === GLOB_ALL_PATTERN) {
      return filename.startsWith(`${dir}/`);
    }
    const resolvedPattern = resolve2posix(dir, pattern2);
    let firstWildcardIndex = -1;
    for (let i2 = 0; i2 < resolvedPattern.length; i2++) {
      if (resolvedPattern[i2] === "*" || resolvedPattern[i2] === "?") {
        firstWildcardIndex = i2;
        hasWildcard = true;
        break;
      }
    }
    if (firstWildcardIndex > 1 && !filename.startsWith(resolvedPattern.slice(0, firstWildcardIndex - 1))) {
      return false;
    }
    if (!hasWildcard) {
      return filename === resolvedPattern;
    }
    if (PATTERN_REGEX_CACHE.has(resolvedPattern)) {
      return PATTERN_REGEX_CACHE.get(resolvedPattern).test(filename);
    }
    const regex = pattern2regex(resolvedPattern);
    PATTERN_REGEX_CACHE.set(resolvedPattern, regex);
    return regex.test(filename);
  });
}
function pattern2regex(resolvedPattern) {
  let regexStr = "^";
  for (let i2 = 0; i2 < resolvedPattern.length; i2++) {
    const char = resolvedPattern[i2];
    if (char === "?") {
      regexStr += "[^\\/]";
      continue;
    }
    if (char === "*") {
      if (resolvedPattern[i2 + 1] === "*" && resolvedPattern[i2 + 2] === "/") {
        i2 += 2;
        regexStr += "(?:[^\\/]*\\/)*";
        continue;
      }
      regexStr += "[^\\/]*";
      continue;
    }
    if ("/.+^${}()|[]\\".includes(char)) {
      regexStr += `\\`;
    }
    regexStr += char;
  }
  if (resolvedPattern.endsWith("*")) {
    regexStr += DEFAULT_EXTENSIONS_RE_GROUP;
  }
  regexStr += "$";
  return new RegExp(regexStr);
}
async function parse$f(filename, options3) {
  const cache2 = options3 == null ? void 0 : options3.cache;
  if (cache2 == null ? void 0 : cache2.has(filename)) {
    return cache2.get(filename);
  }
  let tsconfigFile;
  if (options3 == null ? void 0 : options3.resolveWithEmptyIfConfigNotFound) {
    try {
      tsconfigFile = await resolveTSConfig(filename) || await find(filename, options3);
    } catch (e3) {
      const notFoundResult = {
        tsconfigFile: "no_tsconfig_file_found",
        tsconfig: {}
      };
      cache2 == null ? void 0 : cache2.set(filename, notFoundResult);
      return notFoundResult;
    }
  } else {
    tsconfigFile = await resolveTSConfig(filename) || await find(filename, options3);
  }
  let result;
  if (cache2 == null ? void 0 : cache2.has(tsconfigFile)) {
    result = cache2.get(tsconfigFile);
  } else {
    result = await parseFile$1(tsconfigFile, cache2);
    await Promise.all([parseExtends(result, cache2), parseReferences(result, cache2)]);
    cache2 == null ? void 0 : cache2.set(tsconfigFile, result);
  }
  result = resolveSolutionTSConfig(filename, result);
  cache2 == null ? void 0 : cache2.set(filename, result);
  return result;
}
async function parseFile$1(tsconfigFile, cache2) {
  if (cache2 == null ? void 0 : cache2.has(tsconfigFile)) {
    return cache2.get(tsconfigFile);
  }
  try {
    const tsconfigJson = await import_fs.promises.readFile(tsconfigFile, "utf-8");
    const json2 = toJson(tsconfigJson);
    const result = {
      tsconfigFile,
      tsconfig: normalizeTSConfig(JSON.parse(json2), import_path.default.dirname(tsconfigFile))
    };
    cache2 == null ? void 0 : cache2.set(tsconfigFile, result);
    return result;
  } catch (e3) {
    throw new TSConfckParseError(
      `parsing ${tsconfigFile} failed: ${e3}`,
      "PARSE_FILE",
      tsconfigFile,
      e3
    );
  }
}
function normalizeTSConfig(tsconfig, dir) {
  var _a;
  if (((_a = tsconfig.compilerOptions) == null ? void 0 : _a.baseUrl) && !import_path.default.isAbsolute(tsconfig.compilerOptions.baseUrl)) {
    tsconfig.compilerOptions.baseUrl = resolve2posix(dir, tsconfig.compilerOptions.baseUrl);
  }
  return tsconfig;
}
async function parseReferences(result, cache2) {
  if (!result.tsconfig.references) {
    return;
  }
  const referencedFiles = resolveReferencedTSConfigFiles(result);
  const referenced = await Promise.all(referencedFiles.map((file) => parseFile$1(file, cache2)));
  await Promise.all(referenced.map((ref2) => parseExtends(ref2, cache2)));
  result.referenced = referenced;
}
async function parseExtends(result, cache2) {
  if (!result.tsconfig.extends) {
    return;
  }
  const extended = [
    { tsconfigFile: result.tsconfigFile, tsconfig: JSON.parse(JSON.stringify(result.tsconfig)) }
  ];
  while (extended[extended.length - 1].tsconfig.extends) {
    const extending = extended[extended.length - 1];
    const extendedTSConfigFile = resolveExtends(extending.tsconfig.extends, extending.tsconfigFile);
    if (extended.some((x) => x.tsconfigFile === extendedTSConfigFile)) {
      const circle = extended.concat({ tsconfigFile: extendedTSConfigFile, tsconfig: null }).map((e3) => e3.tsconfigFile).join(" -> ");
      throw new TSConfckParseError(
        `Circular dependency in "extends": ${circle}`,
        "EXTENDS_CIRCULAR",
        result.tsconfigFile
      );
    }
    extended.push(await parseFile$1(extendedTSConfigFile, cache2));
  }
  result.extended = extended;
  for (const ext2 of result.extended.slice(1)) {
    extendTSConfig(result, ext2);
  }
}
function resolveExtends(extended, from) {
  let error3;
  try {
    return (0, import_module.createRequire)(from).resolve(extended);
  } catch (e3) {
    error3 = e3;
  }
  if (!import_path.default.isAbsolute(extended) && !extended.startsWith("./") && !extended.startsWith("../")) {
    try {
      const fallbackExtended = import_path.default.join(extended, "tsconfig.json");
      return (0, import_module.createRequire)(from).resolve(fallbackExtended);
    } catch (e3) {
      error3 = e3;
    }
  }
  throw new TSConfckParseError(
    `failed to resolve "extends":"${extended}" in ${from}`,
    "EXTENDS_RESOLVE",
    from,
    error3
  );
}
var EXTENDABLE_KEYS = [
  "compilerOptions",
  "files",
  "include",
  "exclude",
  "watchOptions",
  "compileOnSave",
  "typeAcquisition",
  "buildOptions"
];
function extendTSConfig(extending, extended) {
  const extendingConfig = extending.tsconfig;
  const extendedConfig = extended.tsconfig;
  const relativePath = native2posix(
    import_path.default.relative(import_path.default.dirname(extending.tsconfigFile), import_path.default.dirname(extended.tsconfigFile))
  );
  for (const key of Object.keys(extendedConfig).filter((key2) => EXTENDABLE_KEYS.includes(key2))) {
    if (key === "compilerOptions") {
      if (!extendingConfig.compilerOptions) {
        extendingConfig.compilerOptions = {};
      }
      for (const option of Object.keys(extendedConfig.compilerOptions)) {
        if (Object.prototype.hasOwnProperty.call(extendingConfig.compilerOptions, option)) {
          continue;
        }
        extendingConfig.compilerOptions[option] = rebaseRelative(
          option,
          extendedConfig.compilerOptions[option],
          relativePath
        );
      }
    } else if (extendingConfig[key] === void 0) {
      if (key === "watchOptions") {
        extendingConfig.watchOptions = {};
        for (const option of Object.keys(extendedConfig.watchOptions)) {
          extendingConfig.watchOptions[option] = rebaseRelative(
            option,
            extendedConfig.watchOptions[option],
            relativePath
          );
        }
      } else {
        extendingConfig[key] = rebaseRelative(key, extendedConfig[key], relativePath);
      }
    }
  }
}
var REBASE_KEYS = [
  "files",
  "include",
  "exclude",
  "baseUrl",
  "rootDir",
  "rootDirs",
  "typeRoots",
  "outDir",
  "outFile",
  "declarationDir",
  "excludeDirectories",
  "excludeFiles"
];
function rebaseRelative(key, value2, prependPath) {
  if (!REBASE_KEYS.includes(key)) {
    return value2;
  }
  if (Array.isArray(value2)) {
    return value2.map((x) => rebasePath(x, prependPath));
  } else {
    return rebasePath(value2, prependPath);
  }
}
function rebasePath(value2, prependPath) {
  if (import_path.default.isAbsolute(value2)) {
    return value2;
  } else {
    return import_path.default.posix.normalize(import_path.default.posix.join(prependPath, value2));
  }
}
var TSConfckParseError = class extends Error {
  constructor(message, code, tsconfigFile, cause) {
    super(message);
    Object.setPrototypeOf(this, TSConfckParseError.prototype);
    this.name = TSConfckParseError.name;
    this.code = code;
    this.cause = cause;
    this.tsconfigFile = tsconfigFile;
  }
};
var debug$f = createDebugger("vite:esbuild");
var INJECT_HELPERS_IIFE_RE = /^(.*?)((?:const|var)\s+\S+\s*=\s*function\s*\([^)]*\)\s*\{.*?"use strict";)/s;
var INJECT_HELPERS_UMD_RE = /^(.*?)(\(function\([^)]*\)\s*\{.+?amd.+?function\([^)]*\)\s*\{.*?"use strict";)/s;
var server;
async function transformWithEsbuild(code, filename, options3, inMap) {
  var _a;
  let loader = options3 == null ? void 0 : options3.loader;
  if (!loader) {
    const ext2 = import_node_path4.default.extname(/\.\w+$/.test(filename) ? filename : cleanUrl(filename)).slice(1);
    if (ext2 === "cjs" || ext2 === "mjs") {
      loader = "js";
    } else if (ext2 === "cts" || ext2 === "mts") {
      loader = "ts";
    } else {
      loader = ext2;
    }
  }
  let tsconfigRaw = options3 == null ? void 0 : options3.tsconfigRaw;
  if (typeof tsconfigRaw !== "string") {
    const meaningfulFields = [
      "alwaysStrict",
      "importsNotUsedAsValues",
      "jsx",
      "jsxFactory",
      "jsxFragmentFactory",
      "jsxImportSource",
      "preserveValueImports",
      "target",
      "useDefineForClassFields"
    ];
    const compilerOptionsForFile = {};
    if (loader === "ts" || loader === "tsx") {
      const loadedTsconfig = await loadTsconfigJsonForFile(filename);
      const loadedCompilerOptions = loadedTsconfig.compilerOptions ?? {};
      for (const field of meaningfulFields) {
        if (field in loadedCompilerOptions) {
          compilerOptionsForFile[field] = loadedCompilerOptions[field];
        }
      }
    }
    tsconfigRaw = {
      ...tsconfigRaw,
      compilerOptions: {
        ...compilerOptionsForFile,
        ...tsconfigRaw == null ? void 0 : tsconfigRaw.compilerOptions
      }
    };
    const { compilerOptions } = tsconfigRaw;
    if (compilerOptions) {
      if (compilerOptions.useDefineForClassFields === void 0) {
        const lowercaseTarget = ((_a = compilerOptions.target) == null ? void 0 : _a.toLowerCase()) ?? "es3";
        if (lowercaseTarget.startsWith("es")) {
          const esVersion = lowercaseTarget.slice(2);
          compilerOptions.useDefineForClassFields = esVersion === "next" || +esVersion >= 2022;
        } else {
          compilerOptions.useDefineForClassFields = false;
        }
      }
    }
  }
  const resolvedOptions = {
    sourcemap: true,
    // ensure source file name contains full query
    sourcefile: filename,
    ...options3,
    loader,
    tsconfigRaw
  };
  if (options3 && typeof resolvedOptions.tsconfigRaw === "object" && resolvedOptions.tsconfigRaw.compilerOptions) {
    options3.jsx && (resolvedOptions.tsconfigRaw.compilerOptions.jsx = void 0);
    options3.jsxFactory && (resolvedOptions.tsconfigRaw.compilerOptions.jsxFactory = void 0);
    options3.jsxFragment && (resolvedOptions.tsconfigRaw.compilerOptions.jsxFragmentFactory = void 0);
    options3.jsxImportSource && (resolvedOptions.tsconfigRaw.compilerOptions.jsxImportSource = void 0);
    options3.target && (resolvedOptions.tsconfigRaw.compilerOptions.target = void 0);
  }
  delete resolvedOptions.include;
  delete resolvedOptions.exclude;
  delete resolvedOptions.jsxInject;
  try {
    const result = await (0, import_esbuild.transform)(code, resolvedOptions);
    let map3;
    if (inMap && resolvedOptions.sourcemap) {
      const nextMap = JSON.parse(result.map);
      nextMap.sourcesContent = [];
      map3 = combineSourcemaps(filename, [
        nextMap,
        inMap
      ]);
    } else {
      map3 = resolvedOptions.sourcemap && resolvedOptions.sourcemap !== "inline" ? JSON.parse(result.map) : { mappings: "" };
    }
    if (Array.isArray(map3.sources)) {
      map3.sources = map3.sources.map((it) => toUpperCaseDriveLetter(it));
    }
    return {
      ...result,
      map: map3
    };
  } catch (e3) {
    debug$f(`esbuild error with options used: `, resolvedOptions);
    if (e3.errors) {
      e3.frame = "";
      e3.errors.forEach((m) => {
        e3.frame += `
` + prettifyMessage(m, code);
      });
      e3.loc = e3.errors[0].location;
    }
    throw e3;
  }
}
function esbuildPlugin(options3 = {}) {
  const filter2 = createFilter2(options3.include || /\.(m?ts|[jt]sx)$/, options3.exclude || /\.js$/);
  const transformOptions = {
    target: "esnext",
    charset: "utf8",
    ...options3,
    minify: false,
    minifyIdentifiers: false,
    minifySyntax: false,
    minifyWhitespace: false,
    treeShaking: false,
    // keepNames is not needed when minify is disabled.
    // Also transforming multiple times with keepNames enabled breaks
    // tree-shaking. (#9164)
    keepNames: false
  };
  return {
    name: "vite:esbuild",
    configureServer(_server) {
      server = _server;
      server.watcher.on("add", reloadOnTsconfigChange).on("change", reloadOnTsconfigChange).on("unlink", reloadOnTsconfigChange);
    },
    async configResolved(config2) {
      await initTSConfck(config2);
    },
    buildEnd() {
      server = null;
    },
    async transform(code, id) {
      if (filter2(id) || filter2(cleanUrl(id))) {
        const result = await transformWithEsbuild(code, id, transformOptions);
        if (result.warnings.length) {
          result.warnings.forEach((m) => {
            this.warn(prettifyMessage(m, code));
          });
        }
        if (options3.jsxInject && /\.(?:j|t)sx\b/.test(id)) {
          result.code = options3.jsxInject + ";" + result.code;
        }
        return {
          code: result.code,
          map: result.map
        };
      }
    }
  };
}
var rollupToEsbuildFormatMap = {
  es: "esm",
  cjs: "cjs",
  // passing `var Lib = (() => {})()` to esbuild with format = "iife"
  // will turn it to `(() => { var Lib = (() => {})() })()`,
  // so we remove the format config to tell esbuild not doing this
  //
  // although esbuild doesn't change format, there is still possibility
  // that `{ treeShaking: true }` removes a top-level no-side-effect variable
  // like: `var Lib = 1`, which becomes `` after esbuild transforming,
  // but thankfully rollup does not do this optimization now
  iife: void 0
};
var buildEsbuildPlugin = (config2) => {
  return {
    name: "vite:esbuild-transpile",
    async configResolved(config3) {
      await initTSConfck(config3);
    },
    async renderChunk(code, chunk, opts) {
      if (opts.__vite_skip_esbuild__) {
        return null;
      }
      const options3 = resolveEsbuildTranspileOptions(config2, opts.format);
      if (!options3) {
        return null;
      }
      const res = await transformWithEsbuild(code, chunk.fileName, options3);
      if (config2.build.lib) {
        const injectHelpers = opts.format === "umd" ? INJECT_HELPERS_UMD_RE : opts.format === "iife" ? INJECT_HELPERS_IIFE_RE : void 0;
        if (injectHelpers) {
          res.code = res.code.replace(injectHelpers, (_, helpers, header) => header + helpers);
        }
      }
      return res;
    }
  };
};
function resolveEsbuildTranspileOptions(config2, format2) {
  const target = config2.build.target;
  const minify = config2.build.minify === "esbuild";
  if ((!target || target === "esnext") && !minify) {
    return null;
  }
  const isEsLibBuild = config2.build.lib && format2 === "es";
  const esbuildOptions = config2.esbuild || {};
  const options3 = {
    charset: "utf8",
    ...esbuildOptions,
    target: target || void 0,
    format: rollupToEsbuildFormatMap[format2],
    // the final build should always support dynamic import and import.meta.
    // if they need to be polyfilled, plugin-legacy should be used.
    // plugin-legacy detects these two features when checking for modern code.
    supported: {
      "dynamic-import": true,
      "import-meta": true,
      ...esbuildOptions.supported
    }
  };
  if (!minify) {
    return {
      ...options3,
      minify: false,
      minifyIdentifiers: false,
      minifySyntax: false,
      minifyWhitespace: false,
      treeShaking: false
    };
  }
  if (options3.minifyIdentifiers != null || options3.minifySyntax != null || options3.minifyWhitespace != null) {
    if (isEsLibBuild) {
      return {
        ...options3,
        minify: false,
        minifyIdentifiers: options3.minifyIdentifiers ?? true,
        minifySyntax: options3.minifySyntax ?? true,
        minifyWhitespace: false,
        treeShaking: true
      };
    } else {
      return {
        ...options3,
        minify: false,
        minifyIdentifiers: options3.minifyIdentifiers ?? true,
        minifySyntax: options3.minifySyntax ?? true,
        minifyWhitespace: options3.minifyWhitespace ?? true,
        treeShaking: true
      };
    }
  }
  if (isEsLibBuild) {
    return {
      ...options3,
      minify: false,
      minifyIdentifiers: true,
      minifySyntax: true,
      minifyWhitespace: false,
      treeShaking: true
    };
  } else {
    return {
      ...options3,
      minify: true,
      treeShaking: true
    };
  }
}
function prettifyMessage(m, code) {
  let res = picocolorsExports.yellow(m.text);
  if (m.location) {
    const lines = code.split(/\r?\n/g);
    const line = Number(m.location.line);
    const column = Number(m.location.column);
    const offset3 = lines.slice(0, line - 1).map((l2) => l2.length).reduce((total, l2) => total + l2 + 1, 0) + column;
    res += `
` + generateCodeFrame(code, offset3, offset3 + 1);
  }
  return res + `
`;
}
var tsconfckParseOptions = {
  cache: /* @__PURE__ */ new Map(),
  tsConfigPaths: void 0,
  root: void 0,
  resolveWithEmptyIfConfigNotFound: true
};
async function initTSConfck(config2) {
  const workspaceRoot = searchForWorkspaceRoot(config2.root);
  debug$f(`init tsconfck (root: ${picocolorsExports.cyan(workspaceRoot)})`);
  tsconfckParseOptions.cache.clear();
  tsconfckParseOptions.root = workspaceRoot;
  tsconfckParseOptions.tsConfigPaths = /* @__PURE__ */ new Set([
    ...await findAll(workspaceRoot, {
      skip: (dir) => dir === "node_modules" || dir === ".git"
    })
  ]);
  debug$f(`init tsconfck end`);
}
async function loadTsconfigJsonForFile(filename) {
  try {
    const result = await parse$f(filename, tsconfckParseOptions);
    if (server && result.tsconfigFile !== "no_tsconfig_file_found") {
      ensureWatchedFile(server.watcher, result.tsconfigFile, server.config.root);
    }
    return result.tsconfig;
  } catch (e3) {
    if (e3 instanceof TSConfckParseError) {
      if (server && e3.tsconfigFile) {
        ensureWatchedFile(server.watcher, e3.tsconfigFile, server.config.root);
      }
    }
    throw e3;
  }
}
function reloadOnTsconfigChange(changedFile) {
  var _a;
  if (!server)
    return;
  if (import_node_path4.default.basename(changedFile) === "tsconfig.json" || changedFile.endsWith(".json") && ((_a = tsconfckParseOptions == null ? void 0 : tsconfckParseOptions.cache) == null ? void 0 : _a.has(changedFile))) {
    server.config.logger.info(`changed tsconfig file detected: ${changedFile} - Clearing cache and forcing full-reload to ensure TypeScript is compiled with updated config values.`, { clear: server.config.clearScreen, timestamp: true });
    server.moduleGraph.invalidateAll();
    initTSConfck(server.config).finally(() => {
      if (server) {
        server.ws.send({
          type: "full-reload",
          path: "*"
        });
      }
    });
  }
}
var dist$1 = {};
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(dist$1, "__esModule", { value: true });
var Worker_1 = dist$1.Worker = void 0;
var os_1 = __importDefault(import_os.default);
var worker_threads_1 = import_worker_threads.default;
var Worker = class {
  constructor(fn, options3 = {}) {
    this.code = genWorkerCode(fn);
    this.max = options3.max || Math.max(1, os_1.default.cpus().length - 1);
    this.pool = [];
    this.idlePool = [];
    this.queue = [];
  }
  async run(...args) {
    const worker = await this._getAvailableWorker();
    return new Promise((resolve4, reject) => {
      worker.currentResolve = resolve4;
      worker.currentReject = reject;
      worker.postMessage(args);
    });
  }
  stop() {
    this.pool.forEach((w) => w.unref());
    this.queue.forEach(([_, reject]) => reject(new Error("Main worker pool stopped before a worker was available.")));
    this.pool = [];
    this.idlePool = [];
    this.queue = [];
  }
  async _getAvailableWorker() {
    if (this.idlePool.length) {
      return this.idlePool.shift();
    }
    if (this.pool.length < this.max) {
      const worker = new worker_threads_1.Worker(this.code, { eval: true });
      worker.on("message", (res) => {
        worker.currentResolve && worker.currentResolve(res);
        worker.currentResolve = null;
        this._assignDoneWorker(worker);
      });
      worker.on("error", (err2) => {
        worker.currentReject && worker.currentReject(err2);
        worker.currentReject = null;
      });
      worker.on("exit", (code) => {
        const i2 = this.pool.indexOf(worker);
        if (i2 > -1)
          this.pool.splice(i2, 1);
        if (code !== 0 && worker.currentReject) {
          worker.currentReject(new Error(`Wroker stopped with non-0 exit code ${code}`));
          worker.currentReject = null;
        }
      });
      this.pool.push(worker);
      return worker;
    }
    let resolve4;
    let reject;
    const onWorkerAvailablePromise = new Promise((r3, rj) => {
      resolve4 = r3;
      reject = rj;
    });
    this.queue.push([resolve4, reject]);
    return onWorkerAvailablePromise;
  }
  _assignDoneWorker(worker) {
    if (this.queue.length) {
      const [resolve4] = this.queue.shift();
      resolve4(worker);
      return;
    }
    this.idlePool.push(worker);
  }
};
Worker_1 = dist$1.Worker = Worker;
function genWorkerCode(fn) {
  return `
const doWork = ${fn.toString()}

const { parentPort } = require('worker_threads')

parentPort.on('message', async (args) => {
  const res = await doWork(...args)
  parentPort.postMessage(res)
})
  `;
}
var terserPath;
var loadTerserPath = (root) => {
  if (terserPath)
    return terserPath;
  try {
    terserPath = requireResolveFromRootWithFallback(root, "terser");
  } catch (e3) {
    if (e3.code === "MODULE_NOT_FOUND") {
      throw new Error("terser not found. Since Vite v3, terser has become an optional dependency. You need to install it.");
    } else {
      const message = new Error(`terser failed to load:
${e3.message}`);
      message.stack = e3.stack + "\n" + message.stack;
      throw message;
    }
  }
  return terserPath;
};
function terserPlugin(config2) {
  const makeWorker = () => new Worker_1(async (terserPath2, code, options3) => {
    const terser = require2(terserPath2);
    return terser.minify(code, options3);
  });
  let worker;
  return {
    name: "vite:terser",
    async renderChunk(code, _chunk, outputOptions) {
      if (config2.build.minify !== "terser" && // @ts-expect-error injected by @vitejs/plugin-legacy
      !outputOptions.__vite_force_terser__) {
        return null;
      }
      if (config2.build.lib && outputOptions.format === "es") {
        return null;
      }
      worker || (worker = makeWorker());
      const terserPath2 = loadTerserPath(config2.root);
      const res = await worker.run(terserPath2, code, {
        safari10: true,
        ...config2.build.terserOptions,
        sourceMap: !!outputOptions.sourcemap,
        module: outputOptions.format.startsWith("es"),
        toplevel: outputOptions.format === "cjs"
      });
      return {
        code: res.code,
        map: res.map
      };
    },
    closeBundle() {
      worker == null ? void 0 : worker.stop();
    }
  };
}
var json = JSON;
var isArray$1 = Array.isArray || function(x) {
  return {}.toString.call(x) === "[object Array]";
};
var objectKeys = Object.keys || function(obj) {
  var has = Object.prototype.hasOwnProperty || function() {
    return true;
  };
  var keys = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      keys.push(key);
    }
  }
  return keys;
};
var jsonStableStringify = function(obj, opts) {
  if (!opts) {
    opts = {};
  }
  if (typeof opts === "function") {
    opts = { cmp: opts };
  }
  var space = opts.space || "";
  if (typeof space === "number") {
    space = Array(space + 1).join(" ");
  }
  var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
  var replacer = opts.replacer || function(key, value2) {
    return value2;
  };
  var cmp = opts.cmp && function(f2) {
    return function(node3) {
      return function(a2, b) {
        var aobj = { key: a2, value: node3[a2] };
        var bobj = { key: b, value: node3[b] };
        return f2(aobj, bobj);
      };
    };
  }(opts.cmp);
  var seen2 = [];
  return function stringify5(parent, key, node3, level3) {
    var indent = space ? "\n" + new Array(level3 + 1).join(space) : "";
    var colonSeparator = space ? ": " : ":";
    if (node3 && node3.toJSON && typeof node3.toJSON === "function") {
      node3 = node3.toJSON();
    }
    node3 = replacer.call(parent, key, node3);
    if (node3 === void 0) {
      return;
    }
    if (typeof node3 !== "object" || node3 === null) {
      return json.stringify(node3);
    }
    if (isArray$1(node3)) {
      var out2 = [];
      for (var i2 = 0; i2 < node3.length; i2++) {
        var item = stringify5(node3, i2, node3[i2], level3 + 1) || json.stringify(null);
        out2.push(indent + space + item);
      }
      return "[" + out2.join(",") + indent + "]";
    }
    if (seen2.indexOf(node3) !== -1) {
      if (cycles) {
        return json.stringify("__cycle__");
      }
      throw new TypeError("Converting circular structure to JSON");
    } else {
      seen2.push(node3);
    }
    var keys = objectKeys(node3).sort(cmp && cmp(node3));
    var out2 = [];
    for (var i2 = 0; i2 < keys.length; i2++) {
      var key = keys[i2];
      var value2 = stringify5(node3, key, node3[key], level3 + 1);
      if (!value2) {
        continue;
      }
      var keyValue = json.stringify(key) + colonSeparator + value2;
      out2.push(indent + space + keyValue);
    }
    seen2.splice(seen2.indexOf(node3), 1);
    return "{" + out2.join(",") + indent + "}";
  }({ "": obj }, "", obj, 0);
};
var mimes$1 = {
  "ez": "application/andrew-inset",
  "aw": "application/applixware",
  "atom": "application/atom+xml",
  "atomcat": "application/atomcat+xml",
  "atomdeleted": "application/atomdeleted+xml",
  "atomsvc": "application/atomsvc+xml",
  "dwd": "application/atsc-dwd+xml",
  "held": "application/atsc-held+xml",
  "rsat": "application/atsc-rsat+xml",
  "bdoc": "application/bdoc",
  "xcs": "application/calendar+xml",
  "ccxml": "application/ccxml+xml",
  "cdfx": "application/cdfx+xml",
  "cdmia": "application/cdmi-capability",
  "cdmic": "application/cdmi-container",
  "cdmid": "application/cdmi-domain",
  "cdmio": "application/cdmi-object",
  "cdmiq": "application/cdmi-queue",
  "cu": "application/cu-seeme",
  "mpd": "application/dash+xml",
  "davmount": "application/davmount+xml",
  "dbk": "application/docbook+xml",
  "dssc": "application/dssc+der",
  "xdssc": "application/dssc+xml",
  "es": "application/ecmascript",
  "ecma": "application/ecmascript",
  "emma": "application/emma+xml",
  "emotionml": "application/emotionml+xml",
  "epub": "application/epub+zip",
  "exi": "application/exi",
  "fdt": "application/fdt+xml",
  "pfr": "application/font-tdpfr",
  "geojson": "application/geo+json",
  "gml": "application/gml+xml",
  "gpx": "application/gpx+xml",
  "gxf": "application/gxf",
  "gz": "application/gzip",
  "hjson": "application/hjson",
  "stk": "application/hyperstudio",
  "ink": "application/inkml+xml",
  "inkml": "application/inkml+xml",
  "ipfix": "application/ipfix",
  "its": "application/its+xml",
  "jar": "application/java-archive",
  "war": "application/java-archive",
  "ear": "application/java-archive",
  "ser": "application/java-serialized-object",
  "class": "application/java-vm",
  "js": "application/javascript",
  "mjs": "application/javascript",
  "json": "application/json",
  "map": "application/json",
  "json5": "application/json5",
  "jsonml": "application/jsonml+json",
  "jsonld": "application/ld+json",
  "lgr": "application/lgr+xml",
  "lostxml": "application/lost+xml",
  "hqx": "application/mac-binhex40",
  "cpt": "application/mac-compactpro",
  "mads": "application/mads+xml",
  "webmanifest": "application/manifest+json",
  "mrc": "application/marc",
  "mrcx": "application/marcxml+xml",
  "ma": "application/mathematica",
  "nb": "application/mathematica",
  "mb": "application/mathematica",
  "mathml": "application/mathml+xml",
  "mbox": "application/mbox",
  "mscml": "application/mediaservercontrol+xml",
  "metalink": "application/metalink+xml",
  "meta4": "application/metalink4+xml",
  "mets": "application/mets+xml",
  "maei": "application/mmt-aei+xml",
  "musd": "application/mmt-usd+xml",
  "mods": "application/mods+xml",
  "m21": "application/mp21",
  "mp21": "application/mp21",
  "mp4s": "application/mp4",
  "m4p": "application/mp4",
  "doc": "application/msword",
  "dot": "application/msword",
  "mxf": "application/mxf",
  "nq": "application/n-quads",
  "nt": "application/n-triples",
  "cjs": "application/node",
  "bin": "application/octet-stream",
  "dms": "application/octet-stream",
  "lrf": "application/octet-stream",
  "mar": "application/octet-stream",
  "so": "application/octet-stream",
  "dist": "application/octet-stream",
  "distz": "application/octet-stream",
  "pkg": "application/octet-stream",
  "bpk": "application/octet-stream",
  "dump": "application/octet-stream",
  "elc": "application/octet-stream",
  "deploy": "application/octet-stream",
  "exe": "application/octet-stream",
  "dll": "application/octet-stream",
  "deb": "application/octet-stream",
  "dmg": "application/octet-stream",
  "iso": "application/octet-stream",
  "img": "application/octet-stream",
  "msi": "application/octet-stream",
  "msp": "application/octet-stream",
  "msm": "application/octet-stream",
  "buffer": "application/octet-stream",
  "oda": "application/oda",
  "opf": "application/oebps-package+xml",
  "ogx": "application/ogg",
  "omdoc": "application/omdoc+xml",
  "onetoc": "application/onenote",
  "onetoc2": "application/onenote",
  "onetmp": "application/onenote",
  "onepkg": "application/onenote",
  "oxps": "application/oxps",
  "relo": "application/p2p-overlay+xml",
  "xer": "application/patch-ops-error+xml",
  "pdf": "application/pdf",
  "pgp": "application/pgp-encrypted",
  "asc": "application/pgp-signature",
  "sig": "application/pgp-signature",
  "prf": "application/pics-rules",
  "p10": "application/pkcs10",
  "p7m": "application/pkcs7-mime",
  "p7c": "application/pkcs7-mime",
  "p7s": "application/pkcs7-signature",
  "p8": "application/pkcs8",
  "ac": "application/pkix-attr-cert",
  "cer": "application/pkix-cert",
  "crl": "application/pkix-crl",
  "pkipath": "application/pkix-pkipath",
  "pki": "application/pkixcmp",
  "pls": "application/pls+xml",
  "ai": "application/postscript",
  "eps": "application/postscript",
  "ps": "application/postscript",
  "provx": "application/provenance+xml",
  "cww": "application/prs.cww",
  "pskcxml": "application/pskc+xml",
  "raml": "application/raml+yaml",
  "rdf": "application/rdf+xml",
  "owl": "application/rdf+xml",
  "rif": "application/reginfo+xml",
  "rnc": "application/relax-ng-compact-syntax",
  "rl": "application/resource-lists+xml",
  "rld": "application/resource-lists-diff+xml",
  "rs": "application/rls-services+xml",
  "rapd": "application/route-apd+xml",
  "sls": "application/route-s-tsid+xml",
  "rusd": "application/route-usd+xml",
  "gbr": "application/rpki-ghostbusters",
  "mft": "application/rpki-manifest",
  "roa": "application/rpki-roa",
  "rsd": "application/rsd+xml",
  "rss": "application/rss+xml",
  "rtf": "application/rtf",
  "sbml": "application/sbml+xml",
  "scq": "application/scvp-cv-request",
  "scs": "application/scvp-cv-response",
  "spq": "application/scvp-vp-request",
  "spp": "application/scvp-vp-response",
  "sdp": "application/sdp",
  "senmlx": "application/senml+xml",
  "sensmlx": "application/sensml+xml",
  "setpay": "application/set-payment-initiation",
  "setreg": "application/set-registration-initiation",
  "shf": "application/shf+xml",
  "siv": "application/sieve",
  "sieve": "application/sieve",
  "smi": "application/smil+xml",
  "smil": "application/smil+xml",
  "rq": "application/sparql-query",
  "srx": "application/sparql-results+xml",
  "gram": "application/srgs",
  "grxml": "application/srgs+xml",
  "sru": "application/sru+xml",
  "ssdl": "application/ssdl+xml",
  "ssml": "application/ssml+xml",
  "swidtag": "application/swid+xml",
  "tei": "application/tei+xml",
  "teicorpus": "application/tei+xml",
  "tfi": "application/thraud+xml",
  "tsd": "application/timestamped-data",
  "toml": "application/toml",
  "trig": "application/trig",
  "ttml": "application/ttml+xml",
  "ubj": "application/ubjson",
  "rsheet": "application/urc-ressheet+xml",
  "td": "application/urc-targetdesc+xml",
  "vxml": "application/voicexml+xml",
  "wasm": "application/wasm",
  "wgt": "application/widget",
  "hlp": "application/winhlp",
  "wsdl": "application/wsdl+xml",
  "wspolicy": "application/wspolicy+xml",
  "xaml": "application/xaml+xml",
  "xav": "application/xcap-att+xml",
  "xca": "application/xcap-caps+xml",
  "xdf": "application/xcap-diff+xml",
  "xel": "application/xcap-el+xml",
  "xns": "application/xcap-ns+xml",
  "xenc": "application/xenc+xml",
  "xhtml": "application/xhtml+xml",
  "xht": "application/xhtml+xml",
  "xlf": "application/xliff+xml",
  "xml": "application/xml",
  "xsl": "application/xml",
  "xsd": "application/xml",
  "rng": "application/xml",
  "dtd": "application/xml-dtd",
  "xop": "application/xop+xml",
  "xpl": "application/xproc+xml",
  "xslt": "application/xml",
  "xspf": "application/xspf+xml",
  "mxml": "application/xv+xml",
  "xhvml": "application/xv+xml",
  "xvml": "application/xv+xml",
  "xvm": "application/xv+xml",
  "yang": "application/yang",
  "yin": "application/yin+xml",
  "zip": "application/zip",
  "3gpp": "video/3gpp",
  "adp": "audio/adpcm",
  "amr": "audio/amr",
  "au": "audio/basic",
  "snd": "audio/basic",
  "mid": "audio/midi",
  "midi": "audio/midi",
  "kar": "audio/midi",
  "rmi": "audio/midi",
  "mxmf": "audio/mobile-xmf",
  "mp3": "audio/mpeg",
  "m4a": "audio/mp4",
  "mp4a": "audio/mp4",
  "mpga": "audio/mpeg",
  "mp2": "audio/mpeg",
  "mp2a": "audio/mpeg",
  "m2a": "audio/mpeg",
  "m3a": "audio/mpeg",
  "oga": "audio/ogg",
  "ogg": "audio/ogg",
  "spx": "audio/ogg",
  "opus": "audio/ogg",
  "s3m": "audio/s3m",
  "sil": "audio/silk",
  "wav": "audio/wav",
  "weba": "audio/webm",
  "xm": "audio/xm",
  "ttc": "font/collection",
  "otf": "font/otf",
  "ttf": "font/ttf",
  "woff": "font/woff",
  "woff2": "font/woff2",
  "exr": "image/aces",
  "apng": "image/apng",
  "avif": "image/avif",
  "bmp": "image/bmp",
  "cgm": "image/cgm",
  "drle": "image/dicom-rle",
  "emf": "image/emf",
  "fits": "image/fits",
  "g3": "image/g3fax",
  "gif": "image/gif",
  "heic": "image/heic",
  "heics": "image/heic-sequence",
  "heif": "image/heif",
  "heifs": "image/heif-sequence",
  "hej2": "image/hej2k",
  "hsj2": "image/hsj2",
  "ief": "image/ief",
  "jls": "image/jls",
  "jp2": "image/jp2",
  "jpg2": "image/jp2",
  "jpeg": "image/jpeg",
  "jpg": "image/jpeg",
  "jpe": "image/jpeg",
  "jph": "image/jph",
  "jhc": "image/jphc",
  "jpm": "image/jpm",
  "jpx": "image/jpx",
  "jpf": "image/jpx",
  "jxr": "image/jxr",
  "jxra": "image/jxra",
  "jxrs": "image/jxrs",
  "jxs": "image/jxs",
  "jxsc": "image/jxsc",
  "jxsi": "image/jxsi",
  "jxss": "image/jxss",
  "ktx": "image/ktx",
  "ktx2": "image/ktx2",
  "png": "image/png",
  "btif": "image/prs.btif",
  "pti": "image/prs.pti",
  "sgi": "image/sgi",
  "svg": "image/svg+xml",
  "svgz": "image/svg+xml",
  "t38": "image/t38",
  "tif": "image/tiff",
  "tiff": "image/tiff",
  "tfx": "image/tiff-fx",
  "webp": "image/webp",
  "wmf": "image/wmf",
  "disposition-notification": "message/disposition-notification",
  "u8msg": "message/global",
  "u8dsn": "message/global-delivery-status",
  "u8mdn": "message/global-disposition-notification",
  "u8hdr": "message/global-headers",
  "eml": "message/rfc822",
  "mime": "message/rfc822",
  "3mf": "model/3mf",
  "gltf": "model/gltf+json",
  "glb": "model/gltf-binary",
  "igs": "model/iges",
  "iges": "model/iges",
  "msh": "model/mesh",
  "mesh": "model/mesh",
  "silo": "model/mesh",
  "mtl": "model/mtl",
  "obj": "model/obj",
  "stpz": "model/step+zip",
  "stpxz": "model/step-xml+zip",
  "stl": "model/stl",
  "wrl": "model/vrml",
  "vrml": "model/vrml",
  "x3db": "model/x3d+fastinfoset",
  "x3dbz": "model/x3d+binary",
  "x3dv": "model/x3d-vrml",
  "x3dvz": "model/x3d+vrml",
  "x3d": "model/x3d+xml",
  "x3dz": "model/x3d+xml",
  "appcache": "text/cache-manifest",
  "manifest": "text/cache-manifest",
  "ics": "text/calendar",
  "ifb": "text/calendar",
  "coffee": "text/coffeescript",
  "litcoffee": "text/coffeescript",
  "css": "text/css",
  "csv": "text/csv",
  "html": "text/html",
  "htm": "text/html",
  "shtml": "text/html",
  "jade": "text/jade",
  "jsx": "text/jsx",
  "less": "text/less",
  "markdown": "text/markdown",
  "md": "text/markdown",
  "mml": "text/mathml",
  "mdx": "text/mdx",
  "n3": "text/n3",
  "txt": "text/plain",
  "text": "text/plain",
  "conf": "text/plain",
  "def": "text/plain",
  "list": "text/plain",
  "log": "text/plain",
  "in": "text/plain",
  "ini": "text/plain",
  "dsc": "text/prs.lines.tag",
  "rtx": "text/richtext",
  "sgml": "text/sgml",
  "sgm": "text/sgml",
  "shex": "text/shex",
  "slim": "text/slim",
  "slm": "text/slim",
  "spdx": "text/spdx",
  "stylus": "text/stylus",
  "styl": "text/stylus",
  "tsv": "text/tab-separated-values",
  "t": "text/troff",
  "tr": "text/troff",
  "roff": "text/troff",
  "man": "text/troff",
  "me": "text/troff",
  "ms": "text/troff",
  "ttl": "text/turtle",
  "uri": "text/uri-list",
  "uris": "text/uri-list",
  "urls": "text/uri-list",
  "vcard": "text/vcard",
  "vtt": "text/vtt",
  "yaml": "text/yaml",
  "yml": "text/yaml",
  "3gp": "video/3gpp",
  "3g2": "video/3gpp2",
  "h261": "video/h261",
  "h263": "video/h263",
  "h264": "video/h264",
  "m4s": "video/iso.segment",
  "jpgv": "video/jpeg",
  "jpgm": "image/jpm",
  "mj2": "video/mj2",
  "mjp2": "video/mj2",
  "ts": "video/mp2t",
  "mp4": "video/mp4",
  "mp4v": "video/mp4",
  "mpg4": "video/mp4",
  "mpeg": "video/mpeg",
  "mpg": "video/mpeg",
  "mpe": "video/mpeg",
  "m1v": "video/mpeg",
  "m2v": "video/mpeg",
  "ogv": "video/ogg",
  "qt": "video/quicktime",
  "mov": "video/quicktime",
  "webm": "video/webm"
};
function lookup(extn) {
  let tmp = ("" + extn).trim().toLowerCase();
  let idx = tmp.lastIndexOf(".");
  return mimes$1[!~idx ? tmp : tmp.substring(++idx)];
}
var assetUrlRE = /__VITE_ASSET__([a-z\d]+)__(?:\$_(.*?)__)?/g;
var rawRE = /(?:\?|&)raw(?:&|$)/;
var urlRE = /(\?|&)url(?:&|$)/;
var jsSourceMapRE = /\.[cm]?js\.map$/;
var assetCache = /* @__PURE__ */ new WeakMap();
var generatedAssets = /* @__PURE__ */ new WeakMap();
function registerCustomMime() {
  mimes$1["ico"] = "image/x-icon";
  mimes$1["flac"] = "audio/flac";
  mimes$1["aac"] = "audio/aac";
  mimes$1["eot"] = "application/vnd.ms-fontobject";
}
function renderAssetUrlInJS(ctx2, config2, chunk, opts, code) {
  const toRelativeRuntime = createToImportMetaURLBasedRelativeRuntime(opts.format);
  let match;
  let s2;
  assetUrlRE.lastIndex = 0;
  while (match = assetUrlRE.exec(code)) {
    s2 || (s2 = new MagicString(code));
    const [full, referenceId, postfix = ""] = match;
    const file = ctx2.getFileName(referenceId);
    chunk.viteMetadata.importedAssets.add(cleanUrl(file));
    const filename = file + postfix;
    const replacement = toOutputFilePathInJS(filename, "asset", chunk.fileName, "js", config2, toRelativeRuntime);
    const replacementString = typeof replacement === "string" ? JSON.stringify(replacement).slice(1, -1) : `"+${replacement.runtime}+"`;
    s2.update(match.index, match.index + full.length, replacementString);
  }
  const publicAssetUrlMap = publicAssetUrlCache.get(config2);
  publicAssetUrlRE.lastIndex = 0;
  while (match = publicAssetUrlRE.exec(code)) {
    s2 || (s2 = new MagicString(code));
    const [full, hash2] = match;
    const publicUrl = publicAssetUrlMap.get(hash2).slice(1);
    const replacement = toOutputFilePathInJS(publicUrl, "public", chunk.fileName, "js", config2, toRelativeRuntime);
    const replacementString = typeof replacement === "string" ? JSON.stringify(replacement).slice(1, -1) : `"+${replacement.runtime}+"`;
    s2.update(match.index, match.index + full.length, replacementString);
  }
  return s2;
}
function assetPlugin(config2) {
  registerCustomMime();
  return {
    name: "vite:asset",
    buildStart() {
      assetCache.set(config2, /* @__PURE__ */ new Map());
      generatedAssets.set(config2, /* @__PURE__ */ new Map());
    },
    resolveId(id) {
      if (!config2.assetsInclude(cleanUrl(id))) {
        return;
      }
      const publicFile = checkPublicFile(id, config2);
      if (publicFile) {
        return id;
      }
    },
    async load(id) {
      if (id.startsWith("\0")) {
        return;
      }
      if (rawRE.test(id)) {
        const file = checkPublicFile(id, config2) || cleanUrl(id);
        return `export default ${JSON.stringify(await import_node_fs4.promises.readFile(file, "utf-8"))}`;
      }
      if (!config2.assetsInclude(cleanUrl(id)) && !urlRE.test(id)) {
        return;
      }
      id = id.replace(urlRE, "$1").replace(/[?&]$/, "");
      const url2 = await fileToUrl(id, config2, this);
      return `export default ${JSON.stringify(url2)}`;
    },
    renderChunk(code, chunk, opts) {
      const s2 = renderAssetUrlInJS(this, config2, chunk, opts, code);
      if (s2) {
        return {
          code: s2.toString(),
          map: config2.build.sourcemap ? s2.generateMap({ hires: true }) : null
        };
      } else {
        return null;
      }
    },
    generateBundle(_, bundle) {
      if (config2.command === "build" && config2.build.ssr && !config2.build.ssrEmitAssets) {
        for (const file in bundle) {
          if (bundle[file].type === "asset" && !file.endsWith("ssr-manifest.json") && !jsSourceMapRE.test(file)) {
            delete bundle[file];
          }
        }
      }
    }
  };
}
function checkPublicFile(url2, { publicDir }) {
  if (!publicDir || !url2.startsWith("/")) {
    return;
  }
  const publicFile = import_node_path4.default.join(publicDir, cleanUrl(url2));
  if (!publicFile.startsWith(publicDir)) {
    return;
  }
  if (import_node_fs4.default.existsSync(publicFile)) {
    return publicFile;
  } else {
    return;
  }
}
async function fileToUrl(id, config2, ctx2) {
  if (config2.command === "serve") {
    return fileToDevUrl(id, config2);
  } else {
    return fileToBuiltUrl(id, config2, ctx2);
  }
}
function fileToDevUrl(id, config2) {
  var _a;
  let rtn;
  if (checkPublicFile(id, config2)) {
    rtn = id;
  } else if (id.startsWith(config2.root)) {
    rtn = "/" + import_node_path4.default.posix.relative(config2.root, id);
  } else {
    rtn = import_node_path4.default.posix.join(FS_PREFIX, id);
  }
  const base2 = joinUrlSegments(((_a = config2.server) == null ? void 0 : _a.origin) ?? "", config2.base);
  return joinUrlSegments(base2, rtn.replace(/^\//, ""));
}
function getPublicAssetFilename(hash2, config2) {
  var _a;
  return (_a = publicAssetUrlCache.get(config2)) == null ? void 0 : _a.get(hash2);
}
var publicAssetUrlCache = /* @__PURE__ */ new WeakMap();
var publicAssetUrlRE = /__VITE_PUBLIC_ASSET__([a-z\d]{8})__/g;
function publicFileToBuiltUrl(url2, config2) {
  if (config2.command !== "build") {
    return joinUrlSegments(config2.base, url2);
  }
  const hash2 = getHash(url2);
  let cache2 = publicAssetUrlCache.get(config2);
  if (!cache2) {
    cache2 = /* @__PURE__ */ new Map();
    publicAssetUrlCache.set(config2, cache2);
  }
  if (!cache2.get(hash2)) {
    cache2.set(hash2, url2);
  }
  return `__VITE_PUBLIC_ASSET__${hash2}__`;
}
var GIT_LFS_PREFIX = import_node_buffer.Buffer.from("version https://git-lfs.github.com");
function isGitLfsPlaceholder(content) {
  if (content.length < GIT_LFS_PREFIX.length)
    return false;
  return GIT_LFS_PREFIX.compare(content, 0, GIT_LFS_PREFIX.length) === 0;
}
async function fileToBuiltUrl(id, config2, pluginContext, skipPublicCheck = false) {
  if (!skipPublicCheck && checkPublicFile(id, config2)) {
    return publicFileToBuiltUrl(id, config2);
  }
  const cache2 = assetCache.get(config2);
  const cached = cache2.get(id);
  if (cached) {
    return cached;
  }
  const file = cleanUrl(id);
  const content = await import_node_fs4.promises.readFile(file);
  let url2;
  if (config2.build.lib || !file.endsWith(".svg") && !file.endsWith(".html") && content.length < Number(config2.build.assetsInlineLimit) && !isGitLfsPlaceholder(content)) {
    if (config2.build.lib && isGitLfsPlaceholder(content)) {
      config2.logger.warn(picocolorsExports.yellow(`Inlined file ${id} was not downloaded via Git LFS`));
    }
    const mimeType = lookup(file) ?? "application/octet-stream";
    url2 = `data:${mimeType};base64,${content.toString("base64")}`;
  } else {
    const { search, hash: hash2 } = (0, import_node_url3.parse)(id);
    const postfix = (search || "") + (hash2 || "");
    const referenceId = pluginContext.emitFile({
      // Ignore directory structure for asset file names
      name: import_node_path4.default.basename(file),
      type: "asset",
      source: content
    });
    const originalName = normalizePath$3(import_node_path4.default.relative(config2.root, file));
    generatedAssets.get(config2).set(referenceId, { originalName });
    url2 = `__VITE_ASSET__${referenceId}__${postfix ? `$_${postfix}__` : ``}`;
  }
  cache2.set(id, url2);
  return url2;
}
async function urlToBuiltUrl(url2, importer, config2, pluginContext) {
  if (checkPublicFile(url2, config2)) {
    return publicFileToBuiltUrl(url2, config2);
  }
  const file = url2.startsWith("/") ? import_node_path4.default.join(config2.root, url2) : import_node_path4.default.join(import_node_path4.default.dirname(importer), url2);
  return fileToBuiltUrl(
    file,
    config2,
    pluginContext,
    // skip public check since we just did it above
    true
  );
}
function manifestPlugin(config2) {
  const manifest = {};
  let outputCount;
  return {
    name: "vite:manifest",
    buildStart() {
      outputCount = 0;
    },
    generateBundle({ format: format2 }, bundle) {
      var _a;
      function getChunkName(chunk) {
        if (chunk.facadeModuleId) {
          let name2 = normalizePath$3(import_node_path4.default.relative(config2.root, chunk.facadeModuleId));
          if (format2 === "system" && !chunk.name.includes("-legacy")) {
            const ext2 = import_node_path4.default.extname(name2);
            const endPos = ext2.length !== 0 ? -ext2.length : void 0;
            name2 = name2.slice(0, endPos) + `-legacy` + ext2;
          }
          return name2.replace(/\0/g, "");
        } else {
          return `_` + import_node_path4.default.basename(chunk.fileName);
        }
      }
      function getInternalImports(imports) {
        const filteredImports = [];
        for (const file of imports) {
          if (bundle[file] === void 0) {
            continue;
          }
          filteredImports.push(getChunkName(bundle[file]));
        }
        return filteredImports;
      }
      function createChunk(chunk) {
        var _a2, _b;
        const manifestChunk = {
          file: chunk.fileName
        };
        if (chunk.facadeModuleId) {
          manifestChunk.src = getChunkName(chunk);
        }
        if (chunk.isEntry) {
          manifestChunk.isEntry = true;
        }
        if (chunk.isDynamicEntry) {
          manifestChunk.isDynamicEntry = true;
        }
        if (chunk.imports.length) {
          const internalImports = getInternalImports(chunk.imports);
          if (internalImports.length > 0) {
            manifestChunk.imports = internalImports;
          }
        }
        if (chunk.dynamicImports.length) {
          const internalImports = getInternalImports(chunk.dynamicImports);
          if (internalImports.length > 0) {
            manifestChunk.dynamicImports = internalImports;
          }
        }
        if ((_a2 = chunk.viteMetadata) == null ? void 0 : _a2.importedCss.size) {
          manifestChunk.css = [...chunk.viteMetadata.importedCss];
        }
        if ((_b = chunk.viteMetadata) == null ? void 0 : _b.importedAssets.size) {
          manifestChunk.assets = [...chunk.viteMetadata.importedAssets];
        }
        return manifestChunk;
      }
      function createAsset(asset, src3, isEntry) {
        const manifestChunk = {
          file: asset.fileName,
          src: src3
        };
        if (isEntry)
          manifestChunk.isEntry = true;
        return manifestChunk;
      }
      const fileNameToAssetMeta = /* @__PURE__ */ new Map();
      const assets = generatedAssets.get(config2);
      assets.forEach((asset, referenceId) => {
        const fileName = this.getFileName(referenceId);
        fileNameToAssetMeta.set(fileName, asset);
      });
      const fileNameToAsset = /* @__PURE__ */ new Map();
      for (const file in bundle) {
        const chunk = bundle[file];
        if (chunk.type === "chunk") {
          manifest[getChunkName(chunk)] = createChunk(chunk);
        } else if (chunk.type === "asset" && typeof chunk.name === "string") {
          const assetMeta = fileNameToAssetMeta.get(chunk.fileName);
          const src3 = (assetMeta == null ? void 0 : assetMeta.originalName) ?? chunk.name;
          const asset = createAsset(chunk, src3, assetMeta == null ? void 0 : assetMeta.isEntry);
          manifest[src3] = asset;
          fileNameToAsset.set(chunk.fileName, asset);
        }
      }
      assets.forEach(({ originalName }, referenceId) => {
        if (!manifest[originalName]) {
          const fileName = this.getFileName(referenceId);
          const asset = fileNameToAsset.get(fileName);
          if (asset) {
            manifest[originalName] = asset;
          }
        }
      });
      outputCount++;
      const output = (_a = config2.build.rollupOptions) == null ? void 0 : _a.output;
      const outputLength = Array.isArray(output) ? output.length : 1;
      if (outputCount >= outputLength) {
        this.emitFile({
          fileName: typeof config2.build.manifest === "string" ? config2.build.manifest : "manifest.json",
          type: "asset",
          source: jsonStableStringify(manifest, { space: 2 })
        });
      }
    }
  };
}
var dataUriRE = /^([^/]+\/[^;,]+)(;base64)?,([\s\S]*)$/;
var dataUriPrefix = `/@data-uri/`;
function dataURIPlugin() {
  let resolved;
  return {
    name: "vite:data-uri",
    buildStart() {
      resolved = {};
    },
    resolveId(id) {
      if (!dataUriRE.test(id)) {
        return null;
      }
      const uri = new import_node_url3.URL(id);
      if (uri.protocol !== "data:") {
        return null;
      }
      const match = uri.pathname.match(dataUriRE);
      if (!match) {
        return null;
      }
      const [, mime, format2, data2] = match;
      if (mime !== "text/javascript") {
        throw new Error(`data URI with non-JavaScript mime type is not supported.`);
      }
      const base64 = format2 && /base64/i.test(format2.substring(1));
      const content = base64 ? Buffer.from(data2, "base64").toString("utf-8") : data2;
      resolved[id] = content;
      return dataUriPrefix + id;
    },
    load(id) {
      if (id.startsWith(dataUriPrefix)) {
        id = id.slice(dataUriPrefix.length);
        return resolved[id] || null;
      }
    }
  };
}
var A = 1 === new Uint8Array(new Uint16Array([1]).buffer)[0];
function parse$e(E2, g = "@") {
  if (!C)
    return init.then(() => parse$e(E2));
  const I = E2.length + 1, K = (C.__heap_base.value || C.__heap_base) + 4 * I - C.memory.buffer.byteLength;
  K > 0 && C.memory.grow(Math.ceil(K / 65536));
  const k = C.sa(I - 1);
  if ((A ? B : Q)(E2, new Uint16Array(C.memory.buffer, k, I)), !C.parse())
    throw Object.assign(new Error(`Parse error ${g}:${E2.slice(0, C.e()).split("\n").length}:${C.e() - E2.lastIndexOf("\n", C.e() - 1)}`), { idx: C.e() });
  const o3 = [], D = [];
  for (; C.ri(); ) {
    const A2 = C.is(), Q2 = C.ie(), B2 = C.ai(), g2 = C.id(), I2 = C.ss(), K2 = C.se();
    let k2;
    C.ip() && (k2 = w(E2.slice(-1 === g2 ? A2 - 1 : A2, -1 === g2 ? Q2 + 1 : Q2))), o3.push({ n: k2, s: A2, e: Q2, ss: I2, se: K2, d: g2, a: B2 });
  }
  for (; C.re(); ) {
    const A2 = C.es(), Q2 = C.ee(), B2 = C.els(), g2 = C.ele(), I2 = E2.slice(A2, Q2), K2 = I2[0], k2 = B2 < 0 ? void 0 : E2.slice(B2, g2), o4 = k2 ? k2[0] : "";
    D.push({ s: A2, e: Q2, ls: B2, le: g2, n: '"' === K2 || "'" === K2 ? w(I2) : I2, ln: '"' === o4 || "'" === o4 ? w(k2) : k2 });
  }
  function w(A2) {
    try {
      return (0, eval)(A2);
    } catch (A3) {
    }
  }
  return [o3, D, !!C.f()];
}
function Q(A2, Q2) {
  const B2 = A2.length;
  let C2 = 0;
  for (; C2 < B2; ) {
    const B3 = A2.charCodeAt(C2);
    Q2[C2++] = (255 & B3) << 8 | B3 >>> 8;
  }
}
function B(A2, Q2) {
  const B2 = A2.length;
  let C2 = 0;
  for (; C2 < B2; )
    Q2[C2] = A2.charCodeAt(C2++);
}
var C;
var init = WebAssembly.compile((E = "AGFzbQEAAAABKghgAX8Bf2AEf39/fwBgAAF/YAAAYAF/AGADf39/AX9gAn9/AX9gAn9/AAMtLAABAQICAgICAgICAgICAgICAgIAAwMDBAQAAAADAAAAAAMDBQYAAAcABgIFBAUBcAEBAQUDAQABBg8CfwFBsPIAC38AQbDyAAsHcBMGbWVtb3J5AgACc2EAAAFlAAMCaXMABAJpZQAFAnNzAAYCc2UABwJhaQAIAmlkAAkCaXAACgJlcwALAmVlAAwDZWxzAA0DZWxlAA4CcmkADwJyZQAQAWYAEQVwYXJzZQASC19faGVhcF9iYXNlAwEKsjssaAEBf0EAIAA2AvgJQQAoAtQJIgEgAEEBdGoiAEEAOwEAQQAgAEECaiIANgL8CUEAIAA2AoAKQQBBADYC2AlBAEEANgLoCUEAQQA2AuAJQQBBADYC3AlBAEEANgLwCUEAQQA2AuQJIAELnwEBA39BACgC6AkhBEEAQQAoAoAKIgU2AugJQQAgBDYC7AlBACAFQSBqNgKACiAEQRxqQdgJIAQbIAU2AgBBACgCzAkhBEEAKALICSEGIAUgATYCACAFIAA2AgggBSACIAJBAmpBACAGIANGGyAEIANGGzYCDCAFIAM2AhQgBUEANgIQIAUgAjYCBCAFQQA2AhwgBUEAKALICSADRjoAGAtWAQF/QQAoAvAJIgRBEGpB3AkgBBtBACgCgAoiBDYCAEEAIAQ2AvAJQQAgBEEUajYCgAogBEEANgIQIAQgAzYCDCAEIAI2AgggBCABNgIEIAQgADYCAAsIAEEAKAKECgsVAEEAKALgCSgCAEEAKALUCWtBAXULHgEBf0EAKALgCSgCBCIAQQAoAtQJa0EBdUF/IAAbCxUAQQAoAuAJKAIIQQAoAtQJa0EBdQseAQF/QQAoAuAJKAIMIgBBACgC1AlrQQF1QX8gABsLHgEBf0EAKALgCSgCECIAQQAoAtQJa0EBdUF/IAAbCzsBAX8CQEEAKALgCSgCFCIAQQAoAsgJRw0AQX8PCwJAIABBACgCzAlHDQBBfg8LIABBACgC1AlrQQF1CwsAQQAoAuAJLQAYCxUAQQAoAuQJKAIAQQAoAtQJa0EBdQsVAEEAKALkCSgCBEEAKALUCWtBAXULHgEBf0EAKALkCSgCCCIAQQAoAtQJa0EBdUF/IAAbCx4BAX9BACgC5AkoAgwiAEEAKALUCWtBAXVBfyAAGwslAQF/QQBBACgC4AkiAEEcakHYCSAAGygCACIANgLgCSAAQQBHCyUBAX9BAEEAKALkCSIAQRBqQdwJIAAbKAIAIgA2AuQJIABBAEcLCABBAC0AiAoL5gwBBn8jAEGA0ABrIgAkAEEAQQE6AIgKQQBBACgC0Ak2ApAKQQBBACgC1AlBfmoiATYCpApBACABQQAoAvgJQQF0aiICNgKoCkEAQQA7AYoKQQBBADsBjApBAEEAOgCUCkEAQQA2AoQKQQBBADoA9AlBACAAQYAQajYCmApBACAANgKcCkEAQQA6AKAKAkACQAJAAkADQEEAIAFBAmoiAzYCpAogASACTw0BAkAgAy8BACICQXdqQQVJDQACQAJAAkACQAJAIAJBm39qDgUBCAgIAgALIAJBIEYNBCACQS9GDQMgAkE7Rg0CDAcLQQAvAYwKDQEgAxATRQ0BIAFBBGpBgghBChArDQEQFEEALQCICg0BQQBBACgCpAoiATYCkAoMBwsgAxATRQ0AIAFBBGpBjAhBChArDQAQFQtBAEEAKAKkCjYCkAoMAQsCQCABLwEEIgNBKkYNACADQS9HDQQQFgwBC0EBEBcLQQAoAqgKIQJBACgCpAohAQwACwtBACECIAMhAUEALQD0CQ0CDAELQQAgATYCpApBAEEAOgCICgsDQEEAIAFBAmoiAzYCpAoCQAJAAkACQAJAAkACQAJAAkAgAUEAKAKoCk8NACADLwEAIgJBd2pBBUkNCAJAAkACQAJAAkACQAJAAkACQAJAIAJBYGoOChIRBhEREREFAQIACwJAAkACQAJAIAJBoH9qDgoLFBQDFAEUFBQCAAsgAkGFf2oOAwUTBgkLQQAvAYwKDRIgAxATRQ0SIAFBBGpBgghBChArDRIQFAwSCyADEBNFDREgAUEEakGMCEEKECsNERAVDBELIAMQE0UNECABKQAEQuyAhIOwjsA5Ug0QIAEvAQwiA0F3aiIBQRdLDQ5BASABdEGfgIAEcUUNDgwPC0EAQQAvAYwKIgFBAWo7AYwKQQAoApgKIAFBA3RqIgFBATYCACABQQAoApAKNgIEDA8LQQAvAYwKIgJFDQtBACACQX9qIgQ7AYwKQQAvAYoKIgJFDQ4gAkECdEEAKAKcCmpBfGooAgAiBSgCFEEAKAKYCiAEQf//A3FBA3RqKAIERw0OAkAgBSgCBA0AIAUgAzYCBAtBACACQX9qOwGKCiAFIAFBBGo2AgwMDgsCQEEAKAKQCiIBLwEAQSlHDQBBACgC6AkiA0UNACADKAIEIAFHDQBBAEEAKALsCSIDNgLoCQJAIANFDQAgA0EANgIcDAELQQBBADYC2AkLQQBBAC8BjAoiA0EBajsBjApBACgCmAogA0EDdGoiA0EGQQJBAC0AoAobNgIAIAMgATYCBEEAQQA6AKAKDA0LQQAvAYwKIgFFDQlBACABQX9qIgE7AYwKQQAoApgKIAFB//8DcUEDdGooAgBBBEYNBAwMC0EnEBgMCwtBIhAYDAoLIAJBL0cNCQJAAkAgAS8BBCIBQSpGDQAgAUEvRw0BEBYMDAtBARAXDAsLAkACQEEAKAKQCiIBLwEAIgMQGUUNAAJAAkAgA0FVag4EAAgBAwgLIAFBfmovAQBBK0YNBgwHCyABQX5qLwEAQS1GDQUMBgsCQCADQf0ARg0AIANBKUcNBUEAKAKYCkEALwGMCkEDdGooAgQQGkUNBQwGC0EAKAKYCkEALwGMCkEDdGoiAigCBBAbDQUgAigCAEEGRg0FDAQLIAFBfmovAQBBUGpB//8DcUEKSQ0DDAQLQQAoApgKQQAvAYwKIgFBA3QiA2pBACgCkAo2AgRBACABQQFqOwGMCkEAKAKYCiADakEDNgIACxAcDAcLQQAtAPQJQQAvAYoKQQAvAYwKcnJFIQIMCQsgARAdDQAgA0UNACADQS9GQQAtAJQKQQBHcQ0AIAFBfmohAUEAKALUCSECAkADQCABQQJqIgQgAk0NAUEAIAE2ApAKIAEvAQAhAyABQX5qIgQhASADEB5FDQALIARBAmohBAtBASEFIANB//8DcRAfRQ0BIARBfmohAQJAA0AgAUECaiIDIAJNDQFBACABNgKQCiABLwEAIQMgAUF+aiIEIQEgAxAfDQALIARBAmohAwsgAxAgRQ0BECFBAEEAOgCUCgwFCxAhQQAhBQtBACAFOgCUCgwDCxAiQQAhAgwFCyADQaABRw0BC0EAQQE6AKAKC0EAQQAoAqQKNgKQCgtBACgCpAohAQwACwsgAEGA0ABqJAAgAgsdAAJAQQAoAtQJIABHDQBBAQ8LIABBfmovAQAQHgvFCgEHf0EAQQAoAqQKIgBBDGoiATYCpApBACgC8AkhAkEBECYhAwJAAkACQAJAAkACQAJAQQAoAqQKIgQgAUcNACADECVFDQELAkACQAJAAkAgA0EqRg0AIANB+wBHDQFBACAEQQJqNgKkCkEBECYhBEEAKAKkCiEBA0ACQAJAIARB//8DcSIDQSJGDQAgA0EnRg0AIAMQKBpBACgCpAohAwwBCyADEBhBAEEAKAKkCkECaiIDNgKkCgtBARAmGgJAIAEgAxApIgRBLEcNAEEAQQAoAqQKQQJqNgKkCkEBECYhBAtBACgCpAohAyAEQf0ARg0DIAMgAUYNCiADIQEgA0EAKAKoCk0NAAwKCwtBACAEQQJqNgKkCkEBECYaQQAoAqQKIgMgAxApGgwCC0EAQQA6AIgKAkACQAJAAkACQAJAIANBn39qDgwCCAQBCAMICAgICAUACyADQfYARg0EDAcLQQAgBEEOaiIANgKkCkHhACEDAkBBARAmIgJB4QBHDQBBACEBQQAoAqQKIgIQE0UNCyACKQACQvOA5IPgjcAxUg0LIAIvAQoQH0UNC0EAIAJBCmo2AqQKQQAQJiECC0HmACEDQQAhASACQeYARw0JQQAhAUEAKAKkCiICEBNFDQogAkECakGkCEEOECsNCiACLwEQIgVBd2oiBkEXSw0HQQEgBnRBn4CABHFFDQcMCAtBACAEQQpqNgKkCkEBECYaQQAoAqQKIQQLQQAgBEEQajYCpAoCQEEBECYiBEEqRw0AQQBBACgCpApBAmo2AqQKQQEQJiEEC0EAKAKkCiEDIAQQKBogA0EAKAKkCiIEIAMgBBACQQBBACgCpApBfmo2AqQKDwsCQCAEKQACQuyAhIOwjsA5Ug0AIAQvAQoQHkUNAEEAIARBCmo2AqQKQQEQJiEEQQAoAqQKIQMgBBAoGiADQQAoAqQKIgQgAyAEEAJBAEEAKAKkCkF+ajYCpAoPC0EAIARBBGoiBDYCpAoLQQAgBEEEaiIDNgKkCkEAQQA6AIgKAkADQEEAIANBAmo2AqQKQQEQJiEEQQAoAqQKIQMgBBAoQSByQfsARg0BQQAoAqQKIgQgA0YNBCADIAQgAyAEEAJBARAmQSxHDQFBACgCpAohAwwACwtBAEEAKAKkCkF+ajYCpAoPC0EAIANBAmo2AqQKC0EBECYhBEEAKAKkCiEDAkAgBEHmAEcNACADQQJqQZ4IQQYQKw0AQQAgA0EIajYCpAogAEEBECYQJyACQRBqQdwJIAIbIQMDQCADKAIAIgNFDQIgA0IANwIIIANBEGohAwwACwtBACADQX5qNgKkCgsPCwJAIAVBWGoOAwEDAQALIAVBoAFHDQILQQAgAkEQajYCpApBASEBAkBBARAmIgJBKkcNAEEAQQAoAqQKQQJqNgKkCkEBECYhAgsgAkEoRw0AIAQgAEEAQQAQAkEAIARBDGo2AqQKDwtB4wAhAwJAIAJB4wBGDQAgAiEDDAELQQAoAqQKIgIQE0UNACACKQACQuyAhIOwjsA5Ug0AAkACQCACLwEKIgVBd2oiBkEXSw0AQQEgBnRBn4CABHENAQsgBUGgAUYNACAFQfsARw0BC0EAIAJBCmo2AqQKQQEhAUEBECYiA0H7AEcNACAEIABBAEEAEAJBACAEQQxqNgKkCg8LQQAoAqQKIQIgAxAoGgJAAkAgAUUNAEEAKAKkCiIDIAJNDQAgBCAAIAIgAxACQQAoAqQKQX5qIQMMAQsgBCAAQQBBABACIARBDGohAwtBACADNgKkCg8LECILvgYBBH9BAEEAKAKkCiIAQQxqIgE2AqQKAkACQAJAAkACQAJAAkACQAJAAkBBARAmIgJBWWoOCAQCAQQBAQEDAAsgAkEiRg0DIAJB+wBGDQQLQQAoAqQKIAFHDQJBACAAQQpqNgKkCg8LQQAoApgKQQAvAYwKIgJBA3RqIgFBACgCpAo2AgRBACACQQFqOwGMCiABQQU2AgBBACgCkAovAQBBLkYNA0EAQQAoAqQKIgFBAmo2AqQKQQEQJiECIABBACgCpApBACABEAFBAEEALwGKCiIBQQFqOwGKCkEAKAKcCiABQQJ0akEAKALoCTYCAAJAIAJBIkYNACACQSdGDQBBAEEAKAKkCkF+ajYCpAoPCyACEBhBAEEAKAKkCkECaiICNgKkCgJAAkACQEEBECZBV2oOBAECAgACC0EAQQAoAqQKQQJqNgKkCkEBECYaQQAoAugJIgEgAjYCBCABQQE6ABggAUEAKAKkCiICNgIQQQAgAkF+ajYCpAoPC0EAKALoCSIBIAI2AgQgAUEBOgAYQQBBAC8BjApBf2o7AYwKIAFBACgCpApBAmo2AgxBAEEALwGKCkF/ajsBigoPC0EAQQAoAqQKQX5qNgKkCg8LQQBBACgCpApBAmo2AqQKQQEQJkHtAEcNAkEAKAKkCiICQQJqQZYIQQYQKw0CQQAoApAKLwEAQS5GDQIgACAAIAJBCGpBACgCzAkQAQ8LQQAvAYwKDQJBACgCpAohAkEAKAKoCiEDA0AgAiADTw0FAkACQCACLwEAIgFBJ0YNACABQSJHDQELIAAgARAnDwtBACACQQJqIgI2AqQKDAALC0EAKAKkCiECQQAvAYwKDQICQANAAkACQAJAIAJBACgCqApPDQBBARAmIgJBIkYNASACQSdGDQEgAkH9AEcNAkEAQQAoAqQKQQJqNgKkCgtBARAmGkEAKAKkCiICKQAAQuaAyIPwjcA2Ug0HQQAgAkEIajYCpApBARAmIgJBIkYNAyACQSdGDQMMBwsgAhAYC0EAQQAoAqQKQQJqIgI2AqQKDAALCyAAIAIQJwsPC0EAQQAoAqQKQX5qNgKkCg8LQQAgAkF+ajYCpAoPCxAiC0cBA39BACgCpApBAmohAEEAKAKoCiEBAkADQCAAIgJBfmogAU8NASACQQJqIQAgAi8BAEF2ag4EAQAAAQALC0EAIAI2AqQKC5gBAQN/QQBBACgCpAoiAUECajYCpAogAUEGaiEBQQAoAqgKIQIDQAJAAkACQCABQXxqIAJPDQAgAUF+ai8BACEDAkACQCAADQAgA0EqRg0BIANBdmoOBAIEBAIECyADQSpHDQMLIAEvAQBBL0cNAkEAIAFBfmo2AqQKDAELIAFBfmohAQtBACABNgKkCg8LIAFBAmohAQwACwuIAQEEf0EAKAKkCiEBQQAoAqgKIQICQAJAA0AgASIDQQJqIQEgAyACTw0BIAEvAQAiBCAARg0CAkAgBEHcAEYNACAEQXZqDgQCAQECAQsgA0EEaiEBIAMvAQRBDUcNACADQQZqIAEgAy8BBkEKRhshAQwACwtBACABNgKkChAiDwtBACABNgKkCgtsAQF/AkACQCAAQV9qIgFBBUsNAEEBIAF0QTFxDQELIABBRmpB//8DcUEGSQ0AIABBKUcgAEFYakH//wNxQQdJcQ0AAkAgAEGlf2oOBAEAAAEACyAAQf0ARyAAQYV/akH//wNxQQRJcQ8LQQELLgEBf0EBIQECQCAAQZgJQQUQIw0AIABBoglBAxAjDQAgAEGoCUECECMhAQsgAQuDAQECf0EBIQECQAJAAkACQAJAAkAgAC8BACICQUVqDgQFBAQBAAsCQCACQZt/ag4EAwQEAgALIAJBKUYNBCACQfkARw0DIABBfmpBtAlBBhAjDwsgAEF+ai8BAEE9Rg8LIABBfmpBrAlBBBAjDwsgAEF+akHACUEDECMPC0EAIQELIAEL3gEBBH9BACgCpAohAEEAKAKoCiEBAkACQAJAA0AgACICQQJqIQAgAiABTw0BAkACQAJAIAAvAQAiA0Gkf2oOBQIDAwMBAAsgA0EkRw0CIAIvAQRB+wBHDQJBACACQQRqIgA2AqQKQQBBAC8BjAoiAkEBajsBjApBACgCmAogAkEDdGoiAkEENgIAIAIgADYCBA8LQQAgADYCpApBAEEALwGMCkF/aiIAOwGMCkEAKAKYCiAAQf//A3FBA3RqKAIAQQNHDQMMBAsgAkEEaiEADAALC0EAIAA2AqQKCxAiCwu0AwECf0EAIQECQAJAAkACQAJAAkACQAJAAkACQCAALwEAQZx/ag4UAAECCQkJCQMJCQQFCQkGCQcJCQgJCwJAAkAgAEF+ai8BAEGXf2oOBAAKCgEKCyAAQXxqQbwIQQIQIw8LIABBfGpBwAhBAxAjDwsCQAJAAkAgAEF+ai8BAEGNf2oOAwABAgoLAkAgAEF8ai8BACICQeEARg0AIAJB7ABHDQogAEF6akHlABAkDwsgAEF6akHjABAkDwsgAEF8akHGCEEEECMPCyAAQXxqQc4IQQYQIw8LIABBfmovAQBB7wBHDQYgAEF8ai8BAEHlAEcNBgJAIABBemovAQAiAkHwAEYNACACQeMARw0HIABBeGpB2ghBBhAjDwsgAEF4akHmCEECECMPCyAAQX5qQeoIQQQQIw8LQQEhASAAQX5qIgBB6QAQJA0EIABB8ghBBRAjDwsgAEF+akHkABAkDwsgAEF+akH8CEEHECMPCyAAQX5qQYoJQQQQIw8LAkAgAEF+ai8BACICQe8ARg0AIAJB5QBHDQEgAEF8akHuABAkDwsgAEF8akGSCUEDECMhAQsgAQs0AQF/QQEhAQJAIABBd2pB//8DcUEFSQ0AIABBgAFyQaABRg0AIABBLkcgABAlcSEBCyABCzABAX8CQAJAIABBd2oiAUEXSw0AQQEgAXRBjYCABHENAQsgAEGgAUYNAEEADwtBAQtOAQJ/QQAhAQJAAkAgAC8BACICQeUARg0AIAJB6wBHDQEgAEF+akHqCEEEECMPCyAAQX5qLwEAQfUARw0AIABBfGpBzghBBhAjIQELIAELcAECfwJAAkADQEEAQQAoAqQKIgBBAmoiATYCpAogAEEAKAKoCk8NAQJAAkACQCABLwEAIgFBpX9qDgIBAgALAkAgAUF2ag4EBAMDBAALIAFBL0cNAgwECxAqGgwBC0EAIABBBGo2AqQKDAALCxAiCws1AQF/QQBBAToA9AlBACgCpAohAEEAQQAoAqgKQQJqNgKkCkEAIABBACgC1AlrQQF1NgKECgtJAQN/QQAhAwJAIAAgAkEBdCICayIEQQJqIgBBACgC1AkiBUkNACAAIAEgAhArDQACQCAAIAVHDQBBAQ8LIAQvAQAQHiEDCyADCz0BAn9BACECAkBBACgC1AkiAyAASw0AIAAvAQAgAUcNAAJAIAMgAEcNAEEBDwsgAEF+ai8BABAeIQILIAILaAECf0EBIQECQAJAIABBX2oiAkEFSw0AQQEgAnRBMXENAQsgAEH4/wNxQShGDQAgAEFGakH//wNxQQZJDQACQCAAQaV/aiICQQNLDQAgAkEBRw0BCyAAQYV/akH//wNxQQRJIQELIAELnAEBA39BACgCpAohAQJAA0ACQAJAIAEvAQAiAkEvRw0AAkAgAS8BAiIBQSpGDQAgAUEvRw0EEBYMAgsgABAXDAELAkACQCAARQ0AIAJBd2oiAUEXSw0BQQEgAXRBn4CABHFFDQEMAgsgAhAfRQ0DDAELIAJBoAFHDQILQQBBACgCpAoiA0ECaiIBNgKkCiADQQAoAqgKSQ0ACwsgAgvCAwEBfwJAIAFBIkYNACABQSdGDQAQIg8LQQAoAqQKIQIgARAYIAAgAkECakEAKAKkCkEAKALICRABQQBBACgCpApBAmo2AqQKQQAQJiEAQQAoAqQKIQECQAJAIABB4QBHDQAgAUECakGyCEEKECtFDQELQQAgAUF+ajYCpAoPC0EAIAFBDGo2AqQKAkBBARAmQfsARg0AQQAgATYCpAoPC0EAKAKkCiICIQADQEEAIABBAmo2AqQKAkACQAJAQQEQJiIAQSJGDQAgAEEnRw0BQScQGEEAQQAoAqQKQQJqNgKkCkEBECYhAAwCC0EiEBhBAEEAKAKkCkECajYCpApBARAmIQAMAQsgABAoIQALAkAgAEE6Rg0AQQAgATYCpAoPC0EAQQAoAqQKQQJqNgKkCgJAQQEQJiIAQSJGDQAgAEEnRg0AQQAgATYCpAoPCyAAEBhBAEEAKAKkCkECajYCpAoCQAJAQQEQJiIAQSxGDQAgAEH9AEYNAUEAIAE2AqQKDwtBAEEAKAKkCkECajYCpApBARAmQf0ARg0AQQAoAqQKIQAMAQsLQQAoAugJIgEgAjYCECABQQAoAqQKQQJqNgIMC20BAn8CQAJAA0ACQCAAQf//A3EiAUF3aiICQRdLDQBBASACdEGfgIAEcQ0CCyABQaABRg0BIAAhAiABECUNAkEAIQJBAEEAKAKkCiIAQQJqNgKkCiAALwECIgANAAwCCwsgACECCyACQf//A3ELqwEBBH8CQAJAQQAoAqQKIgIvAQAiA0HhAEYNACABIQQgACEFDAELQQAgAkEEajYCpApBARAmIQJBACgCpAohBQJAAkAgAkEiRg0AIAJBJ0YNACACECgaQQAoAqQKIQQMAQsgAhAYQQBBACgCpApBAmoiBDYCpAoLQQEQJiEDQQAoAqQKIQILAkAgAiAFRg0AIAUgBEEAIAAgACABRiICG0EAIAEgAhsQAgsgAwtyAQR/QQAoAqQKIQBBACgCqAohAQJAAkADQCAAQQJqIQIgACABTw0BAkACQCACLwEAIgNBpH9qDgIBBAALIAIhACADQXZqDgQCAQECAQsgAEEEaiEADAALC0EAIAI2AqQKECJBAA8LQQAgAjYCpApB3QALSQEDf0EAIQMCQCACRQ0AAkADQCAALQAAIgQgAS0AACIFRw0BIAFBAWohASAAQQFqIQAgAkF/aiICDQAMAgsLIAQgBWshAwsgAwsL5AECAEGACAvGAQAAeABwAG8AcgB0AG0AcABvAHIAdABlAHQAYQBmAHIAbwBtAHUAbgBjAHQAaQBvAG4AcwBzAGUAcgB0AHYAbwB5AGkAZQBkAGUAbABlAGMAbwBuAHQAaQBuAGkAbgBzAHQAYQBuAHQAeQBiAHIAZQBhAHIAZQB0AHUAcgBkAGUAYgB1AGcAZwBlAGEAdwBhAGkAdABoAHIAdwBoAGkAbABlAGYAbwByAGkAZgBjAGEAdABjAGYAaQBuAGEAbABsAGUAbABzAABByAkLEAEAAAACAAAAAAQAADA5AAA=", "undefined" != typeof Buffer ? Buffer.from(E, "base64") : Uint8Array.from(atob(E), (A2) => A2.charCodeAt(0)))).then(WebAssembly.instantiate).then(({ exports: A2 }) => {
  C = A2;
});
var E;
var isDebug$6 = !!process.env.DEBUG;
var debug$e = createDebugger("vite:sourcemap", {
  onlyWhenFocused: true
});
var virtualSourceRE = /^(?:\0|dep:|browser-external:)/;
async function injectSourcesContent(map3, file, logger2) {
  let sourceRoot;
  try {
    sourceRoot = await import_node_fs4.promises.realpath(import_node_path4.default.resolve(import_node_path4.default.dirname(file), map3.sourceRoot || ""));
  } catch {
  }
  const missingSources = [];
  map3.sourcesContent = await Promise.all(map3.sources.map((sourcePath) => {
    if (sourcePath && !virtualSourceRE.test(sourcePath)) {
      sourcePath = decodeURI(sourcePath);
      if (sourceRoot) {
        sourcePath = import_node_path4.default.resolve(sourceRoot, sourcePath);
      }
      return import_node_fs4.promises.readFile(sourcePath, "utf-8").catch(() => {
        missingSources.push(sourcePath);
        return null;
      });
    }
    return null;
  }));
  if (missingSources.length) {
    logger2.warnOnce(`Sourcemap for "${file}" points to missing source files`);
    isDebug$6 && debug$e(`Missing sources:
  ` + missingSources.join(`
  `));
  }
}
function genSourceMapUrl(map3) {
  if (typeof map3 !== "string") {
    map3 = JSON.stringify(map3);
  }
  return `data:application/json;base64,${Buffer.from(map3).toString("base64")}`;
}
function getCodeWithSourcemap(type, code, map3) {
  if (isDebug$6) {
    code += `
/*${JSON.stringify(map3, null, 2).replace(/\*\//g, "*\\/")}*/
`;
  }
  if (type === "js") {
    code += `
//# sourceMappingURL=${genSourceMapUrl(map3)}`;
  } else if (type === "css") {
    code += `
/*# sourceMappingURL=${genSourceMapUrl(map3)} */`;
  }
  return code;
}
function e(e3, n3, r3) {
  throw new Error(r3 ? `No known conditions for "${n3}" specifier in "${e3}" package` : `Missing "${n3}" specifier in "${e3}" package`);
}
function n(n3, i2, o3, f2) {
  let s2, u2, l2 = r(n3, o3), c2 = function(e3) {
    let n4 = /* @__PURE__ */ new Set(["default", ...e3.conditions || []]);
    return e3.unsafe || n4.add(e3.require ? "require" : "import"), e3.unsafe || n4.add(e3.browser ? "browser" : "node"), n4;
  }(f2 || {}), a2 = i2[l2];
  if (void 0 === a2) {
    let e3, n4, r3, t3;
    for (t3 in i2)
      n4 && t3.length < n4.length || ("/" === t3[t3.length - 1] && l2.startsWith(t3) ? (u2 = l2.substring(t3.length), n4 = t3) : t3.length > 1 && (r3 = t3.indexOf("*", 2), ~r3 && (e3 = RegExp("^" + t3.substring(0, r3) + "(.*)" + t3.substring(1 + r3)).exec(l2), e3 && e3[1] && (u2 = e3[1], n4 = t3))));
    a2 = i2[n4];
  }
  return a2 || e(n3, l2), s2 = t(a2, c2), s2 || e(n3, l2, 1), u2 && function(e3, n4) {
    let r3, t3 = 0, i3 = e3.length, o4 = /[*]/g;
    for (; t3 < i3; t3++)
      e3[t3] = o4.test(r3 = e3[t3]) ? r3.replace(o4, n4) : r3 + n4;
  }(s2, u2), s2;
}
function r(e3, n3, r3) {
  if (e3 === n3 || "." === n3)
    return ".";
  let t3 = e3 + "/", i2 = t3.length, o3 = n3.slice(0, i2) === t3, f2 = o3 ? n3.slice(i2) : n3;
  return "#" === f2[0] ? f2 : o3 || !r3 ? "./" === f2.slice(0, 2) ? f2 : "./" + f2 : f2;
}
function t(e3, n3, r3) {
  if (e3) {
    if ("string" == typeof e3)
      return r3 && r3.add(e3), [e3];
    let i2, o3;
    if (Array.isArray(e3)) {
      for (o3 = r3 || /* @__PURE__ */ new Set(), i2 = 0; i2 < e3.length; i2++)
        t(e3[i2], n3, o3);
      if (!r3 && o3.size)
        return [...o3];
    } else
      for (i2 in e3)
        if (n3.has(i2))
          return t(e3[i2], n3, r3);
  }
}
function o(e3, r3, t3) {
  let i2, o3 = e3.exports;
  if (o3) {
    if ("string" == typeof o3)
      o3 = { ".": o3 };
    else
      for (i2 in o3) {
        "." !== i2[0] && (o3 = { ".": o3 });
        break;
      }
    return n(e3.name, o3, r3 || ".", t3);
  }
}
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191];
var nonASCIIidentifierChars = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿";
var nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};
var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
var keywords$1 = {
  5: ecma5AndLessKeywords,
  "5module": ecma5AndLessKeywords + " export import",
  6: ecma5AndLessKeywords + " const class extends export import super"
};
var keywordRelationalOperator = /^in(stanceof)?$/;
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
function isInAstralSet(code, set3) {
  var pos = 65536;
  for (var i2 = 0; i2 < set3.length; i2 += 2) {
    pos += set3[i2];
    if (pos > code) {
      return false;
    }
    pos += set3[i2 + 1];
    if (pos >= code) {
      return true;
    }
  }
  return false;
}
function isIdentifierStart(code, astral) {
  if (code < 65) {
    return code === 36;
  }
  if (code < 91) {
    return true;
  }
  if (code < 97) {
    return code === 95;
  }
  if (code < 123) {
    return true;
  }
  if (code <= 65535) {
    return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code, astralIdentifierStartCodes);
}
function isIdentifierChar(code, astral) {
  if (code < 48) {
    return code === 36;
  }
  if (code < 58) {
    return true;
  }
  if (code < 65) {
    return false;
  }
  if (code < 91) {
    return true;
  }
  if (code < 97) {
    return code === 95;
  }
  if (code < 123) {
    return true;
  }
  if (code <= 65535) {
    return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}
var TokenType = function TokenType2(label, conf) {
  if (conf === void 0)
    conf = {};
  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};
function binop(name2, prec) {
  return new TokenType(name2, { beforeExpr: true, binop: prec });
}
var beforeExpr = { beforeExpr: true };
var startsExpr = { startsExpr: true };
var keywords$2 = {};
function kw(name2, options3) {
  if (options3 === void 0)
    options3 = {};
  options3.keyword = name2;
  return keywords$2[name2] = new TokenType(name2, options3);
}
var types$1 = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  privateId: new TokenType("privateId", startsExpr),
  eof: new TokenType("eof"),
  // Punctuation token types.
  bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  questionDot: new TokenType("?."),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.
  eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
  assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
  incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
  prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", { beforeExpr: true }),
  coalesce: binop("??", 1),
  // Keyword token types.
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", { isLoop: true, beforeExpr: true }),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", { isLoop: true }),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", { isLoop: true }),
  _with: kw("with"),
  _new: kw("new", { beforeExpr: true, startsExpr: true }),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import", startsExpr),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", { beforeExpr: true, binop: 7 }),
  _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
  _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
  _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
  _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
};
var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");
function isNewLine(code) {
  return code === 10 || code === 13 || code === 8232 || code === 8233;
}
function nextLineBreak(code, from, end) {
  if (end === void 0)
    end = code.length;
  for (var i2 = from; i2 < end; i2++) {
    var next = code.charCodeAt(i2);
    if (isNewLine(next)) {
      return i2 < end - 1 && next === 13 && code.charCodeAt(i2 + 1) === 10 ? i2 + 2 : i2 + 1;
    }
  }
  return -1;
}
var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var ref = Object.prototype;
var hasOwnProperty$1 = ref.hasOwnProperty;
var toString$1 = ref.toString;
var hasOwn = Object.hasOwn || function(obj, propName) {
  return hasOwnProperty$1.call(obj, propName);
};
var isArray = Array.isArray || function(obj) {
  return toString$1.call(obj) === "[object Array]";
};
function wordsRegexp(words) {
  return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$");
}
function codePointToString(code) {
  if (code <= 65535) {
    return String.fromCharCode(code);
  }
  code -= 65536;
  return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
}
var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
var Position = function Position2(line, col) {
  this.line = line;
  this.column = col;
};
Position.prototype.offset = function offset(n3) {
  return new Position(this.line, this.column + n3);
};
var SourceLocation = function SourceLocation2(p2, start, end) {
  this.start = start;
  this.end = end;
  if (p2.sourceFile !== null) {
    this.source = p2.sourceFile;
  }
};
function getLineInfo(input, offset3) {
  for (var line = 1, cur = 0; ; ) {
    var nextBreak = nextLineBreak(input, cur, offset3);
    if (nextBreak < 0) {
      return new Position(line, offset3 - cur);
    }
    ++line;
    cur = nextBreak;
  }
}
var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
  // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
  // (the latest version the library supports). This influences
  // support for strict mode, the set of reserved words, and support
  // for new syntax features.
  ecmaVersion: null,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called
  // when a semicolon is automatically inserted. It will be passed
  // the position of the comma as an offset, and if `locations` is
  // enabled, it is given the location as a `{line, column}` object
  // as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program, and an import.meta expression
  // in a script isn't considered an error.
  allowImportExportEverywhere: false,
  // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: null,
  // When enabled, super identifiers are not constrained to
  // appearing in methods and do not raise an error when they appear elsewhere.
  allowSuperOutsideMethod: null,
  // When enabled, hashbang directive in the beginning of file is
  // allowed and treated as a line comment. Enabled by default when
  // `ecmaVersion` >= 2023.
  allowHashBang: false,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callback—that will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callback—that will corrupt its internal state.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false
};
var warnedAboutEcmaVersion = false;
function getOptions(opts) {
  var options3 = {};
  for (var opt in defaultOptions) {
    options3[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
  }
  if (options3.ecmaVersion === "latest") {
    options3.ecmaVersion = 1e8;
  } else if (options3.ecmaVersion == null) {
    if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
      warnedAboutEcmaVersion = true;
      console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
    }
    options3.ecmaVersion = 11;
  } else if (options3.ecmaVersion >= 2015) {
    options3.ecmaVersion -= 2009;
  }
  if (options3.allowReserved == null) {
    options3.allowReserved = options3.ecmaVersion < 5;
  }
  if (!opts || opts.allowHashBang == null) {
    options3.allowHashBang = options3.ecmaVersion >= 14;
  }
  if (isArray(options3.onToken)) {
    var tokens = options3.onToken;
    options3.onToken = function(token) {
      return tokens.push(token);
    };
  }
  if (isArray(options3.onComment)) {
    options3.onComment = pushComment(options3, options3.onComment);
  }
  return options3;
}
function pushComment(options3, array2) {
  return function(block, text, start, end, startLoc, endLoc) {
    var comment2 = {
      type: block ? "Block" : "Line",
      value: text,
      start,
      end
    };
    if (options3.locations) {
      comment2.loc = new SourceLocation(this, startLoc, endLoc);
    }
    if (options3.ranges) {
      comment2.range = [start, end];
    }
    array2.push(comment2);
  };
}
var SCOPE_TOP = 1;
var SCOPE_FUNCTION = 2;
var SCOPE_ASYNC = 4;
var SCOPE_GENERATOR = 8;
var SCOPE_ARROW = 16;
var SCOPE_SIMPLE_CATCH = 32;
var SCOPE_SUPER = 64;
var SCOPE_DIRECT_SUPER = 128;
var SCOPE_CLASS_STATIC_BLOCK = 256;
var SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
function functionFlags(async2, generator) {
  return SCOPE_FUNCTION | (async2 ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
}
var BIND_NONE = 0;
var BIND_VAR = 1;
var BIND_LEXICAL = 2;
var BIND_FUNCTION = 3;
var BIND_SIMPLE_CATCH = 4;
var BIND_OUTSIDE = 5;
var Parser$1 = function Parser(options3, input, startPos) {
  this.options = options3 = getOptions(options3);
  this.sourceFile = options3.sourceFile;
  this.keywords = wordsRegexp(keywords$1[options3.ecmaVersion >= 6 ? 6 : options3.sourceType === "module" ? "5module" : 5]);
  var reserved = "";
  if (options3.allowReserved !== true) {
    reserved = reservedWords[options3.ecmaVersion >= 6 ? 6 : options3.ecmaVersion === 5 ? 5 : 3];
    if (options3.sourceType === "module") {
      reserved += " await";
    }
  }
  this.reservedWords = wordsRegexp(reserved);
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);
  this.containsEsc = false;
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }
  this.type = types$1.eof;
  this.value = null;
  this.start = this.end = this.pos;
  this.startLoc = this.endLoc = this.curPosition();
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;
  this.context = this.initialContext();
  this.exprAllowed = true;
  this.inModule = options3.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);
  this.potentialArrowAt = -1;
  this.potentialArrowInForAwait = false;
  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
  this.labels = [];
  this.undefinedExports = /* @__PURE__ */ Object.create(null);
  if (this.pos === 0 && options3.allowHashBang && this.input.slice(0, 2) === "#!") {
    this.skipLineComment(2);
  }
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);
  this.regexpState = null;
  this.privateNameStack = [];
};
var prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
Parser$1.prototype.parse = function parse3() {
  var node3 = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node3);
};
prototypeAccessors.inFunction.get = function() {
  return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
};
prototypeAccessors.inGenerator.get = function() {
  return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;
};
prototypeAccessors.inAsync.get = function() {
  return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;
};
prototypeAccessors.canAwait.get = function() {
  for (var i2 = this.scopeStack.length - 1; i2 >= 0; i2--) {
    var scope = this.scopeStack[i2];
    if (scope.inClassFieldInit || scope.flags & SCOPE_CLASS_STATIC_BLOCK) {
      return false;
    }
    if (scope.flags & SCOPE_FUNCTION) {
      return (scope.flags & SCOPE_ASYNC) > 0;
    }
  }
  return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
};
prototypeAccessors.allowSuper.get = function() {
  var ref2 = this.currentThisScope();
  var flags = ref2.flags;
  var inClassFieldInit = ref2.inClassFieldInit;
  return (flags & SCOPE_SUPER) > 0 || inClassFieldInit || this.options.allowSuperOutsideMethod;
};
prototypeAccessors.allowDirectSuper.get = function() {
  return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
};
prototypeAccessors.treatFunctionsAsVar.get = function() {
  return this.treatFunctionsAsVarInScope(this.currentScope());
};
prototypeAccessors.allowNewDotTarget.get = function() {
  var ref2 = this.currentThisScope();
  var flags = ref2.flags;
  var inClassFieldInit = ref2.inClassFieldInit;
  return (flags & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || inClassFieldInit;
};
prototypeAccessors.inClassStaticBlock.get = function() {
  return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
};
Parser$1.extend = function extend() {
  var plugins2 = [], len = arguments.length;
  while (len--)
    plugins2[len] = arguments[len];
  var cls = this;
  for (var i2 = 0; i2 < plugins2.length; i2++) {
    cls = plugins2[i2](cls);
  }
  return cls;
};
Parser$1.parse = function parse4(input, options3) {
  return new this(options3, input).parse();
};
Parser$1.parseExpressionAt = function parseExpressionAt(input, pos, options3) {
  var parser2 = new this(options3, input, pos);
  parser2.nextToken();
  return parser2.parseExpression();
};
Parser$1.tokenizer = function tokenizer(input, options3) {
  return new this(options3, input);
};
Object.defineProperties(Parser$1.prototype, prototypeAccessors);
var pp$9 = Parser$1.prototype;
var literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
pp$9.strictDirective = function(start) {
  if (this.options.ecmaVersion < 5) {
    return false;
  }
  for (; ; ) {
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    var match = literal.exec(this.input.slice(start));
    if (!match) {
      return false;
    }
    if ((match[1] || match[2]) === "use strict") {
      skipWhiteSpace.lastIndex = start + match[0].length;
      var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
      var next = this.input.charAt(end);
      return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
    }
    start += match[0].length;
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    if (this.input[start] === ";") {
      start++;
    }
  }
};
pp$9.eat = function(type) {
  if (this.type === type) {
    this.next();
    return true;
  } else {
    return false;
  }
};
pp$9.isContextual = function(name2) {
  return this.type === types$1.name && this.value === name2 && !this.containsEsc;
};
pp$9.eatContextual = function(name2) {
  if (!this.isContextual(name2)) {
    return false;
  }
  this.next();
  return true;
};
pp$9.expectContextual = function(name2) {
  if (!this.eatContextual(name2)) {
    this.unexpected();
  }
};
pp$9.canInsertSemicolon = function() {
  return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$9.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon) {
      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
    }
    return true;
  }
};
pp$9.semicolon = function() {
  if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
    this.unexpected();
  }
};
pp$9.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma) {
      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
    }
    if (!notNext) {
      this.next();
    }
    return true;
  }
};
pp$9.expect = function(type) {
  this.eat(type) || this.unexpected();
};
pp$9.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};
var DestructuringErrors = function DestructuringErrors2() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
};
pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) {
    return;
  }
  if (refDestructuringErrors.trailingComma > -1) {
    this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
  }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) {
    this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
  }
};
pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) {
    return false;
  }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) {
    return shorthandAssign >= 0 || doubleProto >= 0;
  }
  if (shorthandAssign >= 0) {
    this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
  }
  if (doubleProto >= 0) {
    this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
  }
};
pp$9.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
    this.raise(this.yieldPos, "Yield expression cannot be a default value");
  }
  if (this.awaitPos) {
    this.raise(this.awaitPos, "Await expression cannot be a default value");
  }
};
pp$9.isSimpleAssignTarget = function(expr) {
  if (expr.type === "ParenthesizedExpression") {
    return this.isSimpleAssignTarget(expr.expression);
  }
  return expr.type === "Identifier" || expr.type === "MemberExpression";
};
var pp$8 = Parser$1.prototype;
pp$8.parseTopLevel = function(node3) {
  var exports3 = /* @__PURE__ */ Object.create(null);
  if (!node3.body) {
    node3.body = [];
  }
  while (this.type !== types$1.eof) {
    var stmt = this.parseStatement(null, true, exports3);
    node3.body.push(stmt);
  }
  if (this.inModule) {
    for (var i2 = 0, list = Object.keys(this.undefinedExports); i2 < list.length; i2 += 1) {
      var name2 = list[i2];
      this.raiseRecoverable(this.undefinedExports[name2].start, "Export '" + name2 + "' is not defined");
    }
  }
  this.adaptDirectivePrologue(node3.body);
  this.next();
  node3.sourceType = this.options.sourceType;
  return this.finishNode(node3, "Program");
};
var loopLabel = { kind: "loop" };
var switchLabel = { kind: "switch" };
pp$8.isLet = function(context) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
  if (nextCh === 91 || nextCh === 92) {
    return true;
  }
  if (context) {
    return false;
  }
  if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
    return true;
  }
  if (isIdentifierStart(nextCh, true)) {
    var pos = next + 1;
    while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) {
      ++pos;
    }
    if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
      return true;
    }
    var ident = this.input.slice(next, pos);
    if (!keywordRelationalOperator.test(ident)) {
      return true;
    }
  }
  return false;
};
pp$8.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, after;
  return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
};
pp$8.parseStatement = function(context, topLevel, exports3) {
  var starttype = this.type, node3 = this.startNode(), kind;
  if (this.isLet(context)) {
    starttype = types$1._var;
    kind = "let";
  }
  switch (starttype) {
    case types$1._break:
    case types$1._continue:
      return this.parseBreakContinueStatement(node3, starttype.keyword);
    case types$1._debugger:
      return this.parseDebuggerStatement(node3);
    case types$1._do:
      return this.parseDoStatement(node3);
    case types$1._for:
      return this.parseForStatement(node3);
    case types$1._function:
      if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
        this.unexpected();
      }
      return this.parseFunctionStatement(node3, false, !context);
    case types$1._class:
      if (context) {
        this.unexpected();
      }
      return this.parseClass(node3, true);
    case types$1._if:
      return this.parseIfStatement(node3);
    case types$1._return:
      return this.parseReturnStatement(node3);
    case types$1._switch:
      return this.parseSwitchStatement(node3);
    case types$1._throw:
      return this.parseThrowStatement(node3);
    case types$1._try:
      return this.parseTryStatement(node3);
    case types$1._const:
    case types$1._var:
      kind = kind || this.value;
      if (context && kind !== "var") {
        this.unexpected();
      }
      return this.parseVarStatement(node3, kind);
    case types$1._while:
      return this.parseWhileStatement(node3);
    case types$1._with:
      return this.parseWithStatement(node3);
    case types$1.braceL:
      return this.parseBlock(true, node3);
    case types$1.semi:
      return this.parseEmptyStatement(node3);
    case types$1._export:
    case types$1._import:
      if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 40 || nextCh === 46) {
          return this.parseExpressionStatement(node3, this.parseExpression());
        }
      }
      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel) {
          this.raise(this.start, "'import' and 'export' may only appear at the top level");
        }
        if (!this.inModule) {
          this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
        }
      }
      return starttype === types$1._import ? this.parseImport(node3) : this.parseExport(node3, exports3);
    default:
      if (this.isAsyncFunction()) {
        if (context) {
          this.unexpected();
        }
        this.next();
        return this.parseFunctionStatement(node3, true, !context);
      }
      var maybeName = this.value, expr = this.parseExpression();
      if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
        return this.parseLabeledStatement(node3, maybeName, expr, context);
      } else {
        return this.parseExpressionStatement(node3, expr);
      }
  }
};
pp$8.parseBreakContinueStatement = function(node3, keyword) {
  var isBreak = keyword === "break";
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node3.label = null;
  } else if (this.type !== types$1.name) {
    this.unexpected();
  } else {
    node3.label = this.parseIdent();
    this.semicolon();
  }
  var i2 = 0;
  for (; i2 < this.labels.length; ++i2) {
    var lab = this.labels[i2];
    if (node3.label == null || lab.name === node3.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) {
        break;
      }
      if (node3.label && isBreak) {
        break;
      }
    }
  }
  if (i2 === this.labels.length) {
    this.raise(node3.start, "Unsyntactic " + keyword);
  }
  return this.finishNode(node3, isBreak ? "BreakStatement" : "ContinueStatement");
};
pp$8.parseDebuggerStatement = function(node3) {
  this.next();
  this.semicolon();
  return this.finishNode(node3, "DebuggerStatement");
};
pp$8.parseDoStatement = function(node3) {
  this.next();
  this.labels.push(loopLabel);
  node3.body = this.parseStatement("do");
  this.labels.pop();
  this.expect(types$1._while);
  node3.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6) {
    this.eat(types$1.semi);
  } else {
    this.semicolon();
  }
  return this.finishNode(node3, "DoWhileStatement");
};
pp$8.parseForStatement = function(node3) {
  this.next();
  var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterScope(0);
  this.expect(types$1.parenL);
  if (this.type === types$1.semi) {
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node3, null);
  }
  var isLet = this.isLet();
  if (this.type === types$1._var || this.type === types$1._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");
    if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init$1.declarations.length === 1) {
      if (this.options.ecmaVersion >= 9) {
        if (this.type === types$1._in) {
          if (awaitAt > -1) {
            this.unexpected(awaitAt);
          }
        } else {
          node3.await = awaitAt > -1;
        }
      }
      return this.parseForIn(node3, init$1);
    }
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node3, init$1);
  }
  var startsWithLet = this.isContextual("let"), isForOf = false;
  var refDestructuringErrors = new DestructuringErrors();
  var init2 = this.parseExpression(awaitAt > -1 ? "await" : true, refDestructuringErrors);
  if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
    if (this.options.ecmaVersion >= 9) {
      if (this.type === types$1._in) {
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
      } else {
        node3.await = awaitAt > -1;
      }
    }
    if (startsWithLet && isForOf) {
      this.raise(init2.start, "The left-hand side of a for-of loop may not start with 'let'.");
    }
    this.toAssignable(init2, false, refDestructuringErrors);
    this.checkLValPattern(init2);
    return this.parseForIn(node3, init2);
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt > -1) {
    this.unexpected(awaitAt);
  }
  return this.parseFor(node3, init2);
};
pp$8.parseFunctionStatement = function(node3, isAsync, declarationPosition) {
  this.next();
  return this.parseFunction(node3, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
};
pp$8.parseIfStatement = function(node3) {
  this.next();
  node3.test = this.parseParenExpression();
  node3.consequent = this.parseStatement("if");
  node3.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
  return this.finishNode(node3, "IfStatement");
};
pp$8.parseReturnStatement = function(node3) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
    this.raise(this.start, "'return' outside of function");
  }
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node3.argument = null;
  } else {
    node3.argument = this.parseExpression();
    this.semicolon();
  }
  return this.finishNode(node3, "ReturnStatement");
};
pp$8.parseSwitchStatement = function(node3) {
  this.next();
  node3.discriminant = this.parseParenExpression();
  node3.cases = [];
  this.expect(types$1.braceL);
  this.labels.push(switchLabel);
  this.enterScope(0);
  var cur;
  for (var sawDefault = false; this.type !== types$1.braceR; ) {
    if (this.type === types$1._case || this.type === types$1._default) {
      var isCase = this.type === types$1._case;
      if (cur) {
        this.finishNode(cur, "SwitchCase");
      }
      node3.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) {
          this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
        }
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types$1.colon);
    } else {
      if (!cur) {
        this.unexpected();
      }
      cur.consequent.push(this.parseStatement(null));
    }
  }
  this.exitScope();
  if (cur) {
    this.finishNode(cur, "SwitchCase");
  }
  this.next();
  this.labels.pop();
  return this.finishNode(node3, "SwitchStatement");
};
pp$8.parseThrowStatement = function(node3) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
    this.raise(this.lastTokEnd, "Illegal newline after throw");
  }
  node3.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node3, "ThrowStatement");
};
var empty$1 = [];
pp$8.parseTryStatement = function(node3) {
  this.next();
  node3.block = this.parseBlock();
  node3.handler = null;
  if (this.type === types$1._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types$1.parenL)) {
      clause.param = this.parseBindingAtom();
      var simple = clause.param.type === "Identifier";
      this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
      this.checkLValPattern(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
      this.expect(types$1.parenR);
    } else {
      if (this.options.ecmaVersion < 10) {
        this.unexpected();
      }
      clause.param = null;
      this.enterScope(0);
    }
    clause.body = this.parseBlock(false);
    this.exitScope();
    node3.handler = this.finishNode(clause, "CatchClause");
  }
  node3.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
  if (!node3.handler && !node3.finalizer) {
    this.raise(node3.start, "Missing catch or finally clause");
  }
  return this.finishNode(node3, "TryStatement");
};
pp$8.parseVarStatement = function(node3, kind) {
  this.next();
  this.parseVar(node3, false, kind);
  this.semicolon();
  return this.finishNode(node3, "VariableDeclaration");
};
pp$8.parseWhileStatement = function(node3) {
  this.next();
  node3.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node3.body = this.parseStatement("while");
  this.labels.pop();
  return this.finishNode(node3, "WhileStatement");
};
pp$8.parseWithStatement = function(node3) {
  if (this.strict) {
    this.raise(this.start, "'with' in strict mode");
  }
  this.next();
  node3.object = this.parseParenExpression();
  node3.body = this.parseStatement("with");
  return this.finishNode(node3, "WithStatement");
};
pp$8.parseEmptyStatement = function(node3) {
  this.next();
  return this.finishNode(node3, "EmptyStatement");
};
pp$8.parseLabeledStatement = function(node3, maybeName, expr, context) {
  for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1) {
    var label = list[i$1];
    if (label.name === maybeName) {
      this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    }
  }
  var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
  for (var i2 = this.labels.length - 1; i2 >= 0; i2--) {
    var label$1 = this.labels[i2];
    if (label$1.statementStart === node3.start) {
      label$1.statementStart = this.start;
      label$1.kind = kind;
    } else {
      break;
    }
  }
  this.labels.push({ name: maybeName, kind, statementStart: this.start });
  node3.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
  this.labels.pop();
  node3.label = expr;
  return this.finishNode(node3, "LabeledStatement");
};
pp$8.parseExpressionStatement = function(node3, expr) {
  node3.expression = expr;
  this.semicolon();
  return this.finishNode(node3, "ExpressionStatement");
};
pp$8.parseBlock = function(createNewLexicalScope, node3, exitStrict) {
  if (createNewLexicalScope === void 0)
    createNewLexicalScope = true;
  if (node3 === void 0)
    node3 = this.startNode();
  node3.body = [];
  this.expect(types$1.braceL);
  if (createNewLexicalScope) {
    this.enterScope(0);
  }
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node3.body.push(stmt);
  }
  if (exitStrict) {
    this.strict = false;
  }
  this.next();
  if (createNewLexicalScope) {
    this.exitScope();
  }
  return this.finishNode(node3, "BlockStatement");
};
pp$8.parseFor = function(node3, init2) {
  node3.init = init2;
  this.expect(types$1.semi);
  node3.test = this.type === types$1.semi ? null : this.parseExpression();
  this.expect(types$1.semi);
  node3.update = this.type === types$1.parenR ? null : this.parseExpression();
  this.expect(types$1.parenR);
  node3.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node3, "ForStatement");
};
pp$8.parseForIn = function(node3, init2) {
  var isForIn = this.type === types$1._in;
  this.next();
  if (init2.type === "VariableDeclaration" && init2.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init2.kind !== "var" || init2.declarations[0].id.type !== "Identifier")) {
    this.raise(
      init2.start,
      (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
    );
  }
  node3.left = init2;
  node3.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types$1.parenR);
  node3.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node3, isForIn ? "ForInStatement" : "ForOfStatement");
};
pp$8.parseVar = function(node3, isFor, kind) {
  node3.declarations = [];
  node3.kind = kind;
  for (; ; ) {
    var decl = this.startNode();
    this.parseVarId(decl, kind);
    if (this.eat(types$1.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      this.unexpected();
    } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node3.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(types$1.comma)) {
      break;
    }
  }
  return node3;
};
pp$8.parseVarId = function(decl, kind) {
  decl.id = this.parseBindingAtom();
  this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};
var FUNC_STATEMENT = 1;
var FUNC_HANGING_STATEMENT = 2;
var FUNC_NULLABLE_ID = 4;
pp$8.parseFunction = function(node3, statement, allowExpressionBody, isAsync, forInit) {
  this.initFunction(node3);
  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
    if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
      this.unexpected();
    }
    node3.generator = this.eat(types$1.star);
  }
  if (this.options.ecmaVersion >= 8) {
    node3.async = !!isAsync;
  }
  if (statement & FUNC_STATEMENT) {
    node3.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
    if (node3.id && !(statement & FUNC_HANGING_STATEMENT)) {
      this.checkLValSimple(node3.id, this.strict || node3.generator || node3.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
    }
  }
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node3.async, node3.generator));
  if (!(statement & FUNC_STATEMENT)) {
    node3.id = this.type === types$1.name ? this.parseIdent() : null;
  }
  this.parseFunctionParams(node3);
  this.parseFunctionBody(node3, allowExpressionBody, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node3, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
};
pp$8.parseFunctionParams = function(node3) {
  this.expect(types$1.parenL);
  node3.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};
pp$8.parseClass = function(node3, isStatement) {
  this.next();
  var oldStrict = this.strict;
  this.strict = true;
  this.parseClassId(node3, isStatement);
  this.parseClassSuper(node3);
  var privateNameMap = this.enterClassBody();
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types$1.braceL);
  while (this.type !== types$1.braceR) {
    var element = this.parseClassElement(node3.superClass !== null);
    if (element) {
      classBody.body.push(element);
      if (element.type === "MethodDefinition" && element.kind === "constructor") {
        if (hadConstructor) {
          this.raise(element.start, "Duplicate constructor in the same class");
        }
        hadConstructor = true;
      } else if (element.key && element.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element)) {
        this.raiseRecoverable(element.key.start, "Identifier '#" + element.key.name + "' has already been declared");
      }
    }
  }
  this.strict = oldStrict;
  this.next();
  node3.body = this.finishNode(classBody, "ClassBody");
  this.exitClassBody();
  return this.finishNode(node3, isStatement ? "ClassDeclaration" : "ClassExpression");
};
pp$8.parseClassElement = function(constructorAllowsSuper) {
  if (this.eat(types$1.semi)) {
    return null;
  }
  var ecmaVersion = this.options.ecmaVersion;
  var node3 = this.startNode();
  var keyName = "";
  var isGenerator = false;
  var isAsync = false;
  var kind = "method";
  var isStatic = false;
  if (this.eatContextual("static")) {
    if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
      this.parseClassStaticBlock(node3);
      return node3;
    }
    if (this.isClassElementNameStart() || this.type === types$1.star) {
      isStatic = true;
    } else {
      keyName = "static";
    }
  }
  node3.static = isStatic;
  if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
    if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
      isAsync = true;
    } else {
      keyName = "async";
    }
  }
  if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
    isGenerator = true;
  }
  if (!keyName && !isAsync && !isGenerator) {
    var lastValue = this.value;
    if (this.eatContextual("get") || this.eatContextual("set")) {
      if (this.isClassElementNameStart()) {
        kind = lastValue;
      } else {
        keyName = lastValue;
      }
    }
  }
  if (keyName) {
    node3.computed = false;
    node3.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
    node3.key.name = keyName;
    this.finishNode(node3.key, "Identifier");
  } else {
    this.parseClassElementName(node3);
  }
  if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
    var isConstructor = !node3.static && checkKeyName(node3, "constructor");
    var allowsDirectSuper = isConstructor && constructorAllowsSuper;
    if (isConstructor && kind !== "method") {
      this.raise(node3.key.start, "Constructor can't have get/set modifier");
    }
    node3.kind = isConstructor ? "constructor" : kind;
    this.parseClassMethod(node3, isGenerator, isAsync, allowsDirectSuper);
  } else {
    this.parseClassField(node3);
  }
  return node3;
};
pp$8.isClassElementNameStart = function() {
  return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
};
pp$8.parseClassElementName = function(element) {
  if (this.type === types$1.privateId) {
    if (this.value === "constructor") {
      this.raise(this.start, "Classes can't have an element named '#constructor'");
    }
    element.computed = false;
    element.key = this.parsePrivateIdent();
  } else {
    this.parsePropertyName(element);
  }
};
pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
  var key = method.key;
  if (method.kind === "constructor") {
    if (isGenerator) {
      this.raise(key.start, "Constructor can't be a generator");
    }
    if (isAsync) {
      this.raise(key.start, "Constructor can't be an async method");
    }
  } else if (method.static && checkKeyName(method, "prototype")) {
    this.raise(key.start, "Classes may not have a static property named prototype");
  }
  var value2 = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
  if (method.kind === "get" && value2.params.length !== 0) {
    this.raiseRecoverable(value2.start, "getter should have no params");
  }
  if (method.kind === "set" && value2.params.length !== 1) {
    this.raiseRecoverable(value2.start, "setter should have exactly one param");
  }
  if (method.kind === "set" && value2.params[0].type === "RestElement") {
    this.raiseRecoverable(value2.params[0].start, "Setter cannot use rest params");
  }
  return this.finishNode(method, "MethodDefinition");
};
pp$8.parseClassField = function(field) {
  if (checkKeyName(field, "constructor")) {
    this.raise(field.key.start, "Classes can't have a field named 'constructor'");
  } else if (field.static && checkKeyName(field, "prototype")) {
    this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
  }
  if (this.eat(types$1.eq)) {
    var scope = this.currentThisScope();
    var inClassFieldInit = scope.inClassFieldInit;
    scope.inClassFieldInit = true;
    field.value = this.parseMaybeAssign();
    scope.inClassFieldInit = inClassFieldInit;
  } else {
    field.value = null;
  }
  this.semicolon();
  return this.finishNode(field, "PropertyDefinition");
};
pp$8.parseClassStaticBlock = function(node3) {
  node3.body = [];
  var oldLabels = this.labels;
  this.labels = [];
  this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node3.body.push(stmt);
  }
  this.next();
  this.exitScope();
  this.labels = oldLabels;
  return this.finishNode(node3, "StaticBlock");
};
pp$8.parseClassId = function(node3, isStatement) {
  if (this.type === types$1.name) {
    node3.id = this.parseIdent();
    if (isStatement) {
      this.checkLValSimple(node3.id, BIND_LEXICAL, false);
    }
  } else {
    if (isStatement === true) {
      this.unexpected();
    }
    node3.id = null;
  }
};
pp$8.parseClassSuper = function(node3) {
  node3.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
};
pp$8.enterClassBody = function() {
  var element = { declared: /* @__PURE__ */ Object.create(null), used: [] };
  this.privateNameStack.push(element);
  return element.declared;
};
pp$8.exitClassBody = function() {
  var ref2 = this.privateNameStack.pop();
  var declared = ref2.declared;
  var used = ref2.used;
  var len = this.privateNameStack.length;
  var parent = len === 0 ? null : this.privateNameStack[len - 1];
  for (var i2 = 0; i2 < used.length; ++i2) {
    var id = used[i2];
    if (!hasOwn(declared, id.name)) {
      if (parent) {
        parent.used.push(id);
      } else {
        this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
      }
    }
  }
};
function isPrivateNameConflicted(privateNameMap, element) {
  var name2 = element.key.name;
  var curr = privateNameMap[name2];
  var next = "true";
  if (element.type === "MethodDefinition" && (element.kind === "get" || element.kind === "set")) {
    next = (element.static ? "s" : "i") + element.kind;
  }
  if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
    privateNameMap[name2] = "true";
    return false;
  } else if (!curr) {
    privateNameMap[name2] = next;
    return false;
  } else {
    return true;
  }
}
function checkKeyName(node3, name2) {
  var computed = node3.computed;
  var key = node3.key;
  return !computed && (key.type === "Identifier" && key.name === name2 || key.type === "Literal" && key.value === name2);
}
pp$8.parseExport = function(node3, exports3) {
  this.next();
  if (this.eat(types$1.star)) {
    if (this.options.ecmaVersion >= 11) {
      if (this.eatContextual("as")) {
        node3.exported = this.parseModuleExportName();
        this.checkExport(exports3, node3.exported, this.lastTokStart);
      } else {
        node3.exported = null;
      }
    }
    this.expectContextual("from");
    if (this.type !== types$1.string) {
      this.unexpected();
    }
    node3.source = this.parseExprAtom();
    this.semicolon();
    return this.finishNode(node3, "ExportAllDeclaration");
  }
  if (this.eat(types$1._default)) {
    this.checkExport(exports3, "default", this.lastTokStart);
    var isAsync;
    if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
      var fNode = this.startNode();
      this.next();
      if (isAsync) {
        this.next();
      }
      node3.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
    } else if (this.type === types$1._class) {
      var cNode = this.startNode();
      node3.declaration = this.parseClass(cNode, "nullableID");
    } else {
      node3.declaration = this.parseMaybeAssign();
      this.semicolon();
    }
    return this.finishNode(node3, "ExportDefaultDeclaration");
  }
  if (this.shouldParseExportStatement()) {
    node3.declaration = this.parseStatement(null);
    if (node3.declaration.type === "VariableDeclaration") {
      this.checkVariableExport(exports3, node3.declaration.declarations);
    } else {
      this.checkExport(exports3, node3.declaration.id, node3.declaration.id.start);
    }
    node3.specifiers = [];
    node3.source = null;
  } else {
    node3.declaration = null;
    node3.specifiers = this.parseExportSpecifiers(exports3);
    if (this.eatContextual("from")) {
      if (this.type !== types$1.string) {
        this.unexpected();
      }
      node3.source = this.parseExprAtom();
    } else {
      for (var i2 = 0, list = node3.specifiers; i2 < list.length; i2 += 1) {
        var spec = list[i2];
        this.checkUnreserved(spec.local);
        this.checkLocalExport(spec.local);
        if (spec.local.type === "Literal") {
          this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
        }
      }
      node3.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(node3, "ExportNamedDeclaration");
};
pp$8.checkExport = function(exports3, name2, pos) {
  if (!exports3) {
    return;
  }
  if (typeof name2 !== "string") {
    name2 = name2.type === "Identifier" ? name2.name : name2.value;
  }
  if (hasOwn(exports3, name2)) {
    this.raiseRecoverable(pos, "Duplicate export '" + name2 + "'");
  }
  exports3[name2] = true;
};
pp$8.checkPatternExport = function(exports3, pat) {
  var type = pat.type;
  if (type === "Identifier") {
    this.checkExport(exports3, pat, pat.start);
  } else if (type === "ObjectPattern") {
    for (var i2 = 0, list = pat.properties; i2 < list.length; i2 += 1) {
      var prop = list[i2];
      this.checkPatternExport(exports3, prop);
    }
  } else if (type === "ArrayPattern") {
    for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
      var elt = list$1[i$1];
      if (elt) {
        this.checkPatternExport(exports3, elt);
      }
    }
  } else if (type === "Property") {
    this.checkPatternExport(exports3, pat.value);
  } else if (type === "AssignmentPattern") {
    this.checkPatternExport(exports3, pat.left);
  } else if (type === "RestElement") {
    this.checkPatternExport(exports3, pat.argument);
  } else if (type === "ParenthesizedExpression") {
    this.checkPatternExport(exports3, pat.expression);
  }
};
pp$8.checkVariableExport = function(exports3, decls) {
  if (!exports3) {
    return;
  }
  for (var i2 = 0, list = decls; i2 < list.length; i2 += 1) {
    var decl = list[i2];
    this.checkPatternExport(exports3, decl.id);
  }
};
pp$8.shouldParseExportStatement = function() {
  return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
pp$8.parseExportSpecifiers = function(exports3) {
  var nodes = [], first2 = true;
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first2) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first2 = false;
    }
    var node3 = this.startNode();
    node3.local = this.parseModuleExportName();
    node3.exported = this.eatContextual("as") ? this.parseModuleExportName() : node3.local;
    this.checkExport(
      exports3,
      node3.exported,
      node3.exported.start
    );
    nodes.push(this.finishNode(node3, "ExportSpecifier"));
  }
  return nodes;
};
pp$8.parseImport = function(node3) {
  this.next();
  if (this.type === types$1.string) {
    node3.specifiers = empty$1;
    node3.source = this.parseExprAtom();
  } else {
    node3.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node3.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node3, "ImportDeclaration");
};
pp$8.parseImportSpecifiers = function() {
  var nodes = [], first2 = true;
  if (this.type === types$1.name) {
    var node3 = this.startNode();
    node3.local = this.parseIdent();
    this.checkLValSimple(node3.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node3, "ImportDefaultSpecifier"));
    if (!this.eat(types$1.comma)) {
      return nodes;
    }
  }
  if (this.type === types$1.star) {
    var node$12 = this.startNode();
    this.next();
    this.expectContextual("as");
    node$12.local = this.parseIdent();
    this.checkLValSimple(node$12.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node$12, "ImportNamespaceSpecifier"));
    return nodes;
  }
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first2) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first2 = false;
    }
    var node$2 = this.startNode();
    node$2.imported = this.parseModuleExportName();
    if (this.eatContextual("as")) {
      node$2.local = this.parseIdent();
    } else {
      this.checkUnreserved(node$2.imported);
      node$2.local = node$2.imported;
    }
    this.checkLValSimple(node$2.local, BIND_LEXICAL);
    nodes.push(this.finishNode(node$2, "ImportSpecifier"));
  }
  return nodes;
};
pp$8.parseModuleExportName = function() {
  if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
    var stringLiteral = this.parseLiteral(this.value);
    if (loneSurrogate.test(stringLiteral.value)) {
      this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
    }
    return stringLiteral;
  }
  return this.parseIdent(true);
};
pp$8.adaptDirectivePrologue = function(statements) {
  for (var i2 = 0; i2 < statements.length && this.isDirectiveCandidate(statements[i2]); ++i2) {
    statements[i2].directive = statements[i2].expression.raw.slice(1, -1);
  }
};
pp$8.isDirectiveCandidate = function(statement) {
  return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && // Reject parenthesized strings.
  (this.input[statement.start] === '"' || this.input[statement.start] === "'");
};
var pp$7 = Parser$1.prototype;
pp$7.toAssignable = function(node3, isBinding, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 6 && node3) {
    switch (node3.type) {
      case "Identifier":
        if (this.inAsync && node3.name === "await") {
          this.raise(node3.start, "Cannot use 'await' as identifier inside an async function");
        }
        break;
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        node3.type = "ObjectPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        for (var i2 = 0, list = node3.properties; i2 < list.length; i2 += 1) {
          var prop = list[i2];
          this.toAssignable(prop, isBinding);
          if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
            this.raise(prop.argument.start, "Unexpected token");
          }
        }
        break;
      case "Property":
        if (node3.kind !== "init") {
          this.raise(node3.key.start, "Object pattern can't contain getter or setter");
        }
        this.toAssignable(node3.value, isBinding);
        break;
      case "ArrayExpression":
        node3.type = "ArrayPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        this.toAssignableList(node3.elements, isBinding);
        break;
      case "SpreadElement":
        node3.type = "RestElement";
        this.toAssignable(node3.argument, isBinding);
        if (node3.argument.type === "AssignmentPattern") {
          this.raise(node3.argument.start, "Rest elements cannot have a default value");
        }
        break;
      case "AssignmentExpression":
        if (node3.operator !== "=") {
          this.raise(node3.left.end, "Only '=' operator can be used for specifying default value.");
        }
        node3.type = "AssignmentPattern";
        delete node3.operator;
        this.toAssignable(node3.left, isBinding);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(node3.expression, isBinding, refDestructuringErrors);
        break;
      case "ChainExpression":
        this.raiseRecoverable(node3.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        if (!isBinding) {
          break;
        }
      default:
        this.raise(node3.start, "Assigning to rvalue");
    }
  } else if (refDestructuringErrors) {
    this.checkPatternErrors(refDestructuringErrors, true);
  }
  return node3;
};
pp$7.toAssignableList = function(exprList, isBinding) {
  var end = exprList.length;
  for (var i2 = 0; i2 < end; i2++) {
    var elt = exprList[i2];
    if (elt) {
      this.toAssignable(elt, isBinding);
    }
  }
  if (end) {
    var last = exprList[end - 1];
    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier") {
      this.unexpected(last.argument.start);
    }
  }
  return exprList;
};
pp$7.parseSpread = function(refDestructuringErrors) {
  var node3 = this.startNode();
  this.next();
  node3.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node3, "SpreadElement");
};
pp$7.parseRestBinding = function() {
  var node3 = this.startNode();
  this.next();
  if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
    this.unexpected();
  }
  node3.argument = this.parseBindingAtom();
  return this.finishNode(node3, "RestElement");
};
pp$7.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6) {
    switch (this.type) {
      case types$1.bracketL:
        var node3 = this.startNode();
        this.next();
        node3.elements = this.parseBindingList(types$1.bracketR, true, true);
        return this.finishNode(node3, "ArrayPattern");
      case types$1.braceL:
        return this.parseObj(true);
    }
  }
  return this.parseIdent();
};
pp$7.parseBindingList = function(close2, allowEmpty, allowTrailingComma) {
  var elts = [], first2 = true;
  while (!this.eat(close2)) {
    if (first2) {
      first2 = false;
    } else {
      this.expect(types$1.comma);
    }
    if (allowEmpty && this.type === types$1.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close2)) {
      break;
    } else if (this.type === types$1.ellipsis) {
      var rest = this.parseRestBinding();
      this.parseBindingListItem(rest);
      elts.push(rest);
      if (this.type === types$1.comma) {
        this.raise(this.start, "Comma is not permitted after the rest element");
      }
      this.expect(close2);
      break;
    } else {
      var elem = this.parseMaybeDefault(this.start, this.startLoc);
      this.parseBindingListItem(elem);
      elts.push(elem);
    }
  }
  return elts;
};
pp$7.parseBindingListItem = function(param) {
  return param;
};
pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
    return left;
  }
  var node3 = this.startNodeAt(startPos, startLoc);
  node3.left = left;
  node3.right = this.parseMaybeAssign();
  return this.finishNode(node3, "AssignmentPattern");
};
pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0)
    bindingType = BIND_NONE;
  var isBind = bindingType !== BIND_NONE;
  switch (expr.type) {
    case "Identifier":
      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
        this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
      }
      if (isBind) {
        if (bindingType === BIND_LEXICAL && expr.name === "let") {
          this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
        }
        if (checkClashes) {
          if (hasOwn(checkClashes, expr.name)) {
            this.raiseRecoverable(expr.start, "Argument name clash");
          }
          checkClashes[expr.name] = true;
        }
        if (bindingType !== BIND_OUTSIDE) {
          this.declareName(expr.name, bindingType, expr.start);
        }
      }
      break;
    case "ChainExpression":
      this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
      break;
    case "MemberExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding member expression");
      }
      break;
    case "ParenthesizedExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding parenthesized expression");
      }
      return this.checkLValSimple(expr.expression, bindingType, checkClashes);
    default:
      this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
  }
};
pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0)
    bindingType = BIND_NONE;
  switch (expr.type) {
    case "ObjectPattern":
      for (var i2 = 0, list = expr.properties; i2 < list.length; i2 += 1) {
        var prop = list[i2];
        this.checkLValInnerPattern(prop, bindingType, checkClashes);
      }
      break;
    case "ArrayPattern":
      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
        var elem = list$1[i$1];
        if (elem) {
          this.checkLValInnerPattern(elem, bindingType, checkClashes);
        }
      }
      break;
    default:
      this.checkLValSimple(expr, bindingType, checkClashes);
  }
};
pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0)
    bindingType = BIND_NONE;
  switch (expr.type) {
    case "Property":
      this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
      break;
    case "AssignmentPattern":
      this.checkLValPattern(expr.left, bindingType, checkClashes);
      break;
    case "RestElement":
      this.checkLValPattern(expr.argument, bindingType, checkClashes);
      break;
    default:
      this.checkLValPattern(expr, bindingType, checkClashes);
  }
};
var TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};
var types$2 = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function(p2) {
    return p2.tryReadTemplateToken();
  }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};
var pp$6 = Parser$1.prototype;
pp$6.initialContext = function() {
  return [types$2.b_stat];
};
pp$6.curContext = function() {
  return this.context[this.context.length - 1];
};
pp$6.braceIsBlock = function(prevType) {
  var parent = this.curContext();
  if (parent === types$2.f_expr || parent === types$2.f_stat) {
    return true;
  }
  if (prevType === types$1.colon && (parent === types$2.b_stat || parent === types$2.b_expr)) {
    return !parent.isExpr;
  }
  if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
    return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  }
  if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
    return true;
  }
  if (prevType === types$1.braceL) {
    return parent === types$2.b_stat;
  }
  if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
    return false;
  }
  return !this.exprAllowed;
};
pp$6.inGeneratorContext = function() {
  for (var i2 = this.context.length - 1; i2 >= 1; i2--) {
    var context = this.context[i2];
    if (context.token === "function") {
      return context.generator;
    }
  }
  return false;
};
pp$6.updateContext = function(prevType) {
  var update, type = this.type;
  if (type.keyword && prevType === types$1.dot) {
    this.exprAllowed = false;
  } else if (update = type.updateContext) {
    update.call(this, prevType);
  } else {
    this.exprAllowed = type.beforeExpr;
  }
};
pp$6.overrideContext = function(tokenCtx) {
  if (this.curContext() !== tokenCtx) {
    this.context[this.context.length - 1] = tokenCtx;
  }
};
types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return;
  }
  var out2 = this.context.pop();
  if (out2 === types$2.b_stat && this.curContext().token === "function") {
    out2 = this.context.pop();
  }
  this.exprAllowed = !out2.isExpr;
};
types$1.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types$2.b_stat : types$2.b_expr);
  this.exprAllowed = true;
};
types$1.dollarBraceL.updateContext = function() {
  this.context.push(types$2.b_tmpl);
  this.exprAllowed = true;
};
types$1.parenL.updateContext = function(prevType) {
  var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
  this.context.push(statementParens ? types$2.p_stat : types$2.p_expr);
  this.exprAllowed = true;
};
types$1.incDec.updateContext = function() {
};
types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
  if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types$2.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types$2.b_stat)) {
    this.context.push(types$2.f_expr);
  } else {
    this.context.push(types$2.f_stat);
  }
  this.exprAllowed = false;
};
types$1.backQuote.updateContext = function() {
  if (this.curContext() === types$2.q_tmpl) {
    this.context.pop();
  } else {
    this.context.push(types$2.q_tmpl);
  }
  this.exprAllowed = false;
};
types$1.star.updateContext = function(prevType) {
  if (prevType === types$1._function) {
    var index2 = this.context.length - 1;
    if (this.context[index2] === types$2.f_expr) {
      this.context[index2] = types$2.f_expr_gen;
    } else {
      this.context[index2] = types$2.f_gen;
    }
  }
  this.exprAllowed = true;
};
types$1.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
    if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
      allowed = true;
    }
  }
  this.exprAllowed = allowed;
};
var pp$5 = Parser$1.prototype;
pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
    return;
  }
  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
    return;
  }
  var key = prop.key;
  var name2;
  switch (key.type) {
    case "Identifier":
      name2 = key.name;
      break;
    case "Literal":
      name2 = String(key.value);
      break;
    default:
      return;
  }
  var kind = prop.kind;
  if (this.options.ecmaVersion >= 6) {
    if (name2 === "__proto__" && kind === "init") {
      if (propHash.proto) {
        if (refDestructuringErrors) {
          if (refDestructuringErrors.doubleProto < 0) {
            refDestructuringErrors.doubleProto = key.start;
          }
        } else {
          this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
        }
      }
      propHash.proto = true;
    }
    return;
  }
  name2 = "$" + name2;
  var other = propHash[name2];
  if (other) {
    var redefinition;
    if (kind === "init") {
      redefinition = this.strict && other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition) {
      this.raiseRecoverable(key.start, "Redefinition of property");
    }
  } else {
    other = propHash[name2] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};
pp$5.parseExpression = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
  if (this.type === types$1.comma) {
    var node3 = this.startNodeAt(startPos, startLoc);
    node3.expressions = [expr];
    while (this.eat(types$1.comma)) {
      node3.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
    }
    return this.finishNode(node3, "SequenceExpression");
  }
  return expr;
};
pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
  if (this.isContextual("yield")) {
    if (this.inGenerator) {
      return this.parseYield(forInit);
    } else {
      this.exprAllowed = false;
    }
  }
  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    oldDoubleProto = refDestructuringErrors.doubleProto;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors();
    ownDestructuringErrors = true;
  }
  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types$1.parenL || this.type === types$1.name) {
    this.potentialArrowAt = this.start;
    this.potentialArrowInForAwait = forInit === "await";
  }
  var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
  if (afterLeftParse) {
    left = afterLeftParse.call(this, left, startPos, startLoc);
  }
  if (this.type.isAssign) {
    var node3 = this.startNodeAt(startPos, startLoc);
    node3.operator = this.value;
    if (this.type === types$1.eq) {
      left = this.toAssignable(left, false, refDestructuringErrors);
    }
    if (!ownDestructuringErrors) {
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
    }
    if (refDestructuringErrors.shorthandAssign >= left.start) {
      refDestructuringErrors.shorthandAssign = -1;
    }
    if (this.type === types$1.eq) {
      this.checkLValPattern(left);
    } else {
      this.checkLValSimple(left);
    }
    node3.left = left;
    this.next();
    node3.right = this.parseMaybeAssign(forInit);
    if (oldDoubleProto > -1) {
      refDestructuringErrors.doubleProto = oldDoubleProto;
    }
    return this.finishNode(node3, "AssignmentExpression");
  } else {
    if (ownDestructuringErrors) {
      this.checkExpressionErrors(refDestructuringErrors, true);
    }
  }
  if (oldParenAssign > -1) {
    refDestructuringErrors.parenthesizedAssign = oldParenAssign;
  }
  if (oldTrailingComma > -1) {
    refDestructuringErrors.trailingComma = oldTrailingComma;
  }
  return left;
};
pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(forInit, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  if (this.eat(types$1.question)) {
    var node3 = this.startNodeAt(startPos, startLoc);
    node3.test = expr;
    node3.consequent = this.parseMaybeAssign();
    this.expect(types$1.colon);
    node3.alternate = this.parseMaybeAssign(forInit);
    return this.finishNode(node3, "ConditionalExpression");
  }
  return expr;
};
pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
};
pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
  var prec = this.type.binop;
  if (prec != null && (!forInit || this.type !== types$1._in)) {
    if (prec > minPrec) {
      var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
      var coalesce = this.type === types$1.coalesce;
      if (coalesce) {
        prec = types$1.logicalAND.binop;
      }
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
      var node3 = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
      if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
        this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
      }
      return this.parseExprOp(node3, leftStartPos, leftStartLoc, minPrec, forInit);
    }
  }
  return left;
};
pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
  if (right.type === "PrivateIdentifier") {
    this.raise(right.start, "Private identifier can only be left side of binary expression");
  }
  var node3 = this.startNodeAt(startPos, startLoc);
  node3.left = left;
  node3.operator = op;
  node3.right = right;
  return this.finishNode(node3, logical ? "LogicalExpression" : "BinaryExpression");
};
pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual("await") && this.canAwait) {
    expr = this.parseAwait(forInit);
    sawUnary = true;
  } else if (this.type.prefix) {
    var node3 = this.startNode(), update = this.type === types$1.incDec;
    node3.operator = this.value;
    node3.prefix = true;
    this.next();
    node3.argument = this.parseMaybeUnary(null, true, update, forInit);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) {
      this.checkLValSimple(node3.argument);
    } else if (this.strict && node3.operator === "delete" && node3.argument.type === "Identifier") {
      this.raiseRecoverable(node3.start, "Deleting local variable in strict mode");
    } else if (node3.operator === "delete" && isPrivateFieldAccess(node3.argument)) {
      this.raiseRecoverable(node3.start, "Private fields can not be deleted");
    } else {
      sawUnary = true;
    }
    expr = this.finishNode(node3, update ? "UpdateExpression" : "UnaryExpression");
  } else if (!sawUnary && this.type === types$1.privateId) {
    if (forInit || this.privateNameStack.length === 0) {
      this.unexpected();
    }
    expr = this.parsePrivateIdent();
    if (this.type !== types$1._in) {
      this.unexpected();
    }
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
    if (this.checkExpressionErrors(refDestructuringErrors)) {
      return expr;
    }
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$12 = this.startNodeAt(startPos, startLoc);
      node$12.operator = this.value;
      node$12.prefix = false;
      node$12.argument = expr;
      this.checkLValSimple(expr);
      this.next();
      expr = this.finishNode(node$12, "UpdateExpression");
    }
  }
  if (!incDec && this.eat(types$1.starstar)) {
    if (sawUnary) {
      this.unexpected(this.lastTokStart);
    } else {
      return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
    }
  } else {
    return expr;
  }
};
function isPrivateFieldAccess(node3) {
  return node3.type === "MemberExpression" && node3.property.type === "PrivateIdentifier" || node3.type === "ChainExpression" && isPrivateFieldAccess(node3.expression);
}
pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors, forInit);
  if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
    return expr;
  }
  var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) {
      refDestructuringErrors.parenthesizedAssign = -1;
    }
    if (refDestructuringErrors.parenthesizedBind >= result.start) {
      refDestructuringErrors.parenthesizedBind = -1;
    }
    if (refDestructuringErrors.trailingComma >= result.start) {
      refDestructuringErrors.trailingComma = -1;
    }
  }
  return result;
};
pp$5.parseSubscripts = function(base2, startPos, startLoc, noCalls, forInit) {
  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base2.type === "Identifier" && base2.name === "async" && this.lastTokEnd === base2.end && !this.canInsertSemicolon() && base2.end - base2.start === 5 && this.potentialArrowAt === base2.start;
  var optionalChained = false;
  while (true) {
    var element = this.parseSubscript(base2, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
    if (element.optional) {
      optionalChained = true;
    }
    if (element === base2 || element.type === "ArrowFunctionExpression") {
      if (optionalChained) {
        var chainNode = this.startNodeAt(startPos, startLoc);
        chainNode.expression = element;
        element = this.finishNode(chainNode, "ChainExpression");
      }
      return element;
    }
    base2 = element;
  }
};
pp$5.parseSubscript = function(base2, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
  var optionalSupported = this.options.ecmaVersion >= 11;
  var optional = optionalSupported && this.eat(types$1.questionDot);
  if (noCalls && optional) {
    this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
  }
  var computed = this.eat(types$1.bracketL);
  if (computed || optional && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
    var node3 = this.startNodeAt(startPos, startLoc);
    node3.object = base2;
    if (computed) {
      node3.property = this.parseExpression();
      this.expect(types$1.bracketR);
    } else if (this.type === types$1.privateId && base2.type !== "Super") {
      node3.property = this.parsePrivateIdent();
    } else {
      node3.property = this.parseIdent(this.options.allowReserved !== "never");
    }
    node3.computed = !!computed;
    if (optionalSupported) {
      node3.optional = optional;
    }
    base2 = this.finishNode(node3, "MemberExpression");
  } else if (!noCalls && this.eat(types$1.parenL)) {
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
    if (maybeAsyncArrow && !optional && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      if (this.awaitIdentPos > 0) {
        this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
      }
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
    var node$12 = this.startNodeAt(startPos, startLoc);
    node$12.callee = base2;
    node$12.arguments = exprList;
    if (optionalSupported) {
      node$12.optional = optional;
    }
    base2 = this.finishNode(node$12, "CallExpression");
  } else if (this.type === types$1.backQuote) {
    if (optional || optionalChained) {
      this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
    }
    var node$2 = this.startNodeAt(startPos, startLoc);
    node$2.tag = base2;
    node$2.quasi = this.parseTemplate({ isTagged: true });
    base2 = this.finishNode(node$2, "TaggedTemplateExpression");
  }
  return base2;
};
pp$5.parseExprAtom = function(refDestructuringErrors, forInit) {
  if (this.type === types$1.slash) {
    this.readRegexp();
  }
  var node3, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
    case types$1._super:
      if (!this.allowSuper) {
        this.raise(this.start, "'super' keyword outside a method");
      }
      node3 = this.startNode();
      this.next();
      if (this.type === types$1.parenL && !this.allowDirectSuper) {
        this.raise(node3.start, "super() call outside constructor of a subclass");
      }
      if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
        this.unexpected();
      }
      return this.finishNode(node3, "Super");
    case types$1._this:
      node3 = this.startNode();
      this.next();
      return this.finishNode(node3, "ThisExpression");
    case types$1.name:
      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
      var id = this.parseIdent(false);
      if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
        this.overrideContext(types$2.f_expr);
        return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
      }
      if (canBeArrow && !this.canInsertSemicolon()) {
        if (this.eat(types$1.arrow)) {
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
        }
        if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
          id = this.parseIdent(false);
          if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
            this.unexpected();
          }
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
        }
      }
      return id;
    case types$1.regexp:
      var value2 = this.value;
      node3 = this.parseLiteral(value2.value);
      node3.regex = { pattern: value2.pattern, flags: value2.flags };
      return node3;
    case types$1.num:
    case types$1.string:
      return this.parseLiteral(this.value);
    case types$1._null:
    case types$1._true:
    case types$1._false:
      node3 = this.startNode();
      node3.value = this.type === types$1._null ? null : this.type === types$1._true;
      node3.raw = this.type.keyword;
      this.next();
      return this.finishNode(node3, "Literal");
    case types$1.parenL:
      var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
      if (refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
          refDestructuringErrors.parenthesizedAssign = start;
        }
        if (refDestructuringErrors.parenthesizedBind < 0) {
          refDestructuringErrors.parenthesizedBind = start;
        }
      }
      return expr;
    case types$1.bracketL:
      node3 = this.startNode();
      this.next();
      node3.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node3, "ArrayExpression");
    case types$1.braceL:
      this.overrideContext(types$2.b_expr);
      return this.parseObj(false, refDestructuringErrors);
    case types$1._function:
      node3 = this.startNode();
      this.next();
      return this.parseFunction(node3, 0);
    case types$1._class:
      return this.parseClass(this.startNode(), false);
    case types$1._new:
      return this.parseNew();
    case types$1.backQuote:
      return this.parseTemplate();
    case types$1._import:
      if (this.options.ecmaVersion >= 11) {
        return this.parseExprImport();
      } else {
        return this.unexpected();
      }
    default:
      this.unexpected();
  }
};
pp$5.parseExprImport = function() {
  var node3 = this.startNode();
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword import");
  }
  var meta = this.parseIdent(true);
  switch (this.type) {
    case types$1.parenL:
      return this.parseDynamicImport(node3);
    case types$1.dot:
      node3.meta = meta;
      return this.parseImportMeta(node3);
    default:
      this.unexpected();
  }
};
pp$5.parseDynamicImport = function(node3) {
  this.next();
  node3.source = this.parseMaybeAssign();
  if (!this.eat(types$1.parenR)) {
    var errorPos = this.start;
    if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
      this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
    } else {
      this.unexpected(errorPos);
    }
  }
  return this.finishNode(node3, "ImportExpression");
};
pp$5.parseImportMeta = function(node3) {
  this.next();
  var containsEsc = this.containsEsc;
  node3.property = this.parseIdent(true);
  if (node3.property.name !== "meta") {
    this.raiseRecoverable(node3.property.start, "The only valid meta property for import is 'import.meta'");
  }
  if (containsEsc) {
    this.raiseRecoverable(node3.start, "'import.meta' must not contain escaped characters");
  }
  if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
    this.raiseRecoverable(node3.start, "Cannot use 'import.meta' outside a module");
  }
  return this.finishNode(node3, "MetaProperty");
};
pp$5.parseLiteral = function(value2) {
  var node3 = this.startNode();
  node3.value = value2;
  node3.raw = this.input.slice(this.start, this.end);
  if (node3.raw.charCodeAt(node3.raw.length - 1) === 110) {
    node3.bigint = node3.raw.slice(0, -1).replace(/_/g, "");
  }
  this.next();
  return this.finishNode(node3, "Literal");
};
pp$5.parseParenExpression = function() {
  this.expect(types$1.parenL);
  var val = this.parseExpression();
  this.expect(types$1.parenR);
  return val;
};
pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();
    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first2 = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    while (this.type !== types$1.parenR) {
      first2 ? first2 = false : this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
        lastIsComma = true;
        break;
      } else if (this.type === types$1.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRestBinding()));
        if (this.type === types$1.comma) {
          this.raise(this.start, "Comma is not permitted after the rest element");
        }
        break;
      } else {
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
    this.expect(types$1.parenR);
    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types$1.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
    }
    if (!exprList.length || lastIsComma) {
      this.unexpected(this.lastTokStart);
    }
    if (spreadStart) {
      this.unexpected(spreadStart);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }
  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression");
  } else {
    return val;
  }
};
pp$5.parseParenItem = function(item) {
  return item;
};
pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
};
var empty = [];
pp$5.parseNew = function() {
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword new");
  }
  var node3 = this.startNode();
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(types$1.dot)) {
    node3.meta = meta;
    var containsEsc = this.containsEsc;
    node3.property = this.parseIdent(true);
    if (node3.property.name !== "target") {
      this.raiseRecoverable(node3.property.start, "The only valid meta property for new is 'new.target'");
    }
    if (containsEsc) {
      this.raiseRecoverable(node3.start, "'new.target' must not contain escaped characters");
    }
    if (!this.allowNewDotTarget) {
      this.raiseRecoverable(node3.start, "'new.target' can only be used in functions and class static block");
    }
    return this.finishNode(node3, "MetaProperty");
  }
  var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types$1._import;
  node3.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true, false);
  if (isImport && node3.callee.type === "ImportExpression") {
    this.raise(startPos, "Cannot use new with import()");
  }
  if (this.eat(types$1.parenL)) {
    node3.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
  } else {
    node3.arguments = empty;
  }
  return this.finishNode(node3, "NewExpression");
};
pp$5.parseTemplateElement = function(ref2) {
  var isTagged = ref2.isTagged;
  var elem = this.startNode();
  if (this.type === types$1.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
    }
    elem.value = {
      raw: this.value,
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types$1.backQuote;
  return this.finishNode(elem, "TemplateElement");
};
pp$5.parseTemplate = function(ref2) {
  if (ref2 === void 0)
    ref2 = {};
  var isTagged = ref2.isTagged;
  if (isTagged === void 0)
    isTagged = false;
  var node3 = this.startNode();
  this.next();
  node3.expressions = [];
  var curElt = this.parseTemplateElement({ isTagged });
  node3.quasis = [curElt];
  while (!curElt.tail) {
    if (this.type === types$1.eof) {
      this.raise(this.pos, "Unterminated template literal");
    }
    this.expect(types$1.dollarBraceL);
    node3.expressions.push(this.parseExpression());
    this.expect(types$1.braceR);
    node3.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
  }
  this.next();
  return this.finishNode(node3, "TemplateLiteral");
};
pp$5.isAsyncProp = function(prop) {
  return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$5.parseObj = function(isPattern, refDestructuringErrors) {
  var node3 = this.startNode(), first2 = true, propHash = {};
  node3.properties = [];
  this.next();
  while (!this.eat(types$1.braceR)) {
    if (!first2) {
      this.expect(types$1.comma);
      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first2 = false;
    }
    var prop = this.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) {
      this.checkPropClash(prop, propHash, refDestructuringErrors);
    }
    node3.properties.push(prop);
  }
  return this.finishNode(node3, isPattern ? "ObjectPattern" : "ObjectExpression");
};
pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
    if (isPattern) {
      prop.argument = this.parseIdent(false);
      if (this.type === types$1.comma) {
        this.raise(this.start, "Comma is not permitted after the rest element");
      }
      return this.finishNode(prop, "RestElement");
    }
    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
      refDestructuringErrors.trailingComma = this.start;
    }
    return this.finishNode(prop, "SpreadElement");
  }
  if (this.options.ecmaVersion >= 6) {
    prop.method = false;
    prop.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern) {
      isGenerator = this.eat(types$1.star);
    }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop);
  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
    this.parsePropertyName(prop);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop, "Property");
};
pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) && this.type === types$1.colon) {
    this.unexpected();
  }
  if (this.eat(types$1.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
    if (isPattern) {
      this.unexpected();
    }
    prop.kind = "init";
    prop.method = true;
    prop.value = this.parseMethod(isGenerator, isAsync);
  } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    prop.kind = prop.key.name;
    this.parsePropertyName(prop);
    prop.value = this.parseMethod(false);
    var paramCount = prop.kind === "get" ? 0 : 1;
    if (prop.value.params.length !== paramCount) {
      var start = prop.value.start;
      if (prop.kind === "get") {
        this.raiseRecoverable(start, "getter should have no params");
      } else {
        this.raiseRecoverable(start, "setter should have exactly one param");
      }
    } else {
      if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
        this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
      }
    }
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    this.checkUnreserved(prop.key);
    if (prop.key.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = startPos;
    }
    prop.kind = "init";
    if (isPattern) {
      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
    } else if (this.type === types$1.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0) {
        refDestructuringErrors.shorthandAssign = this.start;
      }
      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
    } else {
      prop.value = this.copyNode(prop.key);
    }
    prop.shorthand = true;
  } else {
    this.unexpected();
  }
};
pp$5.parsePropertyName = function(prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types$1.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(types$1.bracketR);
      return prop.key;
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
};
pp$5.initFunction = function(node3) {
  node3.id = null;
  if (this.options.ecmaVersion >= 6) {
    node3.generator = node3.expression = false;
  }
  if (this.options.ecmaVersion >= 8) {
    node3.async = false;
  }
};
pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
  var node3 = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.initFunction(node3);
  if (this.options.ecmaVersion >= 6) {
    node3.generator = isGenerator;
  }
  if (this.options.ecmaVersion >= 8) {
    node3.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(isAsync, node3.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
  this.expect(types$1.parenL);
  node3.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node3, false, true, false);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node3, "FunctionExpression");
};
pp$5.parseArrowExpression = function(node3, params, isAsync, forInit) {
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
  this.initFunction(node3);
  if (this.options.ecmaVersion >= 8) {
    node3.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  node3.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node3, true, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node3, "ArrowFunctionExpression");
};
pp$5.parseFunctionBody = function(node3, isArrowFunction, isMethod, forInit) {
  var isExpression = isArrowFunction && this.type !== types$1.braceL;
  var oldStrict = this.strict, useStrict = false;
  if (isExpression) {
    node3.body = this.parseMaybeAssign(forInit);
    node3.expression = true;
    this.checkParams(node3, false);
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node3.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      if (useStrict && nonSimple) {
        this.raiseRecoverable(node3.start, "Illegal 'use strict' directive in function with non-simple parameter list");
      }
    }
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) {
      this.strict = true;
    }
    this.checkParams(node3, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node3.params));
    if (this.strict && node3.id) {
      this.checkLValSimple(node3.id, BIND_OUTSIDE);
    }
    node3.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
    node3.expression = false;
    this.adaptDirectivePrologue(node3.body.body);
    this.labels = oldLabels;
  }
  this.exitScope();
};
pp$5.isSimpleParamList = function(params) {
  for (var i2 = 0, list = params; i2 < list.length; i2 += 1) {
    var param = list[i2];
    if (param.type !== "Identifier") {
      return false;
    }
  }
  return true;
};
pp$5.checkParams = function(node3, allowDuplicates) {
  var nameHash = /* @__PURE__ */ Object.create(null);
  for (var i2 = 0, list = node3.params; i2 < list.length; i2 += 1) {
    var param = list[i2];
    this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
  }
};
pp$5.parseExprList = function(close2, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [], first2 = true;
  while (!this.eat(close2)) {
    if (!first2) {
      this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(close2)) {
        break;
      }
    } else {
      first2 = false;
    }
    var elt = void 0;
    if (allowEmpty && this.type === types$1.comma) {
      elt = null;
    } else if (this.type === types$1.ellipsis) {
      elt = this.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
        refDestructuringErrors.trailingComma = this.start;
      }
    } else {
      elt = this.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts;
};
pp$5.checkUnreserved = function(ref2) {
  var start = ref2.start;
  var end = ref2.end;
  var name2 = ref2.name;
  if (this.inGenerator && name2 === "yield") {
    this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
  }
  if (this.inAsync && name2 === "await") {
    this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
  }
  if (this.currentThisScope().inClassFieldInit && name2 === "arguments") {
    this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
  }
  if (this.inClassStaticBlock && (name2 === "arguments" || name2 === "await")) {
    this.raise(start, "Cannot use " + name2 + " in class static initialization block");
  }
  if (this.keywords.test(name2)) {
    this.raise(start, "Unexpected keyword '" + name2 + "'");
  }
  if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
    return;
  }
  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re.test(name2)) {
    if (!this.inAsync && name2 === "await") {
      this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
    }
    this.raiseRecoverable(start, "The keyword '" + name2 + "' is reserved");
  }
};
pp$5.parseIdent = function(liberal) {
  var node3 = this.startNode();
  if (this.type === types$1.name) {
    node3.name = this.value;
  } else if (this.type.keyword) {
    node3.name = this.type.keyword;
    if ((node3.name === "class" || node3.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
  } else {
    this.unexpected();
  }
  this.next(!!liberal);
  this.finishNode(node3, "Identifier");
  if (!liberal) {
    this.checkUnreserved(node3);
    if (node3.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = node3.start;
    }
  }
  return node3;
};
pp$5.parsePrivateIdent = function() {
  var node3 = this.startNode();
  if (this.type === types$1.privateId) {
    node3.name = this.value;
  } else {
    this.unexpected();
  }
  this.next();
  this.finishNode(node3, "PrivateIdentifier");
  if (this.privateNameStack.length === 0) {
    this.raise(node3.start, "Private field '#" + node3.name + "' must be declared in an enclosing class");
  } else {
    this.privateNameStack[this.privateNameStack.length - 1].used.push(node3);
  }
  return node3;
};
pp$5.parseYield = function(forInit) {
  if (!this.yieldPos) {
    this.yieldPos = this.start;
  }
  var node3 = this.startNode();
  this.next();
  if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
    node3.delegate = false;
    node3.argument = null;
  } else {
    node3.delegate = this.eat(types$1.star);
    node3.argument = this.parseMaybeAssign(forInit);
  }
  return this.finishNode(node3, "YieldExpression");
};
pp$5.parseAwait = function(forInit) {
  if (!this.awaitPos) {
    this.awaitPos = this.start;
  }
  var node3 = this.startNode();
  this.next();
  node3.argument = this.parseMaybeUnary(null, true, false, forInit);
  return this.finishNode(node3, "AwaitExpression");
};
var pp$4 = Parser$1.prototype;
pp$4.raise = function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err2 = new SyntaxError(message);
  err2.pos = pos;
  err2.loc = loc;
  err2.raisedAt = this.pos;
  throw err2;
};
pp$4.raiseRecoverable = pp$4.raise;
pp$4.curPosition = function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart);
  }
};
var pp$3 = Parser$1.prototype;
var Scope2 = function Scope3(flags) {
  this.flags = flags;
  this.var = [];
  this.lexical = [];
  this.functions = [];
  this.inClassFieldInit = false;
};
pp$3.enterScope = function(flags) {
  this.scopeStack.push(new Scope2(flags));
};
pp$3.exitScope = function() {
  this.scopeStack.pop();
};
pp$3.treatFunctionsAsVarInScope = function(scope) {
  return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
};
pp$3.declareName = function(name2, bindingType, pos) {
  var redeclared = false;
  if (bindingType === BIND_LEXICAL) {
    var scope = this.currentScope();
    redeclared = scope.lexical.indexOf(name2) > -1 || scope.functions.indexOf(name2) > -1 || scope.var.indexOf(name2) > -1;
    scope.lexical.push(name2);
    if (this.inModule && scope.flags & SCOPE_TOP) {
      delete this.undefinedExports[name2];
    }
  } else if (bindingType === BIND_SIMPLE_CATCH) {
    var scope$1 = this.currentScope();
    scope$1.lexical.push(name2);
  } else if (bindingType === BIND_FUNCTION) {
    var scope$2 = this.currentScope();
    if (this.treatFunctionsAsVar) {
      redeclared = scope$2.lexical.indexOf(name2) > -1;
    } else {
      redeclared = scope$2.lexical.indexOf(name2) > -1 || scope$2.var.indexOf(name2) > -1;
    }
    scope$2.functions.push(name2);
  } else {
    for (var i2 = this.scopeStack.length - 1; i2 >= 0; --i2) {
      var scope$3 = this.scopeStack[i2];
      if (scope$3.lexical.indexOf(name2) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name2) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name2) > -1) {
        redeclared = true;
        break;
      }
      scope$3.var.push(name2);
      if (this.inModule && scope$3.flags & SCOPE_TOP) {
        delete this.undefinedExports[name2];
      }
      if (scope$3.flags & SCOPE_VAR) {
        break;
      }
    }
  }
  if (redeclared) {
    this.raiseRecoverable(pos, "Identifier '" + name2 + "' has already been declared");
  }
};
pp$3.checkLocalExport = function(id) {
  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
    this.undefinedExports[id.name] = id;
  }
};
pp$3.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1];
};
pp$3.currentVarScope = function() {
  for (var i2 = this.scopeStack.length - 1; ; i2--) {
    var scope = this.scopeStack[i2];
    if (scope.flags & SCOPE_VAR) {
      return scope;
    }
  }
};
pp$3.currentThisScope = function() {
  for (var i2 = this.scopeStack.length - 1; ; i2--) {
    var scope = this.scopeStack[i2];
    if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) {
      return scope;
    }
  }
};
var Node = function Node2(parser2, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser2.options.locations) {
    this.loc = new SourceLocation(parser2, loc);
  }
  if (parser2.options.directSourceFile) {
    this.sourceFile = parser2.options.directSourceFile;
  }
  if (parser2.options.ranges) {
    this.range = [pos, 0];
  }
};
var pp$2 = Parser$1.prototype;
pp$2.startNode = function() {
  return new Node(this, this.start, this.startLoc);
};
pp$2.startNodeAt = function(pos, loc) {
  return new Node(this, pos, loc);
};
function finishNodeAt(node3, type, pos, loc) {
  node3.type = type;
  node3.end = pos;
  if (this.options.locations) {
    node3.loc.end = loc;
  }
  if (this.options.ranges) {
    node3.range[1] = pos;
  }
  return node3;
}
pp$2.finishNode = function(node3, type) {
  return finishNodeAt.call(this, node3, type, this.lastTokEnd, this.lastTokEndLoc);
};
pp$2.finishNodeAt = function(node3, type, pos, loc) {
  return finishNodeAt.call(this, node3, type, pos, loc);
};
pp$2.copyNode = function(node3) {
  var newNode = new Node(this, node3.start, this.startLoc);
  for (var prop in node3) {
    newNode[prop] = node3[prop];
  }
  return newNode;
};
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
var ecma13BinaryProperties = ecma12BinaryProperties;
var ecma14BinaryProperties = ecma13BinaryProperties;
var unicodeBinaryProperties = {
  9: ecma9BinaryProperties,
  10: ecma10BinaryProperties,
  11: ecma11BinaryProperties,
  12: ecma12BinaryProperties,
  13: ecma13BinaryProperties,
  14: ecma14BinaryProperties
};
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
var ecma14ScriptValues = ecma13ScriptValues + " Kawi Nag_Mundari Nagm";
var unicodeScriptValues = {
  9: ecma9ScriptValues,
  10: ecma10ScriptValues,
  11: ecma11ScriptValues,
  12: ecma12ScriptValues,
  13: ecma13ScriptValues,
  14: ecma14ScriptValues
};
var data = {};
function buildUnicodeData(ecmaVersion) {
  var d2 = data[ecmaVersion] = {
    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
    nonBinary: {
      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
    }
  };
  d2.nonBinary.Script_Extensions = d2.nonBinary.Script;
  d2.nonBinary.gc = d2.nonBinary.General_Category;
  d2.nonBinary.sc = d2.nonBinary.Script;
  d2.nonBinary.scx = d2.nonBinary.Script_Extensions;
}
for (i$1 = 0, list = [9, 10, 11, 12, 13, 14]; i$1 < list.length; i$1 += 1) {
  ecmaVersion = list[i$1];
  buildUnicodeData(ecmaVersion);
}
var ecmaVersion;
var i$1;
var list;
var pp$1 = Parser$1.prototype;
var RegExpValidationState = function RegExpValidationState2(parser2) {
  this.parser = parser2;
  this.validFlags = "gim" + (parser2.options.ecmaVersion >= 6 ? "uy" : "") + (parser2.options.ecmaVersion >= 9 ? "s" : "") + (parser2.options.ecmaVersion >= 13 ? "d" : "");
  this.unicodeProperties = data[parser2.options.ecmaVersion >= 14 ? 14 : parser2.options.ecmaVersion];
  this.source = "";
  this.flags = "";
  this.start = 0;
  this.switchU = false;
  this.switchN = false;
  this.pos = 0;
  this.lastIntValue = 0;
  this.lastStringValue = "";
  this.lastAssertionIsQuantifiable = false;
  this.numCapturingParens = 0;
  this.maxBackReference = 0;
  this.groupNames = [];
  this.backReferenceNames = [];
};
RegExpValidationState.prototype.reset = function reset(start, pattern2, flags) {
  var unicode = flags.indexOf("u") !== -1;
  this.start = start | 0;
  this.source = pattern2 + "";
  this.flags = flags;
  this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
  this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
};
RegExpValidationState.prototype.raise = function raise(message) {
  this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
};
RegExpValidationState.prototype.at = function at(i2, forceU) {
  if (forceU === void 0)
    forceU = false;
  var s2 = this.source;
  var l2 = s2.length;
  if (i2 >= l2) {
    return -1;
  }
  var c2 = s2.charCodeAt(i2);
  if (!(forceU || this.switchU) || c2 <= 55295 || c2 >= 57344 || i2 + 1 >= l2) {
    return c2;
  }
  var next = s2.charCodeAt(i2 + 1);
  return next >= 56320 && next <= 57343 ? (c2 << 10) + next - 56613888 : c2;
};
RegExpValidationState.prototype.nextIndex = function nextIndex(i2, forceU) {
  if (forceU === void 0)
    forceU = false;
  var s2 = this.source;
  var l2 = s2.length;
  if (i2 >= l2) {
    return l2;
  }
  var c2 = s2.charCodeAt(i2), next;
  if (!(forceU || this.switchU) || c2 <= 55295 || c2 >= 57344 || i2 + 1 >= l2 || (next = s2.charCodeAt(i2 + 1)) < 56320 || next > 57343) {
    return i2 + 1;
  }
  return i2 + 2;
};
RegExpValidationState.prototype.current = function current(forceU) {
  if (forceU === void 0)
    forceU = false;
  return this.at(this.pos, forceU);
};
RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
  if (forceU === void 0)
    forceU = false;
  return this.at(this.nextIndex(this.pos, forceU), forceU);
};
RegExpValidationState.prototype.advance = function advance(forceU) {
  if (forceU === void 0)
    forceU = false;
  this.pos = this.nextIndex(this.pos, forceU);
};
RegExpValidationState.prototype.eat = function eat(ch, forceU) {
  if (forceU === void 0)
    forceU = false;
  if (this.current(forceU) === ch) {
    this.advance(forceU);
    return true;
  }
  return false;
};
pp$1.validateRegExpFlags = function(state) {
  var validFlags = state.validFlags;
  var flags = state.flags;
  for (var i2 = 0; i2 < flags.length; i2++) {
    var flag = flags.charAt(i2);
    if (validFlags.indexOf(flag) === -1) {
      this.raise(state.start, "Invalid regular expression flag");
    }
    if (flags.indexOf(flag, i2 + 1) > -1) {
      this.raise(state.start, "Duplicate regular expression flag");
    }
  }
};
pp$1.validateRegExpPattern = function(state) {
  this.regexp_pattern(state);
  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
    state.switchN = true;
    this.regexp_pattern(state);
  }
};
pp$1.regexp_pattern = function(state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = "";
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames.length = 0;
  state.backReferenceNames.length = 0;
  this.regexp_disjunction(state);
  if (state.pos !== state.source.length) {
    if (state.eat(
      41
      /* ) */
    )) {
      state.raise("Unmatched ')'");
    }
    if (state.eat(
      93
      /* ] */
    ) || state.eat(
      125
      /* } */
    )) {
      state.raise("Lone quantifier brackets");
    }
  }
  if (state.maxBackReference > state.numCapturingParens) {
    state.raise("Invalid escape");
  }
  for (var i2 = 0, list = state.backReferenceNames; i2 < list.length; i2 += 1) {
    var name2 = list[i2];
    if (state.groupNames.indexOf(name2) === -1) {
      state.raise("Invalid named capture referenced");
    }
  }
};
pp$1.regexp_disjunction = function(state) {
  this.regexp_alternative(state);
  while (state.eat(
    124
    /* | */
  )) {
    this.regexp_alternative(state);
  }
  if (this.regexp_eatQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  if (state.eat(
    123
    /* { */
  )) {
    state.raise("Lone quantifier brackets");
  }
};
pp$1.regexp_alternative = function(state) {
  while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
  }
};
pp$1.regexp_eatTerm = function(state) {
  if (this.regexp_eatAssertion(state)) {
    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
      if (state.switchU) {
        state.raise("Invalid quantifier");
      }
    }
    return true;
  }
  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true;
  }
  return false;
};
pp$1.regexp_eatAssertion = function(state) {
  var start = state.pos;
  state.lastAssertionIsQuantifiable = false;
  if (state.eat(
    94
    /* ^ */
  ) || state.eat(
    36
    /* $ */
  )) {
    return true;
  }
  if (state.eat(
    92
    /* \ */
  )) {
    if (state.eat(
      66
      /* B */
    ) || state.eat(
      98
      /* b */
    )) {
      return true;
    }
    state.pos = start;
  }
  if (state.eat(
    40
    /* ( */
  ) && state.eat(
    63
    /* ? */
  )) {
    var lookbehind = false;
    if (this.options.ecmaVersion >= 9) {
      lookbehind = state.eat(
        60
        /* < */
      );
    }
    if (state.eat(
      61
      /* = */
    ) || state.eat(
      33
      /* ! */
    )) {
      this.regexp_disjunction(state);
      if (!state.eat(
        41
        /* ) */
      )) {
        state.raise("Unterminated group");
      }
      state.lastAssertionIsQuantifiable = !lookbehind;
      return true;
    }
  }
  state.pos = start;
  return false;
};
pp$1.regexp_eatQuantifier = function(state, noError) {
  if (noError === void 0)
    noError = false;
  if (this.regexp_eatQuantifierPrefix(state, noError)) {
    state.eat(
      63
      /* ? */
    );
    return true;
  }
  return false;
};
pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
  return state.eat(
    42
    /* * */
  ) || state.eat(
    43
    /* + */
  ) || state.eat(
    63
    /* ? */
  ) || this.regexp_eatBracedQuantifier(state, noError);
};
pp$1.regexp_eatBracedQuantifier = function(state, noError) {
  var start = state.pos;
  if (state.eat(
    123
    /* { */
  )) {
    var min2 = 0, max = -1;
    if (this.regexp_eatDecimalDigits(state)) {
      min2 = state.lastIntValue;
      if (state.eat(
        44
        /* , */
      ) && this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }
      if (state.eat(
        125
        /* } */
      )) {
        if (max !== -1 && max < min2 && !noError) {
          state.raise("numbers out of order in {} quantifier");
        }
        return true;
      }
    }
    if (state.switchU && !noError) {
      state.raise("Incomplete quantifier");
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatAtom = function(state) {
  return this.regexp_eatPatternCharacters(state) || state.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
};
pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatAtomEscape(state)) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatUncapturingGroup = function(state) {
  var start = state.pos;
  if (state.eat(
    40
    /* ( */
  )) {
    if (state.eat(
      63
      /* ? */
    ) && state.eat(
      58
      /* : */
    )) {
      this.regexp_disjunction(state);
      if (state.eat(
        41
        /* ) */
      )) {
        return true;
      }
      state.raise("Unterminated group");
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatCapturingGroup = function(state) {
  if (state.eat(
    40
    /* ( */
  )) {
    if (this.options.ecmaVersion >= 9) {
      this.regexp_groupSpecifier(state);
    } else if (state.current() === 63) {
      state.raise("Invalid group");
    }
    this.regexp_disjunction(state);
    if (state.eat(
      41
      /* ) */
    )) {
      state.numCapturingParens += 1;
      return true;
    }
    state.raise("Unterminated group");
  }
  return false;
};
pp$1.regexp_eatExtendedAtom = function(state) {
  return state.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
};
pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  return false;
};
pp$1.regexp_eatSyntaxCharacter = function(state) {
  var ch = state.current();
  if (isSyntaxCharacter(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
function isSyntaxCharacter(ch) {
  return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatPatternCharacters = function(state) {
  var start = state.pos;
  var ch = 0;
  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
    state.advance();
  }
  return state.pos !== start;
};
pp$1.regexp_eatExtendedPatternCharacter = function(state) {
  var ch = state.current();
  if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_groupSpecifier = function(state) {
  if (state.eat(
    63
    /* ? */
  )) {
    if (this.regexp_eatGroupName(state)) {
      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
        state.raise("Duplicate capture group name");
      }
      state.groupNames.push(state.lastStringValue);
      return;
    }
    state.raise("Invalid group");
  }
};
pp$1.regexp_eatGroupName = function(state) {
  state.lastStringValue = "";
  if (state.eat(
    60
    /* < */
  )) {
    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(
      62
      /* > */
    )) {
      return true;
    }
    state.raise("Invalid capture group name");
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = "";
  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierStart = function(state) {
  var start = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);
  if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierStart(ch)) {
    state.lastIntValue = ch;
    return true;
  }
  state.pos = start;
  return false;
};
function isRegExpIdentifierStart(ch) {
  return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
}
pp$1.regexp_eatRegExpIdentifierPart = function(state) {
  var start = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);
  if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierPart(ch)) {
    state.lastIntValue = ch;
    return true;
  }
  state.pos = start;
  return false;
};
function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
}
pp$1.regexp_eatAtomEscape = function(state) {
  if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
    return true;
  }
  if (state.switchU) {
    if (state.current() === 99) {
      state.raise("Invalid unicode escape");
    }
    state.raise("Invalid escape");
  }
  return false;
};
pp$1.regexp_eatBackReference = function(state) {
  var start = state.pos;
  if (this.regexp_eatDecimalEscape(state)) {
    var n3 = state.lastIntValue;
    if (state.switchU) {
      if (n3 > state.maxBackReference) {
        state.maxBackReference = n3;
      }
      return true;
    }
    if (n3 <= state.numCapturingParens) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatKGroupName = function(state) {
  if (state.eat(
    107
    /* k */
  )) {
    if (this.regexp_eatGroupName(state)) {
      state.backReferenceNames.push(state.lastStringValue);
      return true;
    }
    state.raise("Invalid named reference");
  }
  return false;
};
pp$1.regexp_eatCharacterEscape = function(state) {
  return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
};
pp$1.regexp_eatCControlLetter = function(state) {
  var start = state.pos;
  if (state.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatControlLetter(state)) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatZero = function(state) {
  if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
    state.lastIntValue = 0;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlEscape = function(state) {
  var ch = state.current();
  if (ch === 116) {
    state.lastIntValue = 9;
    state.advance();
    return true;
  }
  if (ch === 110) {
    state.lastIntValue = 10;
    state.advance();
    return true;
  }
  if (ch === 118) {
    state.lastIntValue = 11;
    state.advance();
    return true;
  }
  if (ch === 102) {
    state.lastIntValue = 12;
    state.advance();
    return true;
  }
  if (ch === 114) {
    state.lastIntValue = 13;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlLetter = function(state) {
  var ch = state.current();
  if (isControlLetter(ch)) {
    state.lastIntValue = ch % 32;
    state.advance();
    return true;
  }
  return false;
};
function isControlLetter(ch) {
  return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
}
pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
  if (forceU === void 0)
    forceU = false;
  var start = state.pos;
  var switchU = forceU || state.switchU;
  if (state.eat(
    117
    /* u */
  )) {
    if (this.regexp_eatFixedHexDigits(state, 4)) {
      var lead = state.lastIntValue;
      if (switchU && lead >= 55296 && lead <= 56319) {
        var leadSurrogateEnd = state.pos;
        if (state.eat(
          92
          /* \ */
        ) && state.eat(
          117
          /* u */
        ) && this.regexp_eatFixedHexDigits(state, 4)) {
          var trail = state.lastIntValue;
          if (trail >= 56320 && trail <= 57343) {
            state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
            return true;
          }
        }
        state.pos = leadSurrogateEnd;
        state.lastIntValue = lead;
      }
      return true;
    }
    if (switchU && state.eat(
      123
      /* { */
    ) && this.regexp_eatHexDigits(state) && state.eat(
      125
      /* } */
    ) && isValidUnicode(state.lastIntValue)) {
      return true;
    }
    if (switchU) {
      state.raise("Invalid unicode escape");
    }
    state.pos = start;
  }
  return false;
};
function isValidUnicode(ch) {
  return ch >= 0 && ch <= 1114111;
}
pp$1.regexp_eatIdentityEscape = function(state) {
  if (state.switchU) {
    if (this.regexp_eatSyntaxCharacter(state)) {
      return true;
    }
    if (state.eat(
      47
      /* / */
    )) {
      state.lastIntValue = 47;
      return true;
    }
    return false;
  }
  var ch = state.current();
  if (ch !== 99 && (!state.switchN || ch !== 107)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatDecimalEscape = function(state) {
  state.lastIntValue = 0;
  var ch = state.current();
  if (ch >= 49 && ch <= 57) {
    do {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
      state.advance();
    } while ((ch = state.current()) >= 48 && ch <= 57);
    return true;
  }
  return false;
};
pp$1.regexp_eatCharacterClassEscape = function(state) {
  var ch = state.current();
  if (isCharacterClassEscape(ch)) {
    state.lastIntValue = -1;
    state.advance();
    return true;
  }
  if (state.switchU && this.options.ecmaVersion >= 9 && (ch === 80 || ch === 112)) {
    state.lastIntValue = -1;
    state.advance();
    if (state.eat(
      123
      /* { */
    ) && this.regexp_eatUnicodePropertyValueExpression(state) && state.eat(
      125
      /* } */
    )) {
      return true;
    }
    state.raise("Invalid property name");
  }
  return false;
};
function isCharacterClassEscape(ch) {
  return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
}
pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
  var start = state.pos;
  if (this.regexp_eatUnicodePropertyName(state) && state.eat(
    61
    /* = */
  )) {
    var name2 = state.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(state)) {
      var value2 = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state, name2, value2);
      return true;
    }
  }
  state.pos = start;
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
    return true;
  }
  return false;
};
pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name2, value2) {
  if (!hasOwn(state.unicodeProperties.nonBinary, name2)) {
    state.raise("Invalid property name");
  }
  if (!state.unicodeProperties.nonBinary[name2].test(value2)) {
    state.raise("Invalid property value");
  }
};
pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
  if (!state.unicodeProperties.binary.test(nameOrValue)) {
    state.raise("Invalid property name");
  }
};
pp$1.regexp_eatUnicodePropertyName = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyNameCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyNameCharacter(ch) {
  return isControlLetter(ch) || ch === 95;
}
pp$1.regexp_eatUnicodePropertyValue = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyValueCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyValueCharacter(ch) {
  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
}
pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
  return this.regexp_eatUnicodePropertyValue(state);
};
pp$1.regexp_eatCharacterClass = function(state) {
  if (state.eat(
    91
    /* [ */
  )) {
    state.eat(
      94
      /* ^ */
    );
    this.regexp_classRanges(state);
    if (state.eat(
      93
      /* ] */
    )) {
      return true;
    }
    state.raise("Unterminated character class");
  }
  return false;
};
pp$1.regexp_classRanges = function(state) {
  while (this.regexp_eatClassAtom(state)) {
    var left = state.lastIntValue;
    if (state.eat(
      45
      /* - */
    ) && this.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;
      if (state.switchU && (left === -1 || right === -1)) {
        state.raise("Invalid character class");
      }
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
    }
  }
};
pp$1.regexp_eatClassAtom = function(state) {
  var start = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatClassEscape(state)) {
      return true;
    }
    if (state.switchU) {
      var ch$1 = state.current();
      if (ch$1 === 99 || isOctalDigit(ch$1)) {
        state.raise("Invalid class escape");
      }
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  var ch = state.current();
  if (ch !== 93) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatClassEscape = function(state) {
  var start = state.pos;
  if (state.eat(
    98
    /* b */
  )) {
    state.lastIntValue = 8;
    return true;
  }
  if (state.switchU && state.eat(
    45
    /* - */
  )) {
    state.lastIntValue = 45;
    return true;
  }
  if (!state.switchU && state.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatClassControlLetter(state)) {
      return true;
    }
    state.pos = start;
  }
  return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
};
pp$1.regexp_eatClassControlLetter = function(state) {
  var ch = state.current();
  if (isDecimalDigit(ch) || ch === 95) {
    state.lastIntValue = ch % 32;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatHexEscapeSequence = function(state) {
  var start = state.pos;
  if (state.eat(
    120
    /* x */
  )) {
    if (this.regexp_eatFixedHexDigits(state, 2)) {
      return true;
    }
    if (state.switchU) {
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatDecimalDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isDecimalDigit(ch = state.current())) {
    state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
    state.advance();
  }
  return state.pos !== start;
};
function isDecimalDigit(ch) {
  return ch >= 48 && ch <= 57;
}
pp$1.regexp_eatHexDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isHexDigit(ch = state.current())) {
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return state.pos !== start;
};
function isHexDigit(ch) {
  return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
}
function hexToInt(ch) {
  if (ch >= 65 && ch <= 70) {
    return 10 + (ch - 65);
  }
  if (ch >= 97 && ch <= 102) {
    return 10 + (ch - 97);
  }
  return ch - 48;
}
pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
  if (this.regexp_eatOctalDigit(state)) {
    var n1 = state.lastIntValue;
    if (this.regexp_eatOctalDigit(state)) {
      var n22 = state.lastIntValue;
      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n22 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n22;
      }
    } else {
      state.lastIntValue = n1;
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatOctalDigit = function(state) {
  var ch = state.current();
  if (isOctalDigit(ch)) {
    state.lastIntValue = ch - 48;
    state.advance();
    return true;
  }
  state.lastIntValue = 0;
  return false;
};
function isOctalDigit(ch) {
  return ch >= 48 && ch <= 55;
}
pp$1.regexp_eatFixedHexDigits = function(state, length) {
  var start = state.pos;
  state.lastIntValue = 0;
  for (var i2 = 0; i2 < length; ++i2) {
    var ch = state.current();
    if (!isHexDigit(ch)) {
      state.pos = start;
      return false;
    }
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return true;
};
var Token = function Token2(p2) {
  this.type = p2.type;
  this.value = p2.value;
  this.start = p2.start;
  this.end = p2.end;
  if (p2.options.locations) {
    this.loc = new SourceLocation(p2, p2.startLoc, p2.endLoc);
  }
  if (p2.options.ranges) {
    this.range = [p2.start, p2.end];
  }
};
var pp = Parser$1.prototype;
pp.next = function(ignoreEscapeSequenceInKeyword) {
  if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
  }
  if (this.options.onToken) {
    this.options.onToken(new Token(this));
  }
  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};
pp.getToken = function() {
  this.next();
  return new Token(this);
};
if (typeof Symbol !== "undefined") {
  pp[Symbol.iterator] = function() {
    var this$1$1 = this;
    return {
      next: function() {
        var token = this$1$1.getToken();
        return {
          done: token.type === types$1.eof,
          value: token
        };
      }
    };
  };
}
pp.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) {
    this.skipSpace();
  }
  this.start = this.pos;
  if (this.options.locations) {
    this.startLoc = this.curPosition();
  }
  if (this.pos >= this.input.length) {
    return this.finishToken(types$1.eof);
  }
  if (curContext.override) {
    return curContext.override(this);
  } else {
    this.readToken(this.fullCharCodeAtPos());
  }
};
pp.readToken = function(code) {
  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92) {
    return this.readWord();
  }
  return this.getTokenFromCode(code);
};
pp.fullCharCodeAtPos = function() {
  var code = this.input.charCodeAt(this.pos);
  if (code <= 55295 || code >= 56320) {
    return code;
  }
  var next = this.input.charCodeAt(this.pos + 1);
  return next <= 56319 || next >= 57344 ? code : (code << 10) + next - 56613888;
};
pp.skipBlockComment = function() {
  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) {
    this.raise(this.pos - 2, "Unterminated comment");
  }
  this.pos = end + 2;
  if (this.options.locations) {
    for (var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) {
      ++this.curLine;
      pos = this.lineStart = nextBreak;
    }
  }
  if (this.options.onComment) {
    this.options.onComment(
      true,
      this.input.slice(start + 2, end),
      start,
      this.pos,
      startLoc,
      this.curPosition()
    );
  }
};
pp.skipLineComment = function(startSkip) {
  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && !isNewLine(ch)) {
    ch = this.input.charCodeAt(++this.pos);
  }
  if (this.options.onComment) {
    this.options.onComment(
      false,
      this.input.slice(start + startSkip, this.pos),
      start,
      this.pos,
      startLoc,
      this.curPosition()
    );
  }
};
pp.skipSpace = function() {
  loop:
    while (this.pos < this.input.length) {
      var ch = this.input.charCodeAt(this.pos);
      switch (ch) {
        case 32:
        case 160:
          ++this.pos;
          break;
        case 13:
          if (this.input.charCodeAt(this.pos + 1) === 10) {
            ++this.pos;
          }
        case 10:
        case 8232:
        case 8233:
          ++this.pos;
          if (this.options.locations) {
            ++this.curLine;
            this.lineStart = this.pos;
          }
          break;
        case 47:
          switch (this.input.charCodeAt(this.pos + 1)) {
            case 42:
              this.skipBlockComment();
              break;
            case 47:
              this.skipLineComment(2);
              break;
            default:
              break loop;
          }
          break;
        default:
          if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
            ++this.pos;
          } else {
            break loop;
          }
      }
    }
};
pp.finishToken = function(type, val) {
  this.end = this.pos;
  if (this.options.locations) {
    this.endLoc = this.curPosition();
  }
  var prevType = this.type;
  this.type = type;
  this.value = val;
  this.updateContext(prevType);
};
pp.readToken_dot = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) {
    return this.readNumber(true);
  }
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
    this.pos += 3;
    return this.finishToken(types$1.ellipsis);
  } else {
    ++this.pos;
    return this.finishToken(types$1.dot);
  }
};
pp.readToken_slash = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) {
    ++this.pos;
    return this.readRegexp();
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.slash, 1);
};
pp.readToken_mult_modulo_exp = function(code) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? types$1.star : types$1.modulo;
  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
    ++size;
    tokentype = types$1.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, size + 1);
  }
  return this.finishOp(tokentype, size);
};
pp.readToken_pipe_amp = function(code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (this.options.ecmaVersion >= 12) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 === 61) {
        return this.finishOp(types$1.assign, 3);
      }
    }
    return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
};
pp.readToken_caret = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.bitwiseXOR, 1);
};
pp.readToken_plus_min = function(code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken();
    }
    return this.finishOp(types$1.incDec, 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.plusMin, 1);
};
pp.readToken_lt_gt = function(code) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code) {
    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) {
      return this.finishOp(types$1.assign, size + 1);
    }
    return this.finishOp(types$1.bitShift, size);
  }
  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken();
  }
  if (next === 61) {
    size = 2;
  }
  return this.finishOp(types$1.relational, size);
};
pp.readToken_eq_excl = function(code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) {
    return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
  }
  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
    this.pos += 2;
    return this.finishToken(types$1.arrow);
  }
  return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);
};
pp.readToken_question = function() {
  var ecmaVersion = this.options.ecmaVersion;
  if (ecmaVersion >= 11) {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 46) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 < 48 || next2 > 57) {
        return this.finishOp(types$1.questionDot, 2);
      }
    }
    if (next === 63) {
      if (ecmaVersion >= 12) {
        var next2$1 = this.input.charCodeAt(this.pos + 2);
        if (next2$1 === 61) {
          return this.finishOp(types$1.assign, 3);
        }
      }
      return this.finishOp(types$1.coalesce, 2);
    }
  }
  return this.finishOp(types$1.question, 1);
};
pp.readToken_numberSign = function() {
  var ecmaVersion = this.options.ecmaVersion;
  var code = 35;
  if (ecmaVersion >= 13) {
    ++this.pos;
    code = this.fullCharCodeAtPos();
    if (isIdentifierStart(code, true) || code === 92) {
      return this.finishToken(types$1.privateId, this.readWord1());
    }
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};
pp.getTokenFromCode = function(code) {
  switch (code) {
    case 46:
      return this.readToken_dot();
    case 40:
      ++this.pos;
      return this.finishToken(types$1.parenL);
    case 41:
      ++this.pos;
      return this.finishToken(types$1.parenR);
    case 59:
      ++this.pos;
      return this.finishToken(types$1.semi);
    case 44:
      ++this.pos;
      return this.finishToken(types$1.comma);
    case 91:
      ++this.pos;
      return this.finishToken(types$1.bracketL);
    case 93:
      ++this.pos;
      return this.finishToken(types$1.bracketR);
    case 123:
      ++this.pos;
      return this.finishToken(types$1.braceL);
    case 125:
      ++this.pos;
      return this.finishToken(types$1.braceR);
    case 58:
      ++this.pos;
      return this.finishToken(types$1.colon);
    case 96:
      if (this.options.ecmaVersion < 6) {
        break;
      }
      ++this.pos;
      return this.finishToken(types$1.backQuote);
    case 48:
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 120 || next === 88) {
        return this.readRadixNumber(16);
      }
      if (this.options.ecmaVersion >= 6) {
        if (next === 111 || next === 79) {
          return this.readRadixNumber(8);
        }
        if (next === 98 || next === 66) {
          return this.readRadixNumber(2);
        }
      }
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      return this.readNumber(false);
    case 34:
    case 39:
      return this.readString(code);
    case 47:
      return this.readToken_slash();
    case 37:
    case 42:
      return this.readToken_mult_modulo_exp(code);
    case 124:
    case 38:
      return this.readToken_pipe_amp(code);
    case 94:
      return this.readToken_caret();
    case 43:
    case 45:
      return this.readToken_plus_min(code);
    case 60:
    case 62:
      return this.readToken_lt_gt(code);
    case 61:
    case 33:
      return this.readToken_eq_excl(code);
    case 63:
      return this.readToken_question();
    case 126:
      return this.finishOp(types$1.prefix, 1);
    case 35:
      return this.readToken_numberSign();
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};
pp.finishOp = function(type, size) {
  var str2 = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str2);
};
pp.readRegexp = function() {
  var escaped2, inClass, start = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(start, "Unterminated regular expression");
    }
    var ch = this.input.charAt(this.pos);
    if (lineBreak.test(ch)) {
      this.raise(start, "Unterminated regular expression");
    }
    if (!escaped2) {
      if (ch === "[") {
        inClass = true;
      } else if (ch === "]" && inClass) {
        inClass = false;
      } else if (ch === "/" && !inClass) {
        break;
      }
      escaped2 = ch === "\\";
    } else {
      escaped2 = false;
    }
    ++this.pos;
  }
  var pattern2 = this.input.slice(start, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();
  if (this.containsEsc) {
    this.unexpected(flagsStart);
  }
  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start, pattern2, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state);
  var value2 = null;
  try {
    value2 = new RegExp(pattern2, flags);
  } catch (e3) {
  }
  return this.finishToken(types$1.regexp, { pattern: pattern2, flags, value: value2 });
};
pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
  var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
  var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
  var start = this.pos, total = 0, lastCode = 0;
  for (var i2 = 0, e3 = len == null ? Infinity : len; i2 < e3; ++i2, ++this.pos) {
    var code = this.input.charCodeAt(this.pos), val = void 0;
    if (allowSeparators && code === 95) {
      if (isLegacyOctalNumericLiteral) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
      }
      if (lastCode === 95) {
        this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
      }
      if (i2 === 0) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
      }
      lastCode = code;
      continue;
    }
    if (code >= 97) {
      val = code - 97 + 10;
    } else if (code >= 65) {
      val = code - 65 + 10;
    } else if (code >= 48 && code <= 57) {
      val = code - 48;
    } else {
      val = Infinity;
    }
    if (val >= radix) {
      break;
    }
    lastCode = code;
    total = total * radix + val;
  }
  if (allowSeparators && lastCode === 95) {
    this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
  }
  if (this.pos === start || len != null && this.pos - start !== len) {
    return null;
  }
  return total;
};
function stringToNumber(str2, isLegacyOctalNumericLiteral) {
  if (isLegacyOctalNumericLiteral) {
    return parseInt(str2, 8);
  }
  return parseFloat(str2.replace(/_/g, ""));
}
function stringToBigInt(str2) {
  if (typeof BigInt !== "function") {
    return null;
  }
  return BigInt(str2.replace(/_/g, ""));
}
pp.readRadixNumber = function(radix) {
  var start = this.pos;
  this.pos += 2;
  var val = this.readInt(radix);
  if (val == null) {
    this.raise(this.start + 2, "Expected number in radix " + radix);
  }
  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
    val = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;
  } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  return this.finishToken(types$1.num, val);
};
pp.readNumber = function(startsWithDot) {
  var start = this.pos;
  if (!startsWithDot && this.readInt(10, void 0, true) === null) {
    this.raise(start, "Invalid number");
  }
  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
  if (octal && this.strict) {
    this.raise(start, "Invalid number");
  }
  var next = this.input.charCodeAt(this.pos);
  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
    var val$1 = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;
    if (isIdentifierStart(this.fullCharCodeAtPos())) {
      this.raise(this.pos, "Identifier directly after number");
    }
    return this.finishToken(types$1.num, val$1);
  }
  if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
    octal = false;
  }
  if (next === 46 && !octal) {
    ++this.pos;
    this.readInt(10);
    next = this.input.charCodeAt(this.pos);
  }
  if ((next === 69 || next === 101) && !octal) {
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) {
      ++this.pos;
    }
    if (this.readInt(10) === null) {
      this.raise(start, "Invalid number");
    }
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  var val = stringToNumber(this.input.slice(start, this.pos), octal);
  return this.finishToken(types$1.num, val);
};
pp.readCodePoint = function() {
  var ch = this.input.charCodeAt(this.pos), code;
  if (ch === 123) {
    if (this.options.ecmaVersion < 6) {
      this.unexpected();
    }
    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code > 1114111) {
      this.invalidStringToken(codePos, "Code point out of bounds");
    }
  } else {
    code = this.readHexChar(4);
  }
  return code;
};
pp.readString = function(quote) {
  var out2 = "", chunkStart = ++this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated string constant");
    }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === quote) {
      break;
    }
    if (ch === 92) {
      out2 += this.input.slice(chunkStart, this.pos);
      out2 += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else if (ch === 8232 || ch === 8233) {
      if (this.options.ecmaVersion < 10) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
      if (this.options.locations) {
        this.curLine++;
        this.lineStart = this.pos;
      }
    } else {
      if (isNewLine(ch)) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
    }
  }
  out2 += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types$1.string, out2);
};
var INVALID_TEMPLATE_ESCAPE_ERROR = {};
pp.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err2) {
    if (err2 === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err2;
    }
  }
  this.inTemplateElement = false;
};
pp.invalidStringToken = function(position, message) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR;
  } else {
    this.raise(position, message);
  }
};
pp.readTmplToken = function() {
  var out2 = "", chunkStart = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated template");
    }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
      if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
        if (ch === 36) {
          this.pos += 2;
          return this.finishToken(types$1.dollarBraceL);
        } else {
          ++this.pos;
          return this.finishToken(types$1.backQuote);
        }
      }
      out2 += this.input.slice(chunkStart, this.pos);
      return this.finishToken(types$1.template, out2);
    }
    if (ch === 92) {
      out2 += this.input.slice(chunkStart, this.pos);
      out2 += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (isNewLine(ch)) {
      out2 += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
          }
        case 10:
          out2 += "\n";
          break;
        default:
          out2 += String.fromCharCode(ch);
          break;
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
};
pp.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++) {
    switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break;
      case "$":
        if (this.input[this.pos + 1] !== "{") {
          break;
        }
      case "`":
        return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
    }
  }
  this.raise(this.start, "Unterminated template");
};
pp.readEscapedChar = function(inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
    case 110:
      return "\n";
    case 114:
      return "\r";
    case 120:
      return String.fromCharCode(this.readHexChar(2));
    case 117:
      return codePointToString(this.readCodePoint());
    case 116:
      return "	";
    case 98:
      return "\b";
    case 118:
      return "\v";
    case 102:
      return "\f";
    case 13:
      if (this.input.charCodeAt(this.pos) === 10) {
        ++this.pos;
      }
    case 10:
      if (this.options.locations) {
        this.lineStart = this.pos;
        ++this.curLine;
      }
      return "";
    case 56:
    case 57:
      if (this.strict) {
        this.invalidStringToken(
          this.pos - 1,
          "Invalid escape sequence"
        );
      }
      if (inTemplate) {
        var codePos = this.pos - 1;
        this.invalidStringToken(
          codePos,
          "Invalid escape sequence in template string"
        );
      }
    default:
      if (ch >= 48 && ch <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);
        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }
        this.pos += octalStr.length - 1;
        ch = this.input.charCodeAt(this.pos);
        if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
          this.invalidStringToken(
            this.pos - 1 - octalStr.length,
            inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"
          );
        }
        return String.fromCharCode(octal);
      }
      if (isNewLine(ch)) {
        return "";
      }
      return String.fromCharCode(ch);
  }
};
pp.readHexChar = function(len) {
  var codePos = this.pos;
  var n3 = this.readInt(16, len);
  if (n3 === null) {
    this.invalidStringToken(codePos, "Bad character escape sequence");
  }
  return n3;
};
pp.readWord1 = function() {
  this.containsEsc = false;
  var word = "", first2 = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this.fullCharCodeAtPos();
    if (isIdentifierChar(ch, astral)) {
      this.pos += ch <= 65535 ? 1 : 2;
    } else if (ch === 92) {
      this.containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) !== 117) {
        this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
      }
      ++this.pos;
      var esc = this.readCodePoint();
      if (!(first2 ? isIdentifierStart : isIdentifierChar)(esc, astral)) {
        this.invalidStringToken(escStart, "Invalid Unicode escape");
      }
      word += codePointToString(esc);
      chunkStart = this.pos;
    } else {
      break;
    }
    first2 = false;
  }
  return word + this.input.slice(chunkStart, this.pos);
};
pp.readWord = function() {
  var word = this.readWord1();
  var type = types$1.name;
  if (this.keywords.test(word)) {
    type = keywords$2[word];
  }
  return this.finishToken(type, word);
};
var version$2 = "8.8.2";
Parser$1.acorn = {
  Parser: Parser$1,
  version: version$2,
  defaultOptions,
  Position,
  SourceLocation,
  getLineInfo,
  Node,
  TokenType,
  tokTypes: types$1,
  keywordTypes: keywords$2,
  TokContext,
  tokContexts: types$2,
  isIdentifierChar,
  isIdentifierStart,
  Token,
  isNewLine,
  lineBreak,
  lineBreakG,
  nonASCIIwhitespace
};
function parse$d(input, options3) {
  return Parser$1.parse(input, options3);
}
function parseExpressionAt2(input, pos, options3) {
  return Parser$1.parseExpressionAt(input, pos, options3);
}
function tokenizer2(input, options3) {
  return Parser$1.tokenizer(input, options3);
}
var acorn = {
  __proto__: null,
  Node,
  Parser: Parser$1,
  Position,
  SourceLocation,
  TokContext,
  Token,
  TokenType,
  defaultOptions,
  getLineInfo,
  isIdentifierChar,
  isIdentifierStart,
  isNewLine,
  keywordTypes: keywords$2,
  lineBreak,
  lineBreakG,
  nonASCIIwhitespace,
  parse: parse$d,
  parseExpressionAt: parseExpressionAt2,
  tokContexts: types$2,
  tokTypes: types$1,
  tokenizer: tokenizer2,
  version: version$2
};
var HASH_RE = /#/g;
var AMPERSAND_RE = /&/g;
var EQUAL_RE = /=/g;
var PLUS_RE = /\+/g;
var ENC_BRACKET_OPEN_RE = /%5b/gi;
var ENC_BRACKET_CLOSE_RE = /%5d/gi;
var ENC_CARET_RE = /%5e/gi;
var ENC_BACKTICK_RE = /%60/gi;
var ENC_CURLY_OPEN_RE = /%7b/gi;
var ENC_PIPE_RE = /%7c/gi;
var ENC_CURLY_CLOSE_RE = /%7d/gi;
var ENC_SPACE_RE = /%20/gi;
function encode(text) {
  return encodeURI("" + text).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]");
}
function encodeQueryValue(text) {
  return encode(text).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
}
function encodeQueryKey(text) {
  return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
}
function encodeQueryItem(key, value2) {
  if (typeof value2 === "number" || typeof value2 === "boolean") {
    value2 = String(value2);
  }
  if (!value2) {
    return encodeQueryKey(key);
  }
  if (Array.isArray(value2)) {
    return value2.map((_value) => `${encodeQueryKey(key)}=${encodeQueryValue(_value)}`).join("&");
  }
  return `${encodeQueryKey(key)}=${encodeQueryValue(value2)}`;
}
function stringifyQuery(query) {
  return Object.keys(query).filter((k) => query[k] !== void 0).map((k) => encodeQueryItem(k, query[k])).join("&");
}
function matchAll(regex, string3, addition) {
  const matches2 = [];
  for (const match of string3.matchAll(regex)) {
    matches2.push({
      ...addition,
      ...match.groups,
      code: match[0],
      start: match.index,
      end: match.index + match[0].length
    });
  }
  return matches2;
}
var isWindows$3 = import_node_process7.default.platform === "win32";
var own$1 = {}.hasOwnProperty;
function formatList(array2, type = "and") {
  return array2.length < 3 ? array2.join(` ${type} `) : `${array2.slice(0, -1).join(", ")}, ${type} ${array2[array2.length - 1]}`;
}
var messages = /* @__PURE__ */ new Map();
var nodeInternalPrefix = "__node_internal_";
var userStackTraceLimit;
createError2(
  "ERR_INVALID_MODULE_SPECIFIER",
  /**
   * @param {string} request
   * @param {string} reason
   * @param {string} [base]
   */
  (request, reason, base2 = void 0) => {
    return `Invalid module "${request}" ${reason}${base2 ? ` imported from ${base2}` : ""}`;
  },
  TypeError
);
createError2(
  "ERR_INVALID_PACKAGE_CONFIG",
  /**
   * @param {string} path
   * @param {string} [base]
   * @param {string} [message]
   */
  (path8, base2, message) => {
    return `Invalid package config ${path8}${base2 ? ` while importing ${base2}` : ""}${message ? `. ${message}` : ""}`;
  },
  Error
);
createError2(
  "ERR_INVALID_PACKAGE_TARGET",
  /**
   * @param {string} pkgPath
   * @param {string} key
   * @param {unknown} target
   * @param {boolean} [isImport=false]
   * @param {string} [base]
   */
  (pkgPath, key, target, isImport = false, base2 = void 0) => {
    const relError = typeof target === "string" && !isImport && target.length > 0 && !target.startsWith("./");
    if (key === ".") {
      (0, import_node_assert.default)(isImport === false);
      return `Invalid "exports" main target ${JSON.stringify(target)} defined in the package config ${pkgPath}package.json${base2 ? ` imported from ${base2}` : ""}${relError ? '; targets must start with "./"' : ""}`;
    }
    return `Invalid "${isImport ? "imports" : "exports"}" target ${JSON.stringify(
      target
    )} defined for '${key}' in the package config ${pkgPath}package.json${base2 ? ` imported from ${base2}` : ""}${relError ? '; targets must start with "./"' : ""}`;
  },
  Error
);
createError2(
  "ERR_MODULE_NOT_FOUND",
  /**
   * @param {string} path
   * @param {string} base
   * @param {string} [type]
   */
  (path8, base2, type = "package") => {
    return `Cannot find ${type} '${path8}' imported from ${base2}`;
  },
  Error
);
createError2(
  "ERR_NETWORK_IMPORT_DISALLOWED",
  "import of '%s' by %s is not supported: %s",
  Error
);
createError2(
  "ERR_PACKAGE_IMPORT_NOT_DEFINED",
  /**
   * @param {string} specifier
   * @param {string} packagePath
   * @param {string} base
   */
  (specifier, packagePath, base2) => {
    return `Package import specifier "${specifier}" is not defined${packagePath ? ` in package ${packagePath}package.json` : ""} imported from ${base2}`;
  },
  TypeError
);
createError2(
  "ERR_PACKAGE_PATH_NOT_EXPORTED",
  /**
   * @param {string} pkgPath
   * @param {string} subpath
   * @param {string} [base]
   */
  (pkgPath, subpath, base2 = void 0) => {
    if (subpath === ".")
      return `No "exports" main defined in ${pkgPath}package.json${base2 ? ` imported from ${base2}` : ""}`;
    return `Package subpath '${subpath}' is not defined by "exports" in ${pkgPath}package.json${base2 ? ` imported from ${base2}` : ""}`;
  },
  Error
);
createError2(
  "ERR_UNSUPPORTED_DIR_IMPORT",
  "Directory import '%s' is not supported resolving ES modules imported from %s",
  Error
);
createError2(
  "ERR_UNKNOWN_FILE_EXTENSION",
  /**
   * @param {string} ext
   * @param {string} path
   */
  (ext2, path8) => {
    return `Unknown file extension "${ext2}" for ${path8}`;
  },
  TypeError
);
createError2(
  "ERR_INVALID_ARG_VALUE",
  /**
   * @param {string} name
   * @param {unknown} value
   * @param {string} [reason='is invalid']
   */
  (name2, value2, reason = "is invalid") => {
    let inspected = (0, import_node_util.inspect)(value2);
    if (inspected.length > 128) {
      inspected = `${inspected.slice(0, 128)}...`;
    }
    const type = name2.includes(".") ? "property" : "argument";
    return `The ${type} '${name2}' ${reason}. Received ${inspected}`;
  },
  TypeError
  // Note: extra classes have been shaken out.
  // , RangeError
);
createError2(
  "ERR_UNSUPPORTED_ESM_URL_SCHEME",
  /**
   * @param {URL} url
   * @param {Array<string>} supported
   */
  (url2, supported) => {
    let message = `Only URLs with a scheme in: ${formatList(
      supported
    )} are supported by the default ESM loader`;
    if (isWindows$3 && url2.protocol.length === 2) {
      message += ". On Windows, absolute paths must be valid file:// URLs";
    }
    message += `. Received protocol '${url2.protocol}'`;
    return message;
  },
  Error
);
function createError2(sym, value2, def) {
  messages.set(sym, value2);
  return makeNodeErrorWithCode(def, sym);
}
function makeNodeErrorWithCode(Base, key) {
  return NodeError;
  function NodeError(...args) {
    const limit = Error.stackTraceLimit;
    if (isErrorStackTraceLimitWritable())
      Error.stackTraceLimit = 0;
    const error3 = new Base();
    if (isErrorStackTraceLimitWritable())
      Error.stackTraceLimit = limit;
    const message = getMessage(key, args, error3);
    Object.defineProperties(error3, {
      // Note: no need to implement `kIsNodeError` symbol, would be hard,
      // probably.
      message: {
        value: message,
        enumerable: false,
        writable: true,
        configurable: true
      },
      toString: {
        /** @this {Error} */
        value() {
          return `${this.name} [${key}]: ${this.message}`;
        },
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    captureLargerStackTrace(error3);
    error3.code = key;
    return error3;
  }
}
function isErrorStackTraceLimitWritable() {
  try {
    if (import_node_v8.default.startupSnapshot.isBuildingSnapshot()) {
      return false;
    }
  } catch {
  }
  const desc = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
  if (desc === void 0) {
    return Object.isExtensible(Error);
  }
  return own$1.call(desc, "writable") && desc.writable !== void 0 ? desc.writable : desc.set !== void 0;
}
function hideStackFrames(fn) {
  const hidden = nodeInternalPrefix + fn.name;
  Object.defineProperty(fn, "name", { value: hidden });
  return fn;
}
var captureLargerStackTrace = hideStackFrames(
  /**
   * @param {Error} error
   * @returns {Error}
   */
  // @ts-expect-error: fine
  function(error3) {
    const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();
    if (stackTraceLimitIsWritable) {
      userStackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = Number.POSITIVE_INFINITY;
    }
    Error.captureStackTrace(error3);
    if (stackTraceLimitIsWritable)
      Error.stackTraceLimit = userStackTraceLimit;
    return error3;
  }
);
function getMessage(key, args, self2) {
  const message = messages.get(key);
  (0, import_node_assert.default)(typeof message !== "undefined", "expected `message` to be found");
  if (typeof message === "function") {
    (0, import_node_assert.default)(
      message.length <= args.length,
      // Default options do not count.
      `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${message.length}).`
    );
    return Reflect.apply(message, self2, args);
  }
  const regex = /%[dfijoOs]/g;
  let expectedLength = 0;
  while (regex.exec(message) !== null)
    expectedLength++;
  (0, import_node_assert.default)(
    expectedLength === args.length,
    `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`
  );
  if (args.length === 0)
    return message;
  args.unshift(message);
  return Reflect.apply(import_node_util.format, null, args);
}
(0, import_node_url3.pathToFileURL)(process.cwd());
var ESM_STATIC_IMPORT_RE = new RegExp(`(?<=\\s|^|;)import\\s*([\\s"']*(?<imports>[\\w\\t\\n\\r $*,/{}]+)from\\s*)?["']\\s*(?<specifier>(?<="\\s*)[^"]*[^\\s"](?=\\s*")|(?<='\\s*)[^']*[^\\s'](?=\\s*'))\\s*["'][\\s;]*`, "gm");
var TYPE_RE = /^\s*?type\s/;
function findStaticImports(code) {
  return matchAll(ESM_STATIC_IMPORT_RE, code, { type: "static" });
}
function parseStaticImport(matched) {
  var _a, _b, _c, _d;
  const cleanedImports = (matched.imports || "").replace(/(\/\/[^\n]*\n|\/\*.*\*\/)/g, "").replace(/\s+/g, " ");
  const namedImports = {};
  for (const namedImport of ((_b = (_a = cleanedImports.match(/{([^}]*)}/)) == null ? void 0 : _a[1]) == null ? void 0 : _b.split(",")) || []) {
    const [, source = namedImport.trim(), importName = source] = namedImport.match(/^\s*(\S*) as (\S*)\s*$/) || [];
    if (source && !TYPE_RE.test(source)) {
      namedImports[source] = importName;
    }
  }
  const topLevelImports = cleanedImports.replace(/{([^}]*)}/, "");
  const namespacedImport = (_c = topLevelImports.match(/\* as \s*(\S*)/)) == null ? void 0 : _c[1];
  const defaultImport = ((_d = topLevelImports.split(",").find((index2) => !/[*{}]/.test(index2))) == null ? void 0 : _d.trim()) || void 0;
  return {
    ...matched,
    defaultImport,
    namespacedImport,
    namedImports
  };
}
var ESM_RE = /([\s;]|^)(import[\s\w*,{}]*from|import\s*["'*{]|export\b\s*(?:[*{]|default|class|type|function|const|var|let|async function)|import\.meta\b)/m;
function hasESMSyntax(code) {
  return ESM_RE.test(code);
}
var isDebug$5 = process.env.DEBUG;
var debug$d = createDebugger("vite:resolve-details", {
  onlyWhenFocused: true
});
function invalidatePackageData(packageCache, pkgPath) {
  packageCache.delete(pkgPath);
  const pkgDir = import_node_path4.default.dirname(pkgPath);
  packageCache.forEach((pkg, cacheKey) => {
    if (pkg.dir === pkgDir) {
      packageCache.delete(cacheKey);
    }
  });
}
function resolvePackageData(id, basedir, preserveSymlinks = false, packageCache) {
  let pkg;
  let cacheKey;
  if (packageCache) {
    cacheKey = `${id}&${basedir}&${preserveSymlinks}`;
    if (pkg = packageCache.get(cacheKey)) {
      return pkg;
    }
  }
  let pkgPath;
  try {
    pkgPath = resolveFrom(`${id}/package.json`, basedir, preserveSymlinks);
    pkg = loadPackageData(pkgPath, true, packageCache);
    if (packageCache) {
      packageCache.set(cacheKey, pkg);
    }
    return pkg;
  } catch (e3) {
    if (e3 instanceof SyntaxError) {
      isDebug$5 && debug$d(`Parsing failed: ${pkgPath}`);
    } else if (e3.code !== "MODULE_NOT_FOUND") {
      throw e3;
    }
  }
  return null;
}
function loadPackageData(pkgPath, preserveSymlinks, packageCache) {
  if (!preserveSymlinks) {
    pkgPath = import_node_fs4.default.realpathSync.native(pkgPath);
  }
  let cached;
  if (cached = packageCache == null ? void 0 : packageCache.get(pkgPath)) {
    return cached;
  }
  const data2 = JSON.parse(import_node_fs4.default.readFileSync(pkgPath, "utf-8"));
  const pkgDir = import_node_path4.default.dirname(pkgPath);
  const { sideEffects } = data2;
  let hasSideEffects;
  if (typeof sideEffects === "boolean") {
    hasSideEffects = () => sideEffects;
  } else if (Array.isArray(sideEffects)) {
    const finalPackageSideEffects = sideEffects.map((sideEffect) => {
      if (sideEffect.includes("/")) {
        return sideEffect;
      }
      return `**/${sideEffect}`;
    });
    hasSideEffects = createFilter2(finalPackageSideEffects, null, {
      resolve: pkgDir
    });
  } else {
    hasSideEffects = () => true;
  }
  const pkg = {
    dir: pkgDir,
    data: data2,
    hasSideEffects,
    webResolvedImports: {},
    nodeResolvedImports: {},
    setResolvedCache(key, entry2, targetWeb) {
      if (targetWeb) {
        pkg.webResolvedImports[key] = entry2;
      } else {
        pkg.nodeResolvedImports[key] = entry2;
      }
    },
    getResolvedCache(key, targetWeb) {
      if (targetWeb) {
        return pkg.webResolvedImports[key];
      } else {
        return pkg.nodeResolvedImports[key];
      }
    }
  };
  packageCache == null ? void 0 : packageCache.set(pkgPath, pkg);
  return pkg;
}
function watchPackageDataPlugin(config2) {
  const watchQueue = /* @__PURE__ */ new Set();
  let watchFile = (id) => {
    watchQueue.add(id);
  };
  const { packageCache } = config2;
  const setPackageData = packageCache.set.bind(packageCache);
  packageCache.set = (id, pkg) => {
    if (id.endsWith(".json")) {
      watchFile(id);
    }
    return setPackageData(id, pkg);
  };
  return {
    name: "vite:watch-package-data",
    buildStart() {
      watchFile = this.addWatchFile;
      watchQueue.forEach(watchFile);
      watchQueue.clear();
    },
    buildEnd() {
      watchFile = (id) => watchQueue.add(id);
    },
    watchChange(id) {
      if (id.endsWith("/package.json")) {
        invalidatePackageData(packageCache, id);
      }
    }
  };
}
var WORKER_FILE_ID = "worker_file";
var workerCache = /* @__PURE__ */ new WeakMap();
function isWorkerRequest(id) {
  const query = parseRequest(id);
  if (query && query[WORKER_FILE_ID] != null) {
    return true;
  }
  return false;
}
function saveEmitWorkerAsset(config2, asset) {
  const fileName = asset.fileName;
  const workerMap = workerCache.get(config2.mainConfig || config2);
  workerMap.assets.set(fileName, asset);
}
var workerConfigSemaphore = /* @__PURE__ */ new WeakMap();
async function bundleWorkerEntry(config2, id, query) {
  const processing2 = workerConfigSemaphore.get(config2);
  if (processing2) {
    await processing2;
    return bundleWorkerEntry(config2, id, query);
  }
  const promise2 = serialBundleWorkerEntry(config2, id, query);
  workerConfigSemaphore.set(config2, promise2);
  promise2.then(() => workerConfigSemaphore.delete(config2));
  return promise2;
}
async function serialBundleWorkerEntry(config2, id, query) {
  const { rollup } = await import("./rollup-GAFC2Y2B.js");
  const { plugins: plugins2, rollupOptions, format: format2 } = config2.worker;
  const bundle = await rollup({
    ...rollupOptions,
    input: cleanUrl(id),
    plugins: plugins2,
    onwarn(warning, warn4) {
      onRollupWarning(warning, warn4, config2);
    },
    preserveEntrySignatures: false
  });
  let chunk;
  try {
    const workerOutputConfig = config2.worker.rollupOptions.output;
    const workerConfig = workerOutputConfig ? Array.isArray(workerOutputConfig) ? workerOutputConfig[0] || {} : workerOutputConfig : {};
    const { output: [outputChunk, ...outputChunks] } = await bundle.generate({
      entryFileNames: import_node_path4.default.posix.join(config2.build.assetsDir, "[name]-[hash].js"),
      chunkFileNames: import_node_path4.default.posix.join(config2.build.assetsDir, "[name]-[hash].js"),
      assetFileNames: import_node_path4.default.posix.join(config2.build.assetsDir, "[name]-[hash].[ext]"),
      ...workerConfig,
      format: format2,
      sourcemap: config2.build.sourcemap
    });
    chunk = outputChunk;
    outputChunks.forEach((outputChunk2) => {
      if (outputChunk2.type === "asset") {
        saveEmitWorkerAsset(config2, outputChunk2);
      } else if (outputChunk2.type === "chunk") {
        saveEmitWorkerAsset(config2, {
          fileName: outputChunk2.fileName,
          source: outputChunk2.code,
          type: "asset"
        });
      }
    });
  } finally {
    await bundle.close();
  }
  return emitSourcemapForWorkerEntry(config2, query, chunk);
}
function emitSourcemapForWorkerEntry(config2, query, chunk) {
  const { map: sourcemap } = chunk;
  if (sourcemap) {
    if (config2.build.sourcemap === "hidden" || config2.build.sourcemap === true) {
      const data2 = sourcemap.toString();
      const mapFileName = chunk.fileName + ".map";
      saveEmitWorkerAsset(config2, {
        fileName: mapFileName,
        type: "asset",
        source: data2
      });
    }
  }
  return chunk;
}
var workerAssetUrlRE = /__VITE_WORKER_ASSET__([a-z\d]{8})__/g;
function encodeWorkerAssetFileName(fileName, workerCache2) {
  const { fileNameHash } = workerCache2;
  const hash2 = getHash(fileName);
  if (!fileNameHash.get(hash2)) {
    fileNameHash.set(hash2, fileName);
  }
  return `__VITE_WORKER_ASSET__${hash2}__`;
}
async function workerFileToUrl(config2, id, query) {
  const workerMap = workerCache.get(config2.mainConfig || config2);
  let fileName = workerMap.bundle.get(id);
  if (!fileName) {
    const outputChunk = await bundleWorkerEntry(config2, id, query);
    fileName = outputChunk.fileName;
    saveEmitWorkerAsset(config2, {
      fileName,
      source: outputChunk.code,
      type: "asset"
    });
    workerMap.bundle.set(id, fileName);
  }
  return encodeWorkerAssetFileName(fileName, workerMap);
}
function webWorkerPlugin(config2) {
  const isBuild = config2.command === "build";
  let server2;
  const isWorker = config2.isWorker;
  return {
    name: "vite:worker",
    configureServer(_server) {
      server2 = _server;
    },
    buildStart() {
      if (isWorker) {
        return;
      }
      workerCache.set(config2, {
        assets: /* @__PURE__ */ new Map(),
        bundle: /* @__PURE__ */ new Map(),
        fileNameHash: /* @__PURE__ */ new Map()
      });
    },
    load(id) {
      if (isBuild) {
        const parsedQuery = parseRequest(id);
        if (parsedQuery && (parsedQuery.worker ?? parsedQuery.sharedworker) != null) {
          return "";
        }
      }
    },
    async transform(raw, id, options3) {
      var _a, _b;
      const ssr = (options3 == null ? void 0 : options3.ssr) === true;
      const query = parseRequest(id);
      if (query && query[WORKER_FILE_ID] != null) {
        const workerType2 = query["type"];
        let injectEnv = "";
        if (workerType2 === "classic") {
          injectEnv = `importScripts('${ENV_PUBLIC_PATH}')
`;
        } else if (workerType2 === "module") {
          injectEnv = `import '${ENV_PUBLIC_PATH}'
`;
        } else if (workerType2 === "ignore") {
          if (isBuild) {
            injectEnv = "";
          } else if (server2) {
            const { moduleGraph } = server2;
            const module2 = moduleGraph.getModuleById(ENV_ENTRY);
            injectEnv = ((_a = module2 == null ? void 0 : module2.transformResult) == null ? void 0 : _a.code) || "";
          }
        }
        return {
          code: injectEnv + raw
        };
      }
      if (query == null || query && (query.worker ?? query.sharedworker) == null) {
        return;
      }
      let url2;
      const { format: format2 } = config2.worker;
      const workerConstructor = query.sharedworker != null ? "SharedWorker" : "Worker";
      const workerType = isBuild ? format2 === "es" ? "module" : "classic" : "module";
      const workerOptions = workerType === "classic" ? "" : ',{type: "module"}';
      if (isBuild) {
        (_b = getDepsOptimizer(config2, ssr)) == null ? void 0 : _b.registerWorkersSource(id);
        if (query.inline != null) {
          const chunk = await bundleWorkerEntry(config2, id, query);
          return {
            code: `const encodedJs = "${Buffer.from(chunk.code).toString("base64")}";
            const blob = typeof window !== "undefined" && window.Blob && new Blob([atob(encodedJs)], { type: "text/javascript;charset=utf-8" });
            export default function WorkerWrapper() {
              const objURL = blob && (window.URL || window.webkitURL).createObjectURL(blob);
              try {
                return objURL ? new ${workerConstructor}(objURL) : new ${workerConstructor}("data:application/javascript;base64," + encodedJs${workerOptions});
              } finally {
                objURL && (window.URL || window.webkitURL).revokeObjectURL(objURL);
              }
            }`,
            // Empty sourcemap to suppress Rollup warning
            map: { mappings: "" }
          };
        } else {
          url2 = await workerFileToUrl(config2, id, query);
        }
      } else {
        url2 = await fileToUrl(cleanUrl(id), config2, this);
        url2 = injectQuery(url2, WORKER_FILE_ID);
        url2 = injectQuery(url2, `type=${workerType}`);
      }
      if (query.url != null) {
        return {
          code: `export default ${JSON.stringify(url2)}`,
          map: { mappings: "" }
          // Empty sourcemap to suppress Rollup warning
        };
      }
      return {
        code: `export default function WorkerWrapper() {
          return new ${workerConstructor}(${JSON.stringify(url2)}${workerOptions})
        }`,
        map: { mappings: "" }
        // Empty sourcemap to suppress Rollup warning
      };
    },
    renderChunk(code, chunk, outputOptions) {
      let s2;
      const result = () => {
        return s2 && {
          code: s2.toString(),
          map: config2.build.sourcemap ? s2.generateMap({ hires: true }) : null
        };
      };
      if (code.match(workerAssetUrlRE) || code.includes("import.meta.url")) {
        const toRelativeRuntime = createToImportMetaURLBasedRelativeRuntime(outputOptions.format);
        let match;
        s2 = new MagicString(code);
        workerAssetUrlRE.lastIndex = 0;
        const workerMap = workerCache.get(config2.mainConfig || config2);
        const { fileNameHash } = workerMap;
        while (match = workerAssetUrlRE.exec(code)) {
          const [full, hash2] = match;
          const filename = fileNameHash.get(hash2);
          const replacement = toOutputFilePathInJS(filename, "asset", chunk.fileName, "js", config2, toRelativeRuntime);
          const replacementString = typeof replacement === "string" ? JSON.stringify(replacement).slice(1, -1) : `"+${replacement.runtime}+"`;
          s2.update(match.index, match.index + full.length, replacementString);
        }
      }
      return result();
    },
    generateBundle(opts) {
      if (opts.__vite_skip_asset_emit__ || isWorker) {
        return;
      }
      const workerMap = workerCache.get(config2);
      workerMap.assets.forEach((asset) => {
        this.emitFile(asset);
        workerMap.assets.delete(asset.fileName);
      });
    }
  };
}
var normalizedClientEntry$1 = normalizePath$3(CLIENT_ENTRY);
var normalizedEnvEntry$1 = normalizePath$3(ENV_ENTRY);
var browserExternalId = "__vite-browser-external";
var optionalPeerDepId = "__vite-optional-peer-dep";
var nodeModulesInPathRE = /(?:^|\/)node_modules\//;
var isDebug$4 = process.env.DEBUG;
var debug$c = createDebugger("vite:resolve-details", {
  onlyWhenFocused: true
});
function resolvePlugin(resolveOptions) {
  const { root, isProduction, asSrc, ssrConfig, preferRelative = false } = resolveOptions;
  const { target: ssrTarget, noExternal: ssrNoExternal } = ssrConfig ?? {};
  return {
    name: "vite:resolve",
    async resolveId(id, importer, resolveOpts) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
      const ssr = (resolveOpts == null ? void 0 : resolveOpts.ssr) === true;
      const depsOptimizer = (_a = resolveOptions.getDepsOptimizer) == null ? void 0 : _a.call(resolveOptions, ssr);
      if (id.startsWith(browserExternalId)) {
        return id;
      }
      const targetWeb = !ssr || ssrTarget === "webworker";
      const isRequire2 = ((_c = (_b = resolveOpts == null ? void 0 : resolveOpts.custom) == null ? void 0 : _b["node-resolve"]) == null ? void 0 : _c.isRequire) ?? false;
      const options3 = {
        isRequire: isRequire2,
        ...resolveOptions,
        scan: (resolveOpts == null ? void 0 : resolveOpts.scan) ?? resolveOptions.scan
      };
      if (importer) {
        const _importer = isWorkerRequest(importer) ? splitFileAndPostfix(importer).file : importer;
        if (isTsRequest(_importer) || ((_f = (_e = (_d = resolveOpts.custom) == null ? void 0 : _d.depScan) == null ? void 0 : _e.loader) == null ? void 0 : _f.startsWith("ts"))) {
          options3.isFromTsImporter = true;
        } else {
          const moduleLang = (_i = (_h = (_g = this.getModuleInfo(_importer)) == null ? void 0 : _g.meta) == null ? void 0 : _h.vite) == null ? void 0 : _i.lang;
          options3.isFromTsImporter = moduleLang && isTsRequest(`.${moduleLang}`);
        }
      }
      let res;
      if (asSrc && (depsOptimizer == null ? void 0 : depsOptimizer.isOptimizedDepUrl(id))) {
        const optimizedPath = id.startsWith(FS_PREFIX) ? fsPathFromId(id) : normalizePath$3(ensureVolumeInPath(import_node_path4.default.resolve(root, id.slice(1))));
        return optimizedPath;
      }
      const ensureVersionQuery = (resolved) => {
        if (!options3.isBuild && !options3.scan && depsOptimizer && !(resolved === normalizedClientEntry$1 || resolved === normalizedEnvEntry$1)) {
          const isNodeModule = nodeModulesInPathRE.test(normalizePath$3(id)) || nodeModulesInPathRE.test(normalizePath$3(resolved));
          if (isNodeModule && !resolved.match(DEP_VERSION_RE)) {
            const versionHash = depsOptimizer.metadata.browserHash;
            if (versionHash && isOptimizable(resolved, depsOptimizer.options)) {
              resolved = injectQuery(resolved, `v=${versionHash}`);
            }
          }
        }
        return resolved;
      };
      if (asSrc && id.startsWith(FS_PREFIX)) {
        const fsPath = fsPathFromId(id);
        res = tryFsResolve(fsPath, options3);
        isDebug$4 && debug$c(`[@fs] ${picocolorsExports.cyan(id)} -> ${picocolorsExports.dim(res)}`);
        return ensureVersionQuery(res || fsPath);
      }
      if (asSrc && id.startsWith("/")) {
        const fsPath = import_node_path4.default.resolve(root, id.slice(1));
        if (res = tryFsResolve(fsPath, options3)) {
          isDebug$4 && debug$c(`[url] ${picocolorsExports.cyan(id)} -> ${picocolorsExports.dim(res)}`);
          return ensureVersionQuery(res);
        }
      }
      if (id.startsWith(".") || (preferRelative || (importer == null ? void 0 : importer.endsWith(".html"))) && /^\w/.test(id)) {
        const basedir = importer ? import_node_path4.default.dirname(importer) : process.cwd();
        const fsPath = import_node_path4.default.resolve(basedir, id);
        const normalizedFsPath = normalizePath$3(fsPath);
        if (depsOptimizer == null ? void 0 : depsOptimizer.isOptimizedDepFile(normalizedFsPath)) {
          if (!normalizedFsPath.match(DEP_VERSION_RE)) {
            const browserHash = (_j = optimizedDepInfoFromFile(depsOptimizer.metadata, normalizedFsPath)) == null ? void 0 : _j.browserHash;
            if (browserHash) {
              return injectQuery(normalizedFsPath, `v=${browserHash}`);
            }
          }
          return normalizedFsPath;
        }
        if (targetWeb && options3.browserField && (res = tryResolveBrowserMapping(fsPath, importer, options3, true))) {
          return res;
        }
        if (res = tryFsResolve(fsPath, options3)) {
          res = ensureVersionQuery(res);
          isDebug$4 && debug$c(`[relative] ${picocolorsExports.cyan(id)} -> ${picocolorsExports.dim(res)}`);
          const pkg = importer != null && idToPkgMap.get(importer);
          if (pkg) {
            idToPkgMap.set(res, pkg);
            return {
              id: res,
              moduleSideEffects: pkg.hasSideEffects(res)
            };
          }
          return res;
        }
      }
      if (isWindows$4 && id.startsWith("/")) {
        const basedir = importer ? import_node_path4.default.dirname(importer) : process.cwd();
        const fsPath = import_node_path4.default.resolve(basedir, id);
        if (res = tryFsResolve(fsPath, options3)) {
          isDebug$4 && debug$c(`[drive-relative] ${picocolorsExports.cyan(id)} -> ${picocolorsExports.dim(res)}`);
          return ensureVersionQuery(res);
        }
      }
      if (isNonDriveRelativeAbsolutePath(id) && (res = tryFsResolve(id, options3))) {
        isDebug$4 && debug$c(`[fs] ${picocolorsExports.cyan(id)} -> ${picocolorsExports.dim(res)}`);
        return ensureVersionQuery(res);
      }
      if (isExternalUrl(id)) {
        return {
          id,
          external: true
        };
      }
      if (isDataUrl(id)) {
        return null;
      }
      if (bareImportRE.test(id)) {
        const external = (_k = options3.shouldExternalize) == null ? void 0 : _k.call(options3, id);
        if (!external && asSrc && depsOptimizer && !options3.scan && (res = await tryOptimizedResolve(depsOptimizer, id, importer))) {
          return res;
        }
        if (targetWeb && options3.browserField && (res = tryResolveBrowserMapping(id, importer, options3, false, external))) {
          return res;
        }
        if (res = tryNodeResolve(id, importer, options3, targetWeb, depsOptimizer, ssr, external)) {
          return res;
        }
        if (isBuiltin(id)) {
          if (ssr) {
            if (ssrNoExternal === true) {
              let message = `Cannot bundle Node.js built-in "${id}"`;
              if (importer) {
                message += ` imported from "${import_node_path4.default.relative(process.cwd(), importer)}"`;
              }
              message += `. Consider disabling ssr.noExternal or remove the built-in dependency.`;
              this.error(message);
            }
            return {
              id,
              external: true
            };
          } else {
            if (!asSrc) {
              debug$c(`externalized node built-in "${id}" to empty module. (imported by: ${picocolorsExports.white(picocolorsExports.dim(importer))})`);
            }
            return isProduction ? browserExternalId : `${browserExternalId}:${id}`;
          }
        }
      }
      isDebug$4 && debug$c(`[fallthrough] ${picocolorsExports.dim(id)}`);
    },
    load(id) {
      if (id.startsWith(browserExternalId)) {
        if (isProduction) {
          return `export default {}`;
        } else {
          id = id.slice(browserExternalId.length + 1);
          return `export default new Proxy({}, {
  get(_, key) {
    throw new Error(\`Module "${id}" has been externalized for browser compatibility. Cannot access "${id}.\${key}" in client code.  See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.\`)
  }
})`;
        }
      }
      if (id.startsWith(optionalPeerDepId)) {
        if (isProduction) {
          return `export default {}`;
        } else {
          const [, peerDep, parentDep] = id.split(":");
          return `throw new Error(\`Could not resolve "${peerDep}" imported by "${parentDep}". Is it installed?\`)`;
        }
      }
    }
  };
}
function splitFileAndPostfix(path8) {
  let file = path8;
  let postfix = "";
  let postfixIndex = path8.indexOf("?");
  if (postfixIndex < 0) {
    postfixIndex = path8.indexOf("#");
  }
  if (postfixIndex > 0) {
    file = path8.slice(0, postfixIndex);
    postfix = path8.slice(postfixIndex);
  }
  return { file, postfix };
}
function tryFsResolve(fsPath, options3, tryIndex = true, targetWeb = true) {
  const { file, postfix } = splitFileAndPostfix(fsPath);
  let res;
  if (postfix && (res = tryResolveFile(fsPath, "", options3, false, targetWeb, options3.tryPrefix, options3.skipPackageJson))) {
    return res;
  }
  if (res = tryResolveFile(file, postfix, options3, false, targetWeb, options3.tryPrefix, options3.skipPackageJson)) {
    return res;
  }
  for (const ext2 of options3.extensions) {
    if (postfix && (res = tryResolveFile(fsPath + ext2, "", options3, false, targetWeb, options3.tryPrefix, options3.skipPackageJson, false))) {
      return res;
    }
    if (res = tryResolveFile(file + ext2, postfix, options3, false, targetWeb, options3.tryPrefix, options3.skipPackageJson, false)) {
      return res;
    }
  }
  if (!tryIndex)
    return;
  if (postfix && (res = tryResolveFile(fsPath, "", options3, tryIndex, targetWeb, options3.tryPrefix, options3.skipPackageJson))) {
    return res;
  }
  if (res = tryResolveFile(file, postfix, options3, tryIndex, targetWeb, options3.tryPrefix, options3.skipPackageJson)) {
    return res;
  }
}
function tryResolveFile(file, postfix, options3, tryIndex, targetWeb, tryPrefix, skipPackageJson, skipTsExtension) {
  let stat2;
  try {
    stat2 = import_node_fs4.default.statSync(file, { throwIfNoEntry: false });
  } catch {
    return;
  }
  if (stat2) {
    if (!stat2.isDirectory()) {
      return getRealPath(file, options3.preserveSymlinks) + postfix;
    } else if (tryIndex) {
      if (!skipPackageJson) {
        const pkgPath = file + "/package.json";
        try {
          const pkg = loadPackageData(pkgPath, options3.preserveSymlinks);
          const resolved = resolvePackageEntry(file, pkg, targetWeb, options3);
          return resolved;
        } catch (e3) {
          if (e3.code !== "ENOENT") {
            throw e3;
          }
        }
      }
      const index2 = tryFsResolve(file + "/index", options3);
      if (index2)
        return index2 + postfix;
    }
  }
  if (!skipTsExtension && options3.isFromTsImporter && isPossibleTsOutput(file)) {
    const tsSrcPaths = getPotentialTsSrcPaths(file);
    for (const srcPath of tsSrcPaths) {
      const res = tryResolveFile(srcPath, postfix, options3, tryIndex, targetWeb, tryPrefix, skipPackageJson, true);
      if (res)
        return res;
    }
    return;
  }
  if (tryPrefix) {
    const prefixed = `${import_node_path4.default.dirname(file)}/${tryPrefix}${import_node_path4.default.basename(file)}`;
    return tryResolveFile(prefixed, postfix, options3, tryIndex, targetWeb);
  }
}
var idToPkgMap = /* @__PURE__ */ new Map();
function tryNodeResolve(id, importer, options3, targetWeb, depsOptimizer, ssr, externalize, allowLinkedExternal = true) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const { root, dedupe, isBuild, preserveSymlinks, packageCache } = options3;
  ssr ?? (ssr = false);
  const lastArrowIndex = id.lastIndexOf(">");
  const nestedRoot = id.substring(0, lastArrowIndex).trim();
  const nestedPath = id.substring(lastArrowIndex + 1).trim();
  const possiblePkgIds = [];
  for (let prevSlashIndex = -1; ; ) {
    let slashIndex = nestedPath.indexOf("/", prevSlashIndex + 1);
    if (slashIndex < 0) {
      slashIndex = nestedPath.length;
    }
    const part = nestedPath.slice(prevSlashIndex + 1, prevSlashIndex = slashIndex);
    if (!part) {
      break;
    }
    if (possiblePkgIds.length ? import_node_path4.default.extname(part) : part[0] === "@") {
      continue;
    }
    const possiblePkgId = nestedPath.slice(0, slashIndex);
    possiblePkgIds.push(possiblePkgId);
  }
  let basedir;
  if (dedupe == null ? void 0 : dedupe.some((id2) => possiblePkgIds.includes(id2))) {
    basedir = root;
  } else if (importer && import_node_path4.default.isAbsolute(importer) && import_node_fs4.default.existsSync(cleanUrl(importer))) {
    basedir = import_node_path4.default.dirname(importer);
  } else {
    basedir = root;
  }
  if (nestedRoot) {
    basedir = nestedResolveFrom(nestedRoot, basedir, preserveSymlinks);
  }
  let pkg;
  let pkgId;
  let nearestPkg;
  const rootPkgId = possiblePkgIds[0];
  const rootPkg = resolvePackageData(rootPkgId, basedir, preserveSymlinks, packageCache);
  const nearestPkgId = [...possiblePkgIds].reverse().find((pkgId2) => {
    nearestPkg = resolvePackageData(pkgId2, basedir, preserveSymlinks, packageCache);
    return nearestPkg;
  });
  if ((_a = rootPkg == null ? void 0 : rootPkg.data) == null ? void 0 : _a.exports) {
    pkgId = rootPkgId;
    pkg = rootPkg;
  } else {
    pkgId = nearestPkgId;
    pkg = nearestPkg;
  }
  if (!pkg || !nearestPkg) {
    if (basedir !== root && // root has no peer dep
    !isBuiltin(nestedPath) && !nestedPath.includes("\0") && bareImportRE.test(nestedPath)) {
      const mainPackageJson = lookupFile(basedir, ["package.json"], {
        predicate: (content) => !!JSON.parse(content).name
      });
      if (mainPackageJson) {
        const mainPkg = JSON.parse(mainPackageJson);
        if (((_b = mainPkg.peerDependencies) == null ? void 0 : _b[nestedPath]) && ((_d = (_c = mainPkg.peerDependenciesMeta) == null ? void 0 : _c[nestedPath]) == null ? void 0 : _d.optional)) {
          return {
            id: `${optionalPeerDepId}:${nestedPath}:${mainPkg.name}`
          };
        }
      }
    }
    return;
  }
  let resolveId = resolvePackageEntry;
  let unresolvedId = pkgId;
  const isDeepImport = unresolvedId !== nestedPath;
  if (isDeepImport) {
    resolveId = resolveDeepImport;
    unresolvedId = "." + nestedPath.slice(pkgId.length);
  }
  let resolved;
  try {
    resolved = resolveId(unresolvedId, pkg, targetWeb, options3);
  } catch (err2) {
    if (!options3.tryEsmOnly) {
      throw err2;
    }
  }
  if (!resolved && options3.tryEsmOnly) {
    resolved = resolveId(unresolvedId, pkg, targetWeb, {
      ...options3,
      isRequire: false,
      mainFields: DEFAULT_MAIN_FIELDS,
      extensions: DEFAULT_EXTENSIONS
    });
  }
  if (!resolved) {
    return;
  }
  const processResult2 = (resolved2) => {
    if (!externalize) {
      return resolved2;
    }
    if (!allowLinkedExternal && !resolved2.id.includes("node_modules")) {
      return resolved2;
    }
    const resolvedExt = import_node_path4.default.extname(resolved2.id);
    if (resolvedExt && resolvedExt !== ".js" && resolvedExt !== ".mjs" && resolvedExt !== ".cjs") {
      return resolved2;
    }
    let resolvedId = id;
    if (isDeepImport) {
      if (!(pkg == null ? void 0 : pkg.data.exports) && import_node_path4.default.extname(id) !== resolvedExt) {
        resolvedId = resolved2.id.slice(resolved2.id.indexOf(id));
        isDebug$4 && debug$c(`[processResult] ${picocolorsExports.cyan(id)} -> ${picocolorsExports.dim(resolvedId)}`);
      }
    }
    return { ...resolved2, id: resolvedId, external: true };
  };
  idToPkgMap.set(resolved, pkg);
  if (isBuild && !depsOptimizer || externalize) {
    return processResult2({
      id: resolved,
      moduleSideEffects: pkg.hasSideEffects(resolved)
    });
  }
  const ext2 = import_node_path4.default.extname(resolved);
  const isCJS = ext2 === ".cjs" || ext2 === ".js" && nearestPkg.data.type !== "module";
  if (!options3.ssrOptimizeCheck && (!resolved.includes("node_modules") || // linked
  !depsOptimizer || // resolving before listening to the server
  options3.scan)) {
    return { id: resolved };
  }
  const isJsType = depsOptimizer ? isOptimizable(resolved, depsOptimizer.options) : OPTIMIZABLE_ENTRY_RE.test(resolved);
  let exclude = depsOptimizer == null ? void 0 : depsOptimizer.options.exclude;
  let include = depsOptimizer == null ? void 0 : depsOptimizer.options.include;
  if (options3.ssrOptimizeCheck) {
    exclude = (_f = (_e = options3.ssrConfig) == null ? void 0 : _e.optimizeDeps) == null ? void 0 : _f.exclude;
    include = (_h = (_g = options3.ssrConfig) == null ? void 0 : _g.optimizeDeps) == null ? void 0 : _h.include;
  }
  const skipOptimization = !isJsType || (importer == null ? void 0 : importer.includes("node_modules")) || (exclude == null ? void 0 : exclude.includes(pkgId)) || (exclude == null ? void 0 : exclude.includes(nestedPath)) || SPECIAL_QUERY_RE.test(resolved) || // During dev SSR, we don't have a way to reload the module graph if
  // a non-optimized dep is found. So we need to skip optimization here.
  // The only optimized deps are the ones explicitly listed in the config.
  !options3.ssrOptimizeCheck && !isBuild && ssr || // Only optimize non-external CJS deps during SSR by default
  ssr && !isCJS && !((include == null ? void 0 : include.includes(pkgId)) || (include == null ? void 0 : include.includes(nestedPath)));
  if (options3.ssrOptimizeCheck) {
    return {
      id: skipOptimization ? injectQuery(resolved, `__vite_skip_optimization`) : resolved
    };
  }
  if (skipOptimization) {
    if (!isBuild) {
      const versionHash = depsOptimizer.metadata.browserHash;
      if (versionHash && isJsType) {
        resolved = injectQuery(resolved, `v=${versionHash}`);
      }
    }
  } else {
    const optimizedInfo = depsOptimizer.registerMissingImport(id, resolved);
    resolved = depsOptimizer.getOptimizedDepId(optimizedInfo);
  }
  if (isBuild) {
    return {
      id: resolved,
      moduleSideEffects: pkg.hasSideEffects(resolved)
    };
  } else {
    return { id: resolved };
  }
}
async function tryOptimizedResolve(depsOptimizer, id, importer) {
  await depsOptimizer.scanProcessing;
  const metadata = depsOptimizer.metadata;
  const depInfo = optimizedDepInfoFromId(metadata, id);
  if (depInfo) {
    return depsOptimizer.getOptimizedDepId(depInfo);
  }
  if (!importer)
    return;
  let resolvedSrc;
  for (const optimizedData of metadata.depInfoList) {
    if (!optimizedData.src)
      continue;
    const pkgPath = optimizedData.id;
    if (!pkgPath.endsWith(id))
      continue;
    if (resolvedSrc == null) {
      try {
        resolvedSrc = normalizePath$3(resolveFrom(id, import_node_path4.default.dirname(importer)));
      } catch {
        break;
      }
    }
    if (optimizedData.src === resolvedSrc) {
      return depsOptimizer.getOptimizedDepId(optimizedData);
    }
  }
}
function resolvePackageEntry(id, { dir, data: data2, setResolvedCache, getResolvedCache }, targetWeb, options3) {
  const cached = getResolvedCache(".", targetWeb);
  if (cached) {
    return cached;
  }
  try {
    let entryPoint;
    if (data2.exports) {
      entryPoint = resolveExports(data2, ".", options3, targetWeb);
    }
    const resolvedFromExports = !!entryPoint;
    if (targetWeb && options3.browserField && (!entryPoint || entryPoint.endsWith(".mjs"))) {
      const browserEntry = typeof data2.browser === "string" ? data2.browser : isObject$1(data2.browser) && data2.browser["."];
      if (browserEntry) {
        if (!options3.isRequire && options3.mainFields.includes("module") && typeof data2.module === "string" && data2.module !== browserEntry) {
          const resolvedBrowserEntry = tryFsResolve(import_node_path4.default.join(dir, browserEntry), options3);
          if (resolvedBrowserEntry) {
            const content = import_node_fs4.default.readFileSync(resolvedBrowserEntry, "utf-8");
            if (hasESMSyntax(content)) {
              entryPoint = browserEntry;
            } else {
              entryPoint = data2.module;
            }
          }
        } else {
          entryPoint = browserEntry;
        }
      }
    }
    if (!resolvedFromExports && (!entryPoint || entryPoint.endsWith(".mjs"))) {
      for (const field of options3.mainFields) {
        if (field === "browser")
          continue;
        if (typeof data2[field] === "string") {
          entryPoint = data2[field];
          break;
        }
      }
    }
    entryPoint || (entryPoint = data2.main);
    const entryPoints = entryPoint ? [entryPoint] : ["index.js", "index.json", "index.node"];
    for (let entry2 of entryPoints) {
      if (options3.mainFields[0] === "sass" && !options3.extensions.includes(import_node_path4.default.extname(entry2))) {
        entry2 = "";
        options3.skipPackageJson = true;
      }
      const { browser: browserField } = data2;
      if (targetWeb && options3.browserField && isObject$1(browserField)) {
        entry2 = mapWithBrowserField(entry2, browserField) || entry2;
      }
      const entryPointPath = import_node_path4.default.join(dir, entry2);
      const resolvedEntryPoint = tryFsResolve(entryPointPath, options3);
      if (resolvedEntryPoint) {
        isDebug$4 && debug$c(`[package entry] ${picocolorsExports.cyan(id)} -> ${picocolorsExports.dim(resolvedEntryPoint)}`);
        setResolvedCache(".", resolvedEntryPoint, targetWeb);
        return resolvedEntryPoint;
      }
    }
  } catch (e3) {
    packageEntryFailure(id, e3.message);
  }
  packageEntryFailure(id);
}
function packageEntryFailure(id, details) {
  throw new Error(`Failed to resolve entry for package "${id}". The package may have incorrect main/module/exports specified in its package.json` + (details ? ": " + details : "."));
}
var conditionalConditions = /* @__PURE__ */ new Set(["production", "development", "module"]);
function resolveExports(pkg, key, options3, targetWeb) {
  const overrideConditions = options3.overrideConditions ? new Set(options3.overrideConditions) : void 0;
  const conditions = [];
  if ((!overrideConditions || overrideConditions.has("production")) && options3.isProduction) {
    conditions.push("production");
  }
  if ((!overrideConditions || overrideConditions.has("development")) && !options3.isProduction) {
    conditions.push("development");
  }
  if ((!overrideConditions || overrideConditions.has("module")) && !options3.isRequire) {
    conditions.push("module");
  }
  if (options3.overrideConditions) {
    conditions.push(...options3.overrideConditions.filter((condition) => conditionalConditions.has(condition)));
  } else if (options3.conditions.length > 0) {
    conditions.push(...options3.conditions);
  }
  const result = o(pkg, key, {
    browser: targetWeb && !conditions.includes("node"),
    require: options3.isRequire && !conditions.includes("import"),
    conditions
  });
  return result ? result[0] : void 0;
}
function resolveDeepImport(id, { webResolvedImports, setResolvedCache, getResolvedCache, dir, data: data2 }, targetWeb, options3) {
  const cache2 = getResolvedCache(id, targetWeb);
  if (cache2) {
    return cache2;
  }
  let relativeId = id;
  const { exports: exportsField, browser: browserField } = data2;
  if (exportsField) {
    if (isObject$1(exportsField) && !Array.isArray(exportsField)) {
      const { file, postfix } = splitFileAndPostfix(relativeId);
      const exportsId = resolveExports(data2, file, options3, targetWeb);
      if (exportsId !== void 0) {
        relativeId = exportsId + postfix;
      } else {
        relativeId = void 0;
      }
    } else {
      relativeId = void 0;
    }
    if (!relativeId) {
      throw new Error(`Package subpath '${relativeId}' is not defined by "exports" in ${import_node_path4.default.join(dir, "package.json")}.`);
    }
  } else if (targetWeb && options3.browserField && isObject$1(browserField)) {
    const { file, postfix } = splitFileAndPostfix(relativeId);
    const mapped = mapWithBrowserField(file, browserField);
    if (mapped) {
      relativeId = mapped + postfix;
    } else if (mapped === false) {
      return webResolvedImports[id] = browserExternalId;
    }
  }
  if (relativeId) {
    const resolved = tryFsResolve(
      import_node_path4.default.join(dir, relativeId),
      options3,
      !exportsField,
      // try index only if no exports field
      targetWeb
    );
    if (resolved) {
      isDebug$4 && debug$c(`[node/deep-import] ${picocolorsExports.cyan(id)} -> ${picocolorsExports.dim(resolved)}`);
      setResolvedCache(id, resolved, targetWeb);
      return resolved;
    }
  }
}
function tryResolveBrowserMapping(id, importer, options3, isFilePath, externalize) {
  let res;
  const pkg = importer && (idToPkgMap.get(importer) || resolvePkg(importer, options3));
  if (pkg && isObject$1(pkg.data.browser)) {
    const mapId = isFilePath ? "./" + slash$1(import_node_path4.default.relative(pkg.dir, id)) : id;
    const browserMappedPath = mapWithBrowserField(mapId, pkg.data.browser);
    if (browserMappedPath) {
      const fsPath = import_node_path4.default.join(pkg.dir, browserMappedPath);
      if (res = tryFsResolve(fsPath, options3)) {
        isDebug$4 && debug$c(`[browser mapped] ${picocolorsExports.cyan(id)} -> ${picocolorsExports.dim(res)}`);
        idToPkgMap.set(res, pkg);
        const result = {
          id: res,
          moduleSideEffects: pkg.hasSideEffects(res)
        };
        return externalize ? { ...result, external: true } : result;
      }
    } else if (browserMappedPath === false) {
      return browserExternalId;
    }
  }
}
function mapWithBrowserField(relativePathInPkgDir, map3) {
  const normalizedPath = import_node_path4.default.posix.normalize(relativePathInPkgDir);
  for (const key in map3) {
    const normalizedKey = import_node_path4.default.posix.normalize(key);
    if (normalizedPath === normalizedKey || equalWithoutSuffix(normalizedPath, normalizedKey, ".js") || equalWithoutSuffix(normalizedPath, normalizedKey, "/index.js")) {
      return map3[key];
    }
  }
}
function equalWithoutSuffix(path8, key, suffix) {
  return key.endsWith(suffix) && key.slice(0, -suffix.length) === path8;
}
function getRealPath(resolved, preserveSymlinks) {
  resolved = ensureVolumeInPath(resolved);
  if (!preserveSymlinks && browserExternalId !== resolved) {
    resolved = import_node_fs4.default.realpathSync(resolved);
  }
  return normalizePath$3(resolved);
}
function resolvePkg(importer, options3) {
  const { root, preserveSymlinks, packageCache } = options3;
  if (importer.includes("\0")) {
    return null;
  }
  const possiblePkgIds = [];
  for (let prevSlashIndex = -1; ; ) {
    const slashIndex = importer.indexOf(isWindows$4 ? "\\" : "/", prevSlashIndex);
    if (slashIndex < 0) {
      break;
    }
    prevSlashIndex = slashIndex + 1;
    const possiblePkgId = importer.slice(0, slashIndex);
    possiblePkgIds.push(possiblePkgId);
  }
  let pkg;
  possiblePkgIds.reverse().find((pkgId) => {
    pkg = resolvePackageData(pkgId, root, preserveSymlinks, packageCache);
    return pkg;
  });
  if (pkg) {
    idToPkgMap.set(importer, pkg);
  }
  return pkg;
}
var externalWithConversionNamespace = "vite:dep-pre-bundle:external-conversion";
var convertedExternalPrefix = "vite-dep-pre-bundle-external:";
var cjsExternalFacadeNamespace = "vite:cjs-external-facade";
var nonFacadePrefix = "vite-cjs-external-facade:";
var externalTypes = [
  "css",
  // supported pre-processor types
  "less",
  "sass",
  "scss",
  "styl",
  "stylus",
  "pcss",
  "postcss",
  // wasm
  "wasm",
  // known SFC types
  "vue",
  "svelte",
  "marko",
  "astro",
  "imba",
  // JSX/TSX may be configured to be compiled differently from how esbuild
  // handles it by default, so exclude them as well
  "jsx",
  "tsx",
  ...KNOWN_ASSET_TYPES
];
function esbuildDepPlugin(qualified, external, config2, ssr) {
  const { extensions: extensions2 } = getDepOptimizationConfig(config2, ssr);
  const allExternalTypes = extensions2 ? externalTypes.filter((type) => !(extensions2 == null ? void 0 : extensions2.includes("." + type))) : externalTypes;
  const _resolve = config2.createResolver({ asSrc: false, scan: true });
  const _resolveRequire = config2.createResolver({
    asSrc: false,
    isRequire: true,
    scan: true
  });
  const resolve4 = (id, importer, kind, resolveDir) => {
    let _importer;
    if (resolveDir) {
      _importer = normalizePath$3(import_node_path4.default.join(resolveDir, "*"));
    } else {
      _importer = importer in qualified ? qualified[importer] : importer;
    }
    const resolver = kind.startsWith("require") ? _resolveRequire : _resolve;
    return resolver(id, _importer, void 0, ssr);
  };
  const resolveResult = (id, resolved) => {
    if (resolved.startsWith(browserExternalId)) {
      return {
        path: id,
        namespace: "browser-external"
      };
    }
    if (resolved.startsWith(optionalPeerDepId)) {
      return {
        path: resolved,
        namespace: "optional-peer-dep"
      };
    }
    if (ssr && isBuiltin(resolved)) {
      return;
    }
    if (isExternalUrl(resolved)) {
      return {
        path: resolved,
        external: true
      };
    }
    return {
      path: import_node_path4.default.resolve(resolved)
    };
  };
  return {
    name: "vite:dep-pre-bundle",
    setup(build4) {
      build4.onResolve({
        filter: new RegExp(`\\.(` + allExternalTypes.join("|") + `)(\\?.*)?$`)
      }, async ({ path: id, importer, kind }) => {
        if (id.startsWith(convertedExternalPrefix)) {
          return {
            path: id.slice(convertedExternalPrefix.length),
            external: true
          };
        }
        const resolved = await resolve4(id, importer, kind);
        if (resolved) {
          if (kind === "require-call") {
            return {
              path: resolved,
              namespace: externalWithConversionNamespace
            };
          }
          return {
            path: resolved,
            external: true
          };
        }
      });
      build4.onLoad({ filter: /./, namespace: externalWithConversionNamespace }, (args) => {
        return {
          contents: `export { default } from "${convertedExternalPrefix}${args.path}";export * from "${convertedExternalPrefix}${args.path}";`,
          loader: "js"
        };
      });
      function resolveEntry(id) {
        const flatId = flattenId(id);
        if (flatId in qualified) {
          return {
            path: qualified[flatId]
          };
        }
      }
      build4.onResolve({ filter: /^[\w@][^:]/ }, async ({ path: id, importer, kind }) => {
        if (moduleListContains(external, id)) {
          return {
            path: id,
            external: true
          };
        }
        let entry2;
        if (!importer) {
          if (entry2 = resolveEntry(id))
            return entry2;
          const aliased = await _resolve(id, void 0, true);
          if (aliased && (entry2 = resolveEntry(aliased))) {
            return entry2;
          }
        }
        const resolved = await resolve4(id, importer, kind);
        if (resolved) {
          return resolveResult(id, resolved);
        }
      });
      build4.onLoad({ filter: /.*/, namespace: "browser-external" }, ({ path: path8 }) => {
        if (config2.isProduction) {
          return {
            contents: "module.exports = {}"
          };
        } else {
          return {
            // Return in CJS to intercept named imports. Use `Object.create` to
            // create the Proxy in the prototype to workaround esbuild issue. Why?
            //
            // In short, esbuild cjs->esm flow:
            // 1. Create empty object using `Object.create(Object.getPrototypeOf(module.exports))`.
            // 2. Assign props of `module.exports` to the object.
            // 3. Return object for ESM use.
            //
            // If we do `module.exports = new Proxy({}, {})`, step 1 returns empty object,
            // step 2 does nothing as there's no props for `module.exports`. The final object
            // is just an empty object.
            //
            // Creating the Proxy in the prototype satisfies step 1 immediately, which means
            // the returned object is a Proxy that we can intercept.
            //
            // Note: Skip keys that are accessed by esbuild and browser devtools.
            contents: `module.exports = Object.create(new Proxy({}, {
  get(_, key) {
    if (
      key !== '__esModule' &&
      key !== '__proto__' &&
      key !== 'constructor' &&
      key !== 'splice'
    ) {
      console.warn(\`Module "${path8}" has been externalized for browser compatibility. Cannot access "${path8}.\${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.\`)
    }
  }
}))`
          };
        }
      });
      build4.onLoad({ filter: /.*/, namespace: "optional-peer-dep" }, ({ path: path8 }) => {
        if (config2.isProduction) {
          return {
            contents: "module.exports = {}"
          };
        } else {
          const [, peerDep, parentDep] = path8.split(":");
          return {
            contents: `throw new Error(\`Could not resolve "${peerDep}" imported by "${parentDep}". Is it installed?\`)`
          };
        }
      });
    }
  };
}
function esbuildCjsExternalPlugin(externals, platform2) {
  return {
    name: "cjs-external",
    setup(build4) {
      const escape2 = (text) => `^${text.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&")}$`;
      const filter2 = new RegExp(externals.map(escape2).join("|"));
      build4.onResolve({ filter: new RegExp(`^${nonFacadePrefix}`) }, (args) => {
        return {
          path: args.path.slice(nonFacadePrefix.length),
          external: true
        };
      });
      build4.onResolve({ filter: filter2 }, (args) => {
        if (args.kind === "require-call" && platform2 !== "node") {
          return {
            path: args.path,
            namespace: cjsExternalFacadeNamespace
          };
        }
        return {
          path: args.path,
          external: true
        };
      });
      build4.onLoad({ filter: /.*/, namespace: cjsExternalFacadeNamespace }, (args) => ({
        contents: `import * as m from ${JSON.stringify(nonFacadePrefix + args.path)};module.exports = m;`
      }));
    }
  };
}
var tasks = {};
var utils$g = {};
var array$1 = {};
Object.defineProperty(array$1, "__esModule", { value: true });
array$1.splitWhen = array$1.flatten = void 0;
function flatten$1(items) {
  return items.reduce((collection, item) => [].concat(collection, item), []);
}
array$1.flatten = flatten$1;
function splitWhen(items, predicate) {
  const result = [[]];
  let groupIndex = 0;
  for (const item of items) {
    if (predicate(item)) {
      groupIndex++;
      result[groupIndex] = [];
    } else {
      result[groupIndex].push(item);
    }
  }
  return result;
}
array$1.splitWhen = splitWhen;
var errno$1 = {};
Object.defineProperty(errno$1, "__esModule", { value: true });
errno$1.isEnoentCodeError = void 0;
function isEnoentCodeError(error3) {
  return error3.code === "ENOENT";
}
errno$1.isEnoentCodeError = isEnoentCodeError;
var fs$h = {};
Object.defineProperty(fs$h, "__esModule", { value: true });
fs$h.createDirentFromStats = void 0;
var DirentFromStats$1 = class DirentFromStats {
  constructor(name2, stats) {
    this.name = name2;
    this.isBlockDevice = stats.isBlockDevice.bind(stats);
    this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
    this.isDirectory = stats.isDirectory.bind(stats);
    this.isFIFO = stats.isFIFO.bind(stats);
    this.isFile = stats.isFile.bind(stats);
    this.isSocket = stats.isSocket.bind(stats);
    this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
  }
};
function createDirentFromStats$1(name2, stats) {
  return new DirentFromStats$1(name2, stats);
}
fs$h.createDirentFromStats = createDirentFromStats$1;
var path$h = {};
Object.defineProperty(path$h, "__esModule", { value: true });
path$h.removeLeadingDotSegment = path$h.escape = path$h.makeAbsolute = path$h.unixify = void 0;
var path$g = import_path.default;
var LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2;
var UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\())/g;
function unixify(filepath) {
  return filepath.replace(/\\/g, "/");
}
path$h.unixify = unixify;
function makeAbsolute(cwd, filepath) {
  return path$g.resolve(cwd, filepath);
}
path$h.makeAbsolute = makeAbsolute;
function escape$2(pattern2) {
  return pattern2.replace(UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
}
path$h.escape = escape$2;
function removeLeadingDotSegment(entry2) {
  if (entry2.charAt(0) === ".") {
    const secondCharactery = entry2.charAt(1);
    if (secondCharactery === "/" || secondCharactery === "\\") {
      return entry2.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
    }
  }
  return entry2;
}
path$h.removeLeadingDotSegment = removeLeadingDotSegment;
var pattern$1 = {};
var isExtglob$1 = function isExtglob(str2) {
  if (typeof str2 !== "string" || str2 === "") {
    return false;
  }
  var match;
  while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str2)) {
    if (match[2])
      return true;
    str2 = str2.slice(match.index + match[0].length);
  }
  return false;
};
var isExtglob2 = isExtglob$1;
var chars = { "{": "}", "(": ")", "[": "]" };
var strictCheck = function(str2) {
  if (str2[0] === "!") {
    return true;
  }
  var index2 = 0;
  var pipeIndex = -2;
  var closeSquareIndex = -2;
  var closeCurlyIndex = -2;
  var closeParenIndex = -2;
  var backSlashIndex = -2;
  while (index2 < str2.length) {
    if (str2[index2] === "*") {
      return true;
    }
    if (str2[index2 + 1] === "?" && /[\].+)]/.test(str2[index2])) {
      return true;
    }
    if (closeSquareIndex !== -1 && str2[index2] === "[" && str2[index2 + 1] !== "]") {
      if (closeSquareIndex < index2) {
        closeSquareIndex = str2.indexOf("]", index2);
      }
      if (closeSquareIndex > index2) {
        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
          return true;
        }
        backSlashIndex = str2.indexOf("\\", index2);
        if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
          return true;
        }
      }
    }
    if (closeCurlyIndex !== -1 && str2[index2] === "{" && str2[index2 + 1] !== "}") {
      closeCurlyIndex = str2.indexOf("}", index2);
      if (closeCurlyIndex > index2) {
        backSlashIndex = str2.indexOf("\\", index2);
        if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
          return true;
        }
      }
    }
    if (closeParenIndex !== -1 && str2[index2] === "(" && str2[index2 + 1] === "?" && /[:!=]/.test(str2[index2 + 2]) && str2[index2 + 3] !== ")") {
      closeParenIndex = str2.indexOf(")", index2);
      if (closeParenIndex > index2) {
        backSlashIndex = str2.indexOf("\\", index2);
        if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
          return true;
        }
      }
    }
    if (pipeIndex !== -1 && str2[index2] === "(" && str2[index2 + 1] !== "|") {
      if (pipeIndex < index2) {
        pipeIndex = str2.indexOf("|", index2);
      }
      if (pipeIndex !== -1 && str2[pipeIndex + 1] !== ")") {
        closeParenIndex = str2.indexOf(")", pipeIndex);
        if (closeParenIndex > pipeIndex) {
          backSlashIndex = str2.indexOf("\\", pipeIndex);
          if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
            return true;
          }
        }
      }
    }
    if (str2[index2] === "\\") {
      var open2 = str2[index2 + 1];
      index2 += 2;
      var close2 = chars[open2];
      if (close2) {
        var n3 = str2.indexOf(close2, index2);
        if (n3 !== -1) {
          index2 = n3 + 1;
        }
      }
      if (str2[index2] === "!") {
        return true;
      }
    } else {
      index2++;
    }
  }
  return false;
};
var relaxedCheck = function(str2) {
  if (str2[0] === "!") {
    return true;
  }
  var index2 = 0;
  while (index2 < str2.length) {
    if (/[*?{}()[\]]/.test(str2[index2])) {
      return true;
    }
    if (str2[index2] === "\\") {
      var open2 = str2[index2 + 1];
      index2 += 2;
      var close2 = chars[open2];
      if (close2) {
        var n3 = str2.indexOf(close2, index2);
        if (n3 !== -1) {
          index2 = n3 + 1;
        }
      }
      if (str2[index2] === "!") {
        return true;
      }
    } else {
      index2++;
    }
  }
  return false;
};
var isGlob$2 = function isGlob(str2, options3) {
  if (typeof str2 !== "string" || str2 === "") {
    return false;
  }
  if (isExtglob2(str2)) {
    return true;
  }
  var check = strictCheck;
  if (options3 && options3.strict === false) {
    check = relaxedCheck;
  }
  return check(str2);
};
var isGlob$1 = isGlob$2;
var pathPosixDirname = import_path.default.posix.dirname;
var isWin32 = import_os.default.platform() === "win32";
var slash2 = "/";
var backslash = /\\/g;
var enclosure = /[\{\[].*[\}\]]$/;
var globby2 = /(^|[^\\])([\{\[]|\([^\)]+$)/;
var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
var globParent$2 = function globParent(str2, opts) {
  var options3 = Object.assign({ flipBackslashes: true }, opts);
  if (options3.flipBackslashes && isWin32 && str2.indexOf(slash2) < 0) {
    str2 = str2.replace(backslash, slash2);
  }
  if (enclosure.test(str2)) {
    str2 += slash2;
  }
  str2 += "a";
  do {
    str2 = pathPosixDirname(str2);
  } while (isGlob$1(str2) || globby2.test(str2));
  return str2.replace(escaped, "$1");
};
var utils$f = {};
(function(exports3) {
  exports3.isInteger = (num) => {
    if (typeof num === "number") {
      return Number.isInteger(num);
    }
    if (typeof num === "string" && num.trim() !== "") {
      return Number.isInteger(Number(num));
    }
    return false;
  };
  exports3.find = (node3, type) => node3.nodes.find((node4) => node4.type === type);
  exports3.exceedsLimit = (min2, max, step = 1, limit) => {
    if (limit === false)
      return false;
    if (!exports3.isInteger(min2) || !exports3.isInteger(max))
      return false;
    return (Number(max) - Number(min2)) / Number(step) >= limit;
  };
  exports3.escapeNode = (block, n3 = 0, type) => {
    let node3 = block.nodes[n3];
    if (!node3)
      return;
    if (type && node3.type === type || node3.type === "open" || node3.type === "close") {
      if (node3.escaped !== true) {
        node3.value = "\\" + node3.value;
        node3.escaped = true;
      }
    }
  };
  exports3.encloseBrace = (node3) => {
    if (node3.type !== "brace")
      return false;
    if (node3.commas >> 0 + node3.ranges >> 0 === 0) {
      node3.invalid = true;
      return true;
    }
    return false;
  };
  exports3.isInvalidBrace = (block) => {
    if (block.type !== "brace")
      return false;
    if (block.invalid === true || block.dollar)
      return true;
    if (block.commas >> 0 + block.ranges >> 0 === 0) {
      block.invalid = true;
      return true;
    }
    if (block.open !== true || block.close !== true) {
      block.invalid = true;
      return true;
    }
    return false;
  };
  exports3.isOpenOrClose = (node3) => {
    if (node3.type === "open" || node3.type === "close") {
      return true;
    }
    return node3.open === true || node3.close === true;
  };
  exports3.reduce = (nodes) => nodes.reduce((acc, node3) => {
    if (node3.type === "text")
      acc.push(node3.value);
    if (node3.type === "range")
      node3.type = "text";
    return acc;
  }, []);
  exports3.flatten = (...args) => {
    const result = [];
    const flat = (arr) => {
      for (let i2 = 0; i2 < arr.length; i2++) {
        let ele = arr[i2];
        Array.isArray(ele) ? flat(ele) : ele !== void 0 && result.push(ele);
      }
      return result;
    };
    flat(args);
    return result;
  };
})(utils$f);
var utils$e = utils$f;
var stringify$7 = (ast, options3 = {}) => {
  let stringify5 = (node3, parent = {}) => {
    let invalidBlock = options3.escapeInvalid && utils$e.isInvalidBrace(parent);
    let invalidNode = node3.invalid === true && options3.escapeInvalid === true;
    let output = "";
    if (node3.value) {
      if ((invalidBlock || invalidNode) && utils$e.isOpenOrClose(node3)) {
        return "\\" + node3.value;
      }
      return node3.value;
    }
    if (node3.value) {
      return node3.value;
    }
    if (node3.nodes) {
      for (let child of node3.nodes) {
        output += stringify5(child);
      }
    }
    return output;
  };
  return stringify5(ast);
};
var isNumber$2 = function(num) {
  if (typeof num === "number") {
    return num - num === 0;
  }
  if (typeof num === "string" && num.trim() !== "") {
    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
  }
  return false;
};
var isNumber$1 = isNumber$2;
var toRegexRange$1 = (min2, max, options3) => {
  if (isNumber$1(min2) === false) {
    throw new TypeError("toRegexRange: expected the first argument to be a number");
  }
  if (max === void 0 || min2 === max) {
    return String(min2);
  }
  if (isNumber$1(max) === false) {
    throw new TypeError("toRegexRange: expected the second argument to be a number.");
  }
  let opts = { relaxZeros: true, ...options3 };
  if (typeof opts.strictZeros === "boolean") {
    opts.relaxZeros = opts.strictZeros === false;
  }
  let relax = String(opts.relaxZeros);
  let shorthand = String(opts.shorthand);
  let capture = String(opts.capture);
  let wrap3 = String(opts.wrap);
  let cacheKey = min2 + ":" + max + "=" + relax + shorthand + capture + wrap3;
  if (toRegexRange$1.cache.hasOwnProperty(cacheKey)) {
    return toRegexRange$1.cache[cacheKey].result;
  }
  let a2 = Math.min(min2, max);
  let b = Math.max(min2, max);
  if (Math.abs(a2 - b) === 1) {
    let result = min2 + "|" + max;
    if (opts.capture) {
      return `(${result})`;
    }
    if (opts.wrap === false) {
      return result;
    }
    return `(?:${result})`;
  }
  let isPadded2 = hasPadding(min2) || hasPadding(max);
  let state = { min: min2, max, a: a2, b };
  let positives = [];
  let negatives = [];
  if (isPadded2) {
    state.isPadded = isPadded2;
    state.maxLen = String(state.max).length;
  }
  if (a2 < 0) {
    let newMin = b < 0 ? Math.abs(b) : 1;
    negatives = splitToPatterns(newMin, Math.abs(a2), state, opts);
    a2 = state.a = 0;
  }
  if (b >= 0) {
    positives = splitToPatterns(a2, b, state, opts);
  }
  state.negatives = negatives;
  state.positives = positives;
  state.result = collatePatterns(negatives, positives);
  if (opts.capture === true) {
    state.result = `(${state.result})`;
  } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
    state.result = `(?:${state.result})`;
  }
  toRegexRange$1.cache[cacheKey] = state;
  return state.result;
};
function collatePatterns(neg, pos, options3) {
  let onlyNegative = filterPatterns(neg, pos, "-", false) || [];
  let onlyPositive = filterPatterns(pos, neg, "", false) || [];
  let intersected = filterPatterns(neg, pos, "-?", true) || [];
  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
  return subpatterns.join("|");
}
function splitToRanges(min2, max) {
  let nines = 1;
  let zeros2 = 1;
  let stop = countNines(min2, nines);
  let stops = /* @__PURE__ */ new Set([max]);
  while (min2 <= stop && stop <= max) {
    stops.add(stop);
    nines += 1;
    stop = countNines(min2, nines);
  }
  stop = countZeros(max + 1, zeros2) - 1;
  while (min2 < stop && stop <= max) {
    stops.add(stop);
    zeros2 += 1;
    stop = countZeros(max + 1, zeros2) - 1;
  }
  stops = [...stops];
  stops.sort(compare);
  return stops;
}
function rangeToPattern(start, stop, options3) {
  if (start === stop) {
    return { pattern: start, count: [], digits: 0 };
  }
  let zipped = zip(start, stop);
  let digits = zipped.length;
  let pattern2 = "";
  let count = 0;
  for (let i2 = 0; i2 < digits; i2++) {
    let [startDigit, stopDigit] = zipped[i2];
    if (startDigit === stopDigit) {
      pattern2 += startDigit;
    } else if (startDigit !== "0" || stopDigit !== "9") {
      pattern2 += toCharacterClass(startDigit, stopDigit);
    } else {
      count++;
    }
  }
  if (count) {
    pattern2 += options3.shorthand === true ? "\\d" : "[0-9]";
  }
  return { pattern: pattern2, count: [count], digits };
}
function splitToPatterns(min2, max, tok, options3) {
  let ranges = splitToRanges(min2, max);
  let tokens = [];
  let start = min2;
  let prev;
  for (let i2 = 0; i2 < ranges.length; i2++) {
    let max2 = ranges[i2];
    let obj = rangeToPattern(String(start), String(max2), options3);
    let zeros2 = "";
    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
      if (prev.count.length > 1) {
        prev.count.pop();
      }
      prev.count.push(obj.count[0]);
      prev.string = prev.pattern + toQuantifier(prev.count);
      start = max2 + 1;
      continue;
    }
    if (tok.isPadded) {
      zeros2 = padZeros(max2, tok, options3);
    }
    obj.string = zeros2 + obj.pattern + toQuantifier(obj.count);
    tokens.push(obj);
    start = max2 + 1;
    prev = obj;
  }
  return tokens;
}
function filterPatterns(arr, comparison, prefix, intersection, options3) {
  let result = [];
  for (let ele of arr) {
    let { string: string3 } = ele;
    if (!intersection && !contains(comparison, "string", string3)) {
      result.push(prefix + string3);
    }
    if (intersection && contains(comparison, "string", string3)) {
      result.push(prefix + string3);
    }
  }
  return result;
}
function zip(a2, b) {
  let arr = [];
  for (let i2 = 0; i2 < a2.length; i2++)
    arr.push([a2[i2], b[i2]]);
  return arr;
}
function compare(a2, b) {
  return a2 > b ? 1 : b > a2 ? -1 : 0;
}
function contains(arr, key, val) {
  return arr.some((ele) => ele[key] === val);
}
function countNines(min2, len) {
  return Number(String(min2).slice(0, -len) + "9".repeat(len));
}
function countZeros(integer, zeros2) {
  return integer - integer % Math.pow(10, zeros2);
}
function toQuantifier(digits) {
  let [start = 0, stop = ""] = digits;
  if (stop || start > 1) {
    return `{${start + (stop ? "," + stop : "")}}`;
  }
  return "";
}
function toCharacterClass(a2, b, options3) {
  return `[${a2}${b - a2 === 1 ? "" : "-"}${b}]`;
}
function hasPadding(str2) {
  return /^-?(0+)\d/.test(str2);
}
function padZeros(value2, tok, options3) {
  if (!tok.isPadded) {
    return value2;
  }
  let diff = Math.abs(tok.maxLen - String(value2).length);
  let relax = options3.relaxZeros !== false;
  switch (diff) {
    case 0:
      return "";
    case 1:
      return relax ? "0?" : "0";
    case 2:
      return relax ? "0{0,2}" : "00";
    default: {
      return relax ? `0{0,${diff}}` : `0{${diff}}`;
    }
  }
}
toRegexRange$1.cache = {};
toRegexRange$1.clearCache = () => toRegexRange$1.cache = {};
var toRegexRange_1 = toRegexRange$1;
var util$1 = import_util.default;
var toRegexRange = toRegexRange_1;
var isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
var transform$1 = (toNumber) => {
  return (value2) => toNumber === true ? Number(value2) : String(value2);
};
var isValidValue = (value2) => {
  return typeof value2 === "number" || typeof value2 === "string" && value2 !== "";
};
var isNumber = (num) => Number.isInteger(+num);
var zeros = (input) => {
  let value2 = `${input}`;
  let index2 = -1;
  if (value2[0] === "-")
    value2 = value2.slice(1);
  if (value2 === "0")
    return false;
  while (value2[++index2] === "0")
    ;
  return index2 > 0;
};
var stringify$6 = (start, end, options3) => {
  if (typeof start === "string" || typeof end === "string") {
    return true;
  }
  return options3.stringify === true;
};
var pad = (input, maxLength, toNumber) => {
  if (maxLength > 0) {
    let dash = input[0] === "-" ? "-" : "";
    if (dash)
      input = input.slice(1);
    input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
  }
  if (toNumber === false) {
    return String(input);
  }
  return input;
};
var toMaxLen = (input, maxLength) => {
  let negative = input[0] === "-" ? "-" : "";
  if (negative) {
    input = input.slice(1);
    maxLength--;
  }
  while (input.length < maxLength)
    input = "0" + input;
  return negative ? "-" + input : input;
};
var toSequence = (parts, options3) => {
  parts.negatives.sort((a2, b) => a2 < b ? -1 : a2 > b ? 1 : 0);
  parts.positives.sort((a2, b) => a2 < b ? -1 : a2 > b ? 1 : 0);
  let prefix = options3.capture ? "" : "?:";
  let positives = "";
  let negatives = "";
  let result;
  if (parts.positives.length) {
    positives = parts.positives.join("|");
  }
  if (parts.negatives.length) {
    negatives = `-(${prefix}${parts.negatives.join("|")})`;
  }
  if (positives && negatives) {
    result = `${positives}|${negatives}`;
  } else {
    result = positives || negatives;
  }
  if (options3.wrap) {
    return `(${prefix}${result})`;
  }
  return result;
};
var toRange = (a2, b, isNumbers, options3) => {
  if (isNumbers) {
    return toRegexRange(a2, b, { wrap: false, ...options3 });
  }
  let start = String.fromCharCode(a2);
  if (a2 === b)
    return start;
  let stop = String.fromCharCode(b);
  return `[${start}-${stop}]`;
};
var toRegex = (start, end, options3) => {
  if (Array.isArray(start)) {
    let wrap3 = options3.wrap === true;
    let prefix = options3.capture ? "" : "?:";
    return wrap3 ? `(${prefix}${start.join("|")})` : start.join("|");
  }
  return toRegexRange(start, end, options3);
};
var rangeError = (...args) => {
  return new RangeError("Invalid range arguments: " + util$1.inspect(...args));
};
var invalidRange = (start, end, options3) => {
  if (options3.strictRanges === true)
    throw rangeError([start, end]);
  return [];
};
var invalidStep = (step, options3) => {
  if (options3.strictRanges === true) {
    throw new TypeError(`Expected step "${step}" to be a number`);
  }
  return [];
};
var fillNumbers = (start, end, step = 1, options3 = {}) => {
  let a2 = Number(start);
  let b = Number(end);
  if (!Number.isInteger(a2) || !Number.isInteger(b)) {
    if (options3.strictRanges === true)
      throw rangeError([start, end]);
    return [];
  }
  if (a2 === 0)
    a2 = 0;
  if (b === 0)
    b = 0;
  let descending = a2 > b;
  let startString = String(start);
  let endString = String(end);
  let stepString = String(step);
  step = Math.max(Math.abs(step), 1);
  let padded = zeros(startString) || zeros(endString) || zeros(stepString);
  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
  let toNumber = padded === false && stringify$6(start, end, options3) === false;
  let format2 = options3.transform || transform$1(toNumber);
  if (options3.toRegex && step === 1) {
    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options3);
  }
  let parts = { negatives: [], positives: [] };
  let push2 = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
  let range2 = [];
  let index2 = 0;
  while (descending ? a2 >= b : a2 <= b) {
    if (options3.toRegex === true && step > 1) {
      push2(a2);
    } else {
      range2.push(pad(format2(a2, index2), maxLen, toNumber));
    }
    a2 = descending ? a2 - step : a2 + step;
    index2++;
  }
  if (options3.toRegex === true) {
    return step > 1 ? toSequence(parts, options3) : toRegex(range2, null, { wrap: false, ...options3 });
  }
  return range2;
};
var fillLetters = (start, end, step = 1, options3 = {}) => {
  if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
    return invalidRange(start, end, options3);
  }
  let format2 = options3.transform || ((val) => String.fromCharCode(val));
  let a2 = `${start}`.charCodeAt(0);
  let b = `${end}`.charCodeAt(0);
  let descending = a2 > b;
  let min2 = Math.min(a2, b);
  let max = Math.max(a2, b);
  if (options3.toRegex && step === 1) {
    return toRange(min2, max, false, options3);
  }
  let range2 = [];
  let index2 = 0;
  while (descending ? a2 >= b : a2 <= b) {
    range2.push(format2(a2, index2));
    a2 = descending ? a2 - step : a2 + step;
    index2++;
  }
  if (options3.toRegex === true) {
    return toRegex(range2, null, { wrap: false, options: options3 });
  }
  return range2;
};
var fill$2 = (start, end, step, options3 = {}) => {
  if (end == null && isValidValue(start)) {
    return [start];
  }
  if (!isValidValue(start) || !isValidValue(end)) {
    return invalidRange(start, end, options3);
  }
  if (typeof step === "function") {
    return fill$2(start, end, 1, { transform: step });
  }
  if (isObject(step)) {
    return fill$2(start, end, 0, step);
  }
  let opts = { ...options3 };
  if (opts.capture === true)
    opts.wrap = true;
  step = step || opts.step || 1;
  if (!isNumber(step)) {
    if (step != null && !isObject(step))
      return invalidStep(step, opts);
    return fill$2(start, end, 1, step);
  }
  if (isNumber(start) && isNumber(end)) {
    return fillNumbers(start, end, step, opts);
  }
  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
};
var fillRange = fill$2;
var fill$1 = fillRange;
var utils$d = utils$f;
var compile$1 = (ast, options3 = {}) => {
  let walk2 = (node3, parent = {}) => {
    let invalidBlock = utils$d.isInvalidBrace(parent);
    let invalidNode = node3.invalid === true && options3.escapeInvalid === true;
    let invalid = invalidBlock === true || invalidNode === true;
    let prefix = options3.escapeInvalid === true ? "\\" : "";
    let output = "";
    if (node3.isOpen === true) {
      return prefix + node3.value;
    }
    if (node3.isClose === true) {
      return prefix + node3.value;
    }
    if (node3.type === "open") {
      return invalid ? prefix + node3.value : "(";
    }
    if (node3.type === "close") {
      return invalid ? prefix + node3.value : ")";
    }
    if (node3.type === "comma") {
      return node3.prev.type === "comma" ? "" : invalid ? node3.value : "|";
    }
    if (node3.value) {
      return node3.value;
    }
    if (node3.nodes && node3.ranges > 0) {
      let args = utils$d.reduce(node3.nodes);
      let range2 = fill$1(...args, { ...options3, wrap: false, toRegex: true });
      if (range2.length !== 0) {
        return args.length > 1 && range2.length > 1 ? `(${range2})` : range2;
      }
    }
    if (node3.nodes) {
      for (let child of node3.nodes) {
        output += walk2(child, node3);
      }
    }
    return output;
  };
  return walk2(ast);
};
var compile_1 = compile$1;
var fill = fillRange;
var stringify$5 = stringify$7;
var utils$c = utils$f;
var append$1 = (queue2 = "", stash = "", enclose = false) => {
  let result = [];
  queue2 = [].concat(queue2);
  stash = [].concat(stash);
  if (!stash.length)
    return queue2;
  if (!queue2.length) {
    return enclose ? utils$c.flatten(stash).map((ele) => `{${ele}}`) : stash;
  }
  for (let item of queue2) {
    if (Array.isArray(item)) {
      for (let value2 of item) {
        result.push(append$1(value2, stash, enclose));
      }
    } else {
      for (let ele of stash) {
        if (enclose === true && typeof ele === "string")
          ele = `{${ele}}`;
        result.push(Array.isArray(ele) ? append$1(item, ele, enclose) : item + ele);
      }
    }
  }
  return utils$c.flatten(result);
};
var expand$2 = (ast, options3 = {}) => {
  let rangeLimit = options3.rangeLimit === void 0 ? 1e3 : options3.rangeLimit;
  let walk2 = (node3, parent = {}) => {
    node3.queue = [];
    let p2 = parent;
    let q = parent.queue;
    while (p2.type !== "brace" && p2.type !== "root" && p2.parent) {
      p2 = p2.parent;
      q = p2.queue;
    }
    if (node3.invalid || node3.dollar) {
      q.push(append$1(q.pop(), stringify$5(node3, options3)));
      return;
    }
    if (node3.type === "brace" && node3.invalid !== true && node3.nodes.length === 2) {
      q.push(append$1(q.pop(), ["{}"]));
      return;
    }
    if (node3.nodes && node3.ranges > 0) {
      let args = utils$c.reduce(node3.nodes);
      if (utils$c.exceedsLimit(...args, options3.step, rangeLimit)) {
        throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
      }
      let range2 = fill(...args, options3);
      if (range2.length === 0) {
        range2 = stringify$5(node3, options3);
      }
      q.push(append$1(q.pop(), range2));
      node3.nodes = [];
      return;
    }
    let enclose = utils$c.encloseBrace(node3);
    let queue2 = node3.queue;
    let block = node3;
    while (block.type !== "brace" && block.type !== "root" && block.parent) {
      block = block.parent;
      queue2 = block.queue;
    }
    for (let i2 = 0; i2 < node3.nodes.length; i2++) {
      let child = node3.nodes[i2];
      if (child.type === "comma" && node3.type === "brace") {
        if (i2 === 1)
          queue2.push("");
        queue2.push("");
        continue;
      }
      if (child.type === "close") {
        q.push(append$1(q.pop(), queue2, enclose));
        continue;
      }
      if (child.value && child.type !== "open") {
        queue2.push(append$1(queue2.pop(), child.value));
        continue;
      }
      if (child.nodes) {
        walk2(child, node3);
      }
    }
    return queue2;
  };
  return utils$c.flatten(walk2(ast));
};
var expand_1$1 = expand$2;
var constants$3 = {
  MAX_LENGTH: 1024 * 64,
  // Digits
  CHAR_0: "0",
  /* 0 */
  CHAR_9: "9",
  /* 9 */
  // Alphabet chars.
  CHAR_UPPERCASE_A: "A",
  /* A */
  CHAR_LOWERCASE_A: "a",
  /* a */
  CHAR_UPPERCASE_Z: "Z",
  /* Z */
  CHAR_LOWERCASE_Z: "z",
  /* z */
  CHAR_LEFT_PARENTHESES: "(",
  /* ( */
  CHAR_RIGHT_PARENTHESES: ")",
  /* ) */
  CHAR_ASTERISK: "*",
  /* * */
  // Non-alphabetic chars.
  CHAR_AMPERSAND: "&",
  /* & */
  CHAR_AT: "@",
  /* @ */
  CHAR_BACKSLASH: "\\",
  /* \ */
  CHAR_BACKTICK: "`",
  /* ` */
  CHAR_CARRIAGE_RETURN: "\r",
  /* \r */
  CHAR_CIRCUMFLEX_ACCENT: "^",
  /* ^ */
  CHAR_COLON: ":",
  /* : */
  CHAR_COMMA: ",",
  /* , */
  CHAR_DOLLAR: "$",
  /* . */
  CHAR_DOT: ".",
  /* . */
  CHAR_DOUBLE_QUOTE: '"',
  /* " */
  CHAR_EQUAL: "=",
  /* = */
  CHAR_EXCLAMATION_MARK: "!",
  /* ! */
  CHAR_FORM_FEED: "\f",
  /* \f */
  CHAR_FORWARD_SLASH: "/",
  /* / */
  CHAR_HASH: "#",
  /* # */
  CHAR_HYPHEN_MINUS: "-",
  /* - */
  CHAR_LEFT_ANGLE_BRACKET: "<",
  /* < */
  CHAR_LEFT_CURLY_BRACE: "{",
  /* { */
  CHAR_LEFT_SQUARE_BRACKET: "[",
  /* [ */
  CHAR_LINE_FEED: "\n",
  /* \n */
  CHAR_NO_BREAK_SPACE: " ",
  /* \u00A0 */
  CHAR_PERCENT: "%",
  /* % */
  CHAR_PLUS: "+",
  /* + */
  CHAR_QUESTION_MARK: "?",
  /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: ">",
  /* > */
  CHAR_RIGHT_CURLY_BRACE: "}",
  /* } */
  CHAR_RIGHT_SQUARE_BRACKET: "]",
  /* ] */
  CHAR_SEMICOLON: ";",
  /* ; */
  CHAR_SINGLE_QUOTE: "'",
  /* ' */
  CHAR_SPACE: " ",
  /*   */
  CHAR_TAB: "	",
  /* \t */
  CHAR_UNDERSCORE: "_",
  /* _ */
  CHAR_VERTICAL_LINE: "|",
  /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
  /* \uFEFF */
};
var stringify$4 = stringify$7;
var {
  MAX_LENGTH,
  CHAR_BACKSLASH,
  /* \ */
  CHAR_BACKTICK,
  /* ` */
  CHAR_COMMA,
  /* , */
  CHAR_DOT,
  /* . */
  CHAR_LEFT_PARENTHESES,
  /* ( */
  CHAR_RIGHT_PARENTHESES,
  /* ) */
  CHAR_LEFT_CURLY_BRACE,
  /* { */
  CHAR_RIGHT_CURLY_BRACE,
  /* } */
  CHAR_LEFT_SQUARE_BRACKET,
  /* [ */
  CHAR_RIGHT_SQUARE_BRACKET,
  /* ] */
  CHAR_DOUBLE_QUOTE,
  /* " */
  CHAR_SINGLE_QUOTE,
  /* ' */
  CHAR_NO_BREAK_SPACE,
  CHAR_ZERO_WIDTH_NOBREAK_SPACE
} = constants$3;
var parse$c = (input, options3 = {}) => {
  if (typeof input !== "string") {
    throw new TypeError("Expected a string");
  }
  let opts = options3 || {};
  let max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
  if (input.length > max) {
    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
  }
  let ast = { type: "root", input, nodes: [] };
  let stack = [ast];
  let block = ast;
  let prev = ast;
  let brackets = 0;
  let length = input.length;
  let index2 = 0;
  let depth2 = 0;
  let value2;
  const advance2 = () => input[index2++];
  const push2 = (node3) => {
    if (node3.type === "text" && prev.type === "dot") {
      prev.type = "text";
    }
    if (prev && prev.type === "text" && node3.type === "text") {
      prev.value += node3.value;
      return;
    }
    block.nodes.push(node3);
    node3.parent = block;
    node3.prev = prev;
    prev = node3;
    return node3;
  };
  push2({ type: "bos" });
  while (index2 < length) {
    block = stack[stack.length - 1];
    value2 = advance2();
    if (value2 === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value2 === CHAR_NO_BREAK_SPACE) {
      continue;
    }
    if (value2 === CHAR_BACKSLASH) {
      push2({ type: "text", value: (options3.keepEscaping ? value2 : "") + advance2() });
      continue;
    }
    if (value2 === CHAR_RIGHT_SQUARE_BRACKET) {
      push2({ type: "text", value: "\\" + value2 });
      continue;
    }
    if (value2 === CHAR_LEFT_SQUARE_BRACKET) {
      brackets++;
      let next;
      while (index2 < length && (next = advance2())) {
        value2 += next;
        if (next === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          continue;
        }
        if (next === CHAR_BACKSLASH) {
          value2 += advance2();
          continue;
        }
        if (next === CHAR_RIGHT_SQUARE_BRACKET) {
          brackets--;
          if (brackets === 0) {
            break;
          }
        }
      }
      push2({ type: "text", value: value2 });
      continue;
    }
    if (value2 === CHAR_LEFT_PARENTHESES) {
      block = push2({ type: "paren", nodes: [] });
      stack.push(block);
      push2({ type: "text", value: value2 });
      continue;
    }
    if (value2 === CHAR_RIGHT_PARENTHESES) {
      if (block.type !== "paren") {
        push2({ type: "text", value: value2 });
        continue;
      }
      block = stack.pop();
      push2({ type: "text", value: value2 });
      block = stack[stack.length - 1];
      continue;
    }
    if (value2 === CHAR_DOUBLE_QUOTE || value2 === CHAR_SINGLE_QUOTE || value2 === CHAR_BACKTICK) {
      let open2 = value2;
      let next;
      if (options3.keepQuotes !== true) {
        value2 = "";
      }
      while (index2 < length && (next = advance2())) {
        if (next === CHAR_BACKSLASH) {
          value2 += next + advance2();
          continue;
        }
        if (next === open2) {
          if (options3.keepQuotes === true)
            value2 += next;
          break;
        }
        value2 += next;
      }
      push2({ type: "text", value: value2 });
      continue;
    }
    if (value2 === CHAR_LEFT_CURLY_BRACE) {
      depth2++;
      let dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
      let brace = {
        type: "brace",
        open: true,
        close: false,
        dollar,
        depth: depth2,
        commas: 0,
        ranges: 0,
        nodes: []
      };
      block = push2(brace);
      stack.push(block);
      push2({ type: "open", value: value2 });
      continue;
    }
    if (value2 === CHAR_RIGHT_CURLY_BRACE) {
      if (block.type !== "brace") {
        push2({ type: "text", value: value2 });
        continue;
      }
      let type = "close";
      block = stack.pop();
      block.close = true;
      push2({ type, value: value2 });
      depth2--;
      block = stack[stack.length - 1];
      continue;
    }
    if (value2 === CHAR_COMMA && depth2 > 0) {
      if (block.ranges > 0) {
        block.ranges = 0;
        let open2 = block.nodes.shift();
        block.nodes = [open2, { type: "text", value: stringify$4(block) }];
      }
      push2({ type: "comma", value: value2 });
      block.commas++;
      continue;
    }
    if (value2 === CHAR_DOT && depth2 > 0 && block.commas === 0) {
      let siblings = block.nodes;
      if (depth2 === 0 || siblings.length === 0) {
        push2({ type: "text", value: value2 });
        continue;
      }
      if (prev.type === "dot") {
        block.range = [];
        prev.value += value2;
        prev.type = "range";
        if (block.nodes.length !== 3 && block.nodes.length !== 5) {
          block.invalid = true;
          block.ranges = 0;
          prev.type = "text";
          continue;
        }
        block.ranges++;
        block.args = [];
        continue;
      }
      if (prev.type === "range") {
        siblings.pop();
        let before = siblings[siblings.length - 1];
        before.value += prev.value + value2;
        prev = before;
        block.ranges--;
        continue;
      }
      push2({ type: "dot", value: value2 });
      continue;
    }
    push2({ type: "text", value: value2 });
  }
  do {
    block = stack.pop();
    if (block.type !== "root") {
      block.nodes.forEach((node3) => {
        if (!node3.nodes) {
          if (node3.type === "open")
            node3.isOpen = true;
          if (node3.type === "close")
            node3.isClose = true;
          if (!node3.nodes)
            node3.type = "text";
          node3.invalid = true;
        }
      });
      let parent = stack[stack.length - 1];
      let index3 = parent.nodes.indexOf(block);
      parent.nodes.splice(index3, 1, ...block.nodes);
    }
  } while (stack.length > 0);
  push2({ type: "eos" });
  return ast;
};
var parse_1$2 = parse$c;
var stringify$3 = stringify$7;
var compile = compile_1;
var expand$1 = expand_1$1;
var parse$b = parse_1$2;
var braces$2 = (input, options3 = {}) => {
  let output = [];
  if (Array.isArray(input)) {
    for (let pattern2 of input) {
      let result = braces$2.create(pattern2, options3);
      if (Array.isArray(result)) {
        output.push(...result);
      } else {
        output.push(result);
      }
    }
  } else {
    output = [].concat(braces$2.create(input, options3));
  }
  if (options3 && options3.expand === true && options3.nodupes === true) {
    output = [...new Set(output)];
  }
  return output;
};
braces$2.parse = (input, options3 = {}) => parse$b(input, options3);
braces$2.stringify = (input, options3 = {}) => {
  if (typeof input === "string") {
    return stringify$3(braces$2.parse(input, options3), options3);
  }
  return stringify$3(input, options3);
};
braces$2.compile = (input, options3 = {}) => {
  if (typeof input === "string") {
    input = braces$2.parse(input, options3);
  }
  return compile(input, options3);
};
braces$2.expand = (input, options3 = {}) => {
  if (typeof input === "string") {
    input = braces$2.parse(input, options3);
  }
  let result = expand$1(input, options3);
  if (options3.noempty === true) {
    result = result.filter(Boolean);
  }
  if (options3.nodupes === true) {
    result = [...new Set(result)];
  }
  return result;
};
braces$2.create = (input, options3 = {}) => {
  if (input === "" || input.length < 3) {
    return [input];
  }
  return options3.expand !== true ? braces$2.compile(input, options3) : braces$2.expand(input, options3);
};
var braces_1 = braces$2;
var util = import_util.default;
var braces$1 = braces_1;
var picomatch$2 = picomatchExports;
var utils$b = utils$k;
var isEmptyString = (val) => val === "" || val === "./";
var micromatch$1 = (list, patterns2, options3) => {
  patterns2 = [].concat(patterns2);
  list = [].concat(list);
  let omit2 = /* @__PURE__ */ new Set();
  let keep = /* @__PURE__ */ new Set();
  let items = /* @__PURE__ */ new Set();
  let negatives = 0;
  let onResult = (state) => {
    items.add(state.output);
    if (options3 && options3.onResult) {
      options3.onResult(state);
    }
  };
  for (let i2 = 0; i2 < patterns2.length; i2++) {
    let isMatch2 = picomatch$2(String(patterns2[i2]), { ...options3, onResult }, true);
    let negated = isMatch2.state.negated || isMatch2.state.negatedExtglob;
    if (negated)
      negatives++;
    for (let item of list) {
      let matched = isMatch2(item, true);
      let match = negated ? !matched.isMatch : matched.isMatch;
      if (!match)
        continue;
      if (negated) {
        omit2.add(matched.output);
      } else {
        omit2.delete(matched.output);
        keep.add(matched.output);
      }
    }
  }
  let result = negatives === patterns2.length ? [...items] : [...keep];
  let matches2 = result.filter((item) => !omit2.has(item));
  if (options3 && matches2.length === 0) {
    if (options3.failglob === true) {
      throw new Error(`No matches found for "${patterns2.join(", ")}"`);
    }
    if (options3.nonull === true || options3.nullglob === true) {
      return options3.unescape ? patterns2.map((p2) => p2.replace(/\\/g, "")) : patterns2;
    }
  }
  return matches2;
};
micromatch$1.match = micromatch$1;
micromatch$1.matcher = (pattern2, options3) => picomatch$2(pattern2, options3);
micromatch$1.isMatch = (str2, patterns2, options3) => picomatch$2(patterns2, options3)(str2);
micromatch$1.any = micromatch$1.isMatch;
micromatch$1.not = (list, patterns2, options3 = {}) => {
  patterns2 = [].concat(patterns2).map(String);
  let result = /* @__PURE__ */ new Set();
  let items = [];
  let onResult = (state) => {
    if (options3.onResult)
      options3.onResult(state);
    items.push(state.output);
  };
  let matches2 = new Set(micromatch$1(list, patterns2, { ...options3, onResult }));
  for (let item of items) {
    if (!matches2.has(item)) {
      result.add(item);
    }
  }
  return [...result];
};
micromatch$1.contains = (str2, pattern2, options3) => {
  if (typeof str2 !== "string") {
    throw new TypeError(`Expected a string: "${util.inspect(str2)}"`);
  }
  if (Array.isArray(pattern2)) {
    return pattern2.some((p2) => micromatch$1.contains(str2, p2, options3));
  }
  if (typeof pattern2 === "string") {
    if (isEmptyString(str2) || isEmptyString(pattern2)) {
      return false;
    }
    if (str2.includes(pattern2) || str2.startsWith("./") && str2.slice(2).includes(pattern2)) {
      return true;
    }
  }
  return micromatch$1.isMatch(str2, pattern2, { ...options3, contains: true });
};
micromatch$1.matchKeys = (obj, patterns2, options3) => {
  if (!utils$b.isObject(obj)) {
    throw new TypeError("Expected the first argument to be an object");
  }
  let keys = micromatch$1(Object.keys(obj), patterns2, options3);
  let res = {};
  for (let key of keys)
    res[key] = obj[key];
  return res;
};
micromatch$1.some = (list, patterns2, options3) => {
  let items = [].concat(list);
  for (let pattern2 of [].concat(patterns2)) {
    let isMatch2 = picomatch$2(String(pattern2), options3);
    if (items.some((item) => isMatch2(item))) {
      return true;
    }
  }
  return false;
};
micromatch$1.every = (list, patterns2, options3) => {
  let items = [].concat(list);
  for (let pattern2 of [].concat(patterns2)) {
    let isMatch2 = picomatch$2(String(pattern2), options3);
    if (!items.every((item) => isMatch2(item))) {
      return false;
    }
  }
  return true;
};
micromatch$1.all = (str2, patterns2, options3) => {
  if (typeof str2 !== "string") {
    throw new TypeError(`Expected a string: "${util.inspect(str2)}"`);
  }
  return [].concat(patterns2).every((p2) => picomatch$2(p2, options3)(str2));
};
micromatch$1.capture = (glob2, input, options3) => {
  let posix2 = utils$b.isWindows(options3);
  let regex = picomatch$2.makeRe(String(glob2), { ...options3, capture: true });
  let match = regex.exec(posix2 ? utils$b.toPosixSlashes(input) : input);
  if (match) {
    return match.slice(1).map((v) => v === void 0 ? "" : v);
  }
};
micromatch$1.makeRe = (...args) => picomatch$2.makeRe(...args);
micromatch$1.scan = (...args) => picomatch$2.scan(...args);
micromatch$1.parse = (patterns2, options3) => {
  let res = [];
  for (let pattern2 of [].concat(patterns2 || [])) {
    for (let str2 of braces$1(String(pattern2), options3)) {
      res.push(picomatch$2.parse(str2, options3));
    }
  }
  return res;
};
micromatch$1.braces = (pattern2, options3) => {
  if (typeof pattern2 !== "string")
    throw new TypeError("Expected a string");
  if (options3 && options3.nobrace === true || !/\{.*\}/.test(pattern2)) {
    return [pattern2];
  }
  return braces$1(pattern2, options3);
};
micromatch$1.braceExpand = (pattern2, options3) => {
  if (typeof pattern2 !== "string")
    throw new TypeError("Expected a string");
  return micromatch$1.braces(pattern2, { ...options3, expand: true });
};
var micromatch_1 = micromatch$1;
Object.defineProperty(pattern$1, "__esModule", { value: true });
pattern$1.matchAny = pattern$1.convertPatternsToRe = pattern$1.makeRe = pattern$1.getPatternParts = pattern$1.expandBraceExpansion = pattern$1.expandPatternsWithBraceExpansion = pattern$1.isAffectDepthOfReadingPattern = pattern$1.endsWithSlashGlobStar = pattern$1.hasGlobStar = pattern$1.getBaseDirectory = pattern$1.isPatternRelatedToParentDirectory = pattern$1.getPatternsOutsideCurrentDirectory = pattern$1.getPatternsInsideCurrentDirectory = pattern$1.getPositivePatterns = pattern$1.getNegativePatterns = pattern$1.isPositivePattern = pattern$1.isNegativePattern = pattern$1.convertToNegativePattern = pattern$1.convertToPositivePattern = pattern$1.isDynamicPattern = pattern$1.isStaticPattern = void 0;
var path$f = import_path.default;
var globParent$1 = globParent$2;
var micromatch = micromatch_1;
var GLOBSTAR$1 = "**";
var ESCAPE_SYMBOL = "\\";
var COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
var REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[[^[]*]/;
var REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/;
var GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\([^(]*\)/;
var BRACE_EXPANSION_SEPARATORS_RE = /,|\.\./;
function isStaticPattern(pattern2, options3 = {}) {
  return !isDynamicPattern2(pattern2, options3);
}
pattern$1.isStaticPattern = isStaticPattern;
function isDynamicPattern2(pattern2, options3 = {}) {
  if (pattern2 === "") {
    return false;
  }
  if (options3.caseSensitiveMatch === false || pattern2.includes(ESCAPE_SYMBOL)) {
    return true;
  }
  if (COMMON_GLOB_SYMBOLS_RE.test(pattern2) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern2) || REGEX_GROUP_SYMBOLS_RE.test(pattern2)) {
    return true;
  }
  if (options3.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern2)) {
    return true;
  }
  if (options3.braceExpansion !== false && hasBraceExpansion(pattern2)) {
    return true;
  }
  return false;
}
pattern$1.isDynamicPattern = isDynamicPattern2;
function hasBraceExpansion(pattern2) {
  const openingBraceIndex = pattern2.indexOf("{");
  if (openingBraceIndex === -1) {
    return false;
  }
  const closingBraceIndex = pattern2.indexOf("}", openingBraceIndex + 1);
  if (closingBraceIndex === -1) {
    return false;
  }
  const braceContent = pattern2.slice(openingBraceIndex, closingBraceIndex);
  return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);
}
function convertToPositivePattern(pattern2) {
  return isNegativePattern2(pattern2) ? pattern2.slice(1) : pattern2;
}
pattern$1.convertToPositivePattern = convertToPositivePattern;
function convertToNegativePattern(pattern2) {
  return "!" + pattern2;
}
pattern$1.convertToNegativePattern = convertToNegativePattern;
function isNegativePattern2(pattern2) {
  return pattern2.startsWith("!") && pattern2[1] !== "(";
}
pattern$1.isNegativePattern = isNegativePattern2;
function isPositivePattern(pattern2) {
  return !isNegativePattern2(pattern2);
}
pattern$1.isPositivePattern = isPositivePattern;
function getNegativePatterns(patterns2) {
  return patterns2.filter(isNegativePattern2);
}
pattern$1.getNegativePatterns = getNegativePatterns;
function getPositivePatterns$1(patterns2) {
  return patterns2.filter(isPositivePattern);
}
pattern$1.getPositivePatterns = getPositivePatterns$1;
function getPatternsInsideCurrentDirectory(patterns2) {
  return patterns2.filter((pattern2) => !isPatternRelatedToParentDirectory(pattern2));
}
pattern$1.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;
function getPatternsOutsideCurrentDirectory(patterns2) {
  return patterns2.filter(isPatternRelatedToParentDirectory);
}
pattern$1.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;
function isPatternRelatedToParentDirectory(pattern2) {
  return pattern2.startsWith("..") || pattern2.startsWith("./..");
}
pattern$1.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;
function getBaseDirectory(pattern2) {
  return globParent$1(pattern2, { flipBackslashes: false });
}
pattern$1.getBaseDirectory = getBaseDirectory;
function hasGlobStar(pattern2) {
  return pattern2.includes(GLOBSTAR$1);
}
pattern$1.hasGlobStar = hasGlobStar;
function endsWithSlashGlobStar(pattern2) {
  return pattern2.endsWith("/" + GLOBSTAR$1);
}
pattern$1.endsWithSlashGlobStar = endsWithSlashGlobStar;
function isAffectDepthOfReadingPattern(pattern2) {
  const basename2 = path$f.basename(pattern2);
  return endsWithSlashGlobStar(pattern2) || isStaticPattern(basename2);
}
pattern$1.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
function expandPatternsWithBraceExpansion(patterns2) {
  return patterns2.reduce((collection, pattern2) => {
    return collection.concat(expandBraceExpansion(pattern2));
  }, []);
}
pattern$1.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
function expandBraceExpansion(pattern2) {
  return micromatch.braces(pattern2, {
    expand: true,
    nodupes: true
  });
}
pattern$1.expandBraceExpansion = expandBraceExpansion;
function getPatternParts(pattern2, options3) {
  let { parts } = micromatch.scan(pattern2, Object.assign(Object.assign({}, options3), { parts: true }));
  if (parts.length === 0) {
    parts = [pattern2];
  }
  if (parts[0].startsWith("/")) {
    parts[0] = parts[0].slice(1);
    parts.unshift("");
  }
  return parts;
}
pattern$1.getPatternParts = getPatternParts;
function makeRe(pattern2, options3) {
  return micromatch.makeRe(pattern2, options3);
}
pattern$1.makeRe = makeRe;
function convertPatternsToRe(patterns2, options3) {
  return patterns2.map((pattern2) => makeRe(pattern2, options3));
}
pattern$1.convertPatternsToRe = convertPatternsToRe;
function matchAny(entry2, patternsRe) {
  return patternsRe.some((patternRe) => patternRe.test(entry2));
}
pattern$1.matchAny = matchAny;
var stream$4 = {};
var Stream = import_stream.default;
var PassThrough = Stream.PassThrough;
var slice = Array.prototype.slice;
var merge2_1 = merge2$1;
function merge2$1() {
  const streamsQueue = [];
  const args = slice.call(arguments);
  let merging = false;
  let options3 = args[args.length - 1];
  if (options3 && !Array.isArray(options3) && options3.pipe == null) {
    args.pop();
  } else {
    options3 = {};
  }
  const doEnd = options3.end !== false;
  const doPipeError = options3.pipeError === true;
  if (options3.objectMode == null) {
    options3.objectMode = true;
  }
  if (options3.highWaterMark == null) {
    options3.highWaterMark = 64 * 1024;
  }
  const mergedStream = PassThrough(options3);
  function addStream() {
    for (let i2 = 0, len = arguments.length; i2 < len; i2++) {
      streamsQueue.push(pauseStreams(arguments[i2], options3));
    }
    mergeStream();
    return this;
  }
  function mergeStream() {
    if (merging) {
      return;
    }
    merging = true;
    let streams = streamsQueue.shift();
    if (!streams) {
      process.nextTick(endStream);
      return;
    }
    if (!Array.isArray(streams)) {
      streams = [streams];
    }
    let pipesCount = streams.length + 1;
    function next() {
      if (--pipesCount > 0) {
        return;
      }
      merging = false;
      mergeStream();
    }
    function pipe(stream4) {
      function onend() {
        stream4.removeListener("merge2UnpipeEnd", onend);
        stream4.removeListener("end", onend);
        if (doPipeError) {
          stream4.removeListener("error", onerror);
        }
        next();
      }
      function onerror(err2) {
        mergedStream.emit("error", err2);
      }
      if (stream4._readableState.endEmitted) {
        return next();
      }
      stream4.on("merge2UnpipeEnd", onend);
      stream4.on("end", onend);
      if (doPipeError) {
        stream4.on("error", onerror);
      }
      stream4.pipe(mergedStream, { end: false });
      stream4.resume();
    }
    for (let i2 = 0; i2 < streams.length; i2++) {
      pipe(streams[i2]);
    }
    next();
  }
  function endStream() {
    merging = false;
    mergedStream.emit("queueDrain");
    if (doEnd) {
      mergedStream.end();
    }
  }
  mergedStream.setMaxListeners(0);
  mergedStream.add = addStream;
  mergedStream.on("unpipe", function(stream4) {
    stream4.emit("merge2UnpipeEnd");
  });
  if (args.length) {
    addStream.apply(null, args);
  }
  return mergedStream;
}
function pauseStreams(streams, options3) {
  if (!Array.isArray(streams)) {
    if (!streams._readableState && streams.pipe) {
      streams = streams.pipe(PassThrough(options3));
    }
    if (!streams._readableState || !streams.pause || !streams.pipe) {
      throw new Error("Only readable stream can be merged.");
    }
    streams.pause();
  } else {
    for (let i2 = 0, len = streams.length; i2 < len; i2++) {
      streams[i2] = pauseStreams(streams[i2], options3);
    }
  }
  return streams;
}
Object.defineProperty(stream$4, "__esModule", { value: true });
stream$4.merge = void 0;
var merge22 = merge2_1;
function merge$1(streams) {
  const mergedStream = merge22(streams);
  streams.forEach((stream4) => {
    stream4.once("error", (error3) => mergedStream.emit("error", error3));
  });
  mergedStream.once("close", () => propagateCloseEventToSources(streams));
  mergedStream.once("end", () => propagateCloseEventToSources(streams));
  return mergedStream;
}
stream$4.merge = merge$1;
function propagateCloseEventToSources(streams) {
  streams.forEach((stream4) => stream4.emit("close"));
}
var string$2 = {};
Object.defineProperty(string$2, "__esModule", { value: true });
string$2.isEmpty = string$2.isString = void 0;
function isString2(input) {
  return typeof input === "string";
}
string$2.isString = isString2;
function isEmpty$1(input) {
  return input === "";
}
string$2.isEmpty = isEmpty$1;
Object.defineProperty(utils$g, "__esModule", { value: true });
utils$g.string = utils$g.stream = utils$g.pattern = utils$g.path = utils$g.fs = utils$g.errno = utils$g.array = void 0;
var array = array$1;
utils$g.array = array;
var errno = errno$1;
utils$g.errno = errno;
var fs$g = fs$h;
utils$g.fs = fs$g;
var path$e = path$h;
utils$g.path = path$e;
var pattern = pattern$1;
utils$g.pattern = pattern;
var stream$3 = stream$4;
utils$g.stream = stream$3;
var string$1 = string$2;
utils$g.string = string$1;
Object.defineProperty(tasks, "__esModule", { value: true });
tasks.convertPatternGroupToTask = tasks.convertPatternGroupsToTasks = tasks.groupPatternsByBaseDirectory = tasks.getNegativePatternsAsPositive = tasks.getPositivePatterns = tasks.convertPatternsToTasks = tasks.generate = void 0;
var utils$a = utils$g;
function generate(patterns2, settings2) {
  const positivePatterns = getPositivePatterns(patterns2);
  const negativePatterns = getNegativePatternsAsPositive(patterns2, settings2.ignore);
  const staticPatterns = positivePatterns.filter((pattern2) => utils$a.pattern.isStaticPattern(pattern2, settings2));
  const dynamicPatterns = positivePatterns.filter((pattern2) => utils$a.pattern.isDynamicPattern(pattern2, settings2));
  const staticTasks = convertPatternsToTasks(
    staticPatterns,
    negativePatterns,
    /* dynamic */
    false
  );
  const dynamicTasks = convertPatternsToTasks(
    dynamicPatterns,
    negativePatterns,
    /* dynamic */
    true
  );
  return staticTasks.concat(dynamicTasks);
}
tasks.generate = generate;
function convertPatternsToTasks(positive, negative, dynamic) {
  const tasks2 = [];
  const patternsOutsideCurrentDirectory = utils$a.pattern.getPatternsOutsideCurrentDirectory(positive);
  const patternsInsideCurrentDirectory = utils$a.pattern.getPatternsInsideCurrentDirectory(positive);
  const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);
  const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);
  tasks2.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));
  if ("." in insideCurrentDirectoryGroup) {
    tasks2.push(convertPatternGroupToTask(".", patternsInsideCurrentDirectory, negative, dynamic));
  } else {
    tasks2.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));
  }
  return tasks2;
}
tasks.convertPatternsToTasks = convertPatternsToTasks;
function getPositivePatterns(patterns2) {
  return utils$a.pattern.getPositivePatterns(patterns2);
}
tasks.getPositivePatterns = getPositivePatterns;
function getNegativePatternsAsPositive(patterns2, ignore2) {
  const negative = utils$a.pattern.getNegativePatterns(patterns2).concat(ignore2);
  const positive = negative.map(utils$a.pattern.convertToPositivePattern);
  return positive;
}
tasks.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
function groupPatternsByBaseDirectory(patterns2) {
  const group = {};
  return patterns2.reduce((collection, pattern2) => {
    const base2 = utils$a.pattern.getBaseDirectory(pattern2);
    if (base2 in collection) {
      collection[base2].push(pattern2);
    } else {
      collection[base2] = [pattern2];
    }
    return collection;
  }, group);
}
tasks.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
function convertPatternGroupsToTasks(positive, negative, dynamic) {
  return Object.keys(positive).map((base2) => {
    return convertPatternGroupToTask(base2, positive[base2], negative, dynamic);
  });
}
tasks.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
function convertPatternGroupToTask(base2, positive, negative, dynamic) {
  return {
    dynamic,
    positive,
    negative,
    base: base2,
    patterns: [].concat(positive, negative.map(utils$a.pattern.convertToNegativePattern))
  };
}
tasks.convertPatternGroupToTask = convertPatternGroupToTask;
var patterns = {};
Object.defineProperty(patterns, "__esModule", { value: true });
patterns.removeDuplicateSlashes = patterns.transform = void 0;
var DOUBLE_SLASH_RE$1 = /(?!^)\/{2,}/g;
function transform(patterns2) {
  return patterns2.map((pattern2) => removeDuplicateSlashes(pattern2));
}
patterns.transform = transform;
function removeDuplicateSlashes(pattern2) {
  return pattern2.replace(DOUBLE_SLASH_RE$1, "/");
}
patterns.removeDuplicateSlashes = removeDuplicateSlashes;
var async$7 = {};
var async$6 = {};
var out$3 = {};
var async$5 = {};
var async$4 = {};
var out$2 = {};
var async$3 = {};
var out$1 = {};
var async$2 = {};
Object.defineProperty(async$2, "__esModule", { value: true });
async$2.read = void 0;
function read$3(path8, settings2, callback) {
  settings2.fs.lstat(path8, (lstatError, lstat2) => {
    if (lstatError !== null) {
      callFailureCallback$2(callback, lstatError);
      return;
    }
    if (!lstat2.isSymbolicLink() || !settings2.followSymbolicLink) {
      callSuccessCallback$2(callback, lstat2);
      return;
    }
    settings2.fs.stat(path8, (statError, stat2) => {
      if (statError !== null) {
        if (settings2.throwErrorOnBrokenSymbolicLink) {
          callFailureCallback$2(callback, statError);
          return;
        }
        callSuccessCallback$2(callback, lstat2);
        return;
      }
      if (settings2.markSymbolicLink) {
        stat2.isSymbolicLink = () => true;
      }
      callSuccessCallback$2(callback, stat2);
    });
  });
}
async$2.read = read$3;
function callFailureCallback$2(callback, error3) {
  callback(error3);
}
function callSuccessCallback$2(callback, result) {
  callback(null, result);
}
var sync$8 = {};
Object.defineProperty(sync$8, "__esModule", { value: true });
sync$8.read = void 0;
function read$2(path8, settings2) {
  const lstat2 = settings2.fs.lstatSync(path8);
  if (!lstat2.isSymbolicLink() || !settings2.followSymbolicLink) {
    return lstat2;
  }
  try {
    const stat2 = settings2.fs.statSync(path8);
    if (settings2.markSymbolicLink) {
      stat2.isSymbolicLink = () => true;
    }
    return stat2;
  } catch (error3) {
    if (!settings2.throwErrorOnBrokenSymbolicLink) {
      return lstat2;
    }
    throw error3;
  }
}
sync$8.read = read$2;
var settings$3 = {};
var fs$f = {};
(function(exports3) {
  Object.defineProperty(exports3, "__esModule", { value: true });
  exports3.createFileSystemAdapter = exports3.FILE_SYSTEM_ADAPTER = void 0;
  const fs6 = import_fs.default;
  exports3.FILE_SYSTEM_ADAPTER = {
    lstat: fs6.lstat,
    stat: fs6.stat,
    lstatSync: fs6.lstatSync,
    statSync: fs6.statSync
  };
  function createFileSystemAdapter(fsMethods) {
    if (fsMethods === void 0) {
      return exports3.FILE_SYSTEM_ADAPTER;
    }
    return Object.assign(Object.assign({}, exports3.FILE_SYSTEM_ADAPTER), fsMethods);
  }
  exports3.createFileSystemAdapter = createFileSystemAdapter;
})(fs$f);
Object.defineProperty(settings$3, "__esModule", { value: true });
var fs$e = fs$f;
var Settings$2 = class Settings {
  constructor(_options2 = {}) {
    this._options = _options2;
    this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
    this.fs = fs$e.createFileSystemAdapter(this._options.fs);
    this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
    this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
  }
  _getValue(option, value2) {
    return option !== null && option !== void 0 ? option : value2;
  }
};
settings$3.default = Settings$2;
Object.defineProperty(out$1, "__esModule", { value: true });
out$1.statSync = out$1.stat = out$1.Settings = void 0;
var async$1 = async$2;
var sync$7 = sync$8;
var settings_1$3 = settings$3;
out$1.Settings = settings_1$3.default;
function stat$4(path8, optionsOrSettingsOrCallback, callback) {
  if (typeof optionsOrSettingsOrCallback === "function") {
    async$1.read(path8, getSettings$2(), optionsOrSettingsOrCallback);
    return;
  }
  async$1.read(path8, getSettings$2(optionsOrSettingsOrCallback), callback);
}
out$1.stat = stat$4;
function statSync2(path8, optionsOrSettings) {
  const settings2 = getSettings$2(optionsOrSettings);
  return sync$7.read(path8, settings2);
}
out$1.statSync = statSync2;
function getSettings$2(settingsOrOptions = {}) {
  if (settingsOrOptions instanceof settings_1$3.default) {
    return settingsOrOptions;
  }
  return new settings_1$3.default(settingsOrOptions);
}
var promise;
var queueMicrotask_1 = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : commonjsGlobal) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err2) => setTimeout(() => {
  throw err2;
}, 0));
var runParallel_1 = runParallel;
var queueMicrotask$1 = queueMicrotask_1;
function runParallel(tasks2, cb) {
  let results, pending, keys;
  let isSync = true;
  if (Array.isArray(tasks2)) {
    results = [];
    pending = tasks2.length;
  } else {
    keys = Object.keys(tasks2);
    results = {};
    pending = keys.length;
  }
  function done(err2) {
    function end() {
      if (cb)
        cb(err2, results);
      cb = null;
    }
    if (isSync)
      queueMicrotask$1(end);
    else
      end();
  }
  function each(i2, err2, result) {
    results[i2] = result;
    if (--pending === 0 || err2) {
      done(err2);
    }
  }
  if (!pending) {
    done(null);
  } else if (keys) {
    keys.forEach(function(key) {
      tasks2[key](function(err2, result) {
        each(key, err2, result);
      });
    });
  } else {
    tasks2.forEach(function(task, i2) {
      task(function(err2, result) {
        each(i2, err2, result);
      });
    });
  }
  isSync = false;
}
var constants$2 = {};
Object.defineProperty(constants$2, "__esModule", { value: true });
constants$2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
var NODE_PROCESS_VERSION_PARTS = process.versions.node.split(".");
if (NODE_PROCESS_VERSION_PARTS[0] === void 0 || NODE_PROCESS_VERSION_PARTS[1] === void 0) {
  throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
}
var MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
var MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
var SUPPORTED_MAJOR_VERSION = 10;
var SUPPORTED_MINOR_VERSION = 10;
var IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
var IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
constants$2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;
var utils$9 = {};
var fs$d = {};
Object.defineProperty(fs$d, "__esModule", { value: true });
fs$d.createDirentFromStats = void 0;
var DirentFromStats2 = class {
  constructor(name2, stats) {
    this.name = name2;
    this.isBlockDevice = stats.isBlockDevice.bind(stats);
    this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
    this.isDirectory = stats.isDirectory.bind(stats);
    this.isFIFO = stats.isFIFO.bind(stats);
    this.isFile = stats.isFile.bind(stats);
    this.isSocket = stats.isSocket.bind(stats);
    this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
  }
};
function createDirentFromStats(name2, stats) {
  return new DirentFromStats2(name2, stats);
}
fs$d.createDirentFromStats = createDirentFromStats;
Object.defineProperty(utils$9, "__esModule", { value: true });
utils$9.fs = void 0;
var fs$c = fs$d;
utils$9.fs = fs$c;
var common$a = {};
Object.defineProperty(common$a, "__esModule", { value: true });
common$a.joinPathSegments = void 0;
function joinPathSegments$1(a2, b, separator) {
  if (a2.endsWith(separator)) {
    return a2 + b;
  }
  return a2 + separator + b;
}
common$a.joinPathSegments = joinPathSegments$1;
Object.defineProperty(async$3, "__esModule", { value: true });
async$3.readdir = async$3.readdirWithFileTypes = async$3.read = void 0;
var fsStat$5 = out$1;
var rpl = runParallel_1;
var constants_1$1 = constants$2;
var utils$8 = utils$9;
var common$9 = common$a;
function read$1(directory, settings2, callback) {
  if (!settings2.stats && constants_1$1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
    readdirWithFileTypes$1(directory, settings2, callback);
    return;
  }
  readdir$3(directory, settings2, callback);
}
async$3.read = read$1;
function readdirWithFileTypes$1(directory, settings2, callback) {
  settings2.fs.readdir(directory, { withFileTypes: true }, (readdirError, dirents) => {
    if (readdirError !== null) {
      callFailureCallback$1(callback, readdirError);
      return;
    }
    const entries = dirents.map((dirent) => ({
      dirent,
      name: dirent.name,
      path: common$9.joinPathSegments(directory, dirent.name, settings2.pathSegmentSeparator)
    }));
    if (!settings2.followSymbolicLinks) {
      callSuccessCallback$1(callback, entries);
      return;
    }
    const tasks2 = entries.map((entry2) => makeRplTaskEntry(entry2, settings2));
    rpl(tasks2, (rplError, rplEntries) => {
      if (rplError !== null) {
        callFailureCallback$1(callback, rplError);
        return;
      }
      callSuccessCallback$1(callback, rplEntries);
    });
  });
}
async$3.readdirWithFileTypes = readdirWithFileTypes$1;
function makeRplTaskEntry(entry2, settings2) {
  return (done) => {
    if (!entry2.dirent.isSymbolicLink()) {
      done(null, entry2);
      return;
    }
    settings2.fs.stat(entry2.path, (statError, stats) => {
      if (statError !== null) {
        if (settings2.throwErrorOnBrokenSymbolicLink) {
          done(statError);
          return;
        }
        done(null, entry2);
        return;
      }
      entry2.dirent = utils$8.fs.createDirentFromStats(entry2.name, stats);
      done(null, entry2);
    });
  };
}
function readdir$3(directory, settings2, callback) {
  settings2.fs.readdir(directory, (readdirError, names) => {
    if (readdirError !== null) {
      callFailureCallback$1(callback, readdirError);
      return;
    }
    const tasks2 = names.map((name2) => {
      const path8 = common$9.joinPathSegments(directory, name2, settings2.pathSegmentSeparator);
      return (done) => {
        fsStat$5.stat(path8, settings2.fsStatSettings, (error3, stats) => {
          if (error3 !== null) {
            done(error3);
            return;
          }
          const entry2 = {
            name: name2,
            path: path8,
            dirent: utils$8.fs.createDirentFromStats(name2, stats)
          };
          if (settings2.stats) {
            entry2.stats = stats;
          }
          done(null, entry2);
        });
      };
    });
    rpl(tasks2, (rplError, entries) => {
      if (rplError !== null) {
        callFailureCallback$1(callback, rplError);
        return;
      }
      callSuccessCallback$1(callback, entries);
    });
  });
}
async$3.readdir = readdir$3;
function callFailureCallback$1(callback, error3) {
  callback(error3);
}
function callSuccessCallback$1(callback, result) {
  callback(null, result);
}
var sync$6 = {};
Object.defineProperty(sync$6, "__esModule", { value: true });
sync$6.readdir = sync$6.readdirWithFileTypes = sync$6.read = void 0;
var fsStat$4 = out$1;
var constants_1 = constants$2;
var utils$7 = utils$9;
var common$8 = common$a;
function read(directory, settings2) {
  if (!settings2.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
    return readdirWithFileTypes(directory, settings2);
  }
  return readdir$2(directory, settings2);
}
sync$6.read = read;
function readdirWithFileTypes(directory, settings2) {
  const dirents = settings2.fs.readdirSync(directory, { withFileTypes: true });
  return dirents.map((dirent) => {
    const entry2 = {
      dirent,
      name: dirent.name,
      path: common$8.joinPathSegments(directory, dirent.name, settings2.pathSegmentSeparator)
    };
    if (entry2.dirent.isSymbolicLink() && settings2.followSymbolicLinks) {
      try {
        const stats = settings2.fs.statSync(entry2.path);
        entry2.dirent = utils$7.fs.createDirentFromStats(entry2.name, stats);
      } catch (error3) {
        if (settings2.throwErrorOnBrokenSymbolicLink) {
          throw error3;
        }
      }
    }
    return entry2;
  });
}
sync$6.readdirWithFileTypes = readdirWithFileTypes;
function readdir$2(directory, settings2) {
  const names = settings2.fs.readdirSync(directory);
  return names.map((name2) => {
    const entryPath = common$8.joinPathSegments(directory, name2, settings2.pathSegmentSeparator);
    const stats = fsStat$4.statSync(entryPath, settings2.fsStatSettings);
    const entry2 = {
      name: name2,
      path: entryPath,
      dirent: utils$7.fs.createDirentFromStats(name2, stats)
    };
    if (settings2.stats) {
      entry2.stats = stats;
    }
    return entry2;
  });
}
sync$6.readdir = readdir$2;
var settings$2 = {};
var fs$b = {};
(function(exports3) {
  Object.defineProperty(exports3, "__esModule", { value: true });
  exports3.createFileSystemAdapter = exports3.FILE_SYSTEM_ADAPTER = void 0;
  const fs6 = import_fs.default;
  exports3.FILE_SYSTEM_ADAPTER = {
    lstat: fs6.lstat,
    stat: fs6.stat,
    lstatSync: fs6.lstatSync,
    statSync: fs6.statSync,
    readdir: fs6.readdir,
    readdirSync: fs6.readdirSync
  };
  function createFileSystemAdapter(fsMethods) {
    if (fsMethods === void 0) {
      return exports3.FILE_SYSTEM_ADAPTER;
    }
    return Object.assign(Object.assign({}, exports3.FILE_SYSTEM_ADAPTER), fsMethods);
  }
  exports3.createFileSystemAdapter = createFileSystemAdapter;
})(fs$b);
Object.defineProperty(settings$2, "__esModule", { value: true });
var path$d = import_path.default;
var fsStat$3 = out$1;
var fs$a = fs$b;
var Settings$1 = class Settings2 {
  constructor(_options2 = {}) {
    this._options = _options2;
    this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
    this.fs = fs$a.createFileSystemAdapter(this._options.fs);
    this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path$d.sep);
    this.stats = this._getValue(this._options.stats, false);
    this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
    this.fsStatSettings = new fsStat$3.Settings({
      followSymbolicLink: this.followSymbolicLinks,
      fs: this.fs,
      throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
    });
  }
  _getValue(option, value2) {
    return option !== null && option !== void 0 ? option : value2;
  }
};
settings$2.default = Settings$1;
Object.defineProperty(out$2, "__esModule", { value: true });
out$2.Settings = out$2.scandirSync = out$2.scandir = void 0;
var async = async$3;
var sync$5 = sync$6;
var settings_1$2 = settings$2;
out$2.Settings = settings_1$2.default;
function scandir(path8, optionsOrSettingsOrCallback, callback) {
  if (typeof optionsOrSettingsOrCallback === "function") {
    async.read(path8, getSettings$1(), optionsOrSettingsOrCallback);
    return;
  }
  async.read(path8, getSettings$1(optionsOrSettingsOrCallback), callback);
}
out$2.scandir = scandir;
function scandirSync(path8, optionsOrSettings) {
  const settings2 = getSettings$1(optionsOrSettings);
  return sync$5.read(path8, settings2);
}
out$2.scandirSync = scandirSync;
function getSettings$1(settingsOrOptions = {}) {
  if (settingsOrOptions instanceof settings_1$2.default) {
    return settingsOrOptions;
  }
  return new settings_1$2.default(settingsOrOptions);
}
var queueExports = {};
var queue = {
  get exports() {
    return queueExports;
  },
  set exports(v) {
    queueExports = v;
  }
};
function reusify$1(Constructor) {
  var head = new Constructor();
  var tail = head;
  function get3() {
    var current2 = head;
    if (current2.next) {
      head = current2.next;
    } else {
      head = new Constructor();
      tail = head;
    }
    current2.next = null;
    return current2;
  }
  function release(obj) {
    tail.next = obj;
    tail = obj;
  }
  return {
    get: get3,
    release
  };
}
var reusify_1 = reusify$1;
var reusify = reusify_1;
function fastqueue(context, worker, concurrency) {
  if (typeof context === "function") {
    concurrency = worker;
    worker = context;
    context = null;
  }
  if (concurrency < 1) {
    throw new Error("fastqueue concurrency must be greater than 1");
  }
  var cache2 = reusify(Task);
  var queueHead = null;
  var queueTail = null;
  var _running = 0;
  var errorHandler = null;
  var self2 = {
    push: push2,
    drain: noop$3,
    saturated: noop$3,
    pause,
    paused: false,
    concurrency,
    running,
    resume: resume2,
    idle,
    length,
    getQueue,
    unshift,
    empty: noop$3,
    kill,
    killAndDrain,
    error: error3
  };
  return self2;
  function running() {
    return _running;
  }
  function pause() {
    self2.paused = true;
  }
  function length() {
    var current2 = queueHead;
    var counter = 0;
    while (current2) {
      current2 = current2.next;
      counter++;
    }
    return counter;
  }
  function getQueue() {
    var current2 = queueHead;
    var tasks2 = [];
    while (current2) {
      tasks2.push(current2.value);
      current2 = current2.next;
    }
    return tasks2;
  }
  function resume2() {
    if (!self2.paused)
      return;
    self2.paused = false;
    for (var i2 = 0; i2 < self2.concurrency; i2++) {
      _running++;
      release();
    }
  }
  function idle() {
    return _running === 0 && self2.length() === 0;
  }
  function push2(value2, done) {
    var current2 = cache2.get();
    current2.context = context;
    current2.release = release;
    current2.value = value2;
    current2.callback = done || noop$3;
    current2.errorHandler = errorHandler;
    if (_running === self2.concurrency || self2.paused) {
      if (queueTail) {
        queueTail.next = current2;
        queueTail = current2;
      } else {
        queueHead = current2;
        queueTail = current2;
        self2.saturated();
      }
    } else {
      _running++;
      worker.call(context, current2.value, current2.worked);
    }
  }
  function unshift(value2, done) {
    var current2 = cache2.get();
    current2.context = context;
    current2.release = release;
    current2.value = value2;
    current2.callback = done || noop$3;
    if (_running === self2.concurrency || self2.paused) {
      if (queueHead) {
        current2.next = queueHead;
        queueHead = current2;
      } else {
        queueHead = current2;
        queueTail = current2;
        self2.saturated();
      }
    } else {
      _running++;
      worker.call(context, current2.value, current2.worked);
    }
  }
  function release(holder) {
    if (holder) {
      cache2.release(holder);
    }
    var next = queueHead;
    if (next) {
      if (!self2.paused) {
        if (queueTail === queueHead) {
          queueTail = null;
        }
        queueHead = next.next;
        next.next = null;
        worker.call(context, next.value, next.worked);
        if (queueTail === null) {
          self2.empty();
        }
      } else {
        _running--;
      }
    } else if (--_running === 0) {
      self2.drain();
    }
  }
  function kill() {
    queueHead = null;
    queueTail = null;
    self2.drain = noop$3;
  }
  function killAndDrain() {
    queueHead = null;
    queueTail = null;
    self2.drain();
    self2.drain = noop$3;
  }
  function error3(handler) {
    errorHandler = handler;
  }
}
function noop$3() {
}
function Task() {
  this.value = null;
  this.callback = noop$3;
  this.next = null;
  this.release = noop$3;
  this.context = null;
  this.errorHandler = null;
  var self2 = this;
  this.worked = function worked(err2, result) {
    var callback = self2.callback;
    var errorHandler = self2.errorHandler;
    var val = self2.value;
    self2.value = null;
    self2.callback = noop$3;
    if (self2.errorHandler) {
      errorHandler(err2, val);
    }
    callback.call(self2.context, err2, result);
    self2.release(self2);
  };
}
function queueAsPromised(context, worker, concurrency) {
  if (typeof context === "function") {
    concurrency = worker;
    worker = context;
    context = null;
  }
  function asyncWrapper(arg, cb) {
    worker.call(this, arg).then(function(res) {
      cb(null, res);
    }, cb);
  }
  var queue2 = fastqueue(context, asyncWrapper, concurrency);
  var pushCb = queue2.push;
  var unshiftCb = queue2.unshift;
  queue2.push = push2;
  queue2.unshift = unshift;
  queue2.drained = drained;
  return queue2;
  function push2(value2) {
    var p2 = new Promise(function(resolve4, reject) {
      pushCb(value2, function(err2, result) {
        if (err2) {
          reject(err2);
          return;
        }
        resolve4(result);
      });
    });
    p2.catch(noop$3);
    return p2;
  }
  function unshift(value2) {
    var p2 = new Promise(function(resolve4, reject) {
      unshiftCb(value2, function(err2, result) {
        if (err2) {
          reject(err2);
          return;
        }
        resolve4(result);
      });
    });
    p2.catch(noop$3);
    return p2;
  }
  function drained() {
    var previousDrain = queue2.drain;
    var p2 = new Promise(function(resolve4) {
      queue2.drain = function() {
        previousDrain();
        resolve4();
      };
    });
    return p2;
  }
}
queue.exports = fastqueue;
queueExports.promise = queueAsPromised;
var common$7 = {};
Object.defineProperty(common$7, "__esModule", { value: true });
common$7.joinPathSegments = common$7.replacePathSegmentSeparator = common$7.isAppliedFilter = common$7.isFatalError = void 0;
function isFatalError(settings2, error3) {
  if (settings2.errorFilter === null) {
    return true;
  }
  return !settings2.errorFilter(error3);
}
common$7.isFatalError = isFatalError;
function isAppliedFilter(filter2, value2) {
  return filter2 === null || filter2(value2);
}
common$7.isAppliedFilter = isAppliedFilter;
function replacePathSegmentSeparator(filepath, separator) {
  return filepath.split(/[/\\]/).join(separator);
}
common$7.replacePathSegmentSeparator = replacePathSegmentSeparator;
function joinPathSegments(a2, b, separator) {
  if (a2 === "") {
    return b;
  }
  if (a2.endsWith(separator)) {
    return a2 + b;
  }
  return a2 + separator + b;
}
common$7.joinPathSegments = joinPathSegments;
var reader$1 = {};
Object.defineProperty(reader$1, "__esModule", { value: true });
var common$6 = common$7;
var Reader$1 = class Reader {
  constructor(_root, _settings) {
    this._root = _root;
    this._settings = _settings;
    this._root = common$6.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
  }
};
reader$1.default = Reader$1;
Object.defineProperty(async$4, "__esModule", { value: true });
var events_1 = import_events.default;
var fsScandir$2 = out$2;
var fastq = queueExports;
var common$5 = common$7;
var reader_1$4 = reader$1;
var AsyncReader = class extends reader_1$4.default {
  constructor(_root, _settings) {
    super(_root, _settings);
    this._settings = _settings;
    this._scandir = fsScandir$2.scandir;
    this._emitter = new events_1.EventEmitter();
    this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
    this._isFatalError = false;
    this._isDestroyed = false;
    this._queue.drain = () => {
      if (!this._isFatalError) {
        this._emitter.emit("end");
      }
    };
  }
  read() {
    this._isFatalError = false;
    this._isDestroyed = false;
    setImmediate(() => {
      this._pushToQueue(this._root, this._settings.basePath);
    });
    return this._emitter;
  }
  get isDestroyed() {
    return this._isDestroyed;
  }
  destroy() {
    if (this._isDestroyed) {
      throw new Error("The reader is already destroyed");
    }
    this._isDestroyed = true;
    this._queue.killAndDrain();
  }
  onEntry(callback) {
    this._emitter.on("entry", callback);
  }
  onError(callback) {
    this._emitter.once("error", callback);
  }
  onEnd(callback) {
    this._emitter.once("end", callback);
  }
  _pushToQueue(directory, base2) {
    const queueItem = { directory, base: base2 };
    this._queue.push(queueItem, (error3) => {
      if (error3 !== null) {
        this._handleError(error3);
      }
    });
  }
  _worker(item, done) {
    this._scandir(item.directory, this._settings.fsScandirSettings, (error3, entries) => {
      if (error3 !== null) {
        done(error3, void 0);
        return;
      }
      for (const entry2 of entries) {
        this._handleEntry(entry2, item.base);
      }
      done(null, void 0);
    });
  }
  _handleError(error3) {
    if (this._isDestroyed || !common$5.isFatalError(this._settings, error3)) {
      return;
    }
    this._isFatalError = true;
    this._isDestroyed = true;
    this._emitter.emit("error", error3);
  }
  _handleEntry(entry2, base2) {
    if (this._isDestroyed || this._isFatalError) {
      return;
    }
    const fullpath = entry2.path;
    if (base2 !== void 0) {
      entry2.path = common$5.joinPathSegments(base2, entry2.name, this._settings.pathSegmentSeparator);
    }
    if (common$5.isAppliedFilter(this._settings.entryFilter, entry2)) {
      this._emitEntry(entry2);
    }
    if (entry2.dirent.isDirectory() && common$5.isAppliedFilter(this._settings.deepFilter, entry2)) {
      this._pushToQueue(fullpath, base2 === void 0 ? void 0 : entry2.path);
    }
  }
  _emitEntry(entry2) {
    this._emitter.emit("entry", entry2);
  }
};
async$4.default = AsyncReader;
Object.defineProperty(async$5, "__esModule", { value: true });
var async_1$4 = async$4;
var AsyncProvider = class {
  constructor(_root, _settings) {
    this._root = _root;
    this._settings = _settings;
    this._reader = new async_1$4.default(this._root, this._settings);
    this._storage = [];
  }
  read(callback) {
    this._reader.onError((error3) => {
      callFailureCallback(callback, error3);
    });
    this._reader.onEntry((entry2) => {
      this._storage.push(entry2);
    });
    this._reader.onEnd(() => {
      callSuccessCallback(callback, this._storage);
    });
    this._reader.read();
  }
};
async$5.default = AsyncProvider;
function callFailureCallback(callback, error3) {
  callback(error3);
}
function callSuccessCallback(callback, entries) {
  callback(null, entries);
}
var stream$2 = {};
Object.defineProperty(stream$2, "__esModule", { value: true });
var stream_1$5 = import_stream.default;
var async_1$3 = async$4;
var StreamProvider = class {
  constructor(_root, _settings) {
    this._root = _root;
    this._settings = _settings;
    this._reader = new async_1$3.default(this._root, this._settings);
    this._stream = new stream_1$5.Readable({
      objectMode: true,
      read: () => {
      },
      destroy: () => {
        if (!this._reader.isDestroyed) {
          this._reader.destroy();
        }
      }
    });
  }
  read() {
    this._reader.onError((error3) => {
      this._stream.emit("error", error3);
    });
    this._reader.onEntry((entry2) => {
      this._stream.push(entry2);
    });
    this._reader.onEnd(() => {
      this._stream.push(null);
    });
    this._reader.read();
    return this._stream;
  }
};
stream$2.default = StreamProvider;
var sync$4 = {};
var sync$3 = {};
Object.defineProperty(sync$3, "__esModule", { value: true });
var fsScandir$1 = out$2;
var common$4 = common$7;
var reader_1$3 = reader$1;
var SyncReader = class extends reader_1$3.default {
  constructor() {
    super(...arguments);
    this._scandir = fsScandir$1.scandirSync;
    this._storage = [];
    this._queue = /* @__PURE__ */ new Set();
  }
  read() {
    this._pushToQueue(this._root, this._settings.basePath);
    this._handleQueue();
    return this._storage;
  }
  _pushToQueue(directory, base2) {
    this._queue.add({ directory, base: base2 });
  }
  _handleQueue() {
    for (const item of this._queue.values()) {
      this._handleDirectory(item.directory, item.base);
    }
  }
  _handleDirectory(directory, base2) {
    try {
      const entries = this._scandir(directory, this._settings.fsScandirSettings);
      for (const entry2 of entries) {
        this._handleEntry(entry2, base2);
      }
    } catch (error3) {
      this._handleError(error3);
    }
  }
  _handleError(error3) {
    if (!common$4.isFatalError(this._settings, error3)) {
      return;
    }
    throw error3;
  }
  _handleEntry(entry2, base2) {
    const fullpath = entry2.path;
    if (base2 !== void 0) {
      entry2.path = common$4.joinPathSegments(base2, entry2.name, this._settings.pathSegmentSeparator);
    }
    if (common$4.isAppliedFilter(this._settings.entryFilter, entry2)) {
      this._pushToStorage(entry2);
    }
    if (entry2.dirent.isDirectory() && common$4.isAppliedFilter(this._settings.deepFilter, entry2)) {
      this._pushToQueue(fullpath, base2 === void 0 ? void 0 : entry2.path);
    }
  }
  _pushToStorage(entry2) {
    this._storage.push(entry2);
  }
};
sync$3.default = SyncReader;
Object.defineProperty(sync$4, "__esModule", { value: true });
var sync_1$3 = sync$3;
var SyncProvider = class {
  constructor(_root, _settings) {
    this._root = _root;
    this._settings = _settings;
    this._reader = new sync_1$3.default(this._root, this._settings);
  }
  read() {
    return this._reader.read();
  }
};
sync$4.default = SyncProvider;
var settings$1 = {};
Object.defineProperty(settings$1, "__esModule", { value: true });
var path$c = import_path.default;
var fsScandir = out$2;
var Settings3 = class {
  constructor(_options2 = {}) {
    this._options = _options2;
    this.basePath = this._getValue(this._options.basePath, void 0);
    this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY);
    this.deepFilter = this._getValue(this._options.deepFilter, null);
    this.entryFilter = this._getValue(this._options.entryFilter, null);
    this.errorFilter = this._getValue(this._options.errorFilter, null);
    this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path$c.sep);
    this.fsScandirSettings = new fsScandir.Settings({
      followSymbolicLinks: this._options.followSymbolicLinks,
      fs: this._options.fs,
      pathSegmentSeparator: this._options.pathSegmentSeparator,
      stats: this._options.stats,
      throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
    });
  }
  _getValue(option, value2) {
    return option !== null && option !== void 0 ? option : value2;
  }
};
settings$1.default = Settings3;
Object.defineProperty(out$3, "__esModule", { value: true });
out$3.Settings = out$3.walkStream = out$3.walkSync = out$3.walk = void 0;
var async_1$2 = async$5;
var stream_1$4 = stream$2;
var sync_1$2 = sync$4;
var settings_1$1 = settings$1;
out$3.Settings = settings_1$1.default;
function walk$2(directory, optionsOrSettingsOrCallback, callback) {
  if (typeof optionsOrSettingsOrCallback === "function") {
    new async_1$2.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
    return;
  }
  new async_1$2.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
}
out$3.walk = walk$2;
function walkSync(directory, optionsOrSettings) {
  const settings2 = getSettings(optionsOrSettings);
  const provider2 = new sync_1$2.default(directory, settings2);
  return provider2.read();
}
out$3.walkSync = walkSync;
function walkStream(directory, optionsOrSettings) {
  const settings2 = getSettings(optionsOrSettings);
  const provider2 = new stream_1$4.default(directory, settings2);
  return provider2.read();
}
out$3.walkStream = walkStream;
function getSettings(settingsOrOptions = {}) {
  if (settingsOrOptions instanceof settings_1$1.default) {
    return settingsOrOptions;
  }
  return new settings_1$1.default(settingsOrOptions);
}
var reader = {};
Object.defineProperty(reader, "__esModule", { value: true });
var path$b = import_path.default;
var fsStat$2 = out$1;
var utils$6 = utils$g;
var Reader2 = class {
  constructor(_settings) {
    this._settings = _settings;
    this._fsStatSettings = new fsStat$2.Settings({
      followSymbolicLink: this._settings.followSymbolicLinks,
      fs: this._settings.fs,
      throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
    });
  }
  _getFullEntryPath(filepath) {
    return path$b.resolve(this._settings.cwd, filepath);
  }
  _makeEntry(stats, pattern2) {
    const entry2 = {
      name: pattern2,
      path: pattern2,
      dirent: utils$6.fs.createDirentFromStats(pattern2, stats)
    };
    if (this._settings.stats) {
      entry2.stats = stats;
    }
    return entry2;
  }
  _isFatalError(error3) {
    return !utils$6.errno.isEnoentCodeError(error3) && !this._settings.suppressErrors;
  }
};
reader.default = Reader2;
var stream$1 = {};
Object.defineProperty(stream$1, "__esModule", { value: true });
var stream_1$3 = import_stream.default;
var fsStat$1 = out$1;
var fsWalk$2 = out$3;
var reader_1$2 = reader;
var ReaderStream = class extends reader_1$2.default {
  constructor() {
    super(...arguments);
    this._walkStream = fsWalk$2.walkStream;
    this._stat = fsStat$1.stat;
  }
  dynamic(root, options3) {
    return this._walkStream(root, options3);
  }
  static(patterns2, options3) {
    const filepaths = patterns2.map(this._getFullEntryPath, this);
    const stream4 = new stream_1$3.PassThrough({ objectMode: true });
    stream4._write = (index2, _enc, done) => {
      return this._getEntry(filepaths[index2], patterns2[index2], options3).then((entry2) => {
        if (entry2 !== null && options3.entryFilter(entry2)) {
          stream4.push(entry2);
        }
        if (index2 === filepaths.length - 1) {
          stream4.end();
        }
        done();
      }).catch(done);
    };
    for (let i2 = 0; i2 < filepaths.length; i2++) {
      stream4.write(i2);
    }
    return stream4;
  }
  _getEntry(filepath, pattern2, options3) {
    return this._getStat(filepath).then((stats) => this._makeEntry(stats, pattern2)).catch((error3) => {
      if (options3.errorFilter(error3)) {
        return null;
      }
      throw error3;
    });
  }
  _getStat(filepath) {
    return new Promise((resolve4, reject) => {
      this._stat(filepath, this._fsStatSettings, (error3, stats) => {
        return error3 === null ? resolve4(stats) : reject(error3);
      });
    });
  }
};
stream$1.default = ReaderStream;
Object.defineProperty(async$6, "__esModule", { value: true });
var fsWalk$1 = out$3;
var reader_1$1 = reader;
var stream_1$2 = stream$1;
var ReaderAsync = class extends reader_1$1.default {
  constructor() {
    super(...arguments);
    this._walkAsync = fsWalk$1.walk;
    this._readerStream = new stream_1$2.default(this._settings);
  }
  dynamic(root, options3) {
    return new Promise((resolve4, reject) => {
      this._walkAsync(root, options3, (error3, entries) => {
        if (error3 === null) {
          resolve4(entries);
        } else {
          reject(error3);
        }
      });
    });
  }
  async static(patterns2, options3) {
    const entries = [];
    const stream4 = this._readerStream.static(patterns2, options3);
    return new Promise((resolve4, reject) => {
      stream4.once("error", reject);
      stream4.on("data", (entry2) => entries.push(entry2));
      stream4.once("end", () => resolve4(entries));
    });
  }
};
async$6.default = ReaderAsync;
var provider = {};
var deep = {};
var partial = {};
var matcher = {};
Object.defineProperty(matcher, "__esModule", { value: true });
var utils$5 = utils$g;
var Matcher = class {
  constructor(_patterns, _settings, _micromatchOptions) {
    this._patterns = _patterns;
    this._settings = _settings;
    this._micromatchOptions = _micromatchOptions;
    this._storage = [];
    this._fillStorage();
  }
  _fillStorage() {
    const patterns2 = utils$5.pattern.expandPatternsWithBraceExpansion(this._patterns);
    for (const pattern2 of patterns2) {
      const segments = this._getPatternSegments(pattern2);
      const sections = this._splitSegmentsIntoSections(segments);
      this._storage.push({
        complete: sections.length <= 1,
        pattern: pattern2,
        segments,
        sections
      });
    }
  }
  _getPatternSegments(pattern2) {
    const parts = utils$5.pattern.getPatternParts(pattern2, this._micromatchOptions);
    return parts.map((part) => {
      const dynamic = utils$5.pattern.isDynamicPattern(part, this._settings);
      if (!dynamic) {
        return {
          dynamic: false,
          pattern: part
        };
      }
      return {
        dynamic: true,
        pattern: part,
        patternRe: utils$5.pattern.makeRe(part, this._micromatchOptions)
      };
    });
  }
  _splitSegmentsIntoSections(segments) {
    return utils$5.array.splitWhen(segments, (segment) => segment.dynamic && utils$5.pattern.hasGlobStar(segment.pattern));
  }
};
matcher.default = Matcher;
Object.defineProperty(partial, "__esModule", { value: true });
var matcher_1 = matcher;
var PartialMatcher = class extends matcher_1.default {
  match(filepath) {
    const parts = filepath.split("/");
    const levels = parts.length;
    const patterns2 = this._storage.filter((info3) => !info3.complete || info3.segments.length > levels);
    for (const pattern2 of patterns2) {
      const section = pattern2.sections[0];
      if (!pattern2.complete && levels > section.length) {
        return true;
      }
      const match = parts.every((part, index2) => {
        const segment = pattern2.segments[index2];
        if (segment.dynamic && segment.patternRe.test(part)) {
          return true;
        }
        if (!segment.dynamic && segment.pattern === part) {
          return true;
        }
        return false;
      });
      if (match) {
        return true;
      }
    }
    return false;
  }
};
partial.default = PartialMatcher;
Object.defineProperty(deep, "__esModule", { value: true });
var utils$4 = utils$g;
var partial_1 = partial;
var DeepFilter = class {
  constructor(_settings, _micromatchOptions) {
    this._settings = _settings;
    this._micromatchOptions = _micromatchOptions;
  }
  getFilter(basePath, positive, negative) {
    const matcher2 = this._getMatcher(positive);
    const negativeRe = this._getNegativePatternsRe(negative);
    return (entry2) => this._filter(basePath, entry2, matcher2, negativeRe);
  }
  _getMatcher(patterns2) {
    return new partial_1.default(patterns2, this._settings, this._micromatchOptions);
  }
  _getNegativePatternsRe(patterns2) {
    const affectDepthOfReadingPatterns = patterns2.filter(utils$4.pattern.isAffectDepthOfReadingPattern);
    return utils$4.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
  }
  _filter(basePath, entry2, matcher2, negativeRe) {
    if (this._isSkippedByDeep(basePath, entry2.path)) {
      return false;
    }
    if (this._isSkippedSymbolicLink(entry2)) {
      return false;
    }
    const filepath = utils$4.path.removeLeadingDotSegment(entry2.path);
    if (this._isSkippedByPositivePatterns(filepath, matcher2)) {
      return false;
    }
    return this._isSkippedByNegativePatterns(filepath, negativeRe);
  }
  _isSkippedByDeep(basePath, entryPath) {
    if (this._settings.deep === Infinity) {
      return false;
    }
    return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
  }
  _getEntryLevel(basePath, entryPath) {
    const entryPathDepth = entryPath.split("/").length;
    if (basePath === "") {
      return entryPathDepth;
    }
    const basePathDepth = basePath.split("/").length;
    return entryPathDepth - basePathDepth;
  }
  _isSkippedSymbolicLink(entry2) {
    return !this._settings.followSymbolicLinks && entry2.dirent.isSymbolicLink();
  }
  _isSkippedByPositivePatterns(entryPath, matcher2) {
    return !this._settings.baseNameMatch && !matcher2.match(entryPath);
  }
  _isSkippedByNegativePatterns(entryPath, patternsRe) {
    return !utils$4.pattern.matchAny(entryPath, patternsRe);
  }
};
deep.default = DeepFilter;
var entry$1 = {};
Object.defineProperty(entry$1, "__esModule", { value: true });
var utils$3 = utils$g;
var EntryFilter = class {
  constructor(_settings, _micromatchOptions) {
    this._settings = _settings;
    this._micromatchOptions = _micromatchOptions;
    this.index = /* @__PURE__ */ new Map();
  }
  getFilter(positive, negative) {
    const positiveRe = utils$3.pattern.convertPatternsToRe(positive, this._micromatchOptions);
    const negativeRe = utils$3.pattern.convertPatternsToRe(negative, this._micromatchOptions);
    return (entry2) => this._filter(entry2, positiveRe, negativeRe);
  }
  _filter(entry2, positiveRe, negativeRe) {
    if (this._settings.unique && this._isDuplicateEntry(entry2)) {
      return false;
    }
    if (this._onlyFileFilter(entry2) || this._onlyDirectoryFilter(entry2)) {
      return false;
    }
    if (this._isSkippedByAbsoluteNegativePatterns(entry2.path, negativeRe)) {
      return false;
    }
    const filepath = this._settings.baseNameMatch ? entry2.name : entry2.path;
    const isDirectory2 = entry2.dirent.isDirectory();
    const isMatched = this._isMatchToPatterns(filepath, positiveRe, isDirectory2) && !this._isMatchToPatterns(entry2.path, negativeRe, isDirectory2);
    if (this._settings.unique && isMatched) {
      this._createIndexRecord(entry2);
    }
    return isMatched;
  }
  _isDuplicateEntry(entry2) {
    return this.index.has(entry2.path);
  }
  _createIndexRecord(entry2) {
    this.index.set(entry2.path, void 0);
  }
  _onlyFileFilter(entry2) {
    return this._settings.onlyFiles && !entry2.dirent.isFile();
  }
  _onlyDirectoryFilter(entry2) {
    return this._settings.onlyDirectories && !entry2.dirent.isDirectory();
  }
  _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
    if (!this._settings.absolute) {
      return false;
    }
    const fullpath = utils$3.path.makeAbsolute(this._settings.cwd, entryPath);
    return utils$3.pattern.matchAny(fullpath, patternsRe);
  }
  _isMatchToPatterns(entryPath, patternsRe, isDirectory2) {
    const filepath = utils$3.path.removeLeadingDotSegment(entryPath);
    const isMatched = utils$3.pattern.matchAny(filepath, patternsRe);
    if (!isMatched && isDirectory2) {
      return utils$3.pattern.matchAny(filepath + "/", patternsRe);
    }
    return isMatched;
  }
};
entry$1.default = EntryFilter;
var error$2 = {};
Object.defineProperty(error$2, "__esModule", { value: true });
var utils$2 = utils$g;
var ErrorFilter = class {
  constructor(_settings) {
    this._settings = _settings;
  }
  getFilter() {
    return (error3) => this._isNonFatalError(error3);
  }
  _isNonFatalError(error3) {
    return utils$2.errno.isEnoentCodeError(error3) || this._settings.suppressErrors;
  }
};
error$2.default = ErrorFilter;
var entry = {};
Object.defineProperty(entry, "__esModule", { value: true });
var utils$1 = utils$g;
var EntryTransformer = class {
  constructor(_settings) {
    this._settings = _settings;
  }
  getTransformer() {
    return (entry2) => this._transform(entry2);
  }
  _transform(entry2) {
    let filepath = entry2.path;
    if (this._settings.absolute) {
      filepath = utils$1.path.makeAbsolute(this._settings.cwd, filepath);
      filepath = utils$1.path.unixify(filepath);
    }
    if (this._settings.markDirectories && entry2.dirent.isDirectory()) {
      filepath += "/";
    }
    if (!this._settings.objectMode) {
      return filepath;
    }
    return Object.assign(Object.assign({}, entry2), { path: filepath });
  }
};
entry.default = EntryTransformer;
Object.defineProperty(provider, "__esModule", { value: true });
var path$a = import_path.default;
var deep_1 = deep;
var entry_1 = entry$1;
var error_1 = error$2;
var entry_2 = entry;
var Provider = class {
  constructor(_settings) {
    this._settings = _settings;
    this.errorFilter = new error_1.default(this._settings);
    this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
    this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
    this.entryTransformer = new entry_2.default(this._settings);
  }
  _getRootDirectory(task) {
    return path$a.resolve(this._settings.cwd, task.base);
  }
  _getReaderOptions(task) {
    const basePath = task.base === "." ? "" : task.base;
    return {
      basePath,
      pathSegmentSeparator: "/",
      concurrency: this._settings.concurrency,
      deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
      entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
      errorFilter: this.errorFilter.getFilter(),
      followSymbolicLinks: this._settings.followSymbolicLinks,
      fs: this._settings.fs,
      stats: this._settings.stats,
      throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
      transform: this.entryTransformer.getTransformer()
    };
  }
  _getMicromatchOptions() {
    return {
      dot: this._settings.dot,
      matchBase: this._settings.baseNameMatch,
      nobrace: !this._settings.braceExpansion,
      nocase: !this._settings.caseSensitiveMatch,
      noext: !this._settings.extglob,
      noglobstar: !this._settings.globstar,
      posix: true,
      strictSlashes: false
    };
  }
};
provider.default = Provider;
Object.defineProperty(async$7, "__esModule", { value: true });
var async_1$1 = async$6;
var provider_1$2 = provider;
var ProviderAsync = class extends provider_1$2.default {
  constructor() {
    super(...arguments);
    this._reader = new async_1$1.default(this._settings);
  }
  async read(task) {
    const root = this._getRootDirectory(task);
    const options3 = this._getReaderOptions(task);
    const entries = await this.api(root, task, options3);
    return entries.map((entry2) => options3.transform(entry2));
  }
  api(root, task, options3) {
    if (task.dynamic) {
      return this._reader.dynamic(root, options3);
    }
    return this._reader.static(task.patterns, options3);
  }
};
async$7.default = ProviderAsync;
var stream = {};
Object.defineProperty(stream, "__esModule", { value: true });
var stream_1$1 = import_stream.default;
var stream_2 = stream$1;
var provider_1$1 = provider;
var ProviderStream = class extends provider_1$1.default {
  constructor() {
    super(...arguments);
    this._reader = new stream_2.default(this._settings);
  }
  read(task) {
    const root = this._getRootDirectory(task);
    const options3 = this._getReaderOptions(task);
    const source = this.api(root, task, options3);
    const destination = new stream_1$1.Readable({ objectMode: true, read: () => {
    } });
    source.once("error", (error3) => destination.emit("error", error3)).on("data", (entry2) => destination.emit("data", options3.transform(entry2))).once("end", () => destination.emit("end"));
    destination.once("close", () => source.destroy());
    return destination;
  }
  api(root, task, options3) {
    if (task.dynamic) {
      return this._reader.dynamic(root, options3);
    }
    return this._reader.static(task.patterns, options3);
  }
};
stream.default = ProviderStream;
var sync$2 = {};
var sync$1 = {};
Object.defineProperty(sync$1, "__esModule", { value: true });
var fsStat = out$1;
var fsWalk = out$3;
var reader_1 = reader;
var ReaderSync = class extends reader_1.default {
  constructor() {
    super(...arguments);
    this._walkSync = fsWalk.walkSync;
    this._statSync = fsStat.statSync;
  }
  dynamic(root, options3) {
    return this._walkSync(root, options3);
  }
  static(patterns2, options3) {
    const entries = [];
    for (const pattern2 of patterns2) {
      const filepath = this._getFullEntryPath(pattern2);
      const entry2 = this._getEntry(filepath, pattern2, options3);
      if (entry2 === null || !options3.entryFilter(entry2)) {
        continue;
      }
      entries.push(entry2);
    }
    return entries;
  }
  _getEntry(filepath, pattern2, options3) {
    try {
      const stats = this._getStat(filepath);
      return this._makeEntry(stats, pattern2);
    } catch (error3) {
      if (options3.errorFilter(error3)) {
        return null;
      }
      throw error3;
    }
  }
  _getStat(filepath) {
    return this._statSync(filepath, this._fsStatSettings);
  }
};
sync$1.default = ReaderSync;
Object.defineProperty(sync$2, "__esModule", { value: true });
var sync_1$1 = sync$1;
var provider_1 = provider;
var ProviderSync = class extends provider_1.default {
  constructor() {
    super(...arguments);
    this._reader = new sync_1$1.default(this._settings);
  }
  read(task) {
    const root = this._getRootDirectory(task);
    const options3 = this._getReaderOptions(task);
    const entries = this.api(root, task, options3);
    return entries.map(options3.transform);
  }
  api(root, task, options3) {
    if (task.dynamic) {
      return this._reader.dynamic(root, options3);
    }
    return this._reader.static(task.patterns, options3);
  }
};
sync$2.default = ProviderSync;
var settings = {};
(function(exports3) {
  Object.defineProperty(exports3, "__esModule", { value: true });
  exports3.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
  const fs6 = import_fs.default;
  const os2 = import_os.default;
  const CPU_COUNT = Math.max(os2.cpus().length, 1);
  exports3.DEFAULT_FILE_SYSTEM_ADAPTER = {
    lstat: fs6.lstat,
    lstatSync: fs6.lstatSync,
    stat: fs6.stat,
    statSync: fs6.statSync,
    readdir: fs6.readdir,
    readdirSync: fs6.readdirSync
  };
  class Settings4 {
    constructor(_options2 = {}) {
      this._options = _options2;
      this.absolute = this._getValue(this._options.absolute, false);
      this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
      this.braceExpansion = this._getValue(this._options.braceExpansion, true);
      this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
      this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
      this.cwd = this._getValue(this._options.cwd, process.cwd());
      this.deep = this._getValue(this._options.deep, Infinity);
      this.dot = this._getValue(this._options.dot, false);
      this.extglob = this._getValue(this._options.extglob, true);
      this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
      this.fs = this._getFileSystemMethods(this._options.fs);
      this.globstar = this._getValue(this._options.globstar, true);
      this.ignore = this._getValue(this._options.ignore, []);
      this.markDirectories = this._getValue(this._options.markDirectories, false);
      this.objectMode = this._getValue(this._options.objectMode, false);
      this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
      this.onlyFiles = this._getValue(this._options.onlyFiles, true);
      this.stats = this._getValue(this._options.stats, false);
      this.suppressErrors = this._getValue(this._options.suppressErrors, false);
      this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
      this.unique = this._getValue(this._options.unique, true);
      if (this.onlyDirectories) {
        this.onlyFiles = false;
      }
      if (this.stats) {
        this.objectMode = true;
      }
    }
    _getValue(option, value2) {
      return option === void 0 ? value2 : option;
    }
    _getFileSystemMethods(methods = {}) {
      return Object.assign(Object.assign({}, exports3.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
    }
  }
  exports3.default = Settings4;
})(settings);
var taskManager = tasks;
var patternManager = patterns;
var async_1 = async$7;
var stream_1 = stream;
var sync_1 = sync$2;
var settings_1 = settings;
var utils = utils$g;
async function FastGlob(source, options3) {
  assertPatternsInput2(source);
  const works = getWorks(source, async_1.default, options3);
  const result = await Promise.all(works);
  return utils.array.flatten(result);
}
(function(FastGlob2) {
  function sync2(source, options3) {
    assertPatternsInput2(source);
    const works = getWorks(source, sync_1.default, options3);
    return utils.array.flatten(works);
  }
  FastGlob2.sync = sync2;
  function stream4(source, options3) {
    assertPatternsInput2(source);
    const works = getWorks(source, stream_1.default, options3);
    return utils.stream.merge(works);
  }
  FastGlob2.stream = stream4;
  function generateTasks2(source, options3) {
    assertPatternsInput2(source);
    const patterns2 = patternManager.transform([].concat(source));
    const settings2 = new settings_1.default(options3);
    return taskManager.generate(patterns2, settings2);
  }
  FastGlob2.generateTasks = generateTasks2;
  function isDynamicPattern3(source, options3) {
    assertPatternsInput2(source);
    const settings2 = new settings_1.default(options3);
    return utils.pattern.isDynamicPattern(source, settings2);
  }
  FastGlob2.isDynamicPattern = isDynamicPattern3;
  function escapePath(source) {
    assertPatternsInput2(source);
    return utils.path.escape(source);
  }
  FastGlob2.escapePath = escapePath;
})(FastGlob || (FastGlob = {}));
function getWorks(source, _Provider, options3) {
  const patterns2 = patternManager.transform([].concat(source));
  const settings2 = new settings_1.default(options3);
  const tasks2 = taskManager.generate(patterns2, settings2);
  const provider2 = new _Provider(settings2);
  return tasks2.map(provider2.read, provider2);
}
function assertPatternsInput2(input) {
  const source = [].concat(input);
  const isValidSource = source.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));
  if (!isValidSource) {
    throw new TypeError("Patterns must be a string (non empty) or an array of strings");
  }
}
var out = FastGlob;
var debug$b = createDebugger("vite:ssr-external");
function stripNesting(packages) {
  return packages.map((s2) => {
    const arr = s2.split(">");
    return arr[arr.length - 1].trim();
  });
}
function cjsSsrResolveExternals(config2, knownImports) {
  var _a;
  knownImports = stripNesting(knownImports);
  const ssrConfig = config2.ssr;
  if ((ssrConfig == null ? void 0 : ssrConfig.noExternal) === true) {
    return [];
  }
  const ssrExternals = /* @__PURE__ */ new Set();
  const seen2 = /* @__PURE__ */ new Set();
  (_a = ssrConfig == null ? void 0 : ssrConfig.external) == null ? void 0 : _a.forEach((id) => {
    ssrExternals.add(id);
    seen2.add(id);
  });
  cjsSsrCollectExternals(config2.root, config2.resolve, ssrExternals, seen2, config2.logger);
  const importedDeps = knownImports.map(getNpmPackageName).filter(isDefined);
  for (const dep of importedDeps) {
    if (!seen2.has(dep)) {
      ssrExternals.add(dep);
    }
  }
  ssrExternals.delete("vite");
  let externals = [...ssrExternals];
  if (ssrConfig == null ? void 0 : ssrConfig.noExternal) {
    externals = externals.filter(createFilter2(void 0, ssrConfig.noExternal, { resolve: false }));
  }
  return externals;
}
var CJS_CONTENT_RE = /\bmodule\.exports\b|\bexports[.[]|\brequire\s*\(|\bObject\.(?:defineProperty|defineProperties|assign)\s*\(\s*exports\b/;
var _require$2 = (0, import_node_module.createRequire)(import.meta.url);
var isSsrExternalCache = /* @__PURE__ */ new WeakMap();
function shouldExternalizeForSSR(id, config2) {
  let isSsrExternal = isSsrExternalCache.get(config2);
  if (!isSsrExternal) {
    isSsrExternal = createIsSsrExternal(config2);
    isSsrExternalCache.set(config2, isSsrExternal);
  }
  return isSsrExternal(id);
}
function createIsConfiguredAsSsrExternal(config2) {
  const { ssr, root } = config2;
  const noExternal = ssr == null ? void 0 : ssr.noExternal;
  const noExternalFilter = noExternal !== "undefined" && typeof noExternal !== "boolean" && createFilter2(void 0, noExternal, { resolve: false });
  const resolveOptions = {
    ...config2.resolve,
    root,
    isProduction: false,
    isBuild: true
  };
  const isExternalizable = (id, configuredAsExternal) => {
    var _a;
    if (!bareImportRE.test(id) || id.includes("\0")) {
      return false;
    }
    try {
      return !!((_a = tryNodeResolve(
        id,
        void 0,
        resolveOptions,
        (ssr == null ? void 0 : ssr.target) === "webworker",
        void 0,
        true,
        // try to externalize, will return undefined or an object without
        // a external flag if it isn't externalizable
        true,
        // Allow linked packages to be externalized if they are explicitly
        // configured as external
        !!configuredAsExternal
      )) == null ? void 0 : _a.external);
    } catch (e3) {
      debug$b(`Failed to node resolve "${id}". Skipping externalizing it by default.`);
      return false;
    }
  };
  return (id) => {
    var _a, _b;
    const { ssr: ssr2 } = config2;
    if (ssr2) {
      if (
        // If this id is defined as external, force it as external
        // Note that individual package entries are allowed in ssr.external
        (_a = ssr2.external) == null ? void 0 : _a.includes(id)
      ) {
        return true;
      }
      const pkgName = getNpmPackageName(id);
      if (!pkgName) {
        return isExternalizable(id);
      }
      if (
        // A package name in ssr.external externalizes every
        // externalizable package entry
        (_b = ssr2.external) == null ? void 0 : _b.includes(pkgName)
      ) {
        return isExternalizable(id, true);
      }
      if (typeof noExternal === "boolean") {
        return !noExternal;
      }
      if (noExternalFilter && !noExternalFilter(pkgName)) {
        return false;
      }
    }
    return isExternalizable(id);
  };
}
function createIsSsrExternal(config2) {
  const processedIds = /* @__PURE__ */ new Map();
  const isConfiguredAsExternal = createIsConfiguredAsSsrExternal(config2);
  return (id) => {
    if (processedIds.has(id)) {
      return processedIds.get(id);
    }
    let external = false;
    if (!id.startsWith(".") && !import_node_path4.default.isAbsolute(id)) {
      external = isBuiltin(id) || isConfiguredAsExternal(id);
    }
    processedIds.set(id, external);
    return external;
  };
}
function cjsSsrCollectExternals(root, resolveOptions, ssrExternals, seen2, logger2) {
  var _a;
  const rootPkgContent = lookupFile(root, ["package.json"]);
  if (!rootPkgContent) {
    return;
  }
  const rootPkg = JSON.parse(rootPkgContent);
  const deps = {
    ...rootPkg.devDependencies,
    ...rootPkg.dependencies
  };
  const internalResolveOptions = {
    ...resolveOptions,
    root,
    isProduction: false,
    isBuild: true
  };
  const depsToTrace = /* @__PURE__ */ new Set();
  for (const id in deps) {
    if (seen2.has(id))
      continue;
    seen2.add(id);
    let esmEntry;
    let requireEntry;
    try {
      esmEntry = (_a = tryNodeResolve(
        id,
        void 0,
        internalResolveOptions,
        true,
        // we set `targetWeb` to `true` to get the ESM entry
        void 0,
        true
      )) == null ? void 0 : _a.id;
      requireEntry = normalizePath$3(_require$2.resolve(id, { paths: [root] }));
    } catch (e3) {
      try {
        const pkgPath = resolveFrom(`${id}/package.json`, root);
        if (pkgPath.includes("node_modules")) {
          ssrExternals.add(id);
        } else {
          depsToTrace.add(import_node_path4.default.dirname(pkgPath));
        }
        continue;
      } catch {
      }
      debug$b(`Failed to resolve entries for package "${id}"
`, e3);
      continue;
    }
    if (!esmEntry) {
      ssrExternals.add(id);
    } else if (!esmEntry.includes("node_modules")) {
      const pkgPath = resolveFrom(`${id}/package.json`, root);
      depsToTrace.add(import_node_path4.default.dirname(pkgPath));
    } else if (esmEntry !== requireEntry) {
      ssrExternals.add(id);
    } else if (/\.m?js$/.test(esmEntry)) {
      const pkgPath = resolveFrom(`${id}/package.json`, root);
      const pkgContent = import_node_fs4.default.readFileSync(pkgPath, "utf-8");
      if (!pkgContent) {
        continue;
      }
      const pkg = JSON.parse(pkgContent);
      if (pkg.type === "module" || esmEntry.endsWith(".mjs")) {
        ssrExternals.add(id);
        continue;
      }
      const content = import_node_fs4.default.readFileSync(esmEntry, "utf-8");
      if (CJS_CONTENT_RE.test(content)) {
        ssrExternals.add(id);
        continue;
      }
      logger2.warn(`${id} doesn't appear to be written in CJS, but also doesn't appear to be a valid ES module (i.e. it doesn't have "type": "module" or an .mjs extension for the entry point). Please contact the package author to fix.`);
    }
  }
  for (const depRoot of depsToTrace) {
    cjsSsrCollectExternals(depRoot, resolveOptions, ssrExternals, seen2, logger2);
  }
}
function cjsShouldExternalizeForSSR(id, externals) {
  if (!externals) {
    return false;
  }
  const should = externals.some((e3) => {
    if (id === e3) {
      return true;
    }
    if (id.startsWith(e3 + "/") && (!import_node_path4.default.extname(id) || id.endsWith(".js"))) {
      return true;
    }
  });
  return should;
}
function getNpmPackageName(importPath) {
  const parts = importPath.split("/");
  if (parts[0].startsWith("@")) {
    if (!parts[1])
      return null;
    return `${parts[0]}/${parts[1]}`;
  } else {
    return parts[0];
  }
}
var jsonExtRE = /\.json(?:$|\?)(?!commonjs-(?:proxy|external))/;
var jsonLangs = `\\.(?:json|json5)(?:$|\\?)`;
var jsonLangRE = new RegExp(jsonLangs);
var isJSONRequest = (request) => jsonLangRE.test(request);
function jsonPlugin(options3 = {}, isBuild) {
  return {
    name: "vite:json",
    transform(json2, id) {
      if (!jsonExtRE.test(id))
        return null;
      if (SPECIAL_QUERY_RE.test(id))
        return null;
      json2 = stripBomTag(json2);
      try {
        if (options3.stringify) {
          if (isBuild) {
            return {
              // during build, parse then double-stringify to remove all
              // unnecessary whitespaces to reduce bundle size.
              code: `export default JSON.parse(${JSON.stringify(JSON.stringify(JSON.parse(json2)))})`,
              map: { mappings: "" }
            };
          } else {
            return `export default JSON.parse(${JSON.stringify(json2)})`;
          }
        }
        const parsed = JSON.parse(json2);
        return {
          code: dataToEsm(parsed, {
            preferConst: true,
            namedExports: options3.namedExports
          }),
          map: { mappings: "" }
        };
      } catch (e3) {
        const errorMessageList = /\d+/.exec(e3.message);
        const position = errorMessageList && parseInt(errorMessageList[0], 10);
        const msg = position ? `, invalid JSON syntax found at line ${position}` : `.`;
        this.error(`Failed to parse JSON file` + msg, e3.idx);
      }
    }
  };
}
var ERR_OPTIMIZE_DEPS_PROCESSING_ERROR = "ERR_OPTIMIZE_DEPS_PROCESSING_ERROR";
var ERR_OUTDATED_OPTIMIZED_DEP = "ERR_OUTDATED_OPTIMIZED_DEP";
var isDebug$3 = process.env.DEBUG;
var debug$a = createDebugger("vite:optimize-deps");
function optimizedDepsPlugin(config2) {
  return {
    name: "vite:optimized-deps",
    async resolveId(id, source, { ssr }) {
      var _a;
      if ((_a = getDepsOptimizer(config2, ssr)) == null ? void 0 : _a.isOptimizedDepFile(id)) {
        return id;
      }
    },
    // this.load({ id }) isn't implemented in PluginContainer
    // The logic to register an id to wait until it is processed
    // is in importAnalysis, see call to delayDepsOptimizerUntil
    async load(id, options3) {
      const ssr = (options3 == null ? void 0 : options3.ssr) === true;
      const depsOptimizer = getDepsOptimizer(config2, ssr);
      if (depsOptimizer == null ? void 0 : depsOptimizer.isOptimizedDepFile(id)) {
        const metadata = depsOptimizer.metadata;
        const file = cleanUrl(id);
        const versionMatch = id.match(DEP_VERSION_RE);
        const browserHash = versionMatch ? versionMatch[1].split("=")[1] : void 0;
        const info3 = optimizedDepInfoFromFile(metadata, file);
        if (info3) {
          if (browserHash && info3.browserHash !== browserHash) {
            throwOutdatedRequest(id);
          }
          try {
            await info3.processing;
          } catch {
            throwProcessingError(id);
            return;
          }
          const newMetadata = depsOptimizer.metadata;
          if (metadata !== newMetadata) {
            const currentInfo = optimizedDepInfoFromFile(newMetadata, file);
            if (info3.browserHash !== (currentInfo == null ? void 0 : currentInfo.browserHash)) {
              throwOutdatedRequest(id);
            }
          }
        }
        isDebug$3 && debug$a(`load ${picocolorsExports.cyan(file)}`);
        try {
          return await import_node_fs4.promises.readFile(file, "utf-8");
        } catch (e3) {
          throwOutdatedRequest(id);
        }
      }
    }
  };
}
function optimizedDepsBuildPlugin(config2) {
  return {
    name: "vite:optimized-deps-build",
    buildStart() {
      var _a;
      if (!config2.isWorker) {
        (_a = getDepsOptimizer(config2)) == null ? void 0 : _a.resetRegisteredIds();
      }
    },
    async resolveId(id, importer, { ssr }) {
      var _a;
      if ((_a = getDepsOptimizer(config2, ssr)) == null ? void 0 : _a.isOptimizedDepFile(id)) {
        return id;
      }
    },
    transform(_code, id, options3) {
      var _a;
      const ssr = (options3 == null ? void 0 : options3.ssr) === true;
      (_a = getDepsOptimizer(config2, ssr)) == null ? void 0 : _a.delayDepsOptimizerUntil(id, async () => {
        await this.load({ id });
      });
    },
    async load(id, options3) {
      const ssr = (options3 == null ? void 0 : options3.ssr) === true;
      const depsOptimizer = getDepsOptimizer(config2, ssr);
      if (!(depsOptimizer == null ? void 0 : depsOptimizer.isOptimizedDepFile(id))) {
        return;
      }
      depsOptimizer == null ? void 0 : depsOptimizer.ensureFirstRun();
      const file = cleanUrl(id);
      const info3 = optimizedDepInfoFromFile(depsOptimizer.metadata, file);
      if (info3) {
        try {
          await info3.processing;
        } catch {
          return;
        }
        isDebug$3 && debug$a(`load ${picocolorsExports.cyan(file)}`);
      } else {
        return;
      }
      try {
        return await import_node_fs4.promises.readFile(file, "utf-8");
      } catch (e3) {
        return "";
      }
    }
  };
}
function throwProcessingError(id) {
  const err2 = new Error(`Something unexpected happened while optimizing "${id}". The current page should have reloaded by now`);
  err2.code = ERR_OPTIMIZE_DEPS_PROCESSING_ERROR;
  throw err2;
}
function throwOutdatedRequest(id) {
  const err2 = new Error(`There is a new version of the pre-bundle for "${id}", a page reload is going to ask for it.`);
  err2.code = ERR_OUTDATED_OPTIMIZED_DEP;
  throw err2;
}
var dist = {};
(function(exports3) {
  Object.defineProperty(exports3, "__esModule", { value: true });
  exports3.lilconfigSync = exports3.lilconfig = exports3.defaultLoaders = void 0;
  const path8 = import_path.default;
  const fs6 = import_fs.default;
  const os2 = import_os.default;
  const fsReadFileAsync = fs6.promises.readFile;
  function getDefaultSearchPlaces(name2) {
    return [
      "package.json",
      `.${name2}rc.json`,
      `.${name2}rc.js`,
      `${name2}.config.js`,
      `.${name2}rc.cjs`,
      `${name2}.config.cjs`
    ];
  }
  function getSearchPaths(startDir, stopDir) {
    return startDir.split(path8.sep).reduceRight((acc, _, ind, arr) => {
      const currentPath = arr.slice(0, ind + 1).join(path8.sep);
      if (!acc.passedStopDir)
        acc.searchPlaces.push(currentPath || path8.sep);
      if (currentPath === stopDir)
        acc.passedStopDir = true;
      return acc;
    }, { searchPlaces: [], passedStopDir: false }).searchPlaces;
  }
  exports3.defaultLoaders = Object.freeze({
    ".js": __require2,
    ".json": __require2,
    ".cjs": __require2,
    noExt(_, content) {
      return JSON.parse(content);
    }
  });
  function getExtDesc(ext2) {
    return ext2 === "noExt" ? "files without extensions" : `extension "${ext2}"`;
  }
  function getOptions2(name2, options3 = {}) {
    const conf = {
      stopDir: os2.homedir(),
      searchPlaces: getDefaultSearchPlaces(name2),
      ignoreEmptySearchPlaces: true,
      transform: (x) => x,
      packageProp: [name2],
      ...options3,
      loaders: { ...exports3.defaultLoaders, ...options3.loaders }
    };
    conf.searchPlaces.forEach((place) => {
      const key = path8.extname(place) || "noExt";
      const loader = conf.loaders[key];
      if (!loader) {
        throw new Error(`No loader specified for ${getExtDesc(key)}, so searchPlaces item "${place}" is invalid`);
      }
      if (typeof loader !== "function") {
        throw new Error(`loader for ${getExtDesc(key)} is not a function (type provided: "${typeof loader}"), so searchPlaces item "${place}" is invalid`);
      }
    });
    return conf;
  }
  function getPackageProp(props, obj) {
    if (typeof props === "string" && props in obj)
      return obj[props];
    return (Array.isArray(props) ? props : props.split(".")).reduce((acc, prop) => acc === void 0 ? acc : acc[prop], obj) || null;
  }
  function getSearchItems(searchPlaces, searchPaths) {
    return searchPaths.reduce((acc, searchPath) => {
      searchPlaces.forEach((fileName) => acc.push({
        fileName,
        filepath: path8.join(searchPath, fileName),
        loaderKey: path8.extname(fileName) || "noExt"
      }));
      return acc;
    }, []);
  }
  function validateFilePath(filepath) {
    if (!filepath)
      throw new Error("load must pass a non-empty string");
  }
  function validateLoader(loader, ext2) {
    if (!loader)
      throw new Error(`No loader specified for extension "${ext2}"`);
    if (typeof loader !== "function")
      throw new Error("loader is not a function");
  }
  function lilconfig(name2, options3) {
    const { ignoreEmptySearchPlaces, loaders, packageProp, searchPlaces, stopDir, transform: transform2 } = getOptions2(name2, options3);
    return {
      async search(searchFrom = process.cwd()) {
        const searchPaths = getSearchPaths(searchFrom, stopDir);
        const result = {
          config: null,
          filepath: ""
        };
        const searchItems = getSearchItems(searchPlaces, searchPaths);
        for (const { fileName, filepath, loaderKey } of searchItems) {
          try {
            await fs6.promises.access(filepath);
          } catch (_a) {
            continue;
          }
          const content = String(await fsReadFileAsync(filepath));
          const loader = loaders[loaderKey];
          if (fileName === "package.json") {
            const pkg = await loader(filepath, content);
            const maybeConfig = getPackageProp(packageProp, pkg);
            if (maybeConfig != null) {
              result.config = maybeConfig;
              result.filepath = filepath;
              break;
            }
            continue;
          }
          const isEmpty3 = content.trim() === "";
          if (isEmpty3 && ignoreEmptySearchPlaces)
            continue;
          if (isEmpty3) {
            result.isEmpty = true;
            result.config = void 0;
          } else {
            validateLoader(loader, loaderKey);
            result.config = await loader(filepath, content);
          }
          result.filepath = filepath;
          break;
        }
        if (result.filepath === "" && result.config === null)
          return transform2(null);
        return transform2(result);
      },
      async load(filepath) {
        validateFilePath(filepath);
        const absPath = path8.resolve(process.cwd(), filepath);
        const { base: base2, ext: ext2 } = path8.parse(absPath);
        const loaderKey = ext2 || "noExt";
        const loader = loaders[loaderKey];
        validateLoader(loader, loaderKey);
        const content = String(await fsReadFileAsync(absPath));
        if (base2 === "package.json") {
          const pkg = await loader(absPath, content);
          return transform2({
            config: getPackageProp(packageProp, pkg),
            filepath: absPath
          });
        }
        const result = {
          config: null,
          filepath: absPath
        };
        const isEmpty3 = content.trim() === "";
        if (isEmpty3 && ignoreEmptySearchPlaces)
          return transform2({
            config: void 0,
            filepath: absPath,
            isEmpty: true
          });
        result.config = isEmpty3 ? void 0 : await loader(absPath, content);
        return transform2(isEmpty3 ? { ...result, isEmpty: isEmpty3, config: void 0 } : result);
      }
    };
  }
  exports3.lilconfig = lilconfig;
  function lilconfigSync(name2, options3) {
    const { ignoreEmptySearchPlaces, loaders, packageProp, searchPlaces, stopDir, transform: transform2 } = getOptions2(name2, options3);
    return {
      search(searchFrom = process.cwd()) {
        const searchPaths = getSearchPaths(searchFrom, stopDir);
        const result = {
          config: null,
          filepath: ""
        };
        const searchItems = getSearchItems(searchPlaces, searchPaths);
        for (const { fileName, filepath, loaderKey } of searchItems) {
          try {
            fs6.accessSync(filepath);
          } catch (_a) {
            continue;
          }
          const loader = loaders[loaderKey];
          const content = String(fs6.readFileSync(filepath));
          if (fileName === "package.json") {
            const pkg = loader(filepath, content);
            const maybeConfig = getPackageProp(packageProp, pkg);
            if (maybeConfig != null) {
              result.config = maybeConfig;
              result.filepath = filepath;
              break;
            }
            continue;
          }
          const isEmpty3 = content.trim() === "";
          if (isEmpty3 && ignoreEmptySearchPlaces)
            continue;
          if (isEmpty3) {
            result.isEmpty = true;
            result.config = void 0;
          } else {
            validateLoader(loader, loaderKey);
            result.config = loader(filepath, content);
          }
          result.filepath = filepath;
          break;
        }
        if (result.filepath === "" && result.config === null)
          return transform2(null);
        return transform2(result);
      },
      load(filepath) {
        validateFilePath(filepath);
        const absPath = path8.resolve(process.cwd(), filepath);
        const { base: base2, ext: ext2 } = path8.parse(absPath);
        const loaderKey = ext2 || "noExt";
        const loader = loaders[loaderKey];
        validateLoader(loader, loaderKey);
        const content = String(fs6.readFileSync(absPath));
        if (base2 === "package.json") {
          const pkg = loader(absPath, content);
          return transform2({
            config: getPackageProp(packageProp, pkg),
            filepath: absPath
          });
        }
        const result = {
          config: null,
          filepath: absPath
        };
        const isEmpty3 = content.trim() === "";
        if (isEmpty3 && ignoreEmptySearchPlaces)
          return transform2({
            filepath: absPath,
            config: void 0,
            isEmpty: true
          });
        result.config = isEmpty3 ? void 0 : loader(absPath, content);
        return transform2(isEmpty3 ? { ...result, isEmpty: isEmpty3, config: void 0 } : result);
      }
    };
  }
  exports3.lilconfigSync = lilconfigSync;
})(dist);
var ALIAS = Symbol.for("yaml.alias");
var DOC = Symbol.for("yaml.document");
var MAP = Symbol.for("yaml.map");
var PAIR = Symbol.for("yaml.pair");
var SCALAR$1 = Symbol.for("yaml.scalar");
var SEQ = Symbol.for("yaml.seq");
var NODE_TYPE = Symbol.for("yaml.node.type");
var isAlias = (node3) => !!node3 && typeof node3 === "object" && node3[NODE_TYPE] === ALIAS;
var isDocument = (node3) => !!node3 && typeof node3 === "object" && node3[NODE_TYPE] === DOC;
var isMap = (node3) => !!node3 && typeof node3 === "object" && node3[NODE_TYPE] === MAP;
var isPair = (node3) => !!node3 && typeof node3 === "object" && node3[NODE_TYPE] === PAIR;
var isScalar$1 = (node3) => !!node3 && typeof node3 === "object" && node3[NODE_TYPE] === SCALAR$1;
var isSeq = (node3) => !!node3 && typeof node3 === "object" && node3[NODE_TYPE] === SEQ;
function isCollection$1(node3) {
  if (node3 && typeof node3 === "object")
    switch (node3[NODE_TYPE]) {
      case MAP:
      case SEQ:
        return true;
    }
  return false;
}
function isNode$1(node3) {
  if (node3 && typeof node3 === "object")
    switch (node3[NODE_TYPE]) {
      case ALIAS:
      case MAP:
      case SCALAR$1:
      case SEQ:
        return true;
    }
  return false;
}
var hasAnchor = (node3) => (isScalar$1(node3) || isCollection$1(node3)) && !!node3.anchor;
var NodeBase = class {
  constructor(type) {
    Object.defineProperty(this, NODE_TYPE, { value: type });
  }
  /** Create a copy of this node.  */
  clone() {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
};
var BREAK$1 = Symbol("break visit");
var SKIP$1 = Symbol("skip children");
var REMOVE$1 = Symbol("remove node");
function visit$1(node3, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node3)) {
    const cd = visit_(null, node3.contents, visitor_, Object.freeze([node3]));
    if (cd === REMOVE$1)
      node3.contents = null;
  } else
    visit_(null, node3, visitor_, Object.freeze([]));
}
visit$1.BREAK = BREAK$1;
visit$1.SKIP = SKIP$1;
visit$1.REMOVE = REMOVE$1;
function visit_(key, node3, visitor, path8) {
  const ctrl = callVisitor(key, node3, visitor, path8);
  if (isNode$1(ctrl) || isPair(ctrl)) {
    replaceNode(key, path8, ctrl);
    return visit_(key, ctrl, visitor, path8);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection$1(node3)) {
      path8 = Object.freeze(path8.concat(node3));
      for (let i2 = 0; i2 < node3.items.length; ++i2) {
        const ci = visit_(i2, node3.items[i2], visitor, path8);
        if (typeof ci === "number")
          i2 = ci - 1;
        else if (ci === BREAK$1)
          return BREAK$1;
        else if (ci === REMOVE$1) {
          node3.items.splice(i2, 1);
          i2 -= 1;
        }
      }
    } else if (isPair(node3)) {
      path8 = Object.freeze(path8.concat(node3));
      const ck = visit_("key", node3.key, visitor, path8);
      if (ck === BREAK$1)
        return BREAK$1;
      else if (ck === REMOVE$1)
        node3.key = null;
      const cv = visit_("value", node3.value, visitor, path8);
      if (cv === BREAK$1)
        return BREAK$1;
      else if (cv === REMOVE$1)
        node3.value = null;
    }
  }
  return ctrl;
}
async function visitAsync(node3, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node3)) {
    const cd = await visitAsync_(null, node3.contents, visitor_, Object.freeze([node3]));
    if (cd === REMOVE$1)
      node3.contents = null;
  } else
    await visitAsync_(null, node3, visitor_, Object.freeze([]));
}
visitAsync.BREAK = BREAK$1;
visitAsync.SKIP = SKIP$1;
visitAsync.REMOVE = REMOVE$1;
async function visitAsync_(key, node3, visitor, path8) {
  const ctrl = await callVisitor(key, node3, visitor, path8);
  if (isNode$1(ctrl) || isPair(ctrl)) {
    replaceNode(key, path8, ctrl);
    return visitAsync_(key, ctrl, visitor, path8);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection$1(node3)) {
      path8 = Object.freeze(path8.concat(node3));
      for (let i2 = 0; i2 < node3.items.length; ++i2) {
        const ci = await visitAsync_(i2, node3.items[i2], visitor, path8);
        if (typeof ci === "number")
          i2 = ci - 1;
        else if (ci === BREAK$1)
          return BREAK$1;
        else if (ci === REMOVE$1) {
          node3.items.splice(i2, 1);
          i2 -= 1;
        }
      }
    } else if (isPair(node3)) {
      path8 = Object.freeze(path8.concat(node3));
      const ck = await visitAsync_("key", node3.key, visitor, path8);
      if (ck === BREAK$1)
        return BREAK$1;
      else if (ck === REMOVE$1)
        node3.key = null;
      const cv = await visitAsync_("value", node3.value, visitor, path8);
      if (cv === BREAK$1)
        return BREAK$1;
      else if (cv === REMOVE$1)
        node3.value = null;
    }
  }
  return ctrl;
}
function initVisitor(visitor) {
  if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
    return Object.assign({
      Alias: visitor.Node,
      Map: visitor.Node,
      Scalar: visitor.Node,
      Seq: visitor.Node
    }, visitor.Value && {
      Map: visitor.Value,
      Scalar: visitor.Value,
      Seq: visitor.Value
    }, visitor.Collection && {
      Map: visitor.Collection,
      Seq: visitor.Collection
    }, visitor);
  }
  return visitor;
}
function callVisitor(key, node3, visitor, path8) {
  var _a, _b, _c, _d, _e;
  if (typeof visitor === "function")
    return visitor(key, node3, path8);
  if (isMap(node3))
    return (_a = visitor.Map) == null ? void 0 : _a.call(visitor, key, node3, path8);
  if (isSeq(node3))
    return (_b = visitor.Seq) == null ? void 0 : _b.call(visitor, key, node3, path8);
  if (isPair(node3))
    return (_c = visitor.Pair) == null ? void 0 : _c.call(visitor, key, node3, path8);
  if (isScalar$1(node3))
    return (_d = visitor.Scalar) == null ? void 0 : _d.call(visitor, key, node3, path8);
  if (isAlias(node3))
    return (_e = visitor.Alias) == null ? void 0 : _e.call(visitor, key, node3, path8);
  return void 0;
}
function replaceNode(key, path8, node3) {
  const parent = path8[path8.length - 1];
  if (isCollection$1(parent)) {
    parent.items[key] = node3;
  } else if (isPair(parent)) {
    if (key === "key")
      parent.key = node3;
    else
      parent.value = node3;
  } else if (isDocument(parent)) {
    parent.contents = node3;
  } else {
    const pt = isAlias(parent) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${pt} parent`);
  }
}
var escapeChars = {
  "!": "%21",
  ",": "%2C",
  "[": "%5B",
  "]": "%5D",
  "{": "%7B",
  "}": "%7D"
};
var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
var Directives = class {
  constructor(yaml3, tags) {
    this.docStart = null;
    this.docEnd = false;
    this.yaml = Object.assign({}, Directives.defaultYaml, yaml3);
    this.tags = Object.assign({}, Directives.defaultTags, tags);
  }
  clone() {
    const copy = new Directives(this.yaml, this.tags);
    copy.docStart = this.docStart;
    return copy;
  }
  /**
   * During parsing, get a Directives instance for the current document and
   * update the stream state according to the current version's spec.
   */
  atDocument() {
    const res = new Directives(this.yaml, this.tags);
    switch (this.yaml.version) {
      case "1.1":
        this.atNextDocument = true;
        break;
      case "1.2":
        this.atNextDocument = false;
        this.yaml = {
          explicit: Directives.defaultYaml.explicit,
          version: "1.2"
        };
        this.tags = Object.assign({}, Directives.defaultTags);
        break;
    }
    return res;
  }
  /**
   * @param onError - May be called even if the action was successful
   * @returns `true` on success
   */
  add(line, onError) {
    if (this.atNextDocument) {
      this.yaml = { explicit: Directives.defaultYaml.explicit, version: "1.1" };
      this.tags = Object.assign({}, Directives.defaultTags);
      this.atNextDocument = false;
    }
    const parts = line.trim().split(/[ \t]+/);
    const name2 = parts.shift();
    switch (name2) {
      case "%TAG": {
        if (parts.length !== 2) {
          onError(0, "%TAG directive should contain exactly two parts");
          if (parts.length < 2)
            return false;
        }
        const [handle2, prefix] = parts;
        this.tags[handle2] = prefix;
        return true;
      }
      case "%YAML": {
        this.yaml.explicit = true;
        if (parts.length !== 1) {
          onError(0, "%YAML directive should contain exactly one part");
          return false;
        }
        const [version4] = parts;
        if (version4 === "1.1" || version4 === "1.2") {
          this.yaml.version = version4;
          return true;
        } else {
          const isValid = /^\d+\.\d+$/.test(version4);
          onError(6, `Unsupported YAML version ${version4}`, isValid);
          return false;
        }
      }
      default:
        onError(0, `Unknown directive ${name2}`, true);
        return false;
    }
  }
  /**
   * Resolves a tag, matching handles to those defined in %TAG directives.
   *
   * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
   *   `'!local'` tag, or `null` if unresolvable.
   */
  tagName(source, onError) {
    if (source === "!")
      return "!";
    if (source[0] !== "!") {
      onError(`Not a valid tag: ${source}`);
      return null;
    }
    if (source[1] === "<") {
      const verbatim = source.slice(2, -1);
      if (verbatim === "!" || verbatim === "!!") {
        onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
        return null;
      }
      if (source[source.length - 1] !== ">")
        onError("Verbatim tags must end with a >");
      return verbatim;
    }
    const [, handle2, suffix] = source.match(/^(.*!)([^!]*)$/);
    if (!suffix)
      onError(`The ${source} tag has no suffix`);
    const prefix = this.tags[handle2];
    if (prefix)
      return prefix + decodeURIComponent(suffix);
    if (handle2 === "!")
      return source;
    onError(`Could not resolve tag: ${source}`);
    return null;
  }
  /**
   * Given a fully resolved tag, returns its printable string form,
   * taking into account current tag prefixes and defaults.
   */
  tagString(tag) {
    for (const [handle2, prefix] of Object.entries(this.tags)) {
      if (tag.startsWith(prefix))
        return handle2 + escapeTagName(tag.substring(prefix.length));
    }
    return tag[0] === "!" ? tag : `!<${tag}>`;
  }
  toString(doc) {
    const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
    const tagEntries = Object.entries(this.tags);
    let tagNames;
    if (doc && tagEntries.length > 0 && isNode$1(doc.contents)) {
      const tags = {};
      visit$1(doc.contents, (_key, node3) => {
        if (isNode$1(node3) && node3.tag)
          tags[node3.tag] = true;
      });
      tagNames = Object.keys(tags);
    } else
      tagNames = [];
    for (const [handle2, prefix] of tagEntries) {
      if (handle2 === "!!" && prefix === "tag:yaml.org,2002:")
        continue;
      if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
        lines.push(`%TAG ${handle2} ${prefix}`);
    }
    return lines.join("\n");
  }
};
Directives.defaultYaml = { explicit: false, version: "1.2" };
Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
function anchorIsValid(anchor) {
  if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
    const sa = JSON.stringify(anchor);
    const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
    throw new Error(msg);
  }
  return true;
}
function anchorNames(root) {
  const anchors = /* @__PURE__ */ new Set();
  visit$1(root, {
    Value(_key, node3) {
      if (node3.anchor)
        anchors.add(node3.anchor);
    }
  });
  return anchors;
}
function findNewAnchor(prefix, exclude) {
  for (let i2 = 1; true; ++i2) {
    const name2 = `${prefix}${i2}`;
    if (!exclude.has(name2))
      return name2;
  }
}
function createNodeAnchors(doc, prefix) {
  const aliasObjects = [];
  const sourceObjects = /* @__PURE__ */ new Map();
  let prevAnchors = null;
  return {
    onAnchor: (source) => {
      aliasObjects.push(source);
      if (!prevAnchors)
        prevAnchors = anchorNames(doc);
      const anchor = findNewAnchor(prefix, prevAnchors);
      prevAnchors.add(anchor);
      return anchor;
    },
    /**
     * With circular references, the source node is only resolved after all
     * of its child nodes are. This is why anchors are set only after all of
     * the nodes have been created.
     */
    setAnchors: () => {
      for (const source of aliasObjects) {
        const ref2 = sourceObjects.get(source);
        if (typeof ref2 === "object" && ref2.anchor && (isScalar$1(ref2.node) || isCollection$1(ref2.node))) {
          ref2.node.anchor = ref2.anchor;
        } else {
          const error3 = new Error("Failed to resolve repeated object (this should not happen)");
          error3.source = source;
          throw error3;
        }
      }
    },
    sourceObjects
  };
}
var Alias = class extends NodeBase {
  constructor(source) {
    super(ALIAS);
    this.source = source;
    Object.defineProperty(this, "tag", {
      set() {
        throw new Error("Alias nodes cannot have tags");
      }
    });
  }
  /**
   * Resolve the value of this alias within `doc`, finding the last
   * instance of the `source` anchor before this node.
   */
  resolve(doc) {
    let found2 = void 0;
    visit$1(doc, {
      Node: (_key, node3) => {
        if (node3 === this)
          return visit$1.BREAK;
        if (node3.anchor === this.source)
          found2 = node3;
      }
    });
    return found2;
  }
  toJSON(_arg, ctx2) {
    if (!ctx2)
      return { source: this.source };
    const { anchors, doc, maxAliasCount } = ctx2;
    const source = this.resolve(doc);
    if (!source) {
      const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
      throw new ReferenceError(msg);
    }
    const data2 = anchors.get(source);
    if (!data2 || data2.res === void 0) {
      const msg = "This should not happen: Alias anchor was not resolved?";
      throw new ReferenceError(msg);
    }
    if (maxAliasCount >= 0) {
      data2.count += 1;
      if (data2.aliasCount === 0)
        data2.aliasCount = getAliasCount(doc, source, anchors);
      if (data2.count * data2.aliasCount > maxAliasCount) {
        const msg = "Excessive alias count indicates a resource exhaustion attack";
        throw new ReferenceError(msg);
      }
    }
    return data2.res;
  }
  toString(ctx2, _onComment, _onChompKeep) {
    const src3 = `*${this.source}`;
    if (ctx2) {
      anchorIsValid(this.source);
      if (ctx2.options.verifyAliasOrder && !ctx2.anchors.has(this.source)) {
        const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new Error(msg);
      }
      if (ctx2.implicitKey)
        return `${src3} `;
    }
    return src3;
  }
};
function getAliasCount(doc, node3, anchors) {
  if (isAlias(node3)) {
    const source = node3.resolve(doc);
    const anchor = anchors && source && anchors.get(source);
    return anchor ? anchor.count * anchor.aliasCount : 0;
  } else if (isCollection$1(node3)) {
    let count = 0;
    for (const item of node3.items) {
      const c2 = getAliasCount(doc, item, anchors);
      if (c2 > count)
        count = c2;
    }
    return count;
  } else if (isPair(node3)) {
    const kc = getAliasCount(doc, node3.key, anchors);
    const vc = getAliasCount(doc, node3.value, anchors);
    return Math.max(kc, vc);
  }
  return 1;
}
function toJS(value2, arg, ctx2) {
  if (Array.isArray(value2))
    return value2.map((v, i2) => toJS(v, String(i2), ctx2));
  if (value2 && typeof value2.toJSON === "function") {
    if (!ctx2 || !hasAnchor(value2))
      return value2.toJSON(arg, ctx2);
    const data2 = { aliasCount: 0, count: 1, res: void 0 };
    ctx2.anchors.set(value2, data2);
    ctx2.onCreate = (res2) => {
      data2.res = res2;
      delete ctx2.onCreate;
    };
    const res = value2.toJSON(arg, ctx2);
    if (ctx2.onCreate)
      ctx2.onCreate(res);
    return res;
  }
  if (typeof value2 === "bigint" && !(ctx2 == null ? void 0 : ctx2.keep))
    return Number(value2);
  return value2;
}
var isScalarValue = (value2) => !value2 || typeof value2 !== "function" && typeof value2 !== "object";
var Scalar = class extends NodeBase {
  constructor(value2) {
    super(SCALAR$1);
    this.value = value2;
  }
  toJSON(arg, ctx2) {
    return (ctx2 == null ? void 0 : ctx2.keep) ? this.value : toJS(this.value, arg, ctx2);
  }
  toString() {
    return String(this.value);
  }
};
Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
Scalar.PLAIN = "PLAIN";
Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
var defaultTagPrefix = "tag:yaml.org,2002:";
function findTagObject(value2, tagName, tags) {
  if (tagName) {
    const match = tags.filter((t3) => t3.tag === tagName);
    const tagObj = match.find((t3) => !t3.format) ?? match[0];
    if (!tagObj)
      throw new Error(`Tag ${tagName} not found`);
    return tagObj;
  }
  return tags.find((t3) => {
    var _a;
    return ((_a = t3.identify) == null ? void 0 : _a.call(t3, value2)) && !t3.format;
  });
}
function createNode(value2, tagName, ctx2) {
  var _a, _b;
  if (isDocument(value2))
    value2 = value2.contents;
  if (isNode$1(value2))
    return value2;
  if (isPair(value2)) {
    const map3 = (_b = (_a = ctx2.schema[MAP]).createNode) == null ? void 0 : _b.call(_a, ctx2.schema, null, ctx2);
    map3.items.push(value2);
    return map3;
  }
  if (value2 instanceof String || value2 instanceof Number || value2 instanceof Boolean || typeof BigInt === "function" && value2 instanceof BigInt) {
    value2 = value2.valueOf();
  }
  const { aliasDuplicateObjects, onAnchor, onTagObj, schema: schema5, sourceObjects } = ctx2;
  let ref2 = void 0;
  if (aliasDuplicateObjects && value2 && typeof value2 === "object") {
    ref2 = sourceObjects.get(value2);
    if (ref2) {
      if (!ref2.anchor)
        ref2.anchor = onAnchor(value2);
      return new Alias(ref2.anchor);
    } else {
      ref2 = { anchor: null, node: null };
      sourceObjects.set(value2, ref2);
    }
  }
  if (tagName == null ? void 0 : tagName.startsWith("!!"))
    tagName = defaultTagPrefix + tagName.slice(2);
  let tagObj = findTagObject(value2, tagName, schema5.tags);
  if (!tagObj) {
    if (value2 && typeof value2.toJSON === "function") {
      value2 = value2.toJSON();
    }
    if (!value2 || typeof value2 !== "object") {
      const node4 = new Scalar(value2);
      if (ref2)
        ref2.node = node4;
      return node4;
    }
    tagObj = value2 instanceof Map ? schema5[MAP] : Symbol.iterator in Object(value2) ? schema5[SEQ] : schema5[MAP];
  }
  if (onTagObj) {
    onTagObj(tagObj);
    delete ctx2.onTagObj;
  }
  const node3 = (tagObj == null ? void 0 : tagObj.createNode) ? tagObj.createNode(ctx2.schema, value2, ctx2) : new Scalar(value2);
  if (tagName)
    node3.tag = tagName;
  if (ref2)
    ref2.node = node3;
  return node3;
}
function collectionFromPath(schema5, path8, value2) {
  let v = value2;
  for (let i2 = path8.length - 1; i2 >= 0; --i2) {
    const k = path8[i2];
    if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
      const a2 = [];
      a2[k] = v;
      v = a2;
    } else {
      v = /* @__PURE__ */ new Map([[k, v]]);
    }
  }
  return createNode(v, void 0, {
    aliasDuplicateObjects: false,
    keepUndefined: false,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: schema5,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
var isEmptyPath = (path8) => path8 == null || typeof path8 === "object" && !!path8[Symbol.iterator]().next().done;
var Collection = class extends NodeBase {
  constructor(type, schema5) {
    super(type);
    Object.defineProperty(this, "schema", {
      value: schema5,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  /**
   * Create a copy of this collection.
   *
   * @param schema - If defined, overwrites the original's schema
   */
  clone(schema5) {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (schema5)
      copy.schema = schema5;
    copy.items = copy.items.map((it) => isNode$1(it) || isPair(it) ? it.clone(schema5) : it);
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /**
   * Adds a value to the collection. For `!!map` and `!!omap` the value must
   * be a Pair instance or a `{ key, value }` object, which may not have a key
   * that already exists in the map.
   */
  addIn(path8, value2) {
    if (isEmptyPath(path8))
      this.add(value2);
    else {
      const [key, ...rest] = path8;
      const node3 = this.get(key, true);
      if (isCollection$1(node3))
        node3.addIn(rest, value2);
      else if (node3 === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value2));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
  /**
   * Removes a value from the collection.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(path8) {
    const [key, ...rest] = path8;
    if (rest.length === 0)
      return this.delete(key);
    const node3 = this.get(key, true);
    if (isCollection$1(node3))
      return node3.deleteIn(rest);
    else
      throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(path8, keepScalar) {
    const [key, ...rest] = path8;
    const node3 = this.get(key, true);
    if (rest.length === 0)
      return !keepScalar && isScalar$1(node3) ? node3.value : node3;
    else
      return isCollection$1(node3) ? node3.getIn(rest, keepScalar) : void 0;
  }
  hasAllNullValues(allowScalar) {
    return this.items.every((node3) => {
      if (!isPair(node3))
        return false;
      const n3 = node3.value;
      return n3 == null || allowScalar && isScalar$1(n3) && n3.value == null && !n3.commentBefore && !n3.comment && !n3.tag;
    });
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   */
  hasIn(path8) {
    const [key, ...rest] = path8;
    if (rest.length === 0)
      return this.has(key);
    const node3 = this.get(key, true);
    return isCollection$1(node3) ? node3.hasIn(rest) : false;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(path8, value2) {
    const [key, ...rest] = path8;
    if (rest.length === 0) {
      this.set(key, value2);
    } else {
      const node3 = this.get(key, true);
      if (isCollection$1(node3))
        node3.setIn(rest, value2);
      else if (node3 === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value2));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
};
Collection.maxFlowStringSingleLineLength = 60;
var stringifyComment = (str2) => str2.replace(/^(?!$)(?: $)?/gm, "#");
function indentComment(comment2, indent) {
  if (/^\n+$/.test(comment2))
    return comment2.substring(1);
  return indent ? comment2.replace(/^(?! *$)/gm, indent) : comment2;
}
var lineComment = (str2, indent, comment2) => str2.endsWith("\n") ? indentComment(comment2, indent) : comment2.includes("\n") ? "\n" + indentComment(comment2, indent) : (str2.endsWith(" ") ? "" : " ") + comment2;
var FOLD_FLOW = "flow";
var FOLD_BLOCK = "block";
var FOLD_QUOTED = "quoted";
function foldFlowLines(text, indent, mode2 = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
  if (!lineWidth || lineWidth < 0)
    return text;
  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
  if (text.length <= endStep)
    return text;
  const folds = [];
  const escapedFolds = {};
  let end = lineWidth - indent.length;
  if (typeof indentAtStart === "number") {
    if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
      folds.push(0);
    else
      end = lineWidth - indentAtStart;
  }
  let split = void 0;
  let prev = void 0;
  let overflow = false;
  let i2 = -1;
  let escStart = -1;
  let escEnd = -1;
  if (mode2 === FOLD_BLOCK) {
    i2 = consumeMoreIndentedLines(text, i2);
    if (i2 !== -1)
      end = i2 + endStep;
  }
  for (let ch; ch = text[i2 += 1]; ) {
    if (mode2 === FOLD_QUOTED && ch === "\\") {
      escStart = i2;
      switch (text[i2 + 1]) {
        case "x":
          i2 += 3;
          break;
        case "u":
          i2 += 5;
          break;
        case "U":
          i2 += 9;
          break;
        default:
          i2 += 1;
      }
      escEnd = i2;
    }
    if (ch === "\n") {
      if (mode2 === FOLD_BLOCK)
        i2 = consumeMoreIndentedLines(text, i2);
      end = i2 + endStep;
      split = void 0;
    } else {
      if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
        const next = text[i2 + 1];
        if (next && next !== " " && next !== "\n" && next !== "	")
          split = i2;
      }
      if (i2 >= end) {
        if (split) {
          folds.push(split);
          end = split + endStep;
          split = void 0;
        } else if (mode2 === FOLD_QUOTED) {
          while (prev === " " || prev === "	") {
            prev = ch;
            ch = text[i2 += 1];
            overflow = true;
          }
          const j = i2 > escEnd + 1 ? i2 - 2 : escStart - 1;
          if (escapedFolds[j])
            return text;
          folds.push(j);
          escapedFolds[j] = true;
          end = j + endStep;
          split = void 0;
        } else {
          overflow = true;
        }
      }
    }
    prev = ch;
  }
  if (overflow && onOverflow)
    onOverflow();
  if (folds.length === 0)
    return text;
  if (onFold)
    onFold();
  let res = text.slice(0, folds[0]);
  for (let i3 = 0; i3 < folds.length; ++i3) {
    const fold = folds[i3];
    const end2 = folds[i3 + 1] || text.length;
    if (fold === 0)
      res = `
${indent}${text.slice(0, end2)}`;
    else {
      if (mode2 === FOLD_QUOTED && escapedFolds[fold])
        res += `${text[fold]}\\`;
      res += `
${indent}${text.slice(fold + 1, end2)}`;
    }
  }
  return res;
}
function consumeMoreIndentedLines(text, i2) {
  let ch = text[i2 + 1];
  while (ch === " " || ch === "	") {
    do {
      ch = text[i2 += 1];
    } while (ch && ch !== "\n");
    ch = text[i2 + 1];
  }
  return i2;
}
var getFoldOptions = (ctx2) => ({
  indentAtStart: ctx2.indentAtStart,
  lineWidth: ctx2.options.lineWidth,
  minContentWidth: ctx2.options.minContentWidth
});
var containsDocumentMarker = (str2) => /^(%|---|\.\.\.)/m.test(str2);
function lineLengthOverLimit(str2, lineWidth, indentLength) {
  if (!lineWidth || lineWidth < 0)
    return false;
  const limit = lineWidth - indentLength;
  const strLen = str2.length;
  if (strLen <= limit)
    return false;
  for (let i2 = 0, start = 0; i2 < strLen; ++i2) {
    if (str2[i2] === "\n") {
      if (i2 - start > limit)
        return true;
      start = i2 + 1;
      if (strLen - start <= limit)
        return false;
    }
  }
  return true;
}
function doubleQuotedString(value2, ctx2) {
  const json2 = JSON.stringify(value2);
  if (ctx2.options.doubleQuotedAsJSON)
    return json2;
  const { implicitKey } = ctx2;
  const minMultiLineLength = ctx2.options.doubleQuotedMinMultiLineLength;
  const indent = ctx2.indent || (containsDocumentMarker(value2) ? "  " : "");
  let str2 = "";
  let start = 0;
  for (let i2 = 0, ch = json2[i2]; ch; ch = json2[++i2]) {
    if (ch === " " && json2[i2 + 1] === "\\" && json2[i2 + 2] === "n") {
      str2 += json2.slice(start, i2) + "\\ ";
      i2 += 1;
      start = i2;
      ch = "\\";
    }
    if (ch === "\\")
      switch (json2[i2 + 1]) {
        case "u":
          {
            str2 += json2.slice(start, i2);
            const code = json2.substr(i2 + 2, 4);
            switch (code) {
              case "0000":
                str2 += "\\0";
                break;
              case "0007":
                str2 += "\\a";
                break;
              case "000b":
                str2 += "\\v";
                break;
              case "001b":
                str2 += "\\e";
                break;
              case "0085":
                str2 += "\\N";
                break;
              case "00a0":
                str2 += "\\_";
                break;
              case "2028":
                str2 += "\\L";
                break;
              case "2029":
                str2 += "\\P";
                break;
              default:
                if (code.substr(0, 2) === "00")
                  str2 += "\\x" + code.substr(2);
                else
                  str2 += json2.substr(i2, 6);
            }
            i2 += 5;
            start = i2 + 1;
          }
          break;
        case "n":
          if (implicitKey || json2[i2 + 2] === '"' || json2.length < minMultiLineLength) {
            i2 += 1;
          } else {
            str2 += json2.slice(start, i2) + "\n\n";
            while (json2[i2 + 2] === "\\" && json2[i2 + 3] === "n" && json2[i2 + 4] !== '"') {
              str2 += "\n";
              i2 += 2;
            }
            str2 += indent;
            if (json2[i2 + 2] === " ")
              str2 += "\\";
            i2 += 1;
            start = i2 + 1;
          }
          break;
        default:
          i2 += 1;
      }
  }
  str2 = start ? str2 + json2.slice(start) : json2;
  return implicitKey ? str2 : foldFlowLines(str2, indent, FOLD_QUOTED, getFoldOptions(ctx2));
}
function singleQuotedString(value2, ctx2) {
  if (ctx2.options.singleQuote === false || ctx2.implicitKey && value2.includes("\n") || /[ \t]\n|\n[ \t]/.test(value2))
    return doubleQuotedString(value2, ctx2);
  const indent = ctx2.indent || (containsDocumentMarker(value2) ? "  " : "");
  const res = "'" + value2.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
  return ctx2.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx2));
}
function quotedString(value2, ctx2) {
  const { singleQuote } = ctx2.options;
  let qs2;
  if (singleQuote === false)
    qs2 = doubleQuotedString;
  else {
    const hasDouble = value2.includes('"');
    const hasSingle = value2.includes("'");
    if (hasDouble && !hasSingle)
      qs2 = singleQuotedString;
    else if (hasSingle && !hasDouble)
      qs2 = doubleQuotedString;
    else
      qs2 = singleQuote ? singleQuotedString : doubleQuotedString;
  }
  return qs2(value2, ctx2);
}
function blockString({ comment: comment2, type, value: value2 }, ctx2, onComment, onChompKeep) {
  const { blockQuote, commentString, lineWidth } = ctx2.options;
  if (!blockQuote || /\n[\t ]+$/.test(value2) || /^\s*$/.test(value2)) {
    return quotedString(value2, ctx2);
  }
  const indent = ctx2.indent || (ctx2.forceBlockIndent || containsDocumentMarker(value2) ? "  " : "");
  const literal2 = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.BLOCK_FOLDED ? false : type === Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value2, lineWidth, indent.length);
  if (!value2)
    return literal2 ? "|\n" : ">\n";
  let chomp;
  let endStart;
  for (endStart = value2.length; endStart > 0; --endStart) {
    const ch = value2[endStart - 1];
    if (ch !== "\n" && ch !== "	" && ch !== " ")
      break;
  }
  let end = value2.substring(endStart);
  const endNlPos = end.indexOf("\n");
  if (endNlPos === -1) {
    chomp = "-";
  } else if (value2 === end || endNlPos !== end.length - 1) {
    chomp = "+";
    if (onChompKeep)
      onChompKeep();
  } else {
    chomp = "";
  }
  if (end) {
    value2 = value2.slice(0, -end.length);
    if (end[end.length - 1] === "\n")
      end = end.slice(0, -1);
    end = end.replace(/\n+(?!\n|$)/g, `$&${indent}`);
  }
  let startWithSpace = false;
  let startEnd;
  let startNlPos = -1;
  for (startEnd = 0; startEnd < value2.length; ++startEnd) {
    const ch = value2[startEnd];
    if (ch === " ")
      startWithSpace = true;
    else if (ch === "\n")
      startNlPos = startEnd;
    else
      break;
  }
  let start = value2.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
  if (start) {
    value2 = value2.substring(start.length);
    start = start.replace(/\n+/g, `$&${indent}`);
  }
  const indentSize = indent ? "2" : "1";
  let header = (literal2 ? "|" : ">") + (startWithSpace ? indentSize : "") + chomp;
  if (comment2) {
    header += " " + commentString(comment2.replace(/ ?[\r\n]+/g, " "));
    if (onComment)
      onComment();
  }
  if (literal2) {
    value2 = value2.replace(/\n+/g, `$&${indent}`);
    return `${header}
${indent}${start}${value2}${end}`;
  }
  value2 = value2.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
  const body = foldFlowLines(`${start}${value2}${end}`, indent, FOLD_BLOCK, getFoldOptions(ctx2));
  return `${header}
${indent}${body}`;
}
function plainString(item, ctx2, onComment, onChompKeep) {
  const { type, value: value2 } = item;
  const { actualString, implicitKey, indent, inFlow } = ctx2;
  if (implicitKey && /[\n[\]{},]/.test(value2) || inFlow && /[[\]{},]/.test(value2)) {
    return quotedString(value2, ctx2);
  }
  if (!value2 || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value2)) {
    return implicitKey || inFlow || !value2.includes("\n") ? quotedString(value2, ctx2) : blockString(item, ctx2, onComment, onChompKeep);
  }
  if (!implicitKey && !inFlow && type !== Scalar.PLAIN && value2.includes("\n")) {
    return blockString(item, ctx2, onComment, onChompKeep);
  }
  if (indent === "" && containsDocumentMarker(value2)) {
    ctx2.forceBlockIndent = true;
    return blockString(item, ctx2, onComment, onChompKeep);
  }
  const str2 = value2.replace(/\n+/g, `$&
${indent}`);
  if (actualString) {
    const test = (tag) => {
      var _a;
      return tag.default && tag.tag !== "tag:yaml.org,2002:str" && ((_a = tag.test) == null ? void 0 : _a.test(str2));
    };
    const { compat, tags } = ctx2.doc.schema;
    if (tags.some(test) || (compat == null ? void 0 : compat.some(test)))
      return quotedString(value2, ctx2);
  }
  return implicitKey ? str2 : foldFlowLines(str2, indent, FOLD_FLOW, getFoldOptions(ctx2));
}
function stringifyString(item, ctx2, onComment, onChompKeep) {
  const { implicitKey, inFlow } = ctx2;
  const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
  let { type } = item;
  if (type !== Scalar.QUOTE_DOUBLE) {
    if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
      type = Scalar.QUOTE_DOUBLE;
  }
  const _stringify = (_type) => {
    switch (_type) {
      case Scalar.BLOCK_FOLDED:
      case Scalar.BLOCK_LITERAL:
        return implicitKey || inFlow ? quotedString(ss.value, ctx2) : blockString(ss, ctx2, onComment, onChompKeep);
      case Scalar.QUOTE_DOUBLE:
        return doubleQuotedString(ss.value, ctx2);
      case Scalar.QUOTE_SINGLE:
        return singleQuotedString(ss.value, ctx2);
      case Scalar.PLAIN:
        return plainString(ss, ctx2, onComment, onChompKeep);
      default:
        return null;
    }
  };
  let res = _stringify(type);
  if (res === null) {
    const { defaultKeyType, defaultStringType } = ctx2.options;
    const t3 = implicitKey && defaultKeyType || defaultStringType;
    res = _stringify(t3);
    if (res === null)
      throw new Error(`Unsupported default string type ${t3}`);
  }
  return res;
}
function createStringifyContext(doc, options3) {
  const opt = Object.assign({
    blockQuote: true,
    commentString: stringifyComment,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: false,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    indentSeq: true,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: false,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: true
  }, doc.schema.toStringOptions, options3);
  let inFlow;
  switch (opt.collectionStyle) {
    case "block":
      inFlow = false;
      break;
    case "flow":
      inFlow = true;
      break;
    default:
      inFlow = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc,
    indent: "",
    indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
    inFlow,
    options: opt
  };
}
function getTagObject(tags, item) {
  var _a;
  if (item.tag) {
    const match = tags.filter((t3) => t3.tag === item.tag);
    if (match.length > 0)
      return match.find((t3) => t3.format === item.format) ?? match[0];
  }
  let tagObj = void 0;
  let obj;
  if (isScalar$1(item)) {
    obj = item.value;
    const match = tags.filter((t3) => {
      var _a2;
      return (_a2 = t3.identify) == null ? void 0 : _a2.call(t3, obj);
    });
    tagObj = match.find((t3) => t3.format === item.format) ?? match.find((t3) => !t3.format);
  } else {
    obj = item;
    tagObj = tags.find((t3) => t3.nodeClass && obj instanceof t3.nodeClass);
  }
  if (!tagObj) {
    const name2 = ((_a = obj == null ? void 0 : obj.constructor) == null ? void 0 : _a.name) ?? typeof obj;
    throw new Error(`Tag not resolved for ${name2} value`);
  }
  return tagObj;
}
function stringifyProps(node3, tagObj, { anchors, doc }) {
  if (!doc.directives)
    return "";
  const props = [];
  const anchor = (isScalar$1(node3) || isCollection$1(node3)) && node3.anchor;
  if (anchor && anchorIsValid(anchor)) {
    anchors.add(anchor);
    props.push(`&${anchor}`);
  }
  const tag = node3.tag ? node3.tag : tagObj.default ? null : tagObj.tag;
  if (tag)
    props.push(doc.directives.tagString(tag));
  return props.join(" ");
}
function stringify$2(item, ctx2, onComment, onChompKeep) {
  var _a;
  if (isPair(item))
    return item.toString(ctx2, onComment, onChompKeep);
  if (isAlias(item)) {
    if (ctx2.doc.directives)
      return item.toString(ctx2);
    if ((_a = ctx2.resolvedAliases) == null ? void 0 : _a.has(item)) {
      throw new TypeError(`Cannot stringify circular structure without alias nodes`);
    } else {
      if (ctx2.resolvedAliases)
        ctx2.resolvedAliases.add(item);
      else
        ctx2.resolvedAliases = /* @__PURE__ */ new Set([item]);
      item = item.resolve(ctx2.doc);
    }
  }
  let tagObj = void 0;
  const node3 = isNode$1(item) ? item : ctx2.doc.createNode(item, { onTagObj: (o3) => tagObj = o3 });
  if (!tagObj)
    tagObj = getTagObject(ctx2.doc.schema.tags, node3);
  const props = stringifyProps(node3, tagObj, ctx2);
  if (props.length > 0)
    ctx2.indentAtStart = (ctx2.indentAtStart ?? 0) + props.length + 1;
  const str2 = typeof tagObj.stringify === "function" ? tagObj.stringify(node3, ctx2, onComment, onChompKeep) : isScalar$1(node3) ? stringifyString(node3, ctx2, onComment, onChompKeep) : node3.toString(ctx2, onComment, onChompKeep);
  if (!props)
    return str2;
  return isScalar$1(node3) || str2[0] === "{" || str2[0] === "[" ? `${props} ${str2}` : `${props}
${ctx2.indent}${str2}`;
}
function stringifyPair({ key, value: value2 }, ctx2, onComment, onChompKeep) {
  const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx2;
  let keyComment = isNode$1(key) && key.comment || null;
  if (simpleKeys) {
    if (keyComment) {
      throw new Error("With simple keys, key nodes cannot have comments");
    }
    if (isCollection$1(key)) {
      const msg = "With simple keys, collection cannot be used as a key value";
      throw new Error(msg);
    }
  }
  let explicitKey = !simpleKeys && (!key || keyComment && value2 == null && !ctx2.inFlow || isCollection$1(key) || (isScalar$1(key) ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL : typeof key === "object"));
  ctx2 = Object.assign({}, ctx2, {
    allNullValues: false,
    implicitKey: !explicitKey && (simpleKeys || !allNullValues),
    indent: indent + indentStep
  });
  let keyCommentDone = false;
  let chompKeep = false;
  let str2 = stringify$2(key, ctx2, () => keyCommentDone = true, () => chompKeep = true);
  if (!explicitKey && !ctx2.inFlow && str2.length > 1024) {
    if (simpleKeys)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    explicitKey = true;
  }
  if (ctx2.inFlow) {
    if (allNullValues || value2 == null) {
      if (keyCommentDone && onComment)
        onComment();
      return str2 === "" ? "?" : explicitKey ? `? ${str2}` : str2;
    }
  } else if (allNullValues && !simpleKeys || value2 == null && explicitKey) {
    str2 = `? ${str2}`;
    if (keyComment && !keyCommentDone) {
      str2 += lineComment(str2, ctx2.indent, commentString(keyComment));
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str2;
  }
  if (keyCommentDone)
    keyComment = null;
  if (explicitKey) {
    if (keyComment)
      str2 += lineComment(str2, ctx2.indent, commentString(keyComment));
    str2 = `? ${str2}
${indent}:`;
  } else {
    str2 = `${str2}:`;
    if (keyComment)
      str2 += lineComment(str2, ctx2.indent, commentString(keyComment));
  }
  let vcb = "";
  let valueComment = null;
  if (isNode$1(value2)) {
    if (value2.spaceBefore)
      vcb = "\n";
    if (value2.commentBefore) {
      const cs = commentString(value2.commentBefore);
      vcb += `
${indentComment(cs, ctx2.indent)}`;
    }
    valueComment = value2.comment;
  } else if (value2 && typeof value2 === "object") {
    value2 = doc.createNode(value2);
  }
  ctx2.implicitKey = false;
  if (!explicitKey && !keyComment && isScalar$1(value2))
    ctx2.indentAtStart = str2.length + 1;
  chompKeep = false;
  if (!indentSeq && indentStep.length >= 2 && !ctx2.inFlow && !explicitKey && isSeq(value2) && !value2.flow && !value2.tag && !value2.anchor) {
    ctx2.indent = ctx2.indent.substr(2);
  }
  let valueCommentDone = false;
  const valueStr = stringify$2(value2, ctx2, () => valueCommentDone = true, () => chompKeep = true);
  let ws = " ";
  if (vcb || keyComment) {
    if (valueStr === "" && !ctx2.inFlow)
      ws = vcb === "\n" ? "\n\n" : vcb;
    else
      ws = `${vcb}
${ctx2.indent}`;
  } else if (!explicitKey && isCollection$1(value2)) {
    const flow = valueStr[0] === "[" || valueStr[0] === "{";
    if (!flow || valueStr.includes("\n"))
      ws = `
${ctx2.indent}`;
  } else if (valueStr === "" || valueStr[0] === "\n")
    ws = "";
  str2 += ws + valueStr;
  if (ctx2.inFlow) {
    if (valueCommentDone && onComment)
      onComment();
  } else if (valueComment && !valueCommentDone) {
    str2 += lineComment(str2, ctx2.indent, commentString(valueComment));
  } else if (chompKeep && onChompKeep) {
    onChompKeep();
  }
  return str2;
}
function warn2(logLevel, warning) {
  if (logLevel === "debug" || logLevel === "warn") {
    if (typeof process !== "undefined" && process.emitWarning)
      process.emitWarning(warning);
    else
      console.warn(warning);
  }
}
var MERGE_KEY = "<<";
function addPairToJSMap(ctx2, map3, { key, value: value2 }) {
  if ((ctx2 == null ? void 0 : ctx2.doc.schema.merge) && isMergeKey(key)) {
    value2 = isAlias(value2) ? value2.resolve(ctx2.doc) : value2;
    if (isSeq(value2))
      for (const it of value2.items)
        mergeToJSMap(ctx2, map3, it);
    else if (Array.isArray(value2))
      for (const it of value2)
        mergeToJSMap(ctx2, map3, it);
    else
      mergeToJSMap(ctx2, map3, value2);
  } else {
    const jsKey = toJS(key, "", ctx2);
    if (map3 instanceof Map) {
      map3.set(jsKey, toJS(value2, jsKey, ctx2));
    } else if (map3 instanceof Set) {
      map3.add(jsKey);
    } else {
      const stringKey = stringifyKey(key, jsKey, ctx2);
      const jsValue = toJS(value2, stringKey, ctx2);
      if (stringKey in map3)
        Object.defineProperty(map3, stringKey, {
          value: jsValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      else
        map3[stringKey] = jsValue;
    }
  }
  return map3;
}
var isMergeKey = (key) => key === MERGE_KEY || isScalar$1(key) && key.value === MERGE_KEY && (!key.type || key.type === Scalar.PLAIN);
function mergeToJSMap(ctx2, map3, value2) {
  const source = ctx2 && isAlias(value2) ? value2.resolve(ctx2.doc) : value2;
  if (!isMap(source))
    throw new Error("Merge sources must be maps or map aliases");
  const srcMap = source.toJSON(null, ctx2, Map);
  for (const [key, value3] of srcMap) {
    if (map3 instanceof Map) {
      if (!map3.has(key))
        map3.set(key, value3);
    } else if (map3 instanceof Set) {
      map3.add(key);
    } else if (!Object.prototype.hasOwnProperty.call(map3, key)) {
      Object.defineProperty(map3, key, {
        value: value3,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
  return map3;
}
function stringifyKey(key, jsKey, ctx2) {
  if (jsKey === null)
    return "";
  if (typeof jsKey !== "object")
    return String(jsKey);
  if (isNode$1(key) && ctx2 && ctx2.doc) {
    const strCtx = createStringifyContext(ctx2.doc, {});
    strCtx.anchors = /* @__PURE__ */ new Set();
    for (const node3 of ctx2.anchors.keys())
      strCtx.anchors.add(node3.anchor);
    strCtx.inFlow = true;
    strCtx.inStringifyKey = true;
    const strKey = key.toString(strCtx);
    if (!ctx2.mapKeyWarned) {
      let jsonStr = JSON.stringify(strKey);
      if (jsonStr.length > 40)
        jsonStr = jsonStr.substring(0, 36) + '..."';
      warn2(ctx2.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
      ctx2.mapKeyWarned = true;
    }
    return strKey;
  }
  return JSON.stringify(jsKey);
}
function createPair(key, value2, ctx2) {
  const k = createNode(key, void 0, ctx2);
  const v = createNode(value2, void 0, ctx2);
  return new Pair(k, v);
}
var Pair = class {
  constructor(key, value2 = null) {
    Object.defineProperty(this, NODE_TYPE, { value: PAIR });
    this.key = key;
    this.value = value2;
  }
  clone(schema5) {
    let { key, value: value2 } = this;
    if (isNode$1(key))
      key = key.clone(schema5);
    if (isNode$1(value2))
      value2 = value2.clone(schema5);
    return new Pair(key, value2);
  }
  toJSON(_, ctx2) {
    const pair = (ctx2 == null ? void 0 : ctx2.mapAsMap) ? /* @__PURE__ */ new Map() : {};
    return addPairToJSMap(ctx2, pair, this);
  }
  toString(ctx2, onComment, onChompKeep) {
    return (ctx2 == null ? void 0 : ctx2.doc) ? stringifyPair(this, ctx2, onComment, onChompKeep) : JSON.stringify(this);
  }
};
function stringifyCollection(collection, ctx2, options3) {
  const flow = ctx2.inFlow ?? collection.flow;
  const stringify5 = flow ? stringifyFlowCollection : stringifyBlockCollection;
  return stringify5(collection, ctx2, options3);
}
function stringifyBlockCollection({ comment: comment2, items }, ctx2, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
  const { indent, options: { commentString } } = ctx2;
  const itemCtx = Object.assign({}, ctx2, { indent: itemIndent, type: null });
  let chompKeep = false;
  const lines = [];
  for (let i2 = 0; i2 < items.length; ++i2) {
    const item = items[i2];
    let comment3 = null;
    if (isNode$1(item)) {
      if (!chompKeep && item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx2, lines, item.commentBefore, chompKeep);
      if (item.comment)
        comment3 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode$1(item.key) ? item.key : null;
      if (ik) {
        if (!chompKeep && ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx2, lines, ik.commentBefore, chompKeep);
      }
    }
    chompKeep = false;
    let str3 = stringify$2(item, itemCtx, () => comment3 = null, () => chompKeep = true);
    if (comment3)
      str3 += lineComment(str3, itemIndent, commentString(comment3));
    if (chompKeep && comment3)
      chompKeep = false;
    lines.push(blockItemPrefix + str3);
  }
  let str2;
  if (lines.length === 0) {
    str2 = flowChars.start + flowChars.end;
  } else {
    str2 = lines[0];
    for (let i2 = 1; i2 < lines.length; ++i2) {
      const line = lines[i2];
      str2 += line ? `
${indent}${line}` : "\n";
    }
  }
  if (comment2) {
    str2 += "\n" + indentComment(commentString(comment2), indent);
    if (onComment)
      onComment();
  } else if (chompKeep && onChompKeep)
    onChompKeep();
  return str2;
}
function stringifyFlowCollection({ comment: comment2, items }, ctx2, { flowChars, itemIndent, onComment }) {
  const { indent, indentStep, options: { commentString } } = ctx2;
  itemIndent += indentStep;
  const itemCtx = Object.assign({}, ctx2, {
    indent: itemIndent,
    inFlow: true,
    type: null
  });
  let reqNewline = false;
  let linesAtValue = 0;
  const lines = [];
  for (let i2 = 0; i2 < items.length; ++i2) {
    const item = items[i2];
    let comment3 = null;
    if (isNode$1(item)) {
      if (item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx2, lines, item.commentBefore, false);
      if (item.comment)
        comment3 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode$1(item.key) ? item.key : null;
      if (ik) {
        if (ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx2, lines, ik.commentBefore, false);
        if (ik.comment)
          reqNewline = true;
      }
      const iv = isNode$1(item.value) ? item.value : null;
      if (iv) {
        if (iv.comment)
          comment3 = iv.comment;
        if (iv.commentBefore)
          reqNewline = true;
      } else if (item.value == null && ik && ik.comment) {
        comment3 = ik.comment;
      }
    }
    if (comment3)
      reqNewline = true;
    let str3 = stringify$2(item, itemCtx, () => comment3 = null);
    if (i2 < items.length - 1)
      str3 += ",";
    if (comment3)
      str3 += lineComment(str3, itemIndent, commentString(comment3));
    if (!reqNewline && (lines.length > linesAtValue || str3.includes("\n")))
      reqNewline = true;
    lines.push(str3);
    linesAtValue = lines.length;
  }
  let str2;
  const { start, end } = flowChars;
  if (lines.length === 0) {
    str2 = start + end;
  } else {
    if (!reqNewline) {
      const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
      reqNewline = len > Collection.maxFlowStringSingleLineLength;
    }
    if (reqNewline) {
      str2 = start;
      for (const line of lines)
        str2 += line ? `
${indentStep}${indent}${line}` : "\n";
      str2 += `
${indent}${end}`;
    } else {
      str2 = `${start} ${lines.join(" ")} ${end}`;
    }
  }
  if (comment2) {
    str2 += lineComment(str2, commentString(comment2), indent);
    if (onComment)
      onComment();
  }
  return str2;
}
function addCommentBefore({ indent, options: { commentString } }, lines, comment2, chompKeep) {
  if (comment2 && chompKeep)
    comment2 = comment2.replace(/^\n+/, "");
  if (comment2) {
    const ic = indentComment(commentString(comment2), indent);
    lines.push(ic.trimStart());
  }
}
function findPair(items, key) {
  const k = isScalar$1(key) ? key.value : key;
  for (const it of items) {
    if (isPair(it)) {
      if (it.key === key || it.key === k)
        return it;
      if (isScalar$1(it.key) && it.key.value === k)
        return it;
    }
  }
  return void 0;
}
var YAMLMap = class extends Collection {
  constructor(schema5) {
    super(MAP, schema5);
    this.items = [];
  }
  static get tagName() {
    return "tag:yaml.org,2002:map";
  }
  /**
   * Adds a value to the collection.
   *
   * @param overwrite - If not set `true`, using a key that is already in the
   *   collection will throw. Otherwise, overwrites the previous value.
   */
  add(pair, overwrite) {
    var _a;
    let _pair;
    if (isPair(pair))
      _pair = pair;
    else if (!pair || typeof pair !== "object" || !("key" in pair)) {
      _pair = new Pair(pair, pair == null ? void 0 : pair.value);
    } else
      _pair = new Pair(pair.key, pair.value);
    const prev = findPair(this.items, _pair.key);
    const sortEntries = (_a = this.schema) == null ? void 0 : _a.sortMapEntries;
    if (prev) {
      if (!overwrite)
        throw new Error(`Key ${_pair.key} already set`);
      if (isScalar$1(prev.value) && isScalarValue(_pair.value))
        prev.value.value = _pair.value;
      else
        prev.value = _pair.value;
    } else if (sortEntries) {
      const i2 = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
      if (i2 === -1)
        this.items.push(_pair);
      else
        this.items.splice(i2, 0, _pair);
    } else {
      this.items.push(_pair);
    }
  }
  delete(key) {
    const it = findPair(this.items, key);
    if (!it)
      return false;
    const del = this.items.splice(this.items.indexOf(it), 1);
    return del.length > 0;
  }
  get(key, keepScalar) {
    const it = findPair(this.items, key);
    const node3 = it == null ? void 0 : it.value;
    return (!keepScalar && isScalar$1(node3) ? node3.value : node3) ?? void 0;
  }
  has(key) {
    return !!findPair(this.items, key);
  }
  set(key, value2) {
    this.add(new Pair(key, value2), true);
  }
  /**
   * @param ctx - Conversion context, originally set in Document#toJS()
   * @param {Class} Type - If set, forces the returned collection type
   * @returns Instance of Type, Map, or Object
   */
  toJSON(_, ctx2, Type) {
    const map3 = Type ? new Type() : (ctx2 == null ? void 0 : ctx2.mapAsMap) ? /* @__PURE__ */ new Map() : {};
    if (ctx2 == null ? void 0 : ctx2.onCreate)
      ctx2.onCreate(map3);
    for (const item of this.items)
      addPairToJSMap(ctx2, map3, item);
    return map3;
  }
  toString(ctx2, onComment, onChompKeep) {
    if (!ctx2)
      return JSON.stringify(this);
    for (const item of this.items) {
      if (!isPair(item))
        throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
    }
    if (!ctx2.allNullValues && this.hasAllNullValues(false))
      ctx2 = Object.assign({}, ctx2, { allNullValues: true });
    return stringifyCollection(this, ctx2, {
      blockItemPrefix: "",
      flowChars: { start: "{", end: "}" },
      itemIndent: ctx2.indent || "",
      onChompKeep,
      onComment
    });
  }
};
function createMap(schema5, obj, ctx2) {
  const { keepUndefined, replacer } = ctx2;
  const map3 = new YAMLMap(schema5);
  const add = (key, value2) => {
    if (typeof replacer === "function")
      value2 = replacer.call(obj, key, value2);
    else if (Array.isArray(replacer) && !replacer.includes(key))
      return;
    if (value2 !== void 0 || keepUndefined)
      map3.items.push(createPair(key, value2, ctx2));
  };
  if (obj instanceof Map) {
    for (const [key, value2] of obj)
      add(key, value2);
  } else if (obj && typeof obj === "object") {
    for (const key of Object.keys(obj))
      add(key, obj[key]);
  }
  if (typeof schema5.sortMapEntries === "function") {
    map3.items.sort(schema5.sortMapEntries);
  }
  return map3;
}
var map = {
  collection: "map",
  createNode: createMap,
  default: true,
  nodeClass: YAMLMap,
  tag: "tag:yaml.org,2002:map",
  resolve(map3, onError) {
    if (!isMap(map3))
      onError("Expected a mapping for this tag");
    return map3;
  }
};
var YAMLSeq = class extends Collection {
  constructor(schema5) {
    super(SEQ, schema5);
    this.items = [];
  }
  static get tagName() {
    return "tag:yaml.org,2002:seq";
  }
  add(value2) {
    this.items.push(value2);
  }
  /**
   * Removes a value from the collection.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   *
   * @returns `true` if the item was found and removed.
   */
  delete(key) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return false;
    const del = this.items.splice(idx, 1);
    return del.length > 0;
  }
  get(key, keepScalar) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return void 0;
    const it = this.items[idx];
    return !keepScalar && isScalar$1(it) ? it.value : it;
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   */
  has(key) {
    const idx = asItemIndex(key);
    return typeof idx === "number" && idx < this.items.length;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   *
   * If `key` does not contain a representation of an integer, this will throw.
   * It may be wrapped in a `Scalar`.
   */
  set(key, value2) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      throw new Error(`Expected a valid index, not ${key}.`);
    const prev = this.items[idx];
    if (isScalar$1(prev) && isScalarValue(value2))
      prev.value = value2;
    else
      this.items[idx] = value2;
  }
  toJSON(_, ctx2) {
    const seq3 = [];
    if (ctx2 == null ? void 0 : ctx2.onCreate)
      ctx2.onCreate(seq3);
    let i2 = 0;
    for (const item of this.items)
      seq3.push(toJS(item, String(i2++), ctx2));
    return seq3;
  }
  toString(ctx2, onComment, onChompKeep) {
    if (!ctx2)
      return JSON.stringify(this);
    return stringifyCollection(this, ctx2, {
      blockItemPrefix: "- ",
      flowChars: { start: "[", end: "]" },
      itemIndent: (ctx2.indent || "") + "  ",
      onChompKeep,
      onComment
    });
  }
};
function asItemIndex(key) {
  let idx = isScalar$1(key) ? key.value : key;
  if (idx && typeof idx === "string")
    idx = Number(idx);
  return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
}
function createSeq(schema5, obj, ctx2) {
  const { replacer } = ctx2;
  const seq3 = new YAMLSeq(schema5);
  if (obj && Symbol.iterator in Object(obj)) {
    let i2 = 0;
    for (let it of obj) {
      if (typeof replacer === "function") {
        const key = obj instanceof Set ? it : String(i2++);
        it = replacer.call(obj, key, it);
      }
      seq3.items.push(createNode(it, void 0, ctx2));
    }
  }
  return seq3;
}
var seq = {
  collection: "seq",
  createNode: createSeq,
  default: true,
  nodeClass: YAMLSeq,
  tag: "tag:yaml.org,2002:seq",
  resolve(seq3, onError) {
    if (!isSeq(seq3))
      onError("Expected a sequence for this tag");
    return seq3;
  }
};
var string = {
  identify: (value2) => typeof value2 === "string",
  default: true,
  tag: "tag:yaml.org,2002:str",
  resolve: (str2) => str2,
  stringify(item, ctx2, onComment, onChompKeep) {
    ctx2 = Object.assign({ actualString: true }, ctx2);
    return stringifyString(item, ctx2, onComment, onChompKeep);
  }
};
var nullTag = {
  identify: (value2) => value2 == null,
  createNode: () => new Scalar(null),
  default: true,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => new Scalar(null),
  stringify: ({ source }, ctx2) => typeof source === "string" && nullTag.test.test(source) ? source : ctx2.options.nullStr
};
var boolTag = {
  identify: (value2) => typeof value2 === "boolean",
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: (str2) => new Scalar(str2[0] === "t" || str2[0] === "T"),
  stringify({ source, value: value2 }, ctx2) {
    if (source && boolTag.test.test(source)) {
      const sv = source[0] === "t" || source[0] === "T";
      if (value2 === sv)
        return source;
    }
    return value2 ? ctx2.options.trueStr : ctx2.options.falseStr;
  }
};
function stringifyNumber({ format: format2, minFractionDigits, tag, value: value2 }) {
  if (typeof value2 === "bigint")
    return String(value2);
  const num = typeof value2 === "number" ? value2 : Number(value2);
  if (!isFinite(num))
    return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
  let n3 = JSON.stringify(value2);
  if (!format2 && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n3)) {
    let i2 = n3.indexOf(".");
    if (i2 < 0) {
      i2 = n3.length;
      n3 += ".";
    }
    let d2 = minFractionDigits - (n3.length - i2 - 1);
    while (d2-- > 0)
      n3 += "0";
  }
  return n3;
}
var floatNaN$1 = {
  identify: (value2) => typeof value2 === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/,
  resolve: (str2) => str2.slice(-3).toLowerCase() === "nan" ? NaN : str2[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
var floatExp$1 = {
  identify: (value2) => typeof value2 === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: (str2) => parseFloat(str2),
  stringify(node3) {
    const num = Number(node3.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node3);
  }
};
var float$1 = {
  identify: (value2) => typeof value2 === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
  resolve(str2) {
    const node3 = new Scalar(parseFloat(str2));
    const dot = str2.indexOf(".");
    if (dot !== -1 && str2[str2.length - 1] === "0")
      node3.minFractionDigits = str2.length - dot - 1;
    return node3;
  },
  stringify: stringifyNumber
};
var intIdentify$2 = (value2) => typeof value2 === "bigint" || Number.isInteger(value2);
var intResolve$1 = (str2, offset3, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str2) : parseInt(str2.substring(offset3), radix);
function intStringify$1(node3, radix, prefix) {
  const { value: value2 } = node3;
  if (intIdentify$2(value2) && value2 >= 0)
    return prefix + value2.toString(radix);
  return stringifyNumber(node3);
}
var intOct$1 = {
  identify: (value2) => intIdentify$2(value2) && value2 >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^0o[0-7]+$/,
  resolve: (str2, _onError, opt) => intResolve$1(str2, 2, 8, opt),
  stringify: (node3) => intStringify$1(node3, 8, "0o")
};
var int$1 = {
  identify: intIdentify$2,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9]+$/,
  resolve: (str2, _onError, opt) => intResolve$1(str2, 0, 10, opt),
  stringify: stringifyNumber
};
var intHex$1 = {
  identify: (value2) => intIdentify$2(value2) && value2 >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^0x[0-9a-fA-F]+$/,
  resolve: (str2, _onError, opt) => intResolve$1(str2, 2, 16, opt),
  stringify: (node3) => intStringify$1(node3, 16, "0x")
};
var schema$2 = [
  map,
  seq,
  string,
  nullTag,
  boolTag,
  intOct$1,
  int$1,
  intHex$1,
  floatNaN$1,
  floatExp$1,
  float$1
];
function intIdentify$1(value2) {
  return typeof value2 === "bigint" || Number.isInteger(value2);
}
var stringifyJSON = ({ value: value2 }) => JSON.stringify(value2);
var jsonScalars = [
  {
    identify: (value2) => typeof value2 === "string",
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: (str2) => str2,
    stringify: stringifyJSON
  },
  {
    identify: (value2) => value2 == null,
    createNode: () => new Scalar(null),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^null$/,
    resolve: () => null,
    stringify: stringifyJSON
  },
  {
    identify: (value2) => typeof value2 === "boolean",
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^true|false$/,
    resolve: (str2) => str2 === "true",
    stringify: stringifyJSON
  },
  {
    identify: intIdentify$1,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^-?(?:0|[1-9][0-9]*)$/,
    resolve: (str2, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str2) : parseInt(str2, 10),
    stringify: ({ value: value2 }) => intIdentify$1(value2) ? value2.toString() : JSON.stringify(value2)
  },
  {
    identify: (value2) => typeof value2 === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
    resolve: (str2) => parseFloat(str2),
    stringify: stringifyJSON
  }
];
var jsonError = {
  default: true,
  tag: "",
  test: /^/,
  resolve(str2, onError) {
    onError(`Unresolved plain scalar ${JSON.stringify(str2)}`);
    return str2;
  }
};
var schema$1 = [map, seq].concat(jsonScalars, jsonError);
var binary = {
  identify: (value2) => value2 instanceof Uint8Array,
  default: false,
  tag: "tag:yaml.org,2002:binary",
  /**
   * Returns a Buffer in node and an Uint8Array in browsers
   *
   * To use the resulting buffer as an image, you'll want to do something like:
   *
   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
   */
  resolve(src3, onError) {
    if (typeof Buffer === "function") {
      return Buffer.from(src3, "base64");
    } else if (typeof atob === "function") {
      const str2 = atob(src3.replace(/[\n\r]/g, ""));
      const buffer = new Uint8Array(str2.length);
      for (let i2 = 0; i2 < str2.length; ++i2)
        buffer[i2] = str2.charCodeAt(i2);
      return buffer;
    } else {
      onError("This environment does not support reading binary tags; either Buffer or atob is required");
      return src3;
    }
  },
  stringify({ comment: comment2, type, value: value2 }, ctx2, onComment, onChompKeep) {
    const buf = value2;
    let str2;
    if (typeof Buffer === "function") {
      str2 = buf instanceof Buffer ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64");
    } else if (typeof btoa === "function") {
      let s2 = "";
      for (let i2 = 0; i2 < buf.length; ++i2)
        s2 += String.fromCharCode(buf[i2]);
      str2 = btoa(s2);
    } else {
      throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
    }
    if (!type)
      type = Scalar.BLOCK_LITERAL;
    if (type !== Scalar.QUOTE_DOUBLE) {
      const lineWidth = Math.max(ctx2.options.lineWidth - ctx2.indent.length, ctx2.options.minContentWidth);
      const n3 = Math.ceil(str2.length / lineWidth);
      const lines = new Array(n3);
      for (let i2 = 0, o3 = 0; i2 < n3; ++i2, o3 += lineWidth) {
        lines[i2] = str2.substr(o3, lineWidth);
      }
      str2 = lines.join(type === Scalar.BLOCK_LITERAL ? "\n" : " ");
    }
    return stringifyString({ comment: comment2, type, value: str2 }, ctx2, onComment, onChompKeep);
  }
};
function resolvePairs(seq3, onError) {
  if (isSeq(seq3)) {
    for (let i2 = 0; i2 < seq3.items.length; ++i2) {
      let item = seq3.items[i2];
      if (isPair(item))
        continue;
      else if (isMap(item)) {
        if (item.items.length > 1)
          onError("Each pair must have its own sequence indicator");
        const pair = item.items[0] || new Pair(new Scalar(null));
        if (item.commentBefore)
          pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
        if (item.comment) {
          const cn = pair.value ?? pair.key;
          cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
        }
        item = pair;
      }
      seq3.items[i2] = isPair(item) ? item : new Pair(item);
    }
  } else
    onError("Expected a sequence for this tag");
  return seq3;
}
function createPairs(schema5, iterable, ctx2) {
  const { replacer } = ctx2;
  const pairs3 = new YAMLSeq(schema5);
  pairs3.tag = "tag:yaml.org,2002:pairs";
  let i2 = 0;
  if (iterable && Symbol.iterator in Object(iterable))
    for (let it of iterable) {
      if (typeof replacer === "function")
        it = replacer.call(iterable, String(i2++), it);
      let key, value2;
      if (Array.isArray(it)) {
        if (it.length === 2) {
          key = it[0];
          value2 = it[1];
        } else
          throw new TypeError(`Expected [key, value] tuple: ${it}`);
      } else if (it && it instanceof Object) {
        const keys = Object.keys(it);
        if (keys.length === 1) {
          key = keys[0];
          value2 = it[key];
        } else
          throw new TypeError(`Expected { key: value } tuple: ${it}`);
      } else {
        key = it;
      }
      pairs3.items.push(createPair(key, value2, ctx2));
    }
  return pairs3;
}
var pairs = {
  collection: "seq",
  default: false,
  tag: "tag:yaml.org,2002:pairs",
  resolve: resolvePairs,
  createNode: createPairs
};
var YAMLOMap = class extends YAMLSeq {
  constructor() {
    super();
    this.add = YAMLMap.prototype.add.bind(this);
    this.delete = YAMLMap.prototype.delete.bind(this);
    this.get = YAMLMap.prototype.get.bind(this);
    this.has = YAMLMap.prototype.has.bind(this);
    this.set = YAMLMap.prototype.set.bind(this);
    this.tag = YAMLOMap.tag;
  }
  /**
   * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
   * but TypeScript won't allow widening the signature of a child method.
   */
  toJSON(_, ctx2) {
    if (!ctx2)
      return super.toJSON(_);
    const map3 = /* @__PURE__ */ new Map();
    if (ctx2 == null ? void 0 : ctx2.onCreate)
      ctx2.onCreate(map3);
    for (const pair of this.items) {
      let key, value2;
      if (isPair(pair)) {
        key = toJS(pair.key, "", ctx2);
        value2 = toJS(pair.value, key, ctx2);
      } else {
        key = toJS(pair, "", ctx2);
      }
      if (map3.has(key))
        throw new Error("Ordered maps must not include duplicate keys");
      map3.set(key, value2);
    }
    return map3;
  }
};
YAMLOMap.tag = "tag:yaml.org,2002:omap";
var omap = {
  collection: "seq",
  identify: (value2) => value2 instanceof Map,
  nodeClass: YAMLOMap,
  default: false,
  tag: "tag:yaml.org,2002:omap",
  resolve(seq3, onError) {
    const pairs3 = resolvePairs(seq3, onError);
    const seenKeys = [];
    for (const { key } of pairs3.items) {
      if (isScalar$1(key)) {
        if (seenKeys.includes(key.value)) {
          onError(`Ordered maps must not include duplicate keys: ${key.value}`);
        } else {
          seenKeys.push(key.value);
        }
      }
    }
    return Object.assign(new YAMLOMap(), pairs3);
  },
  createNode(schema5, iterable, ctx2) {
    const pairs3 = createPairs(schema5, iterable, ctx2);
    const omap3 = new YAMLOMap();
    omap3.items = pairs3.items;
    return omap3;
  }
};
function boolStringify({ value: value2, source }, ctx2) {
  const boolObj = value2 ? trueTag : falseTag;
  if (source && boolObj.test.test(source))
    return source;
  return value2 ? ctx2.options.trueStr : ctx2.options.falseStr;
}
var trueTag = {
  identify: (value2) => value2 === true,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: () => new Scalar(true),
  stringify: boolStringify
};
var falseTag = {
  identify: (value2) => value2 === false,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
  resolve: () => new Scalar(false),
  stringify: boolStringify
};
var floatNaN = {
  identify: (value2) => typeof value2 === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/,
  resolve: (str2) => str2.slice(-3).toLowerCase() === "nan" ? NaN : str2[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
var floatExp = {
  identify: (value2) => typeof value2 === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: (str2) => parseFloat(str2.replace(/_/g, "")),
  stringify(node3) {
    const num = Number(node3.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node3);
  }
};
var float = {
  identify: (value2) => typeof value2 === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
  resolve(str2) {
    const node3 = new Scalar(parseFloat(str2.replace(/_/g, "")));
    const dot = str2.indexOf(".");
    if (dot !== -1) {
      const f2 = str2.substring(dot + 1).replace(/_/g, "");
      if (f2[f2.length - 1] === "0")
        node3.minFractionDigits = f2.length;
    }
    return node3;
  },
  stringify: stringifyNumber
};
var intIdentify = (value2) => typeof value2 === "bigint" || Number.isInteger(value2);
function intResolve(str2, offset3, radix, { intAsBigInt }) {
  const sign = str2[0];
  if (sign === "-" || sign === "+")
    offset3 += 1;
  str2 = str2.substring(offset3).replace(/_/g, "");
  if (intAsBigInt) {
    switch (radix) {
      case 2:
        str2 = `0b${str2}`;
        break;
      case 8:
        str2 = `0o${str2}`;
        break;
      case 16:
        str2 = `0x${str2}`;
        break;
    }
    const n4 = BigInt(str2);
    return sign === "-" ? BigInt(-1) * n4 : n4;
  }
  const n3 = parseInt(str2, radix);
  return sign === "-" ? -1 * n3 : n3;
}
function intStringify(node3, radix, prefix) {
  const { value: value2 } = node3;
  if (intIdentify(value2)) {
    const str2 = value2.toString(radix);
    return value2 < 0 ? "-" + prefix + str2.substr(1) : prefix + str2;
  }
  return stringifyNumber(node3);
}
var intBin = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "BIN",
  test: /^[-+]?0b[0-1_]+$/,
  resolve: (str2, _onError, opt) => intResolve(str2, 2, 2, opt),
  stringify: (node3) => intStringify(node3, 2, "0b")
};
var intOct = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^[-+]?0[0-7_]+$/,
  resolve: (str2, _onError, opt) => intResolve(str2, 1, 8, opt),
  stringify: (node3) => intStringify(node3, 8, "0")
};
var int = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9][0-9_]*$/,
  resolve: (str2, _onError, opt) => intResolve(str2, 0, 10, opt),
  stringify: stringifyNumber
};
var intHex = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^[-+]?0x[0-9a-fA-F_]+$/,
  resolve: (str2, _onError, opt) => intResolve(str2, 2, 16, opt),
  stringify: (node3) => intStringify(node3, 16, "0x")
};
var YAMLSet = class extends YAMLMap {
  constructor(schema5) {
    super(schema5);
    this.tag = YAMLSet.tag;
  }
  add(key) {
    let pair;
    if (isPair(key))
      pair = key;
    else if (typeof key === "object" && "key" in key && "value" in key && key.value === null)
      pair = new Pair(key.key, null);
    else
      pair = new Pair(key, null);
    const prev = findPair(this.items, pair.key);
    if (!prev)
      this.items.push(pair);
  }
  /**
   * If `keepPair` is `true`, returns the Pair matching `key`.
   * Otherwise, returns the value of that Pair's key.
   */
  get(key, keepPair) {
    const pair = findPair(this.items, key);
    return !keepPair && isPair(pair) ? isScalar$1(pair.key) ? pair.key.value : pair.key : pair;
  }
  set(key, value2) {
    if (typeof value2 !== "boolean")
      throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value2}`);
    const prev = findPair(this.items, key);
    if (prev && !value2) {
      this.items.splice(this.items.indexOf(prev), 1);
    } else if (!prev && value2) {
      this.items.push(new Pair(key));
    }
  }
  toJSON(_, ctx2) {
    return super.toJSON(_, ctx2, Set);
  }
  toString(ctx2, onComment, onChompKeep) {
    if (!ctx2)
      return JSON.stringify(this);
    if (this.hasAllNullValues(true))
      return super.toString(Object.assign({}, ctx2, { allNullValues: true }), onComment, onChompKeep);
    else
      throw new Error("Set items must all have null values");
  }
};
YAMLSet.tag = "tag:yaml.org,2002:set";
var set = {
  collection: "map",
  identify: (value2) => value2 instanceof Set,
  nodeClass: YAMLSet,
  default: false,
  tag: "tag:yaml.org,2002:set",
  resolve(map3, onError) {
    if (isMap(map3)) {
      if (map3.hasAllNullValues(true))
        return Object.assign(new YAMLSet(), map3);
      else
        onError("Set items must all have null values");
    } else
      onError("Expected a mapping for this tag");
    return map3;
  },
  createNode(schema5, iterable, ctx2) {
    const { replacer } = ctx2;
    const set3 = new YAMLSet(schema5);
    if (iterable && Symbol.iterator in Object(iterable))
      for (let value2 of iterable) {
        if (typeof replacer === "function")
          value2 = replacer.call(iterable, value2, value2);
        set3.items.push(createPair(value2, null, ctx2));
      }
    return set3;
  }
};
function parseSexagesimal(str2, asBigInt) {
  const sign = str2[0];
  const parts = sign === "-" || sign === "+" ? str2.substring(1) : str2;
  const num = (n3) => asBigInt ? BigInt(n3) : Number(n3);
  const res = parts.replace(/_/g, "").split(":").reduce((res2, p2) => res2 * num(60) + num(p2), num(0));
  return sign === "-" ? num(-1) * res : res;
}
function stringifySexagesimal(node3) {
  let { value: value2 } = node3;
  let num = (n3) => n3;
  if (typeof value2 === "bigint")
    num = (n3) => BigInt(n3);
  else if (isNaN(value2) || !isFinite(value2))
    return stringifyNumber(node3);
  let sign = "";
  if (value2 < 0) {
    sign = "-";
    value2 *= num(-1);
  }
  const _60 = num(60);
  const parts = [value2 % _60];
  if (value2 < 60) {
    parts.unshift(0);
  } else {
    value2 = (value2 - parts[0]) / _60;
    parts.unshift(value2 % _60);
    if (value2 >= 60) {
      value2 = (value2 - parts[0]) / _60;
      parts.unshift(value2);
    }
  }
  return sign + parts.map((n3) => n3 < 10 ? "0" + String(n3) : String(n3)).join(":").replace(/000000\d*$/, "");
}
var intTime = {
  identify: (value2) => typeof value2 === "bigint" || Number.isInteger(value2),
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
  resolve: (str2, _onError, { intAsBigInt }) => parseSexagesimal(str2, intAsBigInt),
  stringify: stringifySexagesimal
};
var floatTime = {
  identify: (value2) => typeof value2 === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
  resolve: (str2) => parseSexagesimal(str2, false),
  stringify: stringifySexagesimal
};
var timestamp = {
  identify: (value2) => value2 instanceof Date,
  default: true,
  tag: "tag:yaml.org,2002:timestamp",
  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
  // may be omitted altogether, resulting in a date format. In such a case, the time part is
  // assumed to be 00:00:00Z (start of day, UTC).
  test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
  resolve(str2) {
    const match = str2.match(timestamp.test);
    if (!match)
      throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
    const [, year, month, day, hour, minute, second] = match.map(Number);
    const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
    let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
    const tz = match[8];
    if (tz && tz !== "Z") {
      let d2 = parseSexagesimal(tz, false);
      if (Math.abs(d2) < 30)
        d2 *= 60;
      date -= 6e4 * d2;
    }
    return new Date(date);
  },
  stringify: ({ value: value2 }) => value2.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
};
var schema = [
  map,
  seq,
  string,
  nullTag,
  trueTag,
  falseTag,
  intBin,
  intOct,
  int,
  intHex,
  floatNaN,
  floatExp,
  float,
  binary,
  omap,
  pairs,
  set,
  intTime,
  floatTime,
  timestamp
];
var schemas = /* @__PURE__ */ new Map([
  ["core", schema$2],
  ["failsafe", [map, seq, string]],
  ["json", schema$1],
  ["yaml11", schema],
  ["yaml-1.1", schema]
]);
var tagsByName = {
  binary,
  bool: boolTag,
  float: float$1,
  floatExp: floatExp$1,
  floatNaN: floatNaN$1,
  floatTime,
  int: int$1,
  intHex: intHex$1,
  intOct: intOct$1,
  intTime,
  map,
  null: nullTag,
  omap,
  pairs,
  seq,
  set,
  timestamp
};
var coreKnownTags = {
  "tag:yaml.org,2002:binary": binary,
  "tag:yaml.org,2002:omap": omap,
  "tag:yaml.org,2002:pairs": pairs,
  "tag:yaml.org,2002:set": set,
  "tag:yaml.org,2002:timestamp": timestamp
};
function getTags(customTags, schemaName) {
  let tags = schemas.get(schemaName);
  if (!tags) {
    if (Array.isArray(customTags))
      tags = [];
    else {
      const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
    }
  }
  if (Array.isArray(customTags)) {
    for (const tag of customTags)
      tags = tags.concat(tag);
  } else if (typeof customTags === "function") {
    tags = customTags(tags.slice());
  }
  return tags.map((tag) => {
    if (typeof tag !== "string")
      return tag;
    const tagObj = tagsByName[tag];
    if (tagObj)
      return tagObj;
    const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
    throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
  });
}
var sortMapEntriesByKey = (a2, b) => a2.key < b.key ? -1 : a2.key > b.key ? 1 : 0;
var Schema = class {
  constructor({ compat, customTags, merge: merge3, resolveKnownTags, schema: schema5, sortMapEntries, toStringDefaults }) {
    this.compat = Array.isArray(compat) ? getTags(compat, "compat") : compat ? getTags(null, compat) : null;
    this.merge = !!merge3;
    this.name = typeof schema5 === "string" && schema5 || "core";
    this.knownTags = resolveKnownTags ? coreKnownTags : {};
    this.tags = getTags(customTags, this.name);
    this.toStringOptions = toStringDefaults ?? null;
    Object.defineProperty(this, MAP, { value: map });
    Object.defineProperty(this, SCALAR$1, { value: string });
    Object.defineProperty(this, SEQ, { value: seq });
    this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
  }
  clone() {
    const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
    copy.tags = this.tags.slice();
    return copy;
  }
};
function stringifyDocument(doc, options3) {
  var _a;
  const lines = [];
  let hasDirectives = options3.directives === true;
  if (options3.directives !== false && doc.directives) {
    const dir = doc.directives.toString(doc);
    if (dir) {
      lines.push(dir);
      hasDirectives = true;
    } else if (doc.directives.docStart)
      hasDirectives = true;
  }
  if (hasDirectives)
    lines.push("---");
  const ctx2 = createStringifyContext(doc, options3);
  const { commentString } = ctx2.options;
  if (doc.commentBefore) {
    if (lines.length !== 1)
      lines.unshift("");
    const cs = commentString(doc.commentBefore);
    lines.unshift(indentComment(cs, ""));
  }
  let chompKeep = false;
  let contentComment = null;
  if (doc.contents) {
    if (isNode$1(doc.contents)) {
      if (doc.contents.spaceBefore && hasDirectives)
        lines.push("");
      if (doc.contents.commentBefore) {
        const cs = commentString(doc.contents.commentBefore);
        lines.push(indentComment(cs, ""));
      }
      ctx2.forceBlockIndent = !!doc.comment;
      contentComment = doc.contents.comment;
    }
    const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
    let body = stringify$2(doc.contents, ctx2, () => contentComment = null, onChompKeep);
    if (contentComment)
      body += lineComment(body, "", commentString(contentComment));
    if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
      lines[lines.length - 1] = `--- ${body}`;
    } else
      lines.push(body);
  } else {
    lines.push(stringify$2(doc.contents, ctx2));
  }
  if ((_a = doc.directives) == null ? void 0 : _a.docEnd) {
    if (doc.comment) {
      const cs = commentString(doc.comment);
      if (cs.includes("\n")) {
        lines.push("...");
        lines.push(indentComment(cs, ""));
      } else {
        lines.push(`... ${cs}`);
      }
    } else {
      lines.push("...");
    }
  } else {
    let dc = doc.comment;
    if (dc && chompKeep)
      dc = dc.replace(/^\n+/, "");
    if (dc) {
      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
        lines.push("");
      lines.push(indentComment(commentString(dc), ""));
    }
  }
  return lines.join("\n") + "\n";
}
function applyReviver(reviver, obj, key, val) {
  if (val && typeof val === "object") {
    if (Array.isArray(val)) {
      for (let i2 = 0, len = val.length; i2 < len; ++i2) {
        const v0 = val[i2];
        const v1 = applyReviver(reviver, val, String(i2), v0);
        if (v1 === void 0)
          delete val[i2];
        else if (v1 !== v0)
          val[i2] = v1;
      }
    } else if (val instanceof Map) {
      for (const k of Array.from(val.keys())) {
        const v0 = val.get(k);
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          val.delete(k);
        else if (v1 !== v0)
          val.set(k, v1);
      }
    } else if (val instanceof Set) {
      for (const v0 of Array.from(val)) {
        const v1 = applyReviver(reviver, val, v0, v0);
        if (v1 === void 0)
          val.delete(v0);
        else if (v1 !== v0) {
          val.delete(v0);
          val.add(v1);
        }
      }
    } else {
      for (const [k, v0] of Object.entries(val)) {
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          delete val[k];
        else if (v1 !== v0)
          val[k] = v1;
      }
    }
  }
  return reviver.call(obj, key, val);
}
var Document = class {
  constructor(value2, replacer, options3) {
    this.commentBefore = null;
    this.comment = null;
    this.errors = [];
    this.warnings = [];
    Object.defineProperty(this, NODE_TYPE, { value: DOC });
    let _replacer = null;
    if (typeof replacer === "function" || Array.isArray(replacer)) {
      _replacer = replacer;
    } else if (options3 === void 0 && replacer) {
      options3 = replacer;
      replacer = void 0;
    }
    const opt = Object.assign({
      intAsBigInt: false,
      keepSourceTokens: false,
      logLevel: "warn",
      prettyErrors: true,
      strict: true,
      uniqueKeys: true,
      version: "1.2"
    }, options3);
    this.options = opt;
    let { version: version4 } = opt;
    if (options3 == null ? void 0 : options3._directives) {
      this.directives = options3._directives.atDocument();
      if (this.directives.yaml.explicit)
        version4 = this.directives.yaml.version;
    } else
      this.directives = new Directives({ version: version4 });
    this.setSchema(version4, options3);
    if (value2 === void 0)
      this.contents = null;
    else {
      this.contents = this.createNode(value2, _replacer, options3);
    }
  }
  /**
   * Create a deep copy of this Document and its contents.
   *
   * Custom Node values that inherit from `Object` still refer to their original instances.
   */
  clone() {
    const copy = Object.create(Document.prototype, {
      [NODE_TYPE]: { value: DOC }
    });
    copy.commentBefore = this.commentBefore;
    copy.comment = this.comment;
    copy.errors = this.errors.slice();
    copy.warnings = this.warnings.slice();
    copy.options = Object.assign({}, this.options);
    if (this.directives)
      copy.directives = this.directives.clone();
    copy.schema = this.schema.clone();
    copy.contents = isNode$1(this.contents) ? this.contents.clone(copy.schema) : this.contents;
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /** Adds a value to the document. */
  add(value2) {
    if (assertCollection(this.contents))
      this.contents.add(value2);
  }
  /** Adds a value to the document. */
  addIn(path8, value2) {
    if (assertCollection(this.contents))
      this.contents.addIn(path8, value2);
  }
  /**
   * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
   *
   * If `node` already has an anchor, `name` is ignored.
   * Otherwise, the `node.anchor` value will be set to `name`,
   * or if an anchor with that name is already present in the document,
   * `name` will be used as a prefix for a new unique anchor.
   * If `name` is undefined, the generated anchor will use 'a' as a prefix.
   */
  createAlias(node3, name2) {
    if (!node3.anchor) {
      const prev = anchorNames(this);
      node3.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      !name2 || prev.has(name2) ? findNewAnchor(name2 || "a", prev) : name2;
    }
    return new Alias(node3.anchor);
  }
  createNode(value2, replacer, options3) {
    let _replacer = void 0;
    if (typeof replacer === "function") {
      value2 = replacer.call({ "": value2 }, "", value2);
      _replacer = replacer;
    } else if (Array.isArray(replacer)) {
      const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
      const asStr = replacer.filter(keyToStr).map(String);
      if (asStr.length > 0)
        replacer = replacer.concat(asStr);
      _replacer = replacer;
    } else if (options3 === void 0 && replacer) {
      options3 = replacer;
      replacer = void 0;
    }
    const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options3 ?? {};
    const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(
      this,
      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      anchorPrefix || "a"
    );
    const ctx2 = {
      aliasDuplicateObjects: aliasDuplicateObjects ?? true,
      keepUndefined: keepUndefined ?? false,
      onAnchor,
      onTagObj,
      replacer: _replacer,
      schema: this.schema,
      sourceObjects
    };
    const node3 = createNode(value2, tag, ctx2);
    if (flow && isCollection$1(node3))
      node3.flow = true;
    setAnchors();
    return node3;
  }
  /**
   * Convert a key and a value into a `Pair` using the current schema,
   * recursively wrapping all values as `Scalar` or `Collection` nodes.
   */
  createPair(key, value2, options3 = {}) {
    const k = this.createNode(key, null, options3);
    const v = this.createNode(value2, null, options3);
    return new Pair(k, v);
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  delete(key) {
    return assertCollection(this.contents) ? this.contents.delete(key) : false;
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(path8) {
    if (isEmptyPath(path8)) {
      if (this.contents == null)
        return false;
      this.contents = null;
      return true;
    }
    return assertCollection(this.contents) ? this.contents.deleteIn(path8) : false;
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  get(key, keepScalar) {
    return isCollection$1(this.contents) ? this.contents.get(key, keepScalar) : void 0;
  }
  /**
   * Returns item at `path`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(path8, keepScalar) {
    if (isEmptyPath(path8))
      return !keepScalar && isScalar$1(this.contents) ? this.contents.value : this.contents;
    return isCollection$1(this.contents) ? this.contents.getIn(path8, keepScalar) : void 0;
  }
  /**
   * Checks if the document includes a value with the key `key`.
   */
  has(key) {
    return isCollection$1(this.contents) ? this.contents.has(key) : false;
  }
  /**
   * Checks if the document includes a value at `path`.
   */
  hasIn(path8) {
    if (isEmptyPath(path8))
      return this.contents !== void 0;
    return isCollection$1(this.contents) ? this.contents.hasIn(path8) : false;
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  set(key, value2) {
    if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, [key], value2);
    } else if (assertCollection(this.contents)) {
      this.contents.set(key, value2);
    }
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(path8, value2) {
    if (isEmptyPath(path8))
      this.contents = value2;
    else if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, Array.from(path8), value2);
    } else if (assertCollection(this.contents)) {
      this.contents.setIn(path8, value2);
    }
  }
  /**
   * Change the YAML version and schema used by the document.
   * A `null` version disables support for directives, explicit tags, anchors, and aliases.
   * It also requires the `schema` option to be given as a `Schema` instance value.
   *
   * Overrides all previously set schema options.
   */
  setSchema(version4, options3 = {}) {
    if (typeof version4 === "number")
      version4 = String(version4);
    let opt;
    switch (version4) {
      case "1.1":
        if (this.directives)
          this.directives.yaml.version = "1.1";
        else
          this.directives = new Directives({ version: "1.1" });
        opt = { merge: true, resolveKnownTags: false, schema: "yaml-1.1" };
        break;
      case "1.2":
      case "next":
        if (this.directives)
          this.directives.yaml.version = version4;
        else
          this.directives = new Directives({ version: version4 });
        opt = { merge: false, resolveKnownTags: true, schema: "core" };
        break;
      case null:
        if (this.directives)
          delete this.directives;
        opt = null;
        break;
      default: {
        const sv = JSON.stringify(version4);
        throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
      }
    }
    if (options3.schema instanceof Object)
      this.schema = options3.schema;
    else if (opt)
      this.schema = new Schema(Object.assign(opt, options3));
    else
      throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
  }
  // json & jsonArg are only used from toJSON()
  toJS({ json: json2, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
    const ctx2 = {
      anchors: /* @__PURE__ */ new Map(),
      doc: this,
      keep: !json2,
      mapAsMap: mapAsMap === true,
      mapKeyWarned: false,
      maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100,
      stringify: stringify$2
    };
    const res = toJS(this.contents, jsonArg ?? "", ctx2);
    if (typeof onAnchor === "function")
      for (const { count, res: res2 } of ctx2.anchors.values())
        onAnchor(res2, count);
    return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
  }
  /**
   * A JSON representation of the document `contents`.
   *
   * @param jsonArg Used by `JSON.stringify` to indicate the array index or
   *   property name.
   */
  toJSON(jsonArg, onAnchor) {
    return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
  }
  /** A YAML representation of the document. */
  toString(options3 = {}) {
    if (this.errors.length > 0)
      throw new Error("Document with errors cannot be stringified");
    if ("indent" in options3 && (!Number.isInteger(options3.indent) || Number(options3.indent) <= 0)) {
      const s2 = JSON.stringify(options3.indent);
      throw new Error(`"indent" option must be a positive integer, not ${s2}`);
    }
    return stringifyDocument(this, options3);
  }
};
function assertCollection(contents) {
  if (isCollection$1(contents))
    return true;
  throw new Error("Expected a YAML collection as document contents");
}
var YAMLError = class extends Error {
  constructor(name2, pos, code, message) {
    super();
    this.name = name2;
    this.code = code;
    this.message = message;
    this.pos = pos;
  }
};
var YAMLParseError = class extends YAMLError {
  constructor(pos, code, message) {
    super("YAMLParseError", pos, code, message);
  }
};
var YAMLWarning = class extends YAMLError {
  constructor(pos, code, message) {
    super("YAMLWarning", pos, code, message);
  }
};
var prettifyError = (src3, lc) => (error3) => {
  if (error3.pos[0] === -1)
    return;
  error3.linePos = error3.pos.map((pos) => lc.linePos(pos));
  const { line, col } = error3.linePos[0];
  error3.message += ` at line ${line}, column ${col}`;
  let ci = col - 1;
  let lineStr = src3.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
  if (ci >= 60 && lineStr.length > 80) {
    const trimStart = Math.min(ci - 39, lineStr.length - 79);
    lineStr = "…" + lineStr.substring(trimStart);
    ci -= trimStart - 1;
  }
  if (lineStr.length > 80)
    lineStr = lineStr.substring(0, 79) + "…";
  if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
    let prev = src3.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
    if (prev.length > 80)
      prev = prev.substring(0, 79) + "…\n";
    lineStr = prev + lineStr;
  }
  if (/[^ ]/.test(lineStr)) {
    let count = 1;
    const end = error3.linePos[1];
    if (end && end.line === line && end.col > col) {
      count = Math.min(end.col - col, 80 - ci);
    }
    const pointer = " ".repeat(ci) + "^".repeat(count);
    error3.message += `:

${lineStr}
${pointer}
`;
  }
};
function resolveProps(tokens, { flow, indicator, next, offset: offset3, onError, startOnNewline }) {
  let spaceBefore = false;
  let atNewline = startOnNewline;
  let hasSpace = startOnNewline;
  let comment2 = "";
  let commentSep = "";
  let hasNewline = false;
  let hasNewlineAfterProp = false;
  let reqSpace = false;
  let anchor = null;
  let tag = null;
  let comma3 = null;
  let found2 = null;
  let start = null;
  for (const token of tokens) {
    if (reqSpace) {
      if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
        onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      reqSpace = false;
    }
    switch (token.type) {
      case "space":
        if (!flow && atNewline && indicator !== "doc-start" && token.source[0] === "	")
          onError(token, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
        hasSpace = true;
        break;
      case "comment": {
        if (!hasSpace)
          onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const cb = token.source.substring(1) || " ";
        if (!comment2)
          comment2 = cb;
        else
          comment2 += commentSep + cb;
        commentSep = "";
        atNewline = false;
        break;
      }
      case "newline":
        if (atNewline) {
          if (comment2)
            comment2 += token.source;
          else
            spaceBefore = true;
        } else
          commentSep += token.source;
        atNewline = true;
        hasNewline = true;
        if (anchor || tag)
          hasNewlineAfterProp = true;
        hasSpace = true;
        break;
      case "anchor":
        if (anchor)
          onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
        if (token.source.endsWith(":"))
          onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
        anchor = token;
        if (start === null)
          start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      case "tag": {
        if (tag)
          onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
        tag = token;
        if (start === null)
          start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      }
      case indicator:
        if (anchor || tag)
          onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
        if (found2)
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
        found2 = token;
        atNewline = false;
        hasSpace = false;
        break;
      case "comma":
        if (flow) {
          if (comma3)
            onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
          comma3 = token;
          atNewline = false;
          hasSpace = false;
          break;
        }
      default:
        onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
        atNewline = false;
        hasSpace = false;
    }
  }
  const last = tokens[tokens.length - 1];
  const end = last ? last.offset + last.source.length : offset3;
  if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== ""))
    onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
  return {
    comma: comma3,
    found: found2,
    spaceBefore,
    comment: comment2,
    hasNewline,
    hasNewlineAfterProp,
    anchor,
    tag,
    end,
    start: start ?? end
  };
}
function containsNewline(key) {
  if (!key)
    return null;
  switch (key.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (key.source.includes("\n"))
        return true;
      if (key.end) {
        for (const st of key.end)
          if (st.type === "newline")
            return true;
      }
      return false;
    case "flow-collection":
      for (const it of key.items) {
        for (const st of it.start)
          if (st.type === "newline")
            return true;
        if (it.sep) {
          for (const st of it.sep)
            if (st.type === "newline")
              return true;
        }
        if (containsNewline(it.key) || containsNewline(it.value))
          return true;
      }
      return false;
    default:
      return true;
  }
}
function flowIndentCheck(indent, fc, onError) {
  if ((fc == null ? void 0 : fc.type) === "flow-collection") {
    const end = fc.end[0];
    if (end.indent === indent && (end.source === "]" || end.source === "}") && containsNewline(fc)) {
      const msg = "Flow end indicator should be more indented than parent";
      onError(end, "BAD_INDENT", msg, true);
    }
  }
}
function mapIncludes(ctx2, items, search) {
  const { uniqueKeys } = ctx2.options;
  if (uniqueKeys === false)
    return false;
  const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a2, b) => a2 === b || isScalar$1(a2) && isScalar$1(b) && a2.value === b.value && !(a2.value === "<<" && ctx2.schema.merge);
  return items.some((pair) => isEqual(pair.key, search));
}
var startColMsg = "All mapping items must start at the same column";
function resolveBlockMap({ composeNode: composeNode3, composeEmptyNode: composeEmptyNode3 }, ctx2, bm, onError) {
  var _a;
  const map3 = new YAMLMap(ctx2.schema);
  if (ctx2.atRoot)
    ctx2.atRoot = false;
  let offset3 = bm.offset;
  for (const collItem of bm.items) {
    const { start, key, sep: sep2, value: value2 } = collItem;
    const keyProps = resolveProps(start, {
      indicator: "explicit-key-ind",
      next: key ?? (sep2 == null ? void 0 : sep2[0]),
      offset: offset3,
      onError,
      startOnNewline: true
    });
    const implicitKey = !keyProps.found;
    if (implicitKey) {
      if (key) {
        if (key.type === "block-seq")
          onError(offset3, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
        else if ("indent" in key && key.indent !== bm.indent)
          onError(offset3, "BAD_INDENT", startColMsg);
      }
      if (!keyProps.anchor && !keyProps.tag && !sep2) {
        if (keyProps.comment) {
          if (map3.comment)
            map3.comment += "\n" + keyProps.comment;
          else
            map3.comment = keyProps.comment;
        }
        continue;
      }
      if (keyProps.hasNewlineAfterProp || containsNewline(key)) {
        onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
      }
    } else if (((_a = keyProps.found) == null ? void 0 : _a.indent) !== bm.indent) {
      onError(offset3, "BAD_INDENT", startColMsg);
    }
    const keyStart = keyProps.end;
    const keyNode = key ? composeNode3(ctx2, key, keyProps, onError) : composeEmptyNode3(ctx2, keyStart, start, null, keyProps, onError);
    if (ctx2.schema.compat)
      flowIndentCheck(bm.indent, key, onError);
    if (mapIncludes(ctx2, map3.items, keyNode))
      onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
    const valueProps = resolveProps(sep2 ?? [], {
      indicator: "map-value-ind",
      next: value2,
      offset: keyNode.range[2],
      onError,
      startOnNewline: !key || key.type === "block-scalar"
    });
    offset3 = valueProps.end;
    if (valueProps.found) {
      if (implicitKey) {
        if ((value2 == null ? void 0 : value2.type) === "block-map" && !valueProps.hasNewline)
          onError(offset3, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
        if (ctx2.options.strict && keyProps.start < valueProps.found.offset - 1024)
          onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
      }
      const valueNode = value2 ? composeNode3(ctx2, value2, valueProps, onError) : composeEmptyNode3(ctx2, offset3, sep2, null, valueProps, onError);
      if (ctx2.schema.compat)
        flowIndentCheck(bm.indent, value2, onError);
      offset3 = valueNode.range[2];
      const pair = new Pair(keyNode, valueNode);
      if (ctx2.options.keepSourceTokens)
        pair.srcToken = collItem;
      map3.items.push(pair);
    } else {
      if (implicitKey)
        onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
      if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode);
      if (ctx2.options.keepSourceTokens)
        pair.srcToken = collItem;
      map3.items.push(pair);
    }
  }
  map3.range = [bm.offset, offset3, offset3];
  return map3;
}
function resolveBlockSeq({ composeNode: composeNode3, composeEmptyNode: composeEmptyNode3 }, ctx2, bs, onError) {
  const seq3 = new YAMLSeq(ctx2.schema);
  if (ctx2.atRoot)
    ctx2.atRoot = false;
  let offset3 = bs.offset;
  for (const { start, value: value2 } of bs.items) {
    const props = resolveProps(start, {
      indicator: "seq-item-ind",
      next: value2,
      offset: offset3,
      onError,
      startOnNewline: true
    });
    offset3 = props.end;
    if (!props.found) {
      if (props.anchor || props.tag || value2) {
        if (value2 && value2.type === "block-seq")
          onError(offset3, "BAD_INDENT", "All sequence items must start at the same column");
        else
          onError(offset3, "MISSING_CHAR", "Sequence item without - indicator");
      } else {
        if (props.comment)
          seq3.comment = props.comment;
        continue;
      }
    }
    const node3 = value2 ? composeNode3(ctx2, value2, props, onError) : composeEmptyNode3(ctx2, offset3, start, null, props, onError);
    if (ctx2.schema.compat)
      flowIndentCheck(bs.indent, value2, onError);
    offset3 = node3.range[2];
    seq3.items.push(node3);
  }
  seq3.range = [bs.offset, offset3, offset3];
  return seq3;
}
function resolveEnd(end, offset3, reqSpace, onError) {
  let comment2 = "";
  if (end) {
    let hasSpace = false;
    let sep2 = "";
    for (const token of end) {
      const { source, type } = token;
      switch (type) {
        case "space":
          hasSpace = true;
          break;
        case "comment": {
          if (reqSpace && !hasSpace)
            onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = source.substring(1) || " ";
          if (!comment2)
            comment2 = cb;
          else
            comment2 += sep2 + cb;
          sep2 = "";
          break;
        }
        case "newline":
          if (comment2)
            sep2 += source;
          hasSpace = true;
          break;
        default:
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
      }
      offset3 += source.length;
    }
  }
  return { comment: comment2, offset: offset3 };
}
var blockMsg = "Block collections are not allowed within flow collections";
var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
function resolveFlowCollection({ composeNode: composeNode3, composeEmptyNode: composeEmptyNode3 }, ctx2, fc, onError) {
  const isMap3 = fc.start.source === "{";
  const fcName = isMap3 ? "flow map" : "flow sequence";
  const coll = isMap3 ? new YAMLMap(ctx2.schema) : new YAMLSeq(ctx2.schema);
  coll.flow = true;
  const atRoot = ctx2.atRoot;
  if (atRoot)
    ctx2.atRoot = false;
  let offset3 = fc.offset + fc.start.source.length;
  for (let i2 = 0; i2 < fc.items.length; ++i2) {
    const collItem = fc.items[i2];
    const { start, key, sep: sep2, value: value2 } = collItem;
    const props = resolveProps(start, {
      flow: fcName,
      indicator: "explicit-key-ind",
      next: key ?? (sep2 == null ? void 0 : sep2[0]),
      offset: offset3,
      onError,
      startOnNewline: false
    });
    if (!props.found) {
      if (!props.anchor && !props.tag && !sep2 && !value2) {
        if (i2 === 0 && props.comma)
          onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        else if (i2 < fc.items.length - 1)
          onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
        if (props.comment) {
          if (coll.comment)
            coll.comment += "\n" + props.comment;
          else
            coll.comment = props.comment;
        }
        offset3 = props.end;
        continue;
      }
      if (!isMap3 && ctx2.options.strict && containsNewline(key))
        onError(
          key,
          // checked by containsNewline()
          "MULTILINE_IMPLICIT_KEY",
          "Implicit keys of flow sequence pairs need to be on a single line"
        );
    }
    if (i2 === 0) {
      if (props.comma)
        onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
    } else {
      if (!props.comma)
        onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
      if (props.comment) {
        let prevItemComment = "";
        loop:
          for (const st of start) {
            switch (st.type) {
              case "comma":
              case "space":
                break;
              case "comment":
                prevItemComment = st.source.substring(1);
                break loop;
              default:
                break loop;
            }
          }
        if (prevItemComment) {
          let prev = coll.items[coll.items.length - 1];
          if (isPair(prev))
            prev = prev.value ?? prev.key;
          if (prev.comment)
            prev.comment += "\n" + prevItemComment;
          else
            prev.comment = prevItemComment;
          props.comment = props.comment.substring(prevItemComment.length + 1);
        }
      }
    }
    if (!isMap3 && !sep2 && !props.found) {
      const valueNode = value2 ? composeNode3(ctx2, value2, props, onError) : composeEmptyNode3(ctx2, props.end, sep2, null, props, onError);
      coll.items.push(valueNode);
      offset3 = valueNode.range[2];
      if (isBlock(value2))
        onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
    } else {
      const keyStart = props.end;
      const keyNode = key ? composeNode3(ctx2, key, props, onError) : composeEmptyNode3(ctx2, keyStart, start, null, props, onError);
      if (isBlock(key))
        onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
      const valueProps = resolveProps(sep2 ?? [], {
        flow: fcName,
        indicator: "map-value-ind",
        next: value2,
        offset: keyNode.range[2],
        onError,
        startOnNewline: false
      });
      if (valueProps.found) {
        if (!isMap3 && !props.found && ctx2.options.strict) {
          if (sep2)
            for (const st of sep2) {
              if (st === valueProps.found)
                break;
              if (st.type === "newline") {
                onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          if (props.start < valueProps.found.offset - 1024)
            onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else if (value2) {
        if ("source" in value2 && value2.source && value2.source[0] === ":")
          onError(value2, "MISSING_CHAR", `Missing space after : in ${fcName}`);
        else
          onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
      }
      const valueNode = value2 ? composeNode3(ctx2, value2, valueProps, onError) : valueProps.found ? composeEmptyNode3(ctx2, valueProps.end, sep2, null, valueProps, onError) : null;
      if (valueNode) {
        if (isBlock(value2))
          onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode, valueNode);
      if (ctx2.options.keepSourceTokens)
        pair.srcToken = collItem;
      if (isMap3) {
        const map3 = coll;
        if (mapIncludes(ctx2, map3.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        map3.items.push(pair);
      } else {
        const map3 = new YAMLMap(ctx2.schema);
        map3.flow = true;
        map3.items.push(pair);
        coll.items.push(map3);
      }
      offset3 = valueNode ? valueNode.range[2] : valueProps.end;
    }
  }
  const expectedEnd = isMap3 ? "}" : "]";
  const [ce, ...ee] = fc.end;
  let cePos = offset3;
  if (ce && ce.source === expectedEnd)
    cePos = ce.offset + ce.source.length;
  else {
    const name2 = fcName[0].toUpperCase() + fcName.substring(1);
    const msg = atRoot ? `${name2} must end with a ${expectedEnd}` : `${name2} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
    onError(offset3, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
    if (ce && ce.source.length !== 1)
      ee.unshift(ce);
  }
  if (ee.length > 0) {
    const end = resolveEnd(ee, cePos, ctx2.options.strict, onError);
    if (end.comment) {
      if (coll.comment)
        coll.comment += "\n" + end.comment;
      else
        coll.comment = end.comment;
    }
    coll.range = [fc.offset, cePos, end.offset];
  } else {
    coll.range = [fc.offset, cePos, cePos];
  }
  return coll;
}
function composeCollection(CN3, ctx2, token, tagToken, onError) {
  let coll;
  switch (token.type) {
    case "block-map": {
      coll = resolveBlockMap(CN3, ctx2, token, onError);
      break;
    }
    case "block-seq": {
      coll = resolveBlockSeq(CN3, ctx2, token, onError);
      break;
    }
    case "flow-collection": {
      coll = resolveFlowCollection(CN3, ctx2, token, onError);
      break;
    }
  }
  if (!tagToken)
    return coll;
  const tagName = ctx2.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
  if (!tagName)
    return coll;
  const Coll = coll.constructor;
  if (tagName === "!" || tagName === Coll.tagName) {
    coll.tag = Coll.tagName;
    return coll;
  }
  const expType = isMap(coll) ? "map" : "seq";
  let tag = ctx2.schema.tags.find((t3) => t3.collection === expType && t3.tag === tagName);
  if (!tag) {
    const kt = ctx2.schema.knownTags[tagName];
    if (kt && kt.collection === expType) {
      ctx2.schema.tags.push(Object.assign({}, kt, { default: false }));
      tag = kt;
    } else {
      onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
      coll.tag = tagName;
      return coll;
    }
  }
  const res = tag.resolve(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx2.options);
  const node3 = isNode$1(res) ? res : new Scalar(res);
  node3.range = coll.range;
  node3.tag = tagName;
  if (tag == null ? void 0 : tag.format)
    node3.format = tag.format;
  return node3;
}
function resolveBlockScalar(scalar, strict, onError) {
  const start = scalar.offset;
  const header = parseBlockScalarHeader(scalar, strict, onError);
  if (!header)
    return { value: "", type: null, comment: "", range: [start, start, start] };
  const type = header.mode === ">" ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;
  const lines = scalar.source ? splitLines(scalar.source) : [];
  let chompStart = lines.length;
  for (let i2 = lines.length - 1; i2 >= 0; --i2) {
    const content = lines[i2][1];
    if (content === "" || content === "\r")
      chompStart = i2;
    else
      break;
  }
  if (chompStart === 0) {
    const value3 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
    let end2 = start + header.length;
    if (scalar.source)
      end2 += scalar.source.length;
    return { value: value3, type, comment: header.comment, range: [start, end2, end2] };
  }
  let trimIndent = scalar.indent + header.indent;
  let offset3 = scalar.offset + header.length;
  let contentStart = 0;
  for (let i2 = 0; i2 < chompStart; ++i2) {
    const [indent, content] = lines[i2];
    if (content === "" || content === "\r") {
      if (header.indent === 0 && indent.length > trimIndent)
        trimIndent = indent.length;
    } else {
      if (indent.length < trimIndent) {
        const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
        onError(offset3 + indent.length, "MISSING_CHAR", message);
      }
      if (header.indent === 0)
        trimIndent = indent.length;
      contentStart = i2;
      break;
    }
    offset3 += indent.length + content.length + 1;
  }
  for (let i2 = lines.length - 1; i2 >= chompStart; --i2) {
    if (lines[i2][0].length > trimIndent)
      chompStart = i2 + 1;
  }
  let value2 = "";
  let sep2 = "";
  let prevMoreIndented = false;
  for (let i2 = 0; i2 < contentStart; ++i2)
    value2 += lines[i2][0].slice(trimIndent) + "\n";
  for (let i2 = contentStart; i2 < chompStart; ++i2) {
    let [indent, content] = lines[i2];
    offset3 += indent.length + content.length + 1;
    const crlf = content[content.length - 1] === "\r";
    if (crlf)
      content = content.slice(0, -1);
    if (content && indent.length < trimIndent) {
      const src3 = header.indent ? "explicit indentation indicator" : "first line";
      const message = `Block scalar lines must not be less indented than their ${src3}`;
      onError(offset3 - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
      indent = "";
    }
    if (type === Scalar.BLOCK_LITERAL) {
      value2 += sep2 + indent.slice(trimIndent) + content;
      sep2 = "\n";
    } else if (indent.length > trimIndent || content[0] === "	") {
      if (sep2 === " ")
        sep2 = "\n";
      else if (!prevMoreIndented && sep2 === "\n")
        sep2 = "\n\n";
      value2 += sep2 + indent.slice(trimIndent) + content;
      sep2 = "\n";
      prevMoreIndented = true;
    } else if (content === "") {
      if (sep2 === "\n")
        value2 += "\n";
      else
        sep2 = "\n";
    } else {
      value2 += sep2 + content;
      sep2 = " ";
      prevMoreIndented = false;
    }
  }
  switch (header.chomp) {
    case "-":
      break;
    case "+":
      for (let i2 = chompStart; i2 < lines.length; ++i2)
        value2 += "\n" + lines[i2][0].slice(trimIndent);
      if (value2[value2.length - 1] !== "\n")
        value2 += "\n";
      break;
    default:
      value2 += "\n";
  }
  const end = start + header.length + scalar.source.length;
  return { value: value2, type, comment: header.comment, range: [start, end, end] };
}
function parseBlockScalarHeader({ offset: offset3, props }, strict, onError) {
  if (props[0].type !== "block-scalar-header") {
    onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
    return null;
  }
  const { source } = props[0];
  const mode2 = source[0];
  let indent = 0;
  let chomp = "";
  let error3 = -1;
  for (let i2 = 1; i2 < source.length; ++i2) {
    const ch = source[i2];
    if (!chomp && (ch === "-" || ch === "+"))
      chomp = ch;
    else {
      const n3 = Number(ch);
      if (!indent && n3)
        indent = n3;
      else if (error3 === -1)
        error3 = offset3 + i2;
    }
  }
  if (error3 !== -1)
    onError(error3, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
  let hasSpace = false;
  let comment2 = "";
  let length = source.length;
  for (let i2 = 1; i2 < props.length; ++i2) {
    const token = props[i2];
    switch (token.type) {
      case "space":
        hasSpace = true;
      case "newline":
        length += token.source.length;
        break;
      case "comment":
        if (strict && !hasSpace) {
          const message = "Comments must be separated from other tokens by white space characters";
          onError(token, "MISSING_CHAR", message);
        }
        length += token.source.length;
        comment2 = token.source.substring(1);
        break;
      case "error":
        onError(token, "UNEXPECTED_TOKEN", token.message);
        length += token.source.length;
        break;
      default: {
        const message = `Unexpected token in block scalar header: ${token.type}`;
        onError(token, "UNEXPECTED_TOKEN", message);
        const ts = token.source;
        if (ts && typeof ts === "string")
          length += ts.length;
      }
    }
  }
  return { mode: mode2, indent, chomp, comment: comment2, length };
}
function splitLines(source) {
  const split = source.split(/\n( *)/);
  const first2 = split[0];
  const m = first2.match(/^( *)/);
  const line0 = (m == null ? void 0 : m[1]) ? [m[1], first2.slice(m[1].length)] : ["", first2];
  const lines = [line0];
  for (let i2 = 1; i2 < split.length; i2 += 2)
    lines.push([split[i2], split[i2 + 1]]);
  return lines;
}
function resolveFlowScalar(scalar, strict, onError) {
  const { offset: offset3, type, source, end } = scalar;
  let _type;
  let value2;
  const _onError = (rel, code, msg) => onError(offset3 + rel, code, msg);
  switch (type) {
    case "scalar":
      _type = Scalar.PLAIN;
      value2 = plainValue(source, _onError);
      break;
    case "single-quoted-scalar":
      _type = Scalar.QUOTE_SINGLE;
      value2 = singleQuotedValue(source, _onError);
      break;
    case "double-quoted-scalar":
      _type = Scalar.QUOTE_DOUBLE;
      value2 = doubleQuotedValue(source, _onError);
      break;
    default:
      onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
      return {
        value: "",
        type: null,
        comment: "",
        range: [offset3, offset3 + source.length, offset3 + source.length]
      };
  }
  const valueEnd = offset3 + source.length;
  const re = resolveEnd(end, valueEnd, strict, onError);
  return {
    value: value2,
    type: _type,
    comment: re.comment,
    range: [offset3, valueEnd, re.offset]
  };
}
function plainValue(source, onError) {
  let badChar = "";
  switch (source[0]) {
    case "	":
      badChar = "a tab character";
      break;
    case ",":
      badChar = "flow indicator character ,";
      break;
    case "%":
      badChar = "directive indicator character %";
      break;
    case "|":
    case ">": {
      badChar = `block scalar indicator ${source[0]}`;
      break;
    }
    case "@":
    case "`": {
      badChar = `reserved character ${source[0]}`;
      break;
    }
  }
  if (badChar)
    onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
  return foldLines(source);
}
function singleQuotedValue(source, onError) {
  if (source[source.length - 1] !== "'" || source.length === 1)
    onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
  return foldLines(source.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(source) {
  let first2, line;
  try {
    first2 = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
    line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
  } catch (_) {
    first2 = /(.*?)[ \t]*\r?\n/sy;
    line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let match = first2.exec(source);
  if (!match)
    return source;
  let res = match[1];
  let sep2 = " ";
  let pos = first2.lastIndex;
  line.lastIndex = pos;
  while (match = line.exec(source)) {
    if (match[1] === "") {
      if (sep2 === "\n")
        res += sep2;
      else
        sep2 = "\n";
    } else {
      res += sep2 + match[1];
      sep2 = " ";
    }
    pos = line.lastIndex;
  }
  const last = /[ \t]*(.*)/sy;
  last.lastIndex = pos;
  match = last.exec(source);
  return res + sep2 + ((match == null ? void 0 : match[1]) ?? "");
}
function doubleQuotedValue(source, onError) {
  let res = "";
  for (let i2 = 1; i2 < source.length - 1; ++i2) {
    const ch = source[i2];
    if (ch === "\r" && source[i2 + 1] === "\n")
      continue;
    if (ch === "\n") {
      const { fold, offset: offset3 } = foldNewline(source, i2);
      res += fold;
      i2 = offset3;
    } else if (ch === "\\") {
      let next = source[++i2];
      const cc = escapeCodes[next];
      if (cc)
        res += cc;
      else if (next === "\n") {
        next = source[i2 + 1];
        while (next === " " || next === "	")
          next = source[++i2 + 1];
      } else if (next === "\r" && source[i2 + 1] === "\n") {
        next = source[++i2 + 1];
        while (next === " " || next === "	")
          next = source[++i2 + 1];
      } else if (next === "x" || next === "u" || next === "U") {
        const length = { x: 2, u: 4, U: 8 }[next];
        res += parseCharCode(source, i2 + 1, length, onError);
        i2 += length;
      } else {
        const raw = source.substr(i2 - 1, 2);
        onError(i2 - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        res += raw;
      }
    } else if (ch === " " || ch === "	") {
      const wsStart = i2;
      let next = source[i2 + 1];
      while (next === " " || next === "	")
        next = source[++i2 + 1];
      if (next !== "\n" && !(next === "\r" && source[i2 + 2] === "\n"))
        res += i2 > wsStart ? source.slice(wsStart, i2 + 1) : ch;
    } else {
      res += ch;
    }
  }
  if (source[source.length - 1] !== '"' || source.length === 1)
    onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
  return res;
}
function foldNewline(source, offset3) {
  let fold = "";
  let ch = source[offset3 + 1];
  while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
    if (ch === "\r" && source[offset3 + 2] !== "\n")
      break;
    if (ch === "\n")
      fold += "\n";
    offset3 += 1;
    ch = source[offset3 + 1];
  }
  if (!fold)
    fold = " ";
  return { fold, offset: offset3 };
}
var escapeCodes = {
  "0": "\0",
  a: "\x07",
  b: "\b",
  e: "\x1B",
  f: "\f",
  n: "\n",
  r: "\r",
  t: "	",
  v: "\v",
  N: "",
  _: " ",
  L: "\u2028",
  P: "\u2029",
  " ": " ",
  '"': '"',
  "/": "/",
  "\\": "\\",
  "	": "	"
};
function parseCharCode(source, offset3, length, onError) {
  const cc = source.substr(offset3, length);
  const ok2 = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
  const code = ok2 ? parseInt(cc, 16) : NaN;
  if (isNaN(code)) {
    const raw = source.substr(offset3 - 2, length + 2);
    onError(offset3 - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
    return raw;
  }
  return String.fromCodePoint(code);
}
function composeScalar(ctx2, token, tagToken, onError) {
  const { value: value2, type, comment: comment2, range: range2 } = token.type === "block-scalar" ? resolveBlockScalar(token, ctx2.options.strict, onError) : resolveFlowScalar(token, ctx2.options.strict, onError);
  const tagName = tagToken ? ctx2.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
  const tag = tagToken && tagName ? findScalarTagByName(ctx2.schema, value2, tagName, tagToken, onError) : token.type === "scalar" ? findScalarTagByTest(ctx2, value2, token, onError) : ctx2.schema[SCALAR$1];
  let scalar;
  try {
    const res = tag.resolve(value2, (msg) => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx2.options);
    scalar = isScalar$1(res) ? res : new Scalar(res);
  } catch (error3) {
    const msg = error3 instanceof Error ? error3.message : String(error3);
    onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
    scalar = new Scalar(value2);
  }
  scalar.range = range2;
  scalar.source = value2;
  if (type)
    scalar.type = type;
  if (tagName)
    scalar.tag = tagName;
  if (tag.format)
    scalar.format = tag.format;
  if (comment2)
    scalar.comment = comment2;
  return scalar;
}
function findScalarTagByName(schema5, value2, tagName, tagToken, onError) {
  var _a;
  if (tagName === "!")
    return schema5[SCALAR$1];
  const matchWithTest = [];
  for (const tag of schema5.tags) {
    if (!tag.collection && tag.tag === tagName) {
      if (tag.default && tag.test)
        matchWithTest.push(tag);
      else
        return tag;
    }
  }
  for (const tag of matchWithTest)
    if ((_a = tag.test) == null ? void 0 : _a.test(value2))
      return tag;
  const kt = schema5.knownTags[tagName];
  if (kt && !kt.collection) {
    schema5.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
    return kt;
  }
  onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
  return schema5[SCALAR$1];
}
function findScalarTagByTest({ directives, schema: schema5 }, value2, token, onError) {
  const tag = schema5.tags.find((tag2) => {
    var _a;
    return tag2.default && ((_a = tag2.test) == null ? void 0 : _a.test(value2));
  }) || schema5[SCALAR$1];
  if (schema5.compat) {
    const compat = schema5.compat.find((tag2) => {
      var _a;
      return tag2.default && ((_a = tag2.test) == null ? void 0 : _a.test(value2));
    }) ?? schema5[SCALAR$1];
    if (tag.tag !== compat.tag) {
      const ts = directives.tagString(tag.tag);
      const cs = directives.tagString(compat.tag);
      const msg = `Value may be parsed as either ${ts} or ${cs}`;
      onError(token, "TAG_RESOLVE_FAILED", msg, true);
    }
  }
  return tag;
}
function emptyScalarPosition(offset3, before, pos) {
  if (before) {
    if (pos === null)
      pos = before.length;
    for (let i2 = pos - 1; i2 >= 0; --i2) {
      let st = before[i2];
      switch (st.type) {
        case "space":
        case "comment":
        case "newline":
          offset3 -= st.source.length;
          continue;
      }
      st = before[++i2];
      while ((st == null ? void 0 : st.type) === "space") {
        offset3 += st.source.length;
        st = before[++i2];
      }
      break;
    }
  }
  return offset3;
}
var CN = { composeNode, composeEmptyNode };
function composeNode(ctx2, token, props, onError) {
  const { spaceBefore, comment: comment2, anchor, tag } = props;
  let node3;
  let isSrcToken = true;
  switch (token.type) {
    case "alias":
      node3 = composeAlias(ctx2, token, onError);
      if (anchor || tag)
        onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      node3 = composeScalar(ctx2, token, tag, onError);
      if (anchor)
        node3.anchor = anchor.source.substring(1);
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      node3 = composeCollection(CN, ctx2, token, tag, onError);
      if (anchor)
        node3.anchor = anchor.source.substring(1);
      break;
    default: {
      const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
      onError(token, "UNEXPECTED_TOKEN", message);
      node3 = composeEmptyNode(ctx2, token.offset, void 0, null, props, onError);
      isSrcToken = false;
    }
  }
  if (anchor && node3.anchor === "")
    onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  if (spaceBefore)
    node3.spaceBefore = true;
  if (comment2) {
    if (token.type === "scalar" && token.source === "")
      node3.comment = comment2;
    else
      node3.commentBefore = comment2;
  }
  if (ctx2.options.keepSourceTokens && isSrcToken)
    node3.srcToken = token;
  return node3;
}
function composeEmptyNode(ctx2, offset3, before, pos, { spaceBefore, comment: comment2, anchor, tag }, onError) {
  const token = {
    type: "scalar",
    offset: emptyScalarPosition(offset3, before, pos),
    indent: -1,
    source: ""
  };
  const node3 = composeScalar(ctx2, token, tag, onError);
  if (anchor) {
    node3.anchor = anchor.source.substring(1);
    if (node3.anchor === "")
      onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  }
  if (spaceBefore)
    node3.spaceBefore = true;
  if (comment2)
    node3.comment = comment2;
  return node3;
}
function composeAlias({ options: options3 }, { offset: offset3, source, end }, onError) {
  const alias2 = new Alias(source.substring(1));
  if (alias2.source === "")
    onError(offset3, "BAD_ALIAS", "Alias cannot be an empty string");
  if (alias2.source.endsWith(":"))
    onError(offset3 + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
  const valueEnd = offset3 + source.length;
  const re = resolveEnd(end, valueEnd, options3.strict, onError);
  alias2.range = [offset3, valueEnd, re.offset];
  if (re.comment)
    alias2.comment = re.comment;
  return alias2;
}
function composeDoc(options3, directives, { offset: offset3, start, value: value2, end }, onError) {
  const opts = Object.assign({ _directives: directives }, options3);
  const doc = new Document(void 0, opts);
  const ctx2 = {
    atRoot: true,
    directives: doc.directives,
    options: doc.options,
    schema: doc.schema
  };
  const props = resolveProps(start, {
    indicator: "doc-start",
    next: value2 ?? (end == null ? void 0 : end[0]),
    offset: offset3,
    onError,
    startOnNewline: true
  });
  if (props.found) {
    doc.directives.docStart = true;
    if (value2 && (value2.type === "block-map" || value2.type === "block-seq") && !props.hasNewline)
      onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
  }
  doc.contents = value2 ? composeNode(ctx2, value2, props, onError) : composeEmptyNode(ctx2, props.end, start, null, props, onError);
  const contentEnd = doc.contents.range[2];
  const re = resolveEnd(end, contentEnd, false, onError);
  if (re.comment)
    doc.comment = re.comment;
  doc.range = [offset3, contentEnd, re.offset];
  return doc;
}
function getErrorPos(src3) {
  if (typeof src3 === "number")
    return [src3, src3 + 1];
  if (Array.isArray(src3))
    return src3.length === 2 ? src3 : [src3[0], src3[1]];
  const { offset: offset3, source } = src3;
  return [offset3, offset3 + (typeof source === "string" ? source.length : 1)];
}
function parsePrelude(prelude) {
  var _a;
  let comment2 = "";
  let atComment = false;
  let afterEmptyLine = false;
  for (let i2 = 0; i2 < prelude.length; ++i2) {
    const source = prelude[i2];
    switch (source[0]) {
      case "#":
        comment2 += (comment2 === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
        atComment = true;
        afterEmptyLine = false;
        break;
      case "%":
        if (((_a = prelude[i2 + 1]) == null ? void 0 : _a[0]) !== "#")
          i2 += 1;
        atComment = false;
        break;
      default:
        if (!atComment)
          afterEmptyLine = true;
        atComment = false;
    }
  }
  return { comment: comment2, afterEmptyLine };
}
var Composer = class {
  constructor(options3 = {}) {
    this.doc = null;
    this.atDirectives = false;
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
    this.onError = (source, code, message, warning) => {
      const pos = getErrorPos(source);
      if (warning)
        this.warnings.push(new YAMLWarning(pos, code, message));
      else
        this.errors.push(new YAMLParseError(pos, code, message));
    };
    this.directives = new Directives({ version: options3.version || "1.2" });
    this.options = options3;
  }
  decorate(doc, afterDoc) {
    const { comment: comment2, afterEmptyLine } = parsePrelude(this.prelude);
    if (comment2) {
      const dc = doc.contents;
      if (afterDoc) {
        doc.comment = doc.comment ? `${doc.comment}
${comment2}` : comment2;
      } else if (afterEmptyLine || doc.directives.docStart || !dc) {
        doc.commentBefore = comment2;
      } else if (isCollection$1(dc) && !dc.flow && dc.items.length > 0) {
        let it = dc.items[0];
        if (isPair(it))
          it = it.key;
        const cb = it.commentBefore;
        it.commentBefore = cb ? `${comment2}
${cb}` : comment2;
      } else {
        const cb = dc.commentBefore;
        dc.commentBefore = cb ? `${comment2}
${cb}` : comment2;
      }
    }
    if (afterDoc) {
      Array.prototype.push.apply(doc.errors, this.errors);
      Array.prototype.push.apply(doc.warnings, this.warnings);
    } else {
      doc.errors = this.errors;
      doc.warnings = this.warnings;
    }
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
  }
  /**
   * Current stream status information.
   *
   * Mostly useful at the end of input for an empty stream.
   */
  streamInfo() {
    return {
      comment: parsePrelude(this.prelude).comment,
      directives: this.directives,
      errors: this.errors,
      warnings: this.warnings
    };
  }
  /**
   * Compose tokens into documents.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *compose(tokens, forceDoc = false, endOffset = -1) {
    for (const token of tokens)
      yield* this.next(token);
    yield* this.end(forceDoc, endOffset);
  }
  /** Advance the composer by one CST token. */
  *next(token) {
    switch (token.type) {
      case "directive":
        this.directives.add(token.source, (offset3, message, warning) => {
          const pos = getErrorPos(token);
          pos[0] += offset3;
          this.onError(pos, "BAD_DIRECTIVE", message, warning);
        });
        this.prelude.push(token.source);
        this.atDirectives = true;
        break;
      case "document": {
        const doc = composeDoc(this.options, this.directives, token, this.onError);
        if (this.atDirectives && !doc.directives.docStart)
          this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
        this.decorate(doc, false);
        if (this.doc)
          yield this.doc;
        this.doc = doc;
        this.atDirectives = false;
        break;
      }
      case "byte-order-mark":
      case "space":
        break;
      case "comment":
      case "newline":
        this.prelude.push(token.source);
        break;
      case "error": {
        const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
        const error3 = new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
        if (this.atDirectives || !this.doc)
          this.errors.push(error3);
        else
          this.doc.errors.push(error3);
        break;
      }
      case "doc-end": {
        if (!this.doc) {
          const msg = "Unexpected doc-end without preceding document";
          this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
          break;
        }
        this.doc.directives.docEnd = true;
        const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
        this.decorate(this.doc, true);
        if (end.comment) {
          const dc = this.doc.comment;
          this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
        }
        this.doc.range[2] = end.offset;
        break;
      }
      default:
        this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
    }
  }
  /**
   * Call at end of input to yield any remaining document.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *end(forceDoc = false, endOffset = -1) {
    if (this.doc) {
      this.decorate(this.doc, true);
      yield this.doc;
      this.doc = null;
    } else if (forceDoc) {
      const opts = Object.assign({ _directives: this.directives }, this.options);
      const doc = new Document(void 0, opts);
      if (this.atDirectives)
        this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
      doc.range = [0, endOffset, endOffset];
      this.decorate(doc, false);
      yield doc;
    }
  }
};
function resolveAsScalar(token, strict = true, onError) {
  if (token) {
    const _onError = (pos, code, message) => {
      const offset3 = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
      if (onError)
        onError(offset3, code, message);
      else
        throw new YAMLParseError([offset3, offset3 + 1], code, message);
    };
    switch (token.type) {
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return resolveFlowScalar(token, strict, _onError);
      case "block-scalar":
        return resolveBlockScalar(token, strict, _onError);
    }
  }
  return null;
}
function createScalarToken(value2, context) {
  const { implicitKey = false, indent, inFlow = false, offset: offset3 = -1, type = "PLAIN" } = context;
  const source = stringifyString({ type, value: value2 }, {
    implicitKey,
    indent: indent > 0 ? " ".repeat(indent) : "",
    inFlow,
    options: { blockQuote: true, lineWidth: -1 }
  });
  const end = context.end ?? [
    { type: "newline", offset: -1, indent, source: "\n" }
  ];
  switch (source[0]) {
    case "|":
    case ">": {
      const he = source.indexOf("\n");
      const head = source.substring(0, he);
      const body = source.substring(he + 1) + "\n";
      const props = [
        { type: "block-scalar-header", offset: offset3, indent, source: head }
      ];
      if (!addEndtoBlockProps(props, end))
        props.push({ type: "newline", offset: -1, indent, source: "\n" });
      return { type: "block-scalar", offset: offset3, indent, props, source: body };
    }
    case '"':
      return { type: "double-quoted-scalar", offset: offset3, indent, source, end };
    case "'":
      return { type: "single-quoted-scalar", offset: offset3, indent, source, end };
    default:
      return { type: "scalar", offset: offset3, indent, source, end };
  }
}
function setScalarValue(token, value2, context = {}) {
  let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
  let indent = "indent" in token ? token.indent : null;
  if (afterKey && typeof indent === "number")
    indent += 2;
  if (!type)
    switch (token.type) {
      case "single-quoted-scalar":
        type = "QUOTE_SINGLE";
        break;
      case "double-quoted-scalar":
        type = "QUOTE_DOUBLE";
        break;
      case "block-scalar": {
        const header = token.props[0];
        if (header.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
        break;
      }
      default:
        type = "PLAIN";
    }
  const source = stringifyString({ type, value: value2 }, {
    implicitKey: implicitKey || indent === null,
    indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
    inFlow,
    options: { blockQuote: true, lineWidth: -1 }
  });
  switch (source[0]) {
    case "|":
    case ">":
      setBlockScalarValue(token, source);
      break;
    case '"':
      setFlowScalarValue(token, source, "double-quoted-scalar");
      break;
    case "'":
      setFlowScalarValue(token, source, "single-quoted-scalar");
      break;
    default:
      setFlowScalarValue(token, source, "scalar");
  }
}
function setBlockScalarValue(token, source) {
  const he = source.indexOf("\n");
  const head = source.substring(0, he);
  const body = source.substring(he + 1) + "\n";
  if (token.type === "block-scalar") {
    const header = token.props[0];
    if (header.type !== "block-scalar-header")
      throw new Error("Invalid block scalar header");
    header.source = head;
    token.source = body;
  } else {
    const { offset: offset3 } = token;
    const indent = "indent" in token ? token.indent : -1;
    const props = [
      { type: "block-scalar-header", offset: offset3, indent, source: head }
    ];
    if (!addEndtoBlockProps(props, "end" in token ? token.end : void 0))
      props.push({ type: "newline", offset: -1, indent, source: "\n" });
    for (const key of Object.keys(token))
      if (key !== "type" && key !== "offset")
        delete token[key];
    Object.assign(token, { type: "block-scalar", indent, props, source: body });
  }
}
function addEndtoBlockProps(props, end) {
  if (end)
    for (const st of end)
      switch (st.type) {
        case "space":
        case "comment":
          props.push(st);
          break;
        case "newline":
          props.push(st);
          return true;
      }
  return false;
}
function setFlowScalarValue(token, source, type) {
  switch (token.type) {
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      token.type = type;
      token.source = source;
      break;
    case "block-scalar": {
      const end = token.props.slice(1);
      let oa = source.length;
      if (token.props[0].type === "block-scalar-header")
        oa -= token.props[0].source.length;
      for (const tok of end)
        tok.offset += oa;
      delete token.props;
      Object.assign(token, { type, source, end });
      break;
    }
    case "block-map":
    case "block-seq": {
      const offset3 = token.offset + source.length;
      const nl = { type: "newline", offset: offset3, indent: token.indent, source: "\n" };
      delete token.items;
      Object.assign(token, { type, source, end: [nl] });
      break;
    }
    default: {
      const indent = "indent" in token ? token.indent : -1;
      const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
      for (const key of Object.keys(token))
        if (key !== "type" && key !== "offset")
          delete token[key];
      Object.assign(token, { type, indent, source, end });
    }
  }
}
var stringify$1 = (cst2) => "type" in cst2 ? stringifyToken(cst2) : stringifyItem(cst2);
function stringifyToken(token) {
  switch (token.type) {
    case "block-scalar": {
      let res = "";
      for (const tok of token.props)
        res += stringifyToken(tok);
      return res + token.source;
    }
    case "block-map":
    case "block-seq": {
      let res = "";
      for (const item of token.items)
        res += stringifyItem(item);
      return res;
    }
    case "flow-collection": {
      let res = token.start.source;
      for (const item of token.items)
        res += stringifyItem(item);
      for (const st of token.end)
        res += st.source;
      return res;
    }
    case "document": {
      let res = stringifyItem(token);
      if (token.end)
        for (const st of token.end)
          res += st.source;
      return res;
    }
    default: {
      let res = token.source;
      if ("end" in token && token.end)
        for (const st of token.end)
          res += st.source;
      return res;
    }
  }
}
function stringifyItem({ start, key, sep: sep2, value: value2 }) {
  let res = "";
  for (const st of start)
    res += st.source;
  if (key)
    res += stringifyToken(key);
  if (sep2)
    for (const st of sep2)
      res += st.source;
  if (value2)
    res += stringifyToken(value2);
  return res;
}
var BREAK = Symbol("break visit");
var SKIP = Symbol("skip children");
var REMOVE = Symbol("remove item");
function visit(cst2, visitor) {
  if ("type" in cst2 && cst2.type === "document")
    cst2 = { start: cst2.start, value: cst2.value };
  _visit(Object.freeze([]), cst2, visitor);
}
visit.BREAK = BREAK;
visit.SKIP = SKIP;
visit.REMOVE = REMOVE;
visit.itemAtPath = (cst2, path8) => {
  let item = cst2;
  for (const [field, index2] of path8) {
    const tok = item == null ? void 0 : item[field];
    if (tok && "items" in tok) {
      item = tok.items[index2];
    } else
      return void 0;
  }
  return item;
};
visit.parentCollection = (cst2, path8) => {
  const parent = visit.itemAtPath(cst2, path8.slice(0, -1));
  const field = path8[path8.length - 1][0];
  const coll = parent == null ? void 0 : parent[field];
  if (coll && "items" in coll)
    return coll;
  throw new Error("Parent collection not found");
};
function _visit(path8, item, visitor) {
  let ctrl = visitor(item, path8);
  if (typeof ctrl === "symbol")
    return ctrl;
  for (const field of ["key", "value"]) {
    const token = item[field];
    if (token && "items" in token) {
      for (let i2 = 0; i2 < token.items.length; ++i2) {
        const ci = _visit(Object.freeze(path8.concat([[field, i2]])), token.items[i2], visitor);
        if (typeof ci === "number")
          i2 = ci - 1;
        else if (ci === BREAK)
          return BREAK;
        else if (ci === REMOVE) {
          token.items.splice(i2, 1);
          i2 -= 1;
        }
      }
      if (typeof ctrl === "function" && field === "key")
        ctrl = ctrl(item, path8);
    }
  }
  return typeof ctrl === "function" ? ctrl(item, path8) : ctrl;
}
var BOM = "\uFEFF";
var DOCUMENT = "";
var FLOW_END = "";
var SCALAR = "";
var isCollection = (token) => !!token && "items" in token;
var isScalar = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
function prettyToken(token) {
  switch (token) {
    case BOM:
      return "<BOM>";
    case DOCUMENT:
      return "<DOC>";
    case FLOW_END:
      return "<FLOW_END>";
    case SCALAR:
      return "<SCALAR>";
    default:
      return JSON.stringify(token);
  }
}
function tokenType(source) {
  switch (source) {
    case BOM:
      return "byte-order-mark";
    case DOCUMENT:
      return "doc-mode";
    case FLOW_END:
      return "flow-error-end";
    case SCALAR:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case "\n":
    case "\r\n":
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (source[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}
var cst = {
  __proto__: null,
  BOM,
  DOCUMENT,
  FLOW_END,
  SCALAR,
  createScalarToken,
  isCollection,
  isScalar,
  prettyToken,
  resolveAsScalar,
  setScalarValue,
  stringify: stringify$1,
  tokenType,
  visit
};
function isEmpty(ch) {
  switch (ch) {
    case void 0:
    case " ":
    case "\n":
    case "\r":
    case "	":
      return true;
    default:
      return false;
  }
}
var hexDigits = "0123456789ABCDEFabcdef".split("");
var tagChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split("");
var invalidFlowScalarChars = ",[]{}".split("");
var invalidAnchorChars = " ,[]{}\n\r	".split("");
var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.includes(ch);
var Lexer = class {
  constructor() {
    this.atEnd = false;
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    this.buffer = "";
    this.flowKey = false;
    this.flowLevel = 0;
    this.indentNext = 0;
    this.indentValue = 0;
    this.lineEndPos = null;
    this.next = null;
    this.pos = 0;
  }
  /**
   * Generate YAML tokens from the `source` string. If `incomplete`,
   * a part of the last line may be left as a buffer for the next call.
   *
   * @returns A generator of lexical tokens
   */
  *lex(source, incomplete = false) {
    if (source) {
      this.buffer = this.buffer ? this.buffer + source : source;
      this.lineEndPos = null;
    }
    this.atEnd = !incomplete;
    let next = this.next ?? "stream";
    while (next && (incomplete || this.hasChars(1)))
      next = yield* this.parseNext(next);
  }
  atLineEnd() {
    let i2 = this.pos;
    let ch = this.buffer[i2];
    while (ch === " " || ch === "	")
      ch = this.buffer[++i2];
    if (!ch || ch === "#" || ch === "\n")
      return true;
    if (ch === "\r")
      return this.buffer[i2 + 1] === "\n";
    return false;
  }
  charAt(n3) {
    return this.buffer[this.pos + n3];
  }
  continueScalar(offset3) {
    let ch = this.buffer[offset3];
    if (this.indentNext > 0) {
      let indent = 0;
      while (ch === " ")
        ch = this.buffer[++indent + offset3];
      if (ch === "\r") {
        const next = this.buffer[indent + offset3 + 1];
        if (next === "\n" || !next && !this.atEnd)
          return offset3 + indent + 1;
      }
      return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset3 + indent : -1;
    }
    if (ch === "-" || ch === ".") {
      const dt = this.buffer.substr(offset3, 3);
      if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset3 + 3]))
        return -1;
    }
    return offset3;
  }
  getLine() {
    let end = this.lineEndPos;
    if (typeof end !== "number" || end !== -1 && end < this.pos) {
      end = this.buffer.indexOf("\n", this.pos);
      this.lineEndPos = end;
    }
    if (end === -1)
      return this.atEnd ? this.buffer.substring(this.pos) : null;
    if (this.buffer[end - 1] === "\r")
      end -= 1;
    return this.buffer.substring(this.pos, end);
  }
  hasChars(n3) {
    return this.pos + n3 <= this.buffer.length;
  }
  setNext(state) {
    this.buffer = this.buffer.substring(this.pos);
    this.pos = 0;
    this.lineEndPos = null;
    this.next = state;
    return null;
  }
  peek(n3) {
    return this.buffer.substr(this.pos, n3);
  }
  *parseNext(next) {
    switch (next) {
      case "stream":
        return yield* this.parseStream();
      case "line-start":
        return yield* this.parseLineStart();
      case "block-start":
        return yield* this.parseBlockStart();
      case "doc":
        return yield* this.parseDocument();
      case "flow":
        return yield* this.parseFlowCollection();
      case "quoted-scalar":
        return yield* this.parseQuotedScalar();
      case "block-scalar":
        return yield* this.parseBlockScalar();
      case "plain-scalar":
        return yield* this.parsePlainScalar();
    }
  }
  *parseStream() {
    let line = this.getLine();
    if (line === null)
      return this.setNext("stream");
    if (line[0] === BOM) {
      yield* this.pushCount(1);
      line = line.substring(1);
    }
    if (line[0] === "%") {
      let dirEnd = line.length;
      const cs = line.indexOf("#");
      if (cs !== -1) {
        const ch = line[cs - 1];
        if (ch === " " || ch === "	")
          dirEnd = cs - 1;
      }
      while (true) {
        const ch = line[dirEnd - 1];
        if (ch === " " || ch === "	")
          dirEnd -= 1;
        else
          break;
      }
      const n3 = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
      yield* this.pushCount(line.length - n3);
      this.pushNewline();
      return "stream";
    }
    if (this.atLineEnd()) {
      const sp = yield* this.pushSpaces(true);
      yield* this.pushCount(line.length - sp);
      yield* this.pushNewline();
      return "stream";
    }
    yield DOCUMENT;
    return yield* this.parseLineStart();
  }
  *parseLineStart() {
    const ch = this.charAt(0);
    if (!ch && !this.atEnd)
      return this.setNext("line-start");
    if (ch === "-" || ch === ".") {
      if (!this.atEnd && !this.hasChars(4))
        return this.setNext("line-start");
      const s2 = this.peek(3);
      if (s2 === "---" && isEmpty(this.charAt(3))) {
        yield* this.pushCount(3);
        this.indentValue = 0;
        this.indentNext = 0;
        return "doc";
      } else if (s2 === "..." && isEmpty(this.charAt(3))) {
        yield* this.pushCount(3);
        return "stream";
      }
    }
    this.indentValue = yield* this.pushSpaces(false);
    if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
      this.indentNext = this.indentValue;
    return yield* this.parseBlockStart();
  }
  *parseBlockStart() {
    const [ch0, ch1] = this.peek(2);
    if (!ch1 && !this.atEnd)
      return this.setNext("block-start");
    if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
      const n3 = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
      this.indentNext = this.indentValue + 1;
      this.indentValue += n3;
      return yield* this.parseBlockStart();
    }
    return "doc";
  }
  *parseDocument() {
    yield* this.pushSpaces(true);
    const line = this.getLine();
    if (line === null)
      return this.setNext("doc");
    let n3 = yield* this.pushIndicators();
    switch (line[n3]) {
      case "#":
        yield* this.pushCount(line.length - n3);
      case void 0:
        yield* this.pushNewline();
        return yield* this.parseLineStart();
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel = 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        return "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "doc";
      case '"':
      case "'":
        return yield* this.parseQuotedScalar();
      case "|":
      case ">":
        n3 += yield* this.parseBlockScalarHeader();
        n3 += yield* this.pushSpaces(true);
        yield* this.pushCount(line.length - n3);
        yield* this.pushNewline();
        return yield* this.parseBlockScalar();
      default:
        return yield* this.parsePlainScalar();
    }
  }
  *parseFlowCollection() {
    let nl, sp;
    let indent = -1;
    do {
      nl = yield* this.pushNewline();
      if (nl > 0) {
        sp = yield* this.pushSpaces(false);
        this.indentValue = indent = sp;
      } else {
        sp = 0;
      }
      sp += yield* this.pushSpaces(true);
    } while (nl + sp > 0);
    const line = this.getLine();
    if (line === null)
      return this.setNext("flow");
    if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
      const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
      if (!atFlowEndMarker) {
        this.flowLevel = 0;
        yield FLOW_END;
        return yield* this.parseLineStart();
      }
    }
    let n3 = 0;
    while (line[n3] === ",") {
      n3 += yield* this.pushCount(1);
      n3 += yield* this.pushSpaces(true);
      this.flowKey = false;
    }
    n3 += yield* this.pushIndicators();
    switch (line[n3]) {
      case void 0:
        return "flow";
      case "#":
        yield* this.pushCount(line.length - n3);
        return "flow";
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel += 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        this.flowKey = true;
        this.flowLevel -= 1;
        return this.flowLevel ? "flow" : "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "flow";
      case '"':
      case "'":
        this.flowKey = true;
        return yield* this.parseQuotedScalar();
      case ":": {
        const next = this.charAt(1);
        if (this.flowKey || isEmpty(next) || next === ",") {
          this.flowKey = false;
          yield* this.pushCount(1);
          yield* this.pushSpaces(true);
          return "flow";
        }
      }
      default:
        this.flowKey = false;
        return yield* this.parsePlainScalar();
    }
  }
  *parseQuotedScalar() {
    const quote = this.charAt(0);
    let end = this.buffer.indexOf(quote, this.pos + 1);
    if (quote === "'") {
      while (end !== -1 && this.buffer[end + 1] === "'")
        end = this.buffer.indexOf("'", end + 2);
    } else {
      while (end !== -1) {
        let n3 = 0;
        while (this.buffer[end - 1 - n3] === "\\")
          n3 += 1;
        if (n3 % 2 === 0)
          break;
        end = this.buffer.indexOf('"', end + 1);
      }
    }
    const qb = this.buffer.substring(0, end);
    let nl = qb.indexOf("\n", this.pos);
    if (nl !== -1) {
      while (nl !== -1) {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = qb.indexOf("\n", cs);
      }
      if (nl !== -1) {
        end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
      }
    }
    if (end === -1) {
      if (!this.atEnd)
        return this.setNext("quoted-scalar");
      end = this.buffer.length;
    }
    yield* this.pushToIndex(end + 1, false);
    return this.flowLevel ? "flow" : "doc";
  }
  *parseBlockScalarHeader() {
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    let i2 = this.pos;
    while (true) {
      const ch = this.buffer[++i2];
      if (ch === "+")
        this.blockScalarKeep = true;
      else if (ch > "0" && ch <= "9")
        this.blockScalarIndent = Number(ch) - 1;
      else if (ch !== "-")
        break;
    }
    return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
  }
  *parseBlockScalar() {
    let nl = this.pos - 1;
    let indent = 0;
    let ch;
    loop:
      for (let i2 = this.pos; ch = this.buffer[i2]; ++i2) {
        switch (ch) {
          case " ":
            indent += 1;
            break;
          case "\n":
            nl = i2;
            indent = 0;
            break;
          case "\r": {
            const next = this.buffer[i2 + 1];
            if (!next && !this.atEnd)
              return this.setNext("block-scalar");
            if (next === "\n")
              break;
          }
          default:
            break loop;
        }
      }
    if (!ch && !this.atEnd)
      return this.setNext("block-scalar");
    if (indent >= this.indentNext) {
      if (this.blockScalarIndent === -1)
        this.indentNext = indent;
      else
        this.indentNext += this.blockScalarIndent;
      do {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = this.buffer.indexOf("\n", cs);
      } while (nl !== -1);
      if (nl === -1) {
        if (!this.atEnd)
          return this.setNext("block-scalar");
        nl = this.buffer.length;
      }
    }
    if (!this.blockScalarKeep) {
      do {
        let i2 = nl - 1;
        let ch2 = this.buffer[i2];
        if (ch2 === "\r")
          ch2 = this.buffer[--i2];
        const lastChar = i2;
        while (ch2 === " " || ch2 === "	")
          ch2 = this.buffer[--i2];
        if (ch2 === "\n" && i2 >= this.pos && i2 + 1 + indent > lastChar)
          nl = i2;
        else
          break;
      } while (true);
    }
    yield SCALAR;
    yield* this.pushToIndex(nl + 1, true);
    return yield* this.parseLineStart();
  }
  *parsePlainScalar() {
    const inFlow = this.flowLevel > 0;
    let end = this.pos - 1;
    let i2 = this.pos - 1;
    let ch;
    while (ch = this.buffer[++i2]) {
      if (ch === ":") {
        const next = this.buffer[i2 + 1];
        if (isEmpty(next) || inFlow && next === ",")
          break;
        end = i2;
      } else if (isEmpty(ch)) {
        let next = this.buffer[i2 + 1];
        if (ch === "\r") {
          if (next === "\n") {
            i2 += 1;
            ch = "\n";
            next = this.buffer[i2 + 1];
          } else
            end = i2;
        }
        if (next === "#" || inFlow && invalidFlowScalarChars.includes(next))
          break;
        if (ch === "\n") {
          const cs = this.continueScalar(i2 + 1);
          if (cs === -1)
            break;
          i2 = Math.max(i2, cs - 2);
        }
      } else {
        if (inFlow && invalidFlowScalarChars.includes(ch))
          break;
        end = i2;
      }
    }
    if (!ch && !this.atEnd)
      return this.setNext("plain-scalar");
    yield SCALAR;
    yield* this.pushToIndex(end + 1, true);
    return inFlow ? "flow" : "doc";
  }
  *pushCount(n3) {
    if (n3 > 0) {
      yield this.buffer.substr(this.pos, n3);
      this.pos += n3;
      return n3;
    }
    return 0;
  }
  *pushToIndex(i2, allowEmpty) {
    const s2 = this.buffer.slice(this.pos, i2);
    if (s2) {
      yield s2;
      this.pos += s2.length;
      return s2.length;
    } else if (allowEmpty)
      yield "";
    return 0;
  }
  *pushIndicators() {
    switch (this.charAt(0)) {
      case "!":
        return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "&":
        return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "-":
      case "?":
      case ":": {
        const inFlow = this.flowLevel > 0;
        const ch1 = this.charAt(1);
        if (isEmpty(ch1) || inFlow && invalidFlowScalarChars.includes(ch1)) {
          if (!inFlow)
            this.indentNext = this.indentValue + 1;
          else if (this.flowKey)
            this.flowKey = false;
          return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        }
      }
    }
    return 0;
  }
  *pushTag() {
    if (this.charAt(1) === "<") {
      let i2 = this.pos + 2;
      let ch = this.buffer[i2];
      while (!isEmpty(ch) && ch !== ">")
        ch = this.buffer[++i2];
      return yield* this.pushToIndex(ch === ">" ? i2 + 1 : i2, false);
    } else {
      let i2 = this.pos + 1;
      let ch = this.buffer[i2];
      while (ch) {
        if (tagChars.includes(ch))
          ch = this.buffer[++i2];
        else if (ch === "%" && hexDigits.includes(this.buffer[i2 + 1]) && hexDigits.includes(this.buffer[i2 + 2])) {
          ch = this.buffer[i2 += 3];
        } else
          break;
      }
      return yield* this.pushToIndex(i2, false);
    }
  }
  *pushNewline() {
    const ch = this.buffer[this.pos];
    if (ch === "\n")
      return yield* this.pushCount(1);
    else if (ch === "\r" && this.charAt(1) === "\n")
      return yield* this.pushCount(2);
    else
      return 0;
  }
  *pushSpaces(allowTabs) {
    let i2 = this.pos - 1;
    let ch;
    do {
      ch = this.buffer[++i2];
    } while (ch === " " || allowTabs && ch === "	");
    const n3 = i2 - this.pos;
    if (n3 > 0) {
      yield this.buffer.substr(this.pos, n3);
      this.pos = i2;
    }
    return n3;
  }
  *pushUntil(test) {
    let i2 = this.pos;
    let ch = this.buffer[i2];
    while (!test(ch))
      ch = this.buffer[++i2];
    return yield* this.pushToIndex(i2, false);
  }
};
var LineCounter = class {
  constructor() {
    this.lineStarts = [];
    this.addNewLine = (offset3) => this.lineStarts.push(offset3);
    this.linePos = (offset3) => {
      let low = 0;
      let high = this.lineStarts.length;
      while (low < high) {
        const mid = low + high >> 1;
        if (this.lineStarts[mid] < offset3)
          low = mid + 1;
        else
          high = mid;
      }
      if (this.lineStarts[low] === offset3)
        return { line: low + 1, col: 1 };
      if (low === 0)
        return { line: 0, col: offset3 };
      const start = this.lineStarts[low - 1];
      return { line: low, col: offset3 - start + 1 };
    };
  }
};
function includesToken(list, type) {
  for (let i2 = 0; i2 < list.length; ++i2)
    if (list[i2].type === type)
      return true;
  return false;
}
function findNonEmptyIndex(list) {
  for (let i2 = 0; i2 < list.length; ++i2) {
    switch (list[i2].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return i2;
    }
  }
  return -1;
}
function isFlowToken(token) {
  switch (token == null ? void 0 : token.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return true;
    default:
      return false;
  }
}
function getPrevProps(parent) {
  switch (parent.type) {
    case "document":
      return parent.start;
    case "block-map": {
      const it = parent.items[parent.items.length - 1];
      return it.sep ?? it.start;
    }
    case "block-seq":
      return parent.items[parent.items.length - 1].start;
    default:
      return [];
  }
}
function getFirstKeyStartProps(prev) {
  var _a;
  if (prev.length === 0)
    return [];
  let i2 = prev.length;
  loop:
    while (--i2 >= 0) {
      switch (prev[i2].type) {
        case "doc-start":
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
        case "newline":
          break loop;
      }
    }
  while (((_a = prev[++i2]) == null ? void 0 : _a.type) === "space") {
  }
  return prev.splice(i2, prev.length);
}
function fixFlowSeqItems(fc) {
  if (fc.start.type === "flow-seq-start") {
    for (const it of fc.items) {
      if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
        if (it.key)
          it.value = it.key;
        delete it.key;
        if (isFlowToken(it.value)) {
          if (it.value.end)
            Array.prototype.push.apply(it.value.end, it.sep);
          else
            it.value.end = it.sep;
        } else
          Array.prototype.push.apply(it.start, it.sep);
        delete it.sep;
      }
    }
  }
}
var Parser2 = class {
  /**
   * @param onNewLine - If defined, called separately with the start position of
   *   each new line (in `parse()`, including the start of input).
   */
  constructor(onNewLine) {
    this.atNewLine = true;
    this.atScalar = false;
    this.indent = 0;
    this.offset = 0;
    this.onKeyLine = false;
    this.stack = [];
    this.source = "";
    this.type = "";
    this.lexer = new Lexer();
    this.onNewLine = onNewLine;
  }
  /**
   * Parse `source` as a YAML stream.
   * If `incomplete`, a part of the last line may be left as a buffer for the next call.
   *
   * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
   *
   * @returns A generator of tokens representing each directive, document, and other structure.
   */
  *parse(source, incomplete = false) {
    if (this.onNewLine && this.offset === 0)
      this.onNewLine(0);
    for (const lexeme of this.lexer.lex(source, incomplete))
      yield* this.next(lexeme);
    if (!incomplete)
      yield* this.end();
  }
  /**
   * Advance the parser by the `source` of one lexical token.
   */
  *next(source) {
    this.source = source;
    if (this.atScalar) {
      this.atScalar = false;
      yield* this.step();
      this.offset += source.length;
      return;
    }
    const type = tokenType(source);
    if (!type) {
      const message = `Not a YAML token: ${source}`;
      yield* this.pop({ type: "error", offset: this.offset, message, source });
      this.offset += source.length;
    } else if (type === "scalar") {
      this.atNewLine = false;
      this.atScalar = true;
      this.type = "scalar";
    } else {
      this.type = type;
      yield* this.step();
      switch (type) {
        case "newline":
          this.atNewLine = true;
          this.indent = 0;
          if (this.onNewLine)
            this.onNewLine(this.offset + source.length);
          break;
        case "space":
          if (this.atNewLine && source[0] === " ")
            this.indent += source.length;
          break;
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
          if (this.atNewLine)
            this.indent += source.length;
          break;
        case "doc-mode":
        case "flow-error-end":
          return;
        default:
          this.atNewLine = false;
      }
      this.offset += source.length;
    }
  }
  /** Call at end of input to push out any remaining constructions */
  *end() {
    while (this.stack.length > 0)
      yield* this.pop();
  }
  get sourceToken() {
    const st = {
      type: this.type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
    return st;
  }
  *step() {
    const top = this.peek(1);
    if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
      while (this.stack.length > 0)
        yield* this.pop();
      this.stack.push({
        type: "doc-end",
        offset: this.offset,
        source: this.source
      });
      return;
    }
    if (!top)
      return yield* this.stream();
    switch (top.type) {
      case "document":
        return yield* this.document(top);
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return yield* this.scalar(top);
      case "block-scalar":
        return yield* this.blockScalar(top);
      case "block-map":
        return yield* this.blockMap(top);
      case "block-seq":
        return yield* this.blockSequence(top);
      case "flow-collection":
        return yield* this.flowCollection(top);
      case "doc-end":
        return yield* this.documentEnd(top);
    }
    yield* this.pop();
  }
  peek(n3) {
    return this.stack[this.stack.length - n3];
  }
  *pop(error3) {
    const token = error3 ?? this.stack.pop();
    if (!token) {
      const message = "Tried to pop an empty stack";
      yield { type: "error", offset: this.offset, source: "", message };
    } else if (this.stack.length === 0) {
      yield token;
    } else {
      const top = this.peek(1);
      if (token.type === "block-scalar") {
        token.indent = "indent" in top ? top.indent : 0;
      } else if (token.type === "flow-collection" && top.type === "document") {
        token.indent = 0;
      }
      if (token.type === "flow-collection")
        fixFlowSeqItems(token);
      switch (top.type) {
        case "document":
          top.value = token;
          break;
        case "block-scalar":
          top.props.push(token);
          break;
        case "block-map": {
          const it = top.items[top.items.length - 1];
          if (it.value) {
            top.items.push({ start: [], key: token, sep: [] });
            this.onKeyLine = true;
            return;
          } else if (it.sep) {
            it.value = token;
          } else {
            Object.assign(it, { key: token, sep: [] });
            this.onKeyLine = !includesToken(it.start, "explicit-key-ind");
            return;
          }
          break;
        }
        case "block-seq": {
          const it = top.items[top.items.length - 1];
          if (it.value)
            top.items.push({ start: [], value: token });
          else
            it.value = token;
          break;
        }
        case "flow-collection": {
          const it = top.items[top.items.length - 1];
          if (!it || it.value)
            top.items.push({ start: [], key: token, sep: [] });
          else if (it.sep)
            it.value = token;
          else
            Object.assign(it, { key: token, sep: [] });
          return;
        }
        default:
          yield* this.pop();
          yield* this.pop(token);
      }
      if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
        const last = token.items[token.items.length - 1];
        if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
          if (top.type === "document")
            top.end = last.start;
          else
            top.items.push({ start: last.start });
          token.items.splice(-1, 1);
        }
      }
    }
  }
  *stream() {
    switch (this.type) {
      case "directive-line":
        yield { type: "directive", offset: this.offset, source: this.source };
        return;
      case "byte-order-mark":
      case "space":
      case "comment":
      case "newline":
        yield this.sourceToken;
        return;
      case "doc-mode":
      case "doc-start": {
        const doc = {
          type: "document",
          offset: this.offset,
          start: []
        };
        if (this.type === "doc-start")
          doc.start.push(this.sourceToken);
        this.stack.push(doc);
        return;
      }
    }
    yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML stream`,
      source: this.source
    };
  }
  *document(doc) {
    if (doc.value)
      return yield* this.lineEnd(doc);
    switch (this.type) {
      case "doc-start": {
        if (findNonEmptyIndex(doc.start) !== -1) {
          yield* this.pop();
          yield* this.step();
        } else
          doc.start.push(this.sourceToken);
        return;
      }
      case "anchor":
      case "tag":
      case "space":
      case "comment":
      case "newline":
        doc.start.push(this.sourceToken);
        return;
    }
    const bv = this.startBlockValue(doc);
    if (bv)
      this.stack.push(bv);
    else {
      yield {
        type: "error",
        offset: this.offset,
        message: `Unexpected ${this.type} token in YAML document`,
        source: this.source
      };
    }
  }
  *scalar(scalar) {
    if (this.type === "map-value-ind") {
      const prev = getPrevProps(this.peek(2));
      const start = getFirstKeyStartProps(prev);
      let sep2;
      if (scalar.end) {
        sep2 = scalar.end;
        sep2.push(this.sourceToken);
        delete scalar.end;
      } else
        sep2 = [this.sourceToken];
      const map3 = {
        type: "block-map",
        offset: scalar.offset,
        indent: scalar.indent,
        items: [{ start, key: scalar, sep: sep2 }]
      };
      this.onKeyLine = true;
      this.stack[this.stack.length - 1] = map3;
    } else
      yield* this.lineEnd(scalar);
  }
  *blockScalar(scalar) {
    switch (this.type) {
      case "space":
      case "comment":
      case "newline":
        scalar.props.push(this.sourceToken);
        return;
      case "scalar":
        scalar.source = this.source;
        this.atNewLine = true;
        this.indent = 0;
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        yield* this.pop();
        break;
      default:
        yield* this.pop();
        yield* this.step();
    }
  }
  *blockMap(map3) {
    var _a;
    const it = map3.items[map3.items.length - 1];
    switch (this.type) {
      case "newline":
        this.onKeyLine = false;
        if (it.value) {
          const end = "end" in it.value ? it.value.end : void 0;
          const last = Array.isArray(end) ? end[end.length - 1] : void 0;
          if ((last == null ? void 0 : last.type) === "comment")
            end == null ? void 0 : end.push(this.sourceToken);
          else
            map3.items.push({ start: [this.sourceToken] });
        } else if (it.sep) {
          it.sep.push(this.sourceToken);
        } else {
          it.start.push(this.sourceToken);
        }
        return;
      case "space":
      case "comment":
        if (it.value) {
          map3.items.push({ start: [this.sourceToken] });
        } else if (it.sep) {
          it.sep.push(this.sourceToken);
        } else {
          if (this.atIndentedComment(it.start, map3.indent)) {
            const prev = map3.items[map3.items.length - 2];
            const end = (_a = prev == null ? void 0 : prev.value) == null ? void 0 : _a.end;
            if (Array.isArray(end)) {
              Array.prototype.push.apply(end, it.start);
              end.push(this.sourceToken);
              map3.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
    }
    if (this.indent >= map3.indent) {
      const atNextItem = !this.onKeyLine && this.indent === map3.indent && it.sep;
      let start = [];
      if (atNextItem && it.sep && !it.value) {
        const nl = [];
        for (let i2 = 0; i2 < it.sep.length; ++i2) {
          const st = it.sep[i2];
          switch (st.type) {
            case "newline":
              nl.push(i2);
              break;
            case "space":
              break;
            case "comment":
              if (st.indent > map3.indent)
                nl.length = 0;
              break;
            default:
              nl.length = 0;
          }
        }
        if (nl.length >= 2)
          start = it.sep.splice(nl[1]);
      }
      switch (this.type) {
        case "anchor":
        case "tag":
          if (atNextItem || it.value) {
            start.push(this.sourceToken);
            map3.items.push({ start });
            this.onKeyLine = true;
          } else if (it.sep) {
            it.sep.push(this.sourceToken);
          } else {
            it.start.push(this.sourceToken);
          }
          return;
        case "explicit-key-ind":
          if (!it.sep && !includesToken(it.start, "explicit-key-ind")) {
            it.start.push(this.sourceToken);
          } else if (atNextItem || it.value) {
            start.push(this.sourceToken);
            map3.items.push({ start });
          } else {
            this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken] }]
            });
          }
          this.onKeyLine = true;
          return;
        case "map-value-ind":
          if (includesToken(it.start, "explicit-key-ind")) {
            if (!it.sep) {
              if (includesToken(it.start, "newline")) {
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              } else {
                const start2 = getFirstKeyStartProps(it.start);
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                });
              }
            } else if (it.value) {
              map3.items.push({ start: [], key: null, sep: [this.sourceToken] });
            } else if (includesToken(it.sep, "map-value-ind")) {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start, key: null, sep: [this.sourceToken] }]
              });
            } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
              const start2 = getFirstKeyStartProps(it.start);
              const key = it.key;
              const sep2 = it.sep;
              sep2.push(this.sourceToken);
              delete it.key, delete it.sep;
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: start2, key, sep: sep2 }]
              });
            } else if (start.length > 0) {
              it.sep = it.sep.concat(start, this.sourceToken);
            } else {
              it.sep.push(this.sourceToken);
            }
          } else {
            if (!it.sep) {
              Object.assign(it, { key: null, sep: [this.sourceToken] });
            } else if (it.value || atNextItem) {
              map3.items.push({ start, key: null, sep: [this.sourceToken] });
            } else if (includesToken(it.sep, "map-value-ind")) {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: [], key: null, sep: [this.sourceToken] }]
              });
            } else {
              it.sep.push(this.sourceToken);
            }
          }
          this.onKeyLine = true;
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs6 = this.flowScalar(this.type);
          if (atNextItem || it.value) {
            map3.items.push({ start, key: fs6, sep: [] });
            this.onKeyLine = true;
          } else if (it.sep) {
            this.stack.push(fs6);
          } else {
            Object.assign(it, { key: fs6, sep: [] });
            this.onKeyLine = true;
          }
          return;
        }
        default: {
          const bv = this.startBlockValue(map3);
          if (bv) {
            if (atNextItem && bv.type !== "block-seq" && includesToken(it.start, "explicit-key-ind")) {
              map3.items.push({ start });
            }
            this.stack.push(bv);
            return;
          }
        }
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *blockSequence(seq3) {
    var _a;
    const it = seq3.items[seq3.items.length - 1];
    switch (this.type) {
      case "newline":
        if (it.value) {
          const end = "end" in it.value ? it.value.end : void 0;
          const last = Array.isArray(end) ? end[end.length - 1] : void 0;
          if ((last == null ? void 0 : last.type) === "comment")
            end == null ? void 0 : end.push(this.sourceToken);
          else
            seq3.items.push({ start: [this.sourceToken] });
        } else
          it.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (it.value)
          seq3.items.push({ start: [this.sourceToken] });
        else {
          if (this.atIndentedComment(it.start, seq3.indent)) {
            const prev = seq3.items[seq3.items.length - 2];
            const end = (_a = prev == null ? void 0 : prev.value) == null ? void 0 : _a.end;
            if (Array.isArray(end)) {
              Array.prototype.push.apply(end, it.start);
              end.push(this.sourceToken);
              seq3.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
      case "anchor":
      case "tag":
        if (it.value || this.indent <= seq3.indent)
          break;
        it.start.push(this.sourceToken);
        return;
      case "seq-item-ind":
        if (this.indent !== seq3.indent)
          break;
        if (it.value || includesToken(it.start, "seq-item-ind"))
          seq3.items.push({ start: [this.sourceToken] });
        else
          it.start.push(this.sourceToken);
        return;
    }
    if (this.indent > seq3.indent) {
      const bv = this.startBlockValue(seq3);
      if (bv) {
        this.stack.push(bv);
        return;
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *flowCollection(fc) {
    const it = fc.items[fc.items.length - 1];
    if (this.type === "flow-error-end") {
      let top;
      do {
        yield* this.pop();
        top = this.peek(1);
      } while (top && top.type === "flow-collection");
    } else if (fc.end.length === 0) {
      switch (this.type) {
        case "comma":
        case "explicit-key-ind":
          if (!it || it.sep)
            fc.items.push({ start: [this.sourceToken] });
          else
            it.start.push(this.sourceToken);
          return;
        case "map-value-ind":
          if (!it || it.value)
            fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
          else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            Object.assign(it, { key: null, sep: [this.sourceToken] });
          return;
        case "space":
        case "comment":
        case "newline":
        case "anchor":
        case "tag":
          if (!it || it.value)
            fc.items.push({ start: [this.sourceToken] });
          else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            it.start.push(this.sourceToken);
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs6 = this.flowScalar(this.type);
          if (!it || it.value)
            fc.items.push({ start: [], key: fs6, sep: [] });
          else if (it.sep)
            this.stack.push(fs6);
          else
            Object.assign(it, { key: fs6, sep: [] });
          return;
        }
        case "flow-map-end":
        case "flow-seq-end":
          fc.end.push(this.sourceToken);
          return;
      }
      const bv = this.startBlockValue(fc);
      if (bv)
        this.stack.push(bv);
      else {
        yield* this.pop();
        yield* this.step();
      }
    } else {
      const parent = this.peek(2);
      if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
        yield* this.pop();
        yield* this.step();
      } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        fixFlowSeqItems(fc);
        const sep2 = fc.end.splice(1, fc.end.length);
        sep2.push(this.sourceToken);
        const map3 = {
          type: "block-map",
          offset: fc.offset,
          indent: fc.indent,
          items: [{ start, key: fc, sep: sep2 }]
        };
        this.onKeyLine = true;
        this.stack[this.stack.length - 1] = map3;
      } else {
        yield* this.lineEnd(fc);
      }
    }
  }
  flowScalar(type) {
    if (this.onNewLine) {
      let nl = this.source.indexOf("\n") + 1;
      while (nl !== 0) {
        this.onNewLine(this.offset + nl);
        nl = this.source.indexOf("\n", nl) + 1;
      }
    }
    return {
      type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  startBlockValue(parent) {
    switch (this.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return this.flowScalar(this.type);
      case "block-scalar-header":
        return {
          type: "block-scalar",
          offset: this.offset,
          indent: this.indent,
          props: [this.sourceToken],
          source: ""
        };
      case "flow-map-start":
      case "flow-seq-start":
        return {
          type: "flow-collection",
          offset: this.offset,
          indent: this.indent,
          start: this.sourceToken,
          items: [],
          end: []
        };
      case "seq-item-ind":
        return {
          type: "block-seq",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: [this.sourceToken] }]
        };
      case "explicit-key-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        start.push(this.sourceToken);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start }]
        };
      }
      case "map-value-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start, key: null, sep: [this.sourceToken] }]
        };
      }
    }
    return null;
  }
  atIndentedComment(start, indent) {
    if (this.type !== "comment")
      return false;
    if (this.indent <= indent)
      return false;
    return start.every((st) => st.type === "newline" || st.type === "space");
  }
  *documentEnd(docEnd) {
    if (this.type !== "doc-mode") {
      if (docEnd.end)
        docEnd.end.push(this.sourceToken);
      else
        docEnd.end = [this.sourceToken];
      if (this.type === "newline")
        yield* this.pop();
    }
  }
  *lineEnd(token) {
    switch (this.type) {
      case "comma":
      case "doc-start":
      case "doc-end":
      case "flow-seq-end":
      case "flow-map-end":
      case "map-value-ind":
        yield* this.pop();
        yield* this.step();
        break;
      case "newline":
        this.onKeyLine = false;
      case "space":
      case "comment":
      default:
        if (token.end)
          token.end.push(this.sourceToken);
        else
          token.end = [this.sourceToken];
        if (this.type === "newline")
          yield* this.pop();
    }
  }
};
function parseOptions(options3) {
  const prettyErrors = options3.prettyErrors !== false;
  const lineCounter = options3.lineCounter || prettyErrors && new LineCounter() || null;
  return { lineCounter, prettyErrors };
}
function parseAllDocuments(source, options3 = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options3);
  const parser2 = new Parser2(lineCounter == null ? void 0 : lineCounter.addNewLine);
  const composer = new Composer(options3);
  const docs = Array.from(composer.compose(parser2.parse(source)));
  if (prettyErrors && lineCounter)
    for (const doc of docs) {
      doc.errors.forEach(prettifyError(source, lineCounter));
      doc.warnings.forEach(prettifyError(source, lineCounter));
    }
  if (docs.length > 0)
    return docs;
  return Object.assign([], { empty: true }, composer.streamInfo());
}
function parseDocument(source, options3 = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options3);
  const parser2 = new Parser2(lineCounter == null ? void 0 : lineCounter.addNewLine);
  const composer = new Composer(options3);
  let doc = null;
  for (const _doc of composer.compose(parser2.parse(source), true, source.length)) {
    if (!doc)
      doc = _doc;
    else if (doc.options.logLevel !== "silent") {
      doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  }
  if (prettyErrors && lineCounter) {
    doc.errors.forEach(prettifyError(source, lineCounter));
    doc.warnings.forEach(prettifyError(source, lineCounter));
  }
  return doc;
}
function parse$a(src3, reviver, options3) {
  let _reviver = void 0;
  if (typeof reviver === "function") {
    _reviver = reviver;
  } else if (options3 === void 0 && reviver && typeof reviver === "object") {
    options3 = reviver;
  }
  const doc = parseDocument(src3, options3);
  if (!doc)
    return null;
  doc.warnings.forEach((warning) => warn2(doc.options.logLevel, warning));
  if (doc.errors.length > 0) {
    if (doc.options.logLevel !== "silent")
      throw doc.errors[0];
    else
      doc.errors = [];
  }
  return doc.toJS(Object.assign({ reviver: _reviver }, options3));
}
function stringify(value2, replacer, options3) {
  let _replacer = null;
  if (typeof replacer === "function" || Array.isArray(replacer)) {
    _replacer = replacer;
  } else if (options3 === void 0 && replacer) {
    options3 = replacer;
  }
  if (typeof options3 === "string")
    options3 = options3.length;
  if (typeof options3 === "number") {
    const indent = Math.round(options3);
    options3 = indent < 1 ? void 0 : indent > 8 ? { indent: 8 } : { indent };
  }
  if (value2 === void 0) {
    const { keepUndefined } = options3 ?? replacer ?? {};
    if (!keepUndefined)
      return void 0;
  }
  return new Document(value2, _replacer, options3).toString(options3);
}
var YAML = {
  __proto__: null,
  Alias,
  CST: cst,
  Composer,
  Document,
  Lexer,
  LineCounter,
  Pair,
  Parser: Parser2,
  Scalar,
  Schema,
  YAMLError,
  YAMLMap,
  YAMLParseError,
  YAMLSeq,
  YAMLWarning,
  isAlias,
  isCollection: isCollection$1,
  isDocument,
  isMap,
  isNode: isNode$1,
  isPair,
  isScalar: isScalar$1,
  isSeq,
  parse: parse$a,
  parseAllDocuments,
  parseDocument,
  stringify,
  visit: visit$1,
  visitAsync
};
var browser$1 = {
  __proto__: null,
  Alias,
  CST: cst,
  Composer,
  Document,
  Lexer,
  LineCounter,
  Pair,
  Parser: Parser2,
  Scalar,
  Schema,
  YAMLError,
  YAMLMap,
  YAMLParseError,
  YAMLSeq,
  YAMLWarning,
  default: YAML,
  isAlias,
  isCollection: isCollection$1,
  isDocument,
  isMap,
  isNode: isNode$1,
  isPair,
  isScalar: isScalar$1,
  isSeq,
  parse: parse$a,
  parseAllDocuments,
  parseDocument,
  stringify,
  visit: visit$1,
  visitAsync
};
var require$$3$1 = getAugmentedNamespace(browser$1);
var { createRequire, createRequireFromPath } = import_module.default;
function req$2(name2, rootFile) {
  const create = createRequire || createRequireFromPath;
  const require5 = create(rootFile);
  return require5(name2);
}
var req_1 = req$2;
var req$1 = req_1;
var options2 = (config2, file) => {
  if (config2.parser && typeof config2.parser === "string") {
    try {
      config2.parser = req$1(config2.parser, file);
    } catch (err2) {
      throw new Error(`Loading PostCSS Parser failed: ${err2.message}

(@${file})`);
    }
  }
  if (config2.syntax && typeof config2.syntax === "string") {
    try {
      config2.syntax = req$1(config2.syntax, file);
    } catch (err2) {
      throw new Error(`Loading PostCSS Syntax failed: ${err2.message}

(@${file})`);
    }
  }
  if (config2.stringifier && typeof config2.stringifier === "string") {
    try {
      config2.stringifier = req$1(config2.stringifier, file);
    } catch (err2) {
      throw new Error(`Loading PostCSS Stringifier failed: ${err2.message}

(@${file})`);
    }
  }
  if (config2.plugins) {
    delete config2.plugins;
  }
  return config2;
};
var options_1 = options2;
var req = req_1;
var load = (plugin, options3, file) => {
  try {
    if (options3 === null || options3 === void 0 || Object.keys(options3).length === 0) {
      return req(plugin, file);
    } else {
      return req(plugin, file)(options3);
    }
  } catch (err2) {
    throw new Error(`Loading PostCSS Plugin failed: ${err2.message}

(@${file})`);
  }
};
var plugins = (config2, file) => {
  let plugins2 = [];
  if (Array.isArray(config2.plugins)) {
    plugins2 = config2.plugins.filter(Boolean);
  } else {
    plugins2 = Object.keys(config2.plugins).filter((plugin) => {
      return config2.plugins[plugin] !== false ? plugin : "";
    }).map((plugin) => {
      return load(plugin, config2.plugins[plugin], file);
    });
  }
  if (plugins2.length && plugins2.length > 0) {
    plugins2.forEach((plugin, i2) => {
      if (plugin.default) {
        plugin = plugin.default;
      }
      if (plugin.postcss === true) {
        plugin = plugin();
      } else if (plugin.postcss) {
        plugin = plugin.postcss;
      }
      if (
        // eslint-disable-next-line
        !(typeof plugin === "object" && Array.isArray(plugin.plugins) || typeof plugin === "object" && plugin.postcssPlugin || typeof plugin === "function")
      ) {
        throw new TypeError(`Invalid PostCSS Plugin found at: plugins[${i2}]

(@${file})`);
      }
    });
  }
  return plugins2;
};
var plugins_1 = plugins;
var resolve2 = import_path.default.resolve;
var url$4 = import_url3.default;
var config$1 = dist;
var yaml2 = require$$3$1;
var loadOptions = options_1;
var loadPlugins = plugins_1;
var interopRequireDefault = (obj) => obj && obj.__esModule ? obj : { default: obj };
var processResult = (ctx2, result) => {
  const file = result.filepath || "";
  let config2 = interopRequireDefault(result.config).default || {};
  if (typeof config2 === "function") {
    config2 = config2(ctx2);
  } else {
    config2 = Object.assign({}, config2, ctx2);
  }
  if (!config2.plugins) {
    config2.plugins = [];
  }
  return {
    plugins: loadPlugins(config2, file),
    options: loadOptions(config2, file),
    file
  };
};
var createContext = (ctx2) => {
  ctx2 = Object.assign({
    cwd: process.cwd(),
    env: "development"
  }, ctx2);
  if (!ctx2.env) {
    process.env.NODE_ENV = "development";
  }
  return ctx2;
};
var importDefault = async (filepath) => {
  const module2 = await import(url$4.pathToFileURL(filepath).href);
  return module2.default;
};
var addTypeScriptLoader = (options3 = {}, loader) => {
  const moduleName = "postcss";
  return {
    ...options3,
    searchPlaces: [
      ...options3.searchPlaces || [],
      "package.json",
      `.${moduleName}rc`,
      `.${moduleName}rc.json`,
      `.${moduleName}rc.yaml`,
      `.${moduleName}rc.yml`,
      `.${moduleName}rc.ts`,
      `.${moduleName}rc.js`,
      `.${moduleName}rc.cjs`,
      `.${moduleName}rc.mjs`,
      `${moduleName}.config.ts`,
      `${moduleName}.config.js`,
      `${moduleName}.config.cjs`,
      `${moduleName}.config.mjs`
    ],
    loaders: {
      ...options3.loaders,
      ".yaml": (filepath, content) => yaml2.parse(content),
      ".yml": (filepath, content) => yaml2.parse(content),
      ".js": importDefault,
      ".cjs": importDefault,
      ".mjs": importDefault,
      ".ts": loader
    }
  };
};
var withTypeScriptLoader = (rcFunc) => {
  return (ctx, path, options) => {
    return rcFunc(ctx, path, addTypeScriptLoader(options, (configFile) => {
      let registerer = { enabled() {
      } };
      try {
        registerer = eval("require")("ts-node").register();
        return eval("require")(configFile);
      } catch (err2) {
        if (err2.code === "MODULE_NOT_FOUND") {
          throw new Error(
            `'ts-node' is required for the TypeScript configuration files. Make sure it is installed
Error: ${err2.message}`
          );
        }
        throw err2;
      } finally {
        registerer.enabled(false);
      }
    }));
  };
};
var rc = withTypeScriptLoader((ctx2, path8, options3) => {
  ctx2 = createContext(ctx2);
  path8 = path8 ? resolve2(path8) : process.cwd();
  return config$1.lilconfig("postcss", options3).search(path8).then((result) => {
    if (!result) {
      throw new Error(`No PostCSS Config found in: ${path8}`);
    }
    return processResult(ctx2, result);
  });
});
var src$1 = rc;
function stripLiteralAcorn(code) {
  const FILL = " ";
  let result = "";
  function fulfill(index2) {
    if (index2 > result.length)
      result += code.slice(result.length, index2).replace(/[^\n]/g, FILL);
  }
  const tokens = tokenizer2(code, {
    ecmaVersion: "latest",
    sourceType: "module",
    allowHashBang: true,
    allowAwaitOutsideFunction: true,
    allowImportExportEverywhere: true
  });
  const inter = tokens[Symbol.iterator]();
  while (true) {
    const { done, value: token } = inter.next();
    if (done)
      break;
    fulfill(token.start);
    if (token.type.label === "string")
      result += code[token.start] + FILL.repeat(token.end - token.start - 2) + code[token.end - 1];
    else if (token.type.label === "template")
      result += FILL.repeat(token.end - token.start);
    else
      result += code.slice(token.start, token.end);
  }
  fulfill(code.length);
  return result;
}
var multilineCommentsRE = /\/\*([^*\/])*?\*\//gms;
var singlelineCommentsRE = /(?:^|\n|\r)\s*\/\/.*(?:\r|\n|$)/gm;
var templateLiteralRE = /\$\{(\s*(?:(?!\$\{).|\n|\r)*?\s*)\}/g;
var quotesRE = [
  /(["'`])((?:\\\1|(?!\1)|.|\r)*?)\1/gm,
  /([`])((?:\\\1|(?!\1)|.|\n|\r)*?)\1/gm
  // multi-line strings (i.e. template literals only)
];
function stripLiteralRegex(code) {
  code = code.replace(multilineCommentsRE, (s2) => " ".repeat(s2.length)).replace(singlelineCommentsRE, (s2) => " ".repeat(s2.length));
  let expanded = code;
  for (let i2 = 0; i2 < 16; i2++) {
    const before = expanded;
    expanded = expanded.replace(templateLiteralRE, "` $1`");
    if (expanded === before)
      break;
  }
  quotesRE.forEach((re) => {
    expanded = expanded.replace(re, (s2, quote, body, index2) => {
      code = code.slice(0, index2 + 1) + " ".repeat(s2.length - 2) + code.slice(index2 + s2.length - 1);
      return quote + " ".repeat(s2.length - 2) + quote;
    });
  });
  return code;
}
function stripLiteral(code) {
  try {
    return stripLiteralAcorn(code);
  } catch (e3) {
    return stripLiteralRegex(code);
  }
}
var modulePreloadPolyfillId = "vite/modulepreload-polyfill";
var resolvedModulePreloadPolyfillId = "\0" + modulePreloadPolyfillId;
function modulePreloadPolyfillPlugin(config2) {
  const skip = config2.command !== "build" || config2.build.ssr;
  let polyfillString;
  return {
    name: "vite:modulepreload-polyfill",
    resolveId(id) {
      if (id === modulePreloadPolyfillId) {
        return resolvedModulePreloadPolyfillId;
      }
    },
    load(id) {
      if (id === resolvedModulePreloadPolyfillId) {
        if (skip) {
          return "";
        }
        if (!polyfillString) {
          polyfillString = `${isModernFlag}&&(${polyfill.toString()}());`;
        }
        return polyfillString;
      }
    }
  };
}
function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node3 of mutation.addedNodes) {
        if (node3.tagName === "LINK" && node3.rel === "modulepreload")
          processPreload(node3);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity)
      fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy)
      fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
}
var htmlProxyRE$1 = /\?html-proxy=?(?:&inline-css)?&index=(\d+)\.(js|css)$/;
var inlineCSSRE$1 = /__VITE_INLINE_CSS__([a-z\d]{8}_\d+)__/g;
var inlineImportRE = new RegExp(`(?<!(?<!\\.\\.)\\.)\\bimport\\s*\\(("(?:[^"]|(?<=\\\\)")*"|'(?:[^']|(?<=\\\\)')*')\\)`, "g");
var htmlLangRE = /\.(?:html|htm)$/;
var importMapRE = /[ \t]*<script[^>]*type\s*=\s*(?:"importmap"|'importmap'|importmap)[^>]*>.*?<\/script>/is;
var moduleScriptRE = /[ \t]*<script[^>]*type\s*=\s*(?:"module"|'module'|module)[^>]*>/i;
var modulePreloadLinkRE = /[ \t]*<link[^>]*rel\s*=\s*(?:"modulepreload"|'modulepreload'|modulepreload)[\s\S]*?\/>/i;
var importMapAppendRE = new RegExp([moduleScriptRE, modulePreloadLinkRE].map((r3) => r3.source).join("|"), "i");
var isHTMLProxy = (id) => htmlProxyRE$1.test(id);
var isHTMLRequest = (request) => htmlLangRE.test(request);
var htmlProxyMap = /* @__PURE__ */ new WeakMap();
var htmlProxyResult = /* @__PURE__ */ new Map();
function htmlInlineProxyPlugin(config2) {
  htmlProxyMap.set(config2, /* @__PURE__ */ new Map());
  return {
    name: "vite:html-inline-proxy",
    resolveId(id) {
      if (htmlProxyRE$1.test(id)) {
        return id;
      }
    },
    load(id) {
      const proxyMatch = id.match(htmlProxyRE$1);
      if (proxyMatch) {
        const index2 = Number(proxyMatch[1]);
        const file = cleanUrl(id);
        const url2 = file.replace(normalizePath$3(config2.root), "");
        const result = htmlProxyMap.get(config2).get(url2)[index2];
        if (result) {
          return result;
        } else {
          throw new Error(`No matching HTML proxy module found from ${id}`);
        }
      }
    }
  };
}
function addToHTMLProxyCache(config2, filePath, index2, result) {
  if (!htmlProxyMap.get(config2)) {
    htmlProxyMap.set(config2, /* @__PURE__ */ new Map());
  }
  if (!htmlProxyMap.get(config2).get(filePath)) {
    htmlProxyMap.get(config2).set(filePath, []);
  }
  htmlProxyMap.get(config2).get(filePath)[index2] = result;
}
function addToHTMLProxyTransformResult(hash2, code) {
  htmlProxyResult.set(hash2, code);
}
var assetAttrsConfig = {
  link: ["href"],
  video: ["src", "poster"],
  source: ["src", "srcset"],
  img: ["src", "srcset"],
  image: ["xlink:href", "href"],
  use: ["xlink:href", "href"]
};
var isAsyncScriptMap = /* @__PURE__ */ new WeakMap();
function nodeIsElement(node3) {
  return node3.nodeName[0] !== "#";
}
function traverseNodes(node3, visitor) {
  visitor(node3);
  if (nodeIsElement(node3) || node3.nodeName === "#document" || node3.nodeName === "#document-fragment") {
    node3.childNodes.forEach((childNode) => traverseNodes(childNode, visitor));
  }
}
async function traverseHtml(html, filePath, visitor) {
  const { parse: parse7 } = await import("./dep-98d07f71-RHLVRLWI.js");
  const ast = parse7(html, {
    scriptingEnabled: false,
    sourceCodeLocationInfo: true,
    onParseError: (e3) => {
      handleParseError(e3, html, filePath);
    }
  });
  traverseNodes(ast, visitor);
}
function getScriptInfo(node3) {
  var _a;
  let src3;
  let sourceCodeLocation;
  let isModule = false;
  let isAsync = false;
  for (const p2 of node3.attrs) {
    if (p2.prefix !== void 0)
      continue;
    if (p2.name === "src") {
      if (!src3) {
        src3 = p2;
        sourceCodeLocation = (_a = node3.sourceCodeLocation) == null ? void 0 : _a.attrs["src"];
      }
    } else if (p2.name === "type" && p2.value && p2.value === "module") {
      isModule = true;
    } else if (p2.name === "async") {
      isAsync = true;
    }
  }
  return { src: src3, sourceCodeLocation, isModule, isAsync };
}
var attrValueStartRE = /=\s*(.)/;
function overwriteAttrValue(s2, sourceCodeLocation, newValue) {
  const srcString = s2.slice(sourceCodeLocation.startOffset, sourceCodeLocation.endOffset);
  const valueStart = srcString.match(attrValueStartRE);
  if (!valueStart) {
    throw new Error(`[vite:html] internal error, failed to overwrite attribute value`);
  }
  const wrapOffset = valueStart[1] === '"' || valueStart[1] === "'" ? 1 : 0;
  const valueOffset = valueStart.index + valueStart[0].length - 1;
  s2.update(sourceCodeLocation.startOffset + valueOffset + wrapOffset, sourceCodeLocation.endOffset - wrapOffset, newValue);
  return s2;
}
function formatParseError(parserError, id, html) {
  const formattedError = {
    code: parserError.code,
    message: `parse5 error code ${parserError.code}`,
    frame: generateCodeFrame(html, parserError.startOffset),
    loc: {
      file: id,
      line: parserError.startLine,
      column: parserError.startCol
    }
  };
  return formattedError;
}
function handleParseError(parserError, html, filePath) {
  switch (parserError.code) {
    case "missing-doctype":
      return;
    case "abandoned-head-element-child":
      return;
    case "duplicate-attribute":
      return;
    case "non-void-html-element-start-tag-with-trailing-solidus":
      return;
  }
  const parseError = formatParseError(parserError, filePath, html);
  throw new Error(`Unable to parse HTML; ${parseError.message}
 at ${parseError.loc.file}:${parseError.loc.line}:${parseError.loc.column}
${parseError.frame}`);
}
function buildHtmlPlugin(config2) {
  const [preHooks, normalHooks, postHooks] = resolveHtmlTransforms(config2.plugins);
  preHooks.unshift(preImportMapHook(config2));
  postHooks.push(postImportMapHook());
  const processedHtml = /* @__PURE__ */ new Map();
  const isExcludedUrl = (url2) => url2.startsWith("#") || isExternalUrl(url2) || isDataUrl(url2) || checkPublicFile(url2, config2);
  isAsyncScriptMap.set(config2, /* @__PURE__ */ new Map());
  return {
    name: "vite:build-html",
    async transform(html, id) {
      var _a, _b;
      if (id.endsWith(".html")) {
        const relativeUrlPath = import_node_path4.default.posix.relative(config2.root, normalizePath$3(id));
        const publicPath = `/${relativeUrlPath}`;
        const publicBase = getBaseInHTML(relativeUrlPath, config2);
        const publicToRelative = (filename, importer) => publicBase + filename;
        const toOutputPublicFilePath = (url2) => toOutputFilePathInHtml(url2.slice(1), "public", relativeUrlPath, "html", config2, publicToRelative);
        html = await applyHtmlTransforms(html, preHooks, {
          path: publicPath,
          filename: id
        });
        let js = "";
        const s2 = new MagicString(html);
        const assetUrls = [];
        const scriptUrls = [];
        const styleUrls = [];
        let inlineModuleIndex = -1;
        let everyScriptIsAsync = true;
        let someScriptsAreAsync = false;
        let someScriptsAreDefer = false;
        await traverseHtml(html, id, (node3) => {
          if (!nodeIsElement(node3)) {
            return;
          }
          let shouldRemove = false;
          if (node3.nodeName === "script") {
            const { src: src3, sourceCodeLocation, isModule, isAsync } = getScriptInfo(node3);
            const url2 = src3 && src3.value;
            const isPublicFile = !!(url2 && checkPublicFile(url2, config2));
            if (isPublicFile) {
              overwriteAttrValue(s2, sourceCodeLocation, toOutputPublicFilePath(url2));
            }
            if (isModule) {
              inlineModuleIndex++;
              if (url2 && !isExcludedUrl(url2)) {
                js += `
import ${JSON.stringify(url2)}`;
                shouldRemove = true;
              } else if (node3.childNodes.length) {
                const scriptNode = node3.childNodes.pop();
                const contents = scriptNode.value;
                const filePath = id.replace(normalizePath$3(config2.root), "");
                addToHTMLProxyCache(config2, filePath, inlineModuleIndex, {
                  code: contents
                });
                js += `
import "${id}?html-proxy&index=${inlineModuleIndex}.js"`;
                shouldRemove = true;
              }
              everyScriptIsAsync && (everyScriptIsAsync = isAsync);
              someScriptsAreAsync || (someScriptsAreAsync = isAsync);
              someScriptsAreDefer || (someScriptsAreDefer = !isAsync);
            } else if (url2 && !isPublicFile) {
              if (!isExcludedUrl(url2)) {
                config2.logger.warn(`<script src="${url2}"> in "${publicPath}" can't be bundled without type="module" attribute`);
              }
            } else if (node3.childNodes.length) {
              const scriptNode = node3.childNodes.pop();
              const cleanCode = stripLiteral(scriptNode.value);
              let match;
              inlineImportRE.lastIndex = 0;
              while (match = inlineImportRE.exec(cleanCode)) {
                const { 1: url3, index: index2 } = match;
                const startUrl = cleanCode.indexOf(url3, index2);
                const start = startUrl + 1;
                const end = start + url3.length - 2;
                const startOffset = scriptNode.sourceCodeLocation.startOffset;
                scriptUrls.push({
                  start: start + startOffset,
                  end: end + startOffset,
                  url: scriptNode.value.slice(start, end)
                });
              }
            }
          }
          const assetAttrs = assetAttrsConfig[node3.nodeName];
          if (assetAttrs) {
            for (const p2 of node3.attrs) {
              const attrKey = getAttrKey(p2);
              if (p2.value && assetAttrs.includes(attrKey)) {
                const attrSourceCodeLocation = node3.sourceCodeLocation.attrs[attrKey];
                const url2 = decodeURI(p2.value);
                if (!isExcludedUrl(url2)) {
                  if (node3.nodeName === "link" && isCSSRequest(url2) && // should not be converted if following attributes are present (#6748)
                  !node3.attrs.some((p3) => p3.prefix === void 0 && (p3.name === "media" || p3.name === "disabled"))) {
                    const importExpression = `
import ${JSON.stringify(url2)}`;
                    styleUrls.push({
                      url: url2,
                      start: node3.sourceCodeLocation.startOffset,
                      end: node3.sourceCodeLocation.endOffset
                    });
                    js += importExpression;
                  } else {
                    assetUrls.push({
                      attr: p2,
                      sourceCodeLocation: attrSourceCodeLocation
                    });
                  }
                } else if (checkPublicFile(url2, config2)) {
                  overwriteAttrValue(s2, attrSourceCodeLocation, toOutputPublicFilePath(url2));
                }
              }
            }
          }
          const inlineStyle = node3.attrs.find((prop) => prop.prefix === void 0 && prop.name === "style" && prop.value.includes("url("));
          if (inlineStyle) {
            inlineModuleIndex++;
            const code = inlineStyle.value;
            const filePath = id.replace(normalizePath$3(config2.root), "");
            addToHTMLProxyCache(config2, filePath, inlineModuleIndex, { code });
            js += `
import "${id}?html-proxy&inline-css&index=${inlineModuleIndex}.css"`;
            const hash2 = getHash(cleanUrl(id));
            const sourceCodeLocation = node3.sourceCodeLocation.attrs["style"];
            overwriteAttrValue(s2, sourceCodeLocation, `__VITE_INLINE_CSS__${hash2}_${inlineModuleIndex}__`);
          }
          if (node3.nodeName === "style" && node3.childNodes.length) {
            const styleNode = node3.childNodes.pop();
            const filePath = id.replace(normalizePath$3(config2.root), "");
            inlineModuleIndex++;
            addToHTMLProxyCache(config2, filePath, inlineModuleIndex, {
              code: styleNode.value
            });
            js += `
import "${id}?html-proxy&inline-css&index=${inlineModuleIndex}.css"`;
            const hash2 = getHash(cleanUrl(id));
            s2.update(styleNode.sourceCodeLocation.startOffset, styleNode.sourceCodeLocation.endOffset, `__VITE_INLINE_CSS__${hash2}_${inlineModuleIndex}__`);
          }
          if (shouldRemove) {
            s2.remove(node3.sourceCodeLocation.startOffset, node3.sourceCodeLocation.endOffset);
          }
        });
        isAsyncScriptMap.get(config2).set(id, everyScriptIsAsync);
        if (someScriptsAreAsync && someScriptsAreDefer) {
          config2.logger.warn(`
Mixed async and defer script modules in ${id}, output script will fallback to defer. Every script, including inline ones, need to be marked as async for your output script to be async.`);
        }
        const namedOutput = Object.keys(((_b = (_a = config2 == null ? void 0 : config2.build) == null ? void 0 : _a.rollupOptions) == null ? void 0 : _b.input) || {});
        for (const { attr, sourceCodeLocation } of assetUrls) {
          const content = decodeURI(attr.value);
          if (content !== "" && // Empty attribute
          !namedOutput.includes(content) && // Direct reference to named output
          !namedOutput.includes(content.replace(/^\//, ""))) {
            try {
              const url2 = attr.prefix === void 0 && attr.name === "srcset" ? await processSrcSet(content, ({ url: url3 }) => urlToBuiltUrl(url3, id, config2, this)) : await urlToBuiltUrl(content, id, config2, this);
              overwriteAttrValue(s2, sourceCodeLocation, url2);
            } catch (e3) {
              if (e3.code !== "ENOENT") {
                throw e3;
              }
            }
          }
        }
        for (const { start, end, url: url2 } of scriptUrls) {
          if (!isExcludedUrl(url2)) {
            s2.update(start, end, await urlToBuiltUrl(url2, id, config2, this));
          } else if (checkPublicFile(url2, config2)) {
            s2.update(start, end, toOutputPublicFilePath(url2));
          }
        }
        const resolvedStyleUrls = await Promise.all(styleUrls.map(async (styleUrl) => ({
          ...styleUrl,
          resolved: await this.resolve(styleUrl.url, id)
        })));
        for (const { start, end, url: url2, resolved } of resolvedStyleUrls) {
          if (resolved == null) {
            config2.logger.warnOnce(`
${url2} doesn't exist at build time, it will remain unchanged to be resolved at runtime`);
            const importExpression = `
import ${JSON.stringify(url2)}`;
            js = js.replace(importExpression, "");
          } else {
            s2.remove(start, end);
          }
        }
        processedHtml.set(id, s2.toString());
        const { modulePreload } = config2.build;
        if ((modulePreload === true || typeof modulePreload === "object" && modulePreload.polyfill) && (someScriptsAreAsync || someScriptsAreDefer)) {
          js = `import "${modulePreloadPolyfillId}";
${js}`;
        }
        return js;
      }
    },
    async generateBundle(options3, bundle) {
      const analyzedChunk = /* @__PURE__ */ new Map();
      const getImportedChunks = (chunk, seen2 = /* @__PURE__ */ new Set()) => {
        const chunks = [];
        chunk.imports.forEach((file) => {
          const importee = bundle[file];
          if ((importee == null ? void 0 : importee.type) === "chunk" && !seen2.has(file)) {
            seen2.add(file);
            chunks.push(...getImportedChunks(importee, seen2));
            chunks.push(importee);
          }
        });
        return chunks;
      };
      const toScriptTag = (chunk, toOutputPath, isAsync) => ({
        tag: "script",
        attrs: {
          ...isAsync ? { async: true } : {},
          type: "module",
          crossorigin: true,
          src: toOutputPath(chunk.fileName)
        }
      });
      const toPreloadTag = (filename, toOutputPath) => ({
        tag: "link",
        attrs: {
          rel: "modulepreload",
          crossorigin: true,
          href: toOutputPath(filename)
        }
      });
      const getCssTagsForChunk = (chunk, toOutputPath, seen2 = /* @__PURE__ */ new Set()) => {
        const tags = [];
        if (!analyzedChunk.has(chunk)) {
          analyzedChunk.set(chunk, 1);
          chunk.imports.forEach((file) => {
            const importee = bundle[file];
            if ((importee == null ? void 0 : importee.type) === "chunk") {
              tags.push(...getCssTagsForChunk(importee, toOutputPath, seen2));
            }
          });
        }
        chunk.viteMetadata.importedCss.forEach((file) => {
          if (!seen2.has(file)) {
            seen2.add(file);
            tags.push({
              tag: "link",
              attrs: {
                rel: "stylesheet",
                href: toOutputPath(file)
              }
            });
          }
        });
        return tags;
      };
      for (const [id, html] of processedHtml) {
        const relativeUrlPath = import_node_path4.default.posix.relative(config2.root, normalizePath$3(id));
        const assetsBase = getBaseInHTML(relativeUrlPath, config2);
        const toOutputFilePath = (filename, type) => {
          if (isExternalUrl(filename)) {
            return filename;
          } else {
            return toOutputFilePathInHtml(filename, type, relativeUrlPath, "html", config2, (filename2, importer) => assetsBase + filename2);
          }
        };
        const toOutputAssetFilePath = (filename) => toOutputFilePath(filename, "asset");
        const toOutputPublicAssetFilePath = (filename) => toOutputFilePath(filename, "public");
        const isAsync = isAsyncScriptMap.get(config2).get(id);
        let result = html;
        const chunk = Object.values(bundle).find((chunk2) => chunk2.type === "chunk" && chunk2.isEntry && chunk2.facadeModuleId === id);
        let canInlineEntry = false;
        if (chunk) {
          if (options3.format === "es" && isEntirelyImport(chunk.code)) {
            canInlineEntry = true;
          }
          const imports = getImportedChunks(chunk);
          let assetTags;
          if (canInlineEntry) {
            assetTags = imports.map((chunk2) => toScriptTag(chunk2, toOutputAssetFilePath, isAsync));
          } else {
            assetTags = [toScriptTag(chunk, toOutputAssetFilePath, isAsync)];
            const { modulePreload } = config2.build;
            if (modulePreload !== false) {
              const resolveDependencies = typeof modulePreload === "object" && modulePreload.resolveDependencies;
              const importsFileNames = imports.map((chunk2) => chunk2.fileName);
              const resolvedDeps = resolveDependencies ? resolveDependencies(chunk.fileName, importsFileNames, {
                hostId: relativeUrlPath,
                hostType: "html"
              }) : importsFileNames;
              assetTags.push(...resolvedDeps.map((i2) => toPreloadTag(i2, toOutputAssetFilePath)));
            }
          }
          assetTags.push(...getCssTagsForChunk(chunk, toOutputAssetFilePath));
          result = injectToHead(result, assetTags);
        }
        if (!config2.build.cssCodeSplit) {
          const cssChunk = Object.values(bundle).find((chunk2) => chunk2.type === "asset" && chunk2.name === "style.css");
          if (cssChunk) {
            result = injectToHead(result, [
              {
                tag: "link",
                attrs: {
                  rel: "stylesheet",
                  href: toOutputAssetFilePath(cssChunk.fileName)
                }
              }
            ]);
          }
        }
        let match;
        let s2;
        inlineCSSRE$1.lastIndex = 0;
        while (match = inlineCSSRE$1.exec(result)) {
          s2 || (s2 = new MagicString(result));
          const { 0: full, 1: scopedName } = match;
          const cssTransformedCode = htmlProxyResult.get(scopedName);
          s2.update(match.index, match.index + full.length, cssTransformedCode);
        }
        if (s2) {
          result = s2.toString();
        }
        result = await applyHtmlTransforms(result, [...normalHooks, ...postHooks], {
          path: "/" + relativeUrlPath,
          filename: id,
          bundle,
          chunk
        });
        result = result.replace(assetUrlRE, (_, fileHash, postfix = "") => {
          return toOutputAssetFilePath(this.getFileName(fileHash)) + postfix;
        });
        result = result.replace(publicAssetUrlRE, (_, fileHash) => {
          return normalizePath$3(toOutputPublicAssetFilePath(getPublicAssetFilename(fileHash, config2)));
        });
        if (chunk && canInlineEntry) {
          delete bundle[chunk.fileName];
        }
        const shortEmitName = normalizePath$3(import_node_path4.default.relative(config2.root, id));
        this.emitFile({
          type: "asset",
          fileName: shortEmitName,
          source: result
        });
      }
    }
  };
}
function preImportMapHook(config2) {
  return (html, ctx2) => {
    var _a, _b;
    const importMapIndex = (_a = html.match(importMapRE)) == null ? void 0 : _a.index;
    if (importMapIndex === void 0)
      return;
    const importMapAppendIndex = (_b = html.match(importMapAppendRE)) == null ? void 0 : _b.index;
    if (importMapAppendIndex === void 0)
      return;
    if (importMapAppendIndex < importMapIndex) {
      const relativeHtml = normalizePath$3(import_node_path4.default.relative(config2.root, ctx2.filename));
      config2.logger.warnOnce(picocolorsExports.yellow(picocolorsExports.bold(`(!) <script type="importmap"> should come before <script type="module"> and <link rel="modulepreload"> in /${relativeHtml}`)));
    }
  };
}
function postImportMapHook() {
  return (html) => {
    if (!importMapAppendRE.test(html))
      return;
    let importMap;
    html = html.replace(importMapRE, (match) => {
      importMap = match;
      return "";
    });
    if (importMap) {
      html = html.replace(importMapAppendRE, (match) => `${importMap}
${match}`);
    }
    return html;
  };
}
function resolveHtmlTransforms(plugins2) {
  const preHooks = [];
  const normalHooks = [];
  const postHooks = [];
  for (const plugin of plugins2) {
    const hook = plugin.transformIndexHtml;
    if (!hook)
      continue;
    if (typeof hook === "function") {
      normalHooks.push(hook);
    } else {
      const order = hook.order ?? (hook.enforce === "pre" ? "pre" : void 0);
      const handler = hook.handler ?? hook.transform;
      if (order === "pre") {
        preHooks.push(handler);
      } else if (order === "post") {
        postHooks.push(handler);
      } else {
        normalHooks.push(handler);
      }
    }
  }
  return [preHooks, normalHooks, postHooks];
}
async function applyHtmlTransforms(html, hooks, ctx2) {
  for (const hook of hooks) {
    const res = await hook(html, ctx2);
    if (!res) {
      continue;
    }
    if (typeof res === "string") {
      html = res;
    } else {
      let tags;
      if (Array.isArray(res)) {
        tags = res;
      } else {
        html = res.html || html;
        tags = res.tags;
      }
      const headTags = [];
      const headPrependTags = [];
      const bodyTags = [];
      const bodyPrependTags = [];
      for (const tag of tags) {
        if (tag.injectTo === "body") {
          bodyTags.push(tag);
        } else if (tag.injectTo === "body-prepend") {
          bodyPrependTags.push(tag);
        } else if (tag.injectTo === "head") {
          headTags.push(tag);
        } else {
          headPrependTags.push(tag);
        }
      }
      html = injectToHead(html, headPrependTags, true);
      html = injectToHead(html, headTags);
      html = injectToBody(html, bodyPrependTags, true);
      html = injectToBody(html, bodyTags);
    }
  }
  return html;
}
var importRE = /\bimport\s*("[^"]*[^\\]"|'[^']*[^\\]');*/g;
var commentRE$1 = /\/\*[\s\S]*?\*\/|\/\/.*$/gm;
function isEntirelyImport(code) {
  return !code.replace(importRE, "").replace(commentRE$1, "").trim().length;
}
function getBaseInHTML(urlRelativePath, config2) {
  return config2.base === "./" || config2.base === "" ? import_node_path4.default.posix.join(import_node_path4.default.posix.relative(urlRelativePath, "").slice(0, -2), "./") : config2.base;
}
var headInjectRE = /([ \t]*)<\/head>/i;
var headPrependInjectRE = /([ \t]*)<head[^>]*>/i;
var htmlInjectRE = /<\/html>/i;
var htmlPrependInjectRE = /([ \t]*)<html[^>]*>/i;
var bodyInjectRE = /([ \t]*)<\/body>/i;
var bodyPrependInjectRE = /([ \t]*)<body[^>]*>/i;
var doctypePrependInjectRE = /<!doctype html>/i;
function injectToHead(html, tags, prepend = false) {
  if (tags.length === 0)
    return html;
  if (prepend) {
    if (headPrependInjectRE.test(html)) {
      return html.replace(headPrependInjectRE, (match, p1) => `${match}
${serializeTags(tags, incrementIndent(p1))}`);
    }
  } else {
    if (headInjectRE.test(html)) {
      return html.replace(headInjectRE, (match, p1) => `${serializeTags(tags, incrementIndent(p1))}${match}`);
    }
    if (bodyPrependInjectRE.test(html)) {
      return html.replace(bodyPrependInjectRE, (match, p1) => `${serializeTags(tags, p1)}
${match}`);
    }
  }
  return prependInjectFallback(html, tags);
}
function injectToBody(html, tags, prepend = false) {
  if (tags.length === 0)
    return html;
  if (prepend) {
    if (bodyPrependInjectRE.test(html)) {
      return html.replace(bodyPrependInjectRE, (match, p1) => `${match}
${serializeTags(tags, incrementIndent(p1))}`);
    }
    if (headInjectRE.test(html)) {
      return html.replace(headInjectRE, (match, p1) => `${match}
${serializeTags(tags, p1)}`);
    }
    return prependInjectFallback(html, tags);
  } else {
    if (bodyInjectRE.test(html)) {
      return html.replace(bodyInjectRE, (match, p1) => `${serializeTags(tags, incrementIndent(p1))}${match}`);
    }
    if (htmlInjectRE.test(html)) {
      return html.replace(htmlInjectRE, `${serializeTags(tags)}
$&`);
    }
    return html + `
` + serializeTags(tags);
  }
}
function prependInjectFallback(html, tags) {
  if (htmlPrependInjectRE.test(html)) {
    return html.replace(htmlPrependInjectRE, `$&
${serializeTags(tags)}`);
  }
  if (doctypePrependInjectRE.test(html)) {
    return html.replace(doctypePrependInjectRE, `$&
${serializeTags(tags)}`);
  }
  return serializeTags(tags) + html;
}
var unaryTags = /* @__PURE__ */ new Set(["link", "meta", "base"]);
function serializeTag({ tag, attrs, children }, indent = "") {
  if (unaryTags.has(tag)) {
    return `<${tag}${serializeAttrs(attrs)}>`;
  } else {
    return `<${tag}${serializeAttrs(attrs)}>${serializeTags(children, incrementIndent(indent))}</${tag}>`;
  }
}
function serializeTags(tags, indent = "") {
  if (typeof tags === "string") {
    return tags;
  } else if (tags && tags.length) {
    return tags.map((tag) => `${indent}${serializeTag(tag, indent)}
`).join("");
  }
  return "";
}
function serializeAttrs(attrs) {
  let res = "";
  for (const key in attrs) {
    if (typeof attrs[key] === "boolean") {
      res += attrs[key] ? ` ${key}` : ``;
    } else {
      res += ` ${key}=${JSON.stringify(attrs[key])}`;
    }
  }
  return res;
}
function incrementIndent(indent = "") {
  return `${indent}${indent[0] === "	" ? "	" : "  "}`;
}
function getAttrKey(attr) {
  return attr.prefix === void 0 ? attr.name : `${attr.prefix}:${attr.name}`;
}
var cssModuleRE = new RegExp(`\\.module${CSS_LANGS_RE.source}`);
var directRequestRE = /(?:\?|&)direct\b/;
var htmlProxyRE = /(?:\?|&)html-proxy\b/;
var commonjsProxyRE = /\?commonjs-proxy/;
var inlineRE = /(?:\?|&)inline\b/;
var inlineCSSRE = /(?:\?|&)inline-css\b/;
var usedRE = /(?:\?|&)used\b/;
var varRE = /^var\(/i;
var cssBundleName = "style.css";
var isCSSRequest = (request) => CSS_LANGS_RE.test(request);
var isModuleCSSRequest = (request) => cssModuleRE.test(request);
var isDirectCSSRequest = (request) => CSS_LANGS_RE.test(request) && directRequestRE.test(request);
var isDirectRequest = (request) => directRequestRE.test(request);
var cssModulesCache = /* @__PURE__ */ new WeakMap();
var removedPureCssFilesCache = /* @__PURE__ */ new WeakMap();
var postcssConfigCache = {};
function encodePublicUrlsInCSS(config2) {
  return config2.command === "build";
}
function cssPlugin(config2) {
  let server2;
  let moduleCache;
  const resolveUrl = config2.createResolver({
    preferRelative: true,
    tryIndex: false,
    extensions: []
  });
  return {
    name: "vite:css",
    configureServer(_server) {
      server2 = _server;
    },
    buildStart() {
      moduleCache = /* @__PURE__ */ new Map();
      cssModulesCache.set(config2, moduleCache);
      removedPureCssFilesCache.set(config2, /* @__PURE__ */ new Map());
    },
    async transform(raw, id, options3) {
      var _a;
      if (!isCSSRequest(id) || commonjsProxyRE.test(id) || SPECIAL_QUERY_RE.test(id)) {
        return;
      }
      const ssr = (options3 == null ? void 0 : options3.ssr) === true;
      const urlReplacer = async (url2, importer) => {
        if (checkPublicFile(url2, config2)) {
          if (encodePublicUrlsInCSS(config2)) {
            return publicFileToBuiltUrl(url2, config2);
          } else {
            return joinUrlSegments(config2.base, url2);
          }
        }
        const resolved = await resolveUrl(url2, importer);
        if (resolved) {
          return fileToUrl(resolved, config2, this);
        }
        if (config2.command === "build") {
          config2.logger.warnOnce(`
${url2} referenced in ${id} didn't resolve at build time, it will remain unchanged to be resolved at runtime`);
        }
        return url2;
      };
      const { code: css, modules, deps, map: map3 } = await compileCSS(id, raw, config2, urlReplacer);
      if (modules) {
        moduleCache.set(id, modules);
      }
      if (config2.command === "build" && config2.build.watch && deps) {
        for (const file of deps) {
          this.addWatchFile(file);
        }
      }
      if (server2) {
        const { moduleGraph } = server2;
        const thisModule = moduleGraph.getModuleById(id);
        if (thisModule) {
          const isSelfAccepting = !modules && !inlineRE.test(id) && !htmlProxyRE.test(id);
          if (deps) {
            const depModules = /* @__PURE__ */ new Set();
            const devBase = config2.base;
            for (const file of deps) {
              depModules.add(isCSSRequest(file) ? moduleGraph.createFileOnlyEntry(file) : await moduleGraph.ensureEntryFromUrl(stripBase(await fileToUrl(file, config2, this), (((_a = config2.server) == null ? void 0 : _a.origin) ?? "") + devBase), ssr));
            }
            moduleGraph.updateModuleInfo(
              thisModule,
              depModules,
              null,
              // The root CSS proxy module is self-accepting and should not
              // have an explicit accept list
              /* @__PURE__ */ new Set(),
              null,
              isSelfAccepting,
              ssr
            );
            for (const file of deps) {
              this.addWatchFile(file);
            }
          } else {
            thisModule.isSelfAccepting = isSelfAccepting;
          }
        }
      }
      return {
        code: css,
        map: map3
      };
    }
  };
}
function cssPostPlugin(config2) {
  var _a;
  const styles3 = /* @__PURE__ */ new Map();
  let pureCssChunks;
  let outputToExtractedCSSMap;
  let hasEmitted = false;
  const rollupOptionsOutput = config2.build.rollupOptions.output;
  const assetFileNames = (_a = Array.isArray(rollupOptionsOutput) ? rollupOptionsOutput[0] : rollupOptionsOutput) == null ? void 0 : _a.assetFileNames;
  const getCssAssetDirname = (cssAssetName) => {
    if (!assetFileNames) {
      return config2.build.assetsDir;
    } else if (typeof assetFileNames === "string") {
      return import_node_path4.default.dirname(assetFileNames);
    } else {
      return import_node_path4.default.dirname(assetFileNames({
        name: cssAssetName,
        type: "asset",
        source: "/* vite internal call, ignore */"
      }));
    }
  };
  return {
    name: "vite:css-post",
    buildStart() {
      pureCssChunks = /* @__PURE__ */ new Set();
      outputToExtractedCSSMap = /* @__PURE__ */ new Map();
      hasEmitted = false;
    },
    async transform(css, id, options3) {
      if (!isCSSRequest(id) || commonjsProxyRE.test(id) || SPECIAL_QUERY_RE.test(id)) {
        return;
      }
      css = stripBomTag(css);
      const inlined = inlineRE.test(id);
      const modules = cssModulesCache.get(config2).get(id);
      const modulesCode = modules && !inlined && dataToEsm(modules, { namedExports: true, preferConst: true });
      if (config2.command === "serve") {
        const getContentWithSourcemap = async (content) => {
          var _a2;
          if ((_a2 = config2.css) == null ? void 0 : _a2.devSourcemap) {
            const sourcemap = this.getCombinedSourcemap();
            await injectSourcesContent(sourcemap, cleanUrl(id), config2.logger);
            return getCodeWithSourcemap("css", content, sourcemap);
          }
          return content;
        };
        if (isDirectCSSRequest(id)) {
          return await getContentWithSourcemap(css);
        }
        if (options3 == null ? void 0 : options3.ssr) {
          return modulesCode || `export default ${JSON.stringify(css)}`;
        }
        if (inlined) {
          return `export default ${JSON.stringify(css)}`;
        }
        const cssContent = await getContentWithSourcemap(css);
        const code2 = [
          `import { updateStyle as __vite__updateStyle, removeStyle as __vite__removeStyle } from ${JSON.stringify(import_node_path4.default.posix.join(config2.base, CLIENT_PUBLIC_PATH))}`,
          `const __vite__id = ${JSON.stringify(id)}`,
          `const __vite__css = ${JSON.stringify(cssContent)}`,
          `__vite__updateStyle(__vite__id, __vite__css)`,
          // css modules exports change on edit so it can't self accept
          `${modulesCode || `import.meta.hot.accept()
export default __vite__css`}`,
          `import.meta.hot.prune(() => __vite__removeStyle(__vite__id))`
        ].join("\n");
        return { code: code2, map: { mappings: "" } };
      }
      const inlineCSS = inlineCSSRE.test(id);
      const isHTMLProxy2 = htmlProxyRE.test(id);
      const query = parseRequest(id);
      if (inlineCSS && isHTMLProxy2) {
        addToHTMLProxyTransformResult(`${getHash(cleanUrl(id))}_${Number.parseInt(query.index)}`, css);
        return `export default ''`;
      }
      if (!inlined) {
        styles3.set(id, css);
      }
      let code;
      if (usedRE.test(id)) {
        if (modulesCode) {
          code = modulesCode;
        } else {
          let content = css;
          if (config2.build.minify) {
            content = await minifyCSS(content, config2);
          }
          code = `export default ${JSON.stringify(content)}`;
        }
      } else {
        code = modulesCode || `export default ''`;
      }
      return {
        code,
        map: { mappings: "" },
        // avoid the css module from being tree-shaken so that we can retrieve
        // it in renderChunk()
        moduleSideEffects: inlined ? false : "no-treeshake"
      };
    },
    async renderChunk(code, chunk, opts) {
      var _a2;
      let chunkCSS = "";
      let isPureCssChunk = true;
      const ids = Object.keys(chunk.modules);
      for (const id of ids) {
        if (styles3.has(id)) {
          chunkCSS += styles3.get(id);
          if (cssModuleRE.test(id)) {
            isPureCssChunk = false;
          }
        } else {
          isPureCssChunk = false;
        }
      }
      if (!chunkCSS) {
        return null;
      }
      const publicAssetUrlMap = publicAssetUrlCache.get(config2);
      const resolveAssetUrlsInCss = (chunkCSS2, cssAssetName) => {
        const encodedPublicUrls = encodePublicUrlsInCSS(config2);
        const relative2 = config2.base === "./" || config2.base === "";
        const cssAssetDirname = encodedPublicUrls || relative2 ? getCssAssetDirname(cssAssetName) : void 0;
        const toRelative = (filename, importer) => {
          const relativePath = import_node_path4.default.posix.relative(cssAssetDirname, filename);
          return relativePath.startsWith(".") ? relativePath : "./" + relativePath;
        };
        chunkCSS2 = chunkCSS2.replace(assetUrlRE, (_, fileHash, postfix = "") => {
          const filename = this.getFileName(fileHash) + postfix;
          chunk.viteMetadata.importedAssets.add(cleanUrl(filename));
          return toOutputFilePathInCss(filename, "asset", cssAssetName, "css", config2, toRelative);
        });
        if (encodedPublicUrls) {
          const relativePathToPublicFromCSS = import_node_path4.default.posix.relative(cssAssetDirname, "");
          chunkCSS2 = chunkCSS2.replace(publicAssetUrlRE, (_, hash2) => {
            const publicUrl = publicAssetUrlMap.get(hash2).slice(1);
            return toOutputFilePathInCss(publicUrl, "public", cssAssetName, "css", config2, () => `${relativePathToPublicFromCSS}/${publicUrl}`);
          });
        }
        return chunkCSS2;
      };
      function ensureFileExt(name2, ext2) {
        return normalizePath$3(import_node_path4.default.format({ ...import_node_path4.default.parse(name2), base: void 0, ext: ext2 }));
      }
      if (config2.build.cssCodeSplit) {
        if (isPureCssChunk) {
          pureCssChunks.add(chunk);
        }
        if (opts.format === "es" || opts.format === "cjs") {
          const cssAssetName = chunk.facadeModuleId ? normalizePath$3(import_node_path4.default.relative(config2.root, chunk.facadeModuleId)) : chunk.name;
          const lang = import_node_path4.default.extname(cssAssetName).slice(1);
          const cssFileName = ensureFileExt(cssAssetName, ".css");
          chunkCSS = resolveAssetUrlsInCss(chunkCSS, cssAssetName);
          chunkCSS = await finalizeCss(chunkCSS, true, config2);
          const referenceId = this.emitFile({
            name: import_node_path4.default.basename(cssFileName),
            type: "asset",
            source: chunkCSS
          });
          const originalName = isPreProcessor(lang) ? cssAssetName : cssFileName;
          const isEntry = chunk.isEntry && isPureCssChunk;
          generatedAssets.get(config2).set(referenceId, { originalName, isEntry });
          chunk.viteMetadata.importedCss.add(this.getFileName(referenceId));
        } else if (!config2.build.ssr) {
          chunkCSS = await finalizeCss(chunkCSS, true, config2);
          let cssString = JSON.stringify(chunkCSS);
          cssString = ((_a2 = renderAssetUrlInJS(this, config2, chunk, opts, cssString)) == null ? void 0 : _a2.toString()) || cssString;
          const style = `__vite_style__`;
          const injectCode = `var ${style} = document.createElement('style');${style}.textContent = ${cssString};document.head.appendChild(${style});`;
          const wrapIdx = code.indexOf("System.register");
          const insertMark = "'use strict';";
          const insertIdx = code.indexOf(insertMark, wrapIdx);
          const s2 = new MagicString(code);
          s2.appendLeft(insertIdx + insertMark.length, injectCode);
          if (config2.build.sourcemap) {
            return {
              code: s2.toString(),
              map: s2.generateMap({ hires: true })
            };
          } else {
            return { code: s2.toString() };
          }
        }
      } else {
        chunkCSS = resolveAssetUrlsInCss(chunkCSS, cssBundleName);
        outputToExtractedCSSMap.set(opts, (outputToExtractedCSSMap.get(opts) || "") + chunkCSS);
      }
      return null;
    },
    augmentChunkHash(chunk) {
      var _a2;
      if ((_a2 = chunk.viteMetadata) == null ? void 0 : _a2.importedCss.size) {
        let hash2 = "";
        for (const id of chunk.viteMetadata.importedCss) {
          hash2 += id;
        }
        return hash2;
      }
    },
    async generateBundle(opts, bundle) {
      if (opts.__vite_skip_asset_emit__) {
        return;
      }
      if (pureCssChunks.size) {
        const pureCssChunkNames = [];
        for (const pureCssChunk of pureCssChunks) {
          for (const key in bundle) {
            const bundleChunk = bundle[key];
            if (bundleChunk.type === "chunk" && arrayEqual(bundleChunk.moduleIds, pureCssChunk.moduleIds)) {
              pureCssChunkNames.push(key);
              break;
            }
          }
        }
        const emptyChunkFiles = pureCssChunkNames.map((file) => import_node_path4.default.basename(file)).join("|").replace(/\./g, "\\.");
        const emptyChunkRE = new RegExp(opts.format === "es" ? `\\bimport\\s*["'][^"']*(?:${emptyChunkFiles})["'];
?` : `\\brequire\\(\\s*["'][^"']*(?:${emptyChunkFiles})["']\\);
?`, "g");
        for (const file in bundle) {
          const chunk = bundle[file];
          if (chunk.type === "chunk") {
            chunk.imports = chunk.imports.filter((file2) => {
              if (pureCssChunkNames.includes(file2)) {
                const { importedCss } = bundle[file2].viteMetadata;
                importedCss.forEach((file3) => chunk.viteMetadata.importedCss.add(file3));
                return false;
              }
              return true;
            });
            chunk.code = chunk.code.replace(
              emptyChunkRE,
              // remove css import while preserving source map location
              (m) => `/* empty css ${"".padEnd(m.length - 15)}*/`
            );
          }
        }
        const removedPureCssFiles = removedPureCssFilesCache.get(config2);
        pureCssChunkNames.forEach((fileName) => {
          removedPureCssFiles.set(fileName, bundle[fileName]);
          delete bundle[fileName];
        });
      }
      let extractedCss = outputToExtractedCSSMap.get(opts);
      if (extractedCss && !hasEmitted) {
        hasEmitted = true;
        extractedCss = await finalizeCss(extractedCss, true, config2);
        this.emitFile({
          name: cssBundleName,
          type: "asset",
          source: extractedCss
        });
      }
    }
  };
}
function createCSSResolvers(config2) {
  let cssResolve;
  let sassResolve;
  let lessResolve;
  return {
    get css() {
      return cssResolve || (cssResolve = config2.createResolver({
        extensions: [".css"],
        mainFields: ["style"],
        tryIndex: false,
        preferRelative: true
      }));
    },
    get sass() {
      return sassResolve || (sassResolve = config2.createResolver({
        extensions: [".scss", ".sass", ".css"],
        mainFields: ["sass", "style"],
        tryIndex: true,
        tryPrefix: "_",
        preferRelative: true
      }));
    },
    get less() {
      return lessResolve || (lessResolve = config2.createResolver({
        extensions: [".less", ".css"],
        mainFields: ["less", "style"],
        tryIndex: false,
        preferRelative: true
      }));
    }
  };
}
function getCssResolversKeys(resolvers) {
  return Object.keys(resolvers);
}
var configToAtImportResolvers = /* @__PURE__ */ new WeakMap();
async function compileCSS(id, code, config2, urlReplacer) {
  var _a;
  const { modules: modulesOptions, preprocessorOptions, devSourcemap } = config2.css || {};
  const isModule = modulesOptions !== false && cssModuleRE.test(id);
  const needInlineImport = code.includes("@import");
  const hasUrl = cssUrlRE.test(code) || cssImageSetRE.test(code);
  const lang = (_a = id.match(CSS_LANGS_RE)) == null ? void 0 : _a[1];
  const postcssConfig = await resolvePostcssConfig(config2, getCssDialect(lang));
  if (lang === "css" && !postcssConfig && !isModule && !needInlineImport && !hasUrl) {
    return { code, map: null };
  }
  let preprocessorMap;
  let modules;
  const deps = /* @__PURE__ */ new Set();
  let atImportResolvers = configToAtImportResolvers.get(config2);
  if (!atImportResolvers) {
    atImportResolvers = createCSSResolvers(config2);
    configToAtImportResolvers.set(config2, atImportResolvers);
  }
  if (isPreProcessor(lang)) {
    const preProcessor = preProcessors[lang];
    let opts = preprocessorOptions && preprocessorOptions[lang] || {};
    switch (lang) {
      case "scss":
      case "sass":
        opts = {
          includePaths: ["node_modules"],
          alias: config2.resolve.alias,
          ...opts
        };
        break;
      case "less":
      case "styl":
      case "stylus":
        opts = {
          paths: ["node_modules"],
          alias: config2.resolve.alias,
          ...opts
        };
    }
    opts.filename = cleanUrl(id);
    opts.enableSourcemap = devSourcemap ?? false;
    const preprocessResult = await preProcessor(code, config2.root, opts, atImportResolvers);
    if (preprocessResult.error) {
      throw preprocessResult.error;
    }
    code = preprocessResult.code;
    preprocessorMap = combineSourcemapsIfExists(opts.filename, preprocessResult.map, preprocessResult.additionalMap);
    if (preprocessResult.deps) {
      preprocessResult.deps.forEach((dep) => {
        if (normalizePath$3(dep) !== normalizePath$3(opts.filename)) {
          deps.add(dep);
        }
      });
    }
  }
  const postcssOptions = postcssConfig && postcssConfig.options || {};
  if (lang === "sss") {
    postcssOptions.parser = loadPreprocessor("sugarss", config2.root);
  }
  const postcssPlugins = postcssConfig && postcssConfig.plugins ? postcssConfig.plugins.slice() : [];
  if (needInlineImport) {
    postcssPlugins.unshift((await import("./dep-53dc1ef4-TOYYUDW5.js").then(function(n3) {
      return n3.i;
    })).default({
      async resolve(id2, basedir) {
        const publicFile = checkPublicFile(id2, config2);
        if (publicFile) {
          return publicFile;
        }
        const resolved = await atImportResolvers.css(id2, import_node_path4.default.join(basedir, "*"));
        if (resolved) {
          return import_node_path4.default.resolve(resolved);
        }
        return id2;
      },
      nameLayer(index2) {
        return `vite--anon-layer-${getHash(id)}-${index2}`;
      }
    }));
  }
  if (urlReplacer) {
    postcssPlugins.push(UrlRewritePostcssPlugin({
      replacer: urlReplacer,
      logger: config2.logger
    }));
  }
  if (isModule) {
    postcssPlugins.unshift((await import("./dep-f597f42f-FLELWIU4.js").then(function(n3) {
      return n3.i;
    })).default({
      ...modulesOptions,
      localsConvention: modulesOptions == null ? void 0 : modulesOptions.localsConvention,
      getJSON(cssFileName, _modules, outputFileName) {
        modules = _modules;
        if (modulesOptions && typeof modulesOptions.getJSON === "function") {
          modulesOptions.getJSON(cssFileName, _modules, outputFileName);
        }
      },
      async resolve(id2, importer) {
        for (const key of getCssResolversKeys(atImportResolvers)) {
          const resolved = await atImportResolvers[key](id2, importer);
          if (resolved) {
            return import_node_path4.default.resolve(resolved);
          }
        }
        return id2;
      }
    }));
  }
  if (!postcssPlugins.length) {
    return {
      code,
      map: preprocessorMap
    };
  }
  let postcssResult;
  try {
    const source = removeDirectQuery(id);
    postcssResult = await (await import("./postcss-H7EVQPU6.js")).default(postcssPlugins).process(code, {
      ...postcssOptions,
      to: source,
      from: source,
      ...devSourcemap ? {
        map: {
          inline: false,
          annotation: false,
          // postcss may return virtual files
          // we cannot obtain content of them, so this needs to be enabled
          sourcesContent: true
          // when "prev: preprocessorMap", the result map may include duplicate filename in `postcssResult.map.sources`
          // prev: preprocessorMap,
        }
      } : {}
    });
    for (const message of postcssResult.messages) {
      if (message.type === "dependency") {
        deps.add(normalizePath$3(message.file));
      } else if (message.type === "dir-dependency") {
        const { dir, glob: globPattern = "**" } = message;
        const pattern2 = out.escapePath(normalizePath$3(import_node_path4.default.resolve(import_node_path4.default.dirname(id), dir))) + `/` + globPattern;
        const files = out.sync(pattern2, {
          ignore: ["**/node_modules/**"]
        });
        for (let i2 = 0; i2 < files.length; i2++) {
          deps.add(files[i2]);
        }
      } else if (message.type === "warning") {
        let msg = `[vite:css] ${message.text}`;
        if (message.line && message.column) {
          msg += `
${generateCodeFrame(code, {
            line: message.line,
            column: message.column
          })}`;
        }
        config2.logger.warn(picocolorsExports.yellow(msg));
      }
    }
  } catch (e3) {
    e3.message = `[postcss] ${e3.message}`;
    e3.code = code;
    e3.loc = {
      column: e3.column,
      line: e3.line
    };
    throw e3;
  }
  if (!devSourcemap) {
    return {
      ast: postcssResult,
      code: postcssResult.css,
      map: { mappings: "" },
      modules,
      deps
    };
  }
  const rawPostcssMap = postcssResult.map.toJSON();
  const postcssMap = await formatPostcssSourceMap(
    // version property of rawPostcssMap is declared as string
    // but actually it is a number
    rawPostcssMap,
    cleanUrl(id)
  );
  return {
    ast: postcssResult,
    code: postcssResult.css,
    map: combineSourcemapsIfExists(cleanUrl(id), postcssMap, preprocessorMap),
    modules,
    deps
  };
}
async function preprocessCSS(code, filename, config2) {
  return await compileCSS(filename, code, config2);
}
async function formatPostcssSourceMap(rawMap, file) {
  const inputFileDir = import_node_path4.default.dirname(file);
  const sources = rawMap.sources.map((source) => {
    const cleanSource = cleanUrl(decodeURIComponent(source));
    if (/^<.+>$/.test(cleanSource)) {
      return `\0${cleanSource}`;
    }
    return normalizePath$3(import_node_path4.default.resolve(inputFileDir, cleanSource));
  });
  return {
    file,
    mappings: rawMap.mappings,
    names: rawMap.names,
    sources,
    sourcesContent: rawMap.sourcesContent,
    version: rawMap.version
  };
}
function combineSourcemapsIfExists(filename, map1, map22) {
  return map1 && map22 ? combineSourcemaps(filename, [
    // type of version property of ExistingRawSourceMap is number
    // but it is always 3
    map1,
    map22
  ]) : map1;
}
async function finalizeCss(css, minify, config2) {
  if (css.includes("@import") || css.includes("@charset")) {
    css = await hoistAtRules(css);
  }
  if (minify && config2.build.minify) {
    css = await minifyCSS(css, config2);
  }
  return css;
}
async function resolvePostcssConfig(config2, dialect = "css") {
  var _a;
  postcssConfigCache[dialect] ?? (postcssConfigCache[dialect] = /* @__PURE__ */ new WeakMap());
  let result = postcssConfigCache[dialect].get(config2);
  if (result !== void 0) {
    return result;
  }
  const inlineOptions = (_a = config2.css) == null ? void 0 : _a.postcss;
  if (isObject$1(inlineOptions)) {
    const options3 = { ...inlineOptions };
    delete options3.plugins;
    result = {
      options: options3,
      plugins: inlineOptions.plugins || []
    };
  } else {
    const searchPath = typeof inlineOptions === "string" ? inlineOptions : config2.root;
    try {
      result = await src$1({}, searchPath);
    } catch (e3) {
      if (!/No PostCSS Config found/.test(e3.message)) {
        if (e3 instanceof Error) {
          const { name: name2, message, stack } = e3;
          e3.name = "Failed to load PostCSS config";
          e3.message = `Failed to load PostCSS config (searchPath: ${searchPath}): [${name2}] ${message}
${stack}`;
          e3.stack = "";
          throw e3;
        } else {
          throw new Error(`Failed to load PostCSS config: ${e3}`);
        }
      }
      result = null;
    }
  }
  postcssConfigCache[dialect].set(config2, result);
  return result;
}
var cssUrlRE = new RegExp(`(?<=^|[^\\w\\-\\u0080-\\uffff])url\\((\\s*('[^']+'|"[^"]+")\\s*|[^'")]+)\\)`);
var cssDataUriRE = new RegExp(`(?<=^|[^\\w\\-\\u0080-\\uffff])data-uri\\((\\s*('[^']+'|"[^"]+")\\s*|[^'")]+)\\)`);
var importCssRE = /@import ('[^']+\.css'|"[^"]+\.css"|[^'")]+\.css)/;
var cssImageSetRE = new RegExp("(?<=image-set\\()((?:[\\w\\-]{1,256}\\([^)]*\\)|[^)])*)(?=\\))");
var UrlRewritePostcssPlugin = (opts) => {
  if (!opts) {
    throw new Error("base or replace is required");
  }
  return {
    postcssPlugin: "vite-url-rewrite",
    Once(root) {
      const promises2 = [];
      root.walkDecls((declaration2) => {
        var _a;
        const importer = (_a = declaration2.source) == null ? void 0 : _a.input.file;
        if (!importer) {
          opts.logger.warnOnce("\nA PostCSS plugin did not pass the `from` option to `postcss.parse`. This may cause imported assets to be incorrectly transformed. If you've recently added a PostCSS plugin that raised this warning, please contact the package author to fix the issue.");
        }
        const isCssUrl = cssUrlRE.test(declaration2.value);
        const isCssImageSet = cssImageSetRE.test(declaration2.value);
        if (isCssUrl || isCssImageSet) {
          const replacerForDeclaration = (rawUrl) => {
            return opts.replacer(rawUrl, importer);
          };
          const rewriterToUse = isCssImageSet ? rewriteCssImageSet : rewriteCssUrls;
          promises2.push(rewriterToUse(declaration2.value, replacerForDeclaration).then((url2) => {
            declaration2.value = url2;
          }));
        }
      });
      if (promises2.length) {
        return Promise.all(promises2);
      }
    }
  };
};
UrlRewritePostcssPlugin.postcss = true;
function rewriteCssUrls(css, replacer) {
  return asyncReplace(css, cssUrlRE, async (match) => {
    const [matched, rawUrl] = match;
    return await doUrlReplace(rawUrl.trim(), matched, replacer);
  });
}
function rewriteCssDataUris(css, replacer) {
  return asyncReplace(css, cssDataUriRE, async (match) => {
    const [matched, rawUrl] = match;
    return await doUrlReplace(rawUrl.trim(), matched, replacer, "data-uri");
  });
}
function rewriteImportCss(css, replacer) {
  return asyncReplace(css, importCssRE, async (match) => {
    const [matched, rawUrl] = match;
    return await doImportCSSReplace(rawUrl, matched, replacer);
  });
}
var cssNotProcessedRE = /(?:gradient|element|cross-fade|image)\(/;
async function rewriteCssImageSet(css, replacer) {
  return await asyncReplace(css, cssImageSetRE, async (match) => {
    const [, rawUrl] = match;
    const url2 = await processSrcSet(rawUrl, async ({ url: url3 }) => {
      if (cssUrlRE.test(url3)) {
        return await rewriteCssUrls(url3, replacer);
      }
      if (!cssNotProcessedRE.test(url3)) {
        return await doUrlReplace(url3, url3, replacer);
      }
      return url3;
    });
    return url2;
  });
}
async function doUrlReplace(rawUrl, matched, replacer, funcName = "url") {
  let wrap3 = "";
  const first2 = rawUrl[0];
  if (first2 === `"` || first2 === `'`) {
    wrap3 = first2;
    rawUrl = rawUrl.slice(1, -1);
  }
  if (isExternalUrl(rawUrl) || isDataUrl(rawUrl) || rawUrl.startsWith("#") || varRE.test(rawUrl)) {
    return matched;
  }
  const newUrl = await replacer(rawUrl);
  if (wrap3 === "" && newUrl !== encodeURI(newUrl)) {
    wrap3 = "'";
  }
  return `${funcName}(${wrap3}${newUrl}${wrap3})`;
}
async function doImportCSSReplace(rawUrl, matched, replacer) {
  let wrap3 = "";
  const first2 = rawUrl[0];
  if (first2 === `"` || first2 === `'`) {
    wrap3 = first2;
    rawUrl = rawUrl.slice(1, -1);
  }
  if (isExternalUrl(rawUrl) || isDataUrl(rawUrl) || rawUrl.startsWith("#")) {
    return matched;
  }
  return `@import ${wrap3}${await replacer(rawUrl)}${wrap3}`;
}
async function minifyCSS(css, config2) {
  try {
    const { code, warnings } = await (0, import_esbuild.transform)(css, {
      loader: "css",
      target: config2.build.cssTarget || void 0,
      ...resolveEsbuildMinifyOptions(config2.esbuild || {})
    });
    if (warnings.length) {
      const msgs = await (0, import_esbuild.formatMessages)(warnings, { kind: "warning" });
      config2.logger.warn(picocolorsExports.yellow(`warnings when minifying css:
${msgs.join("\n")}`));
    }
    return code;
  } catch (e3) {
    if (e3.errors) {
      e3.message = "[esbuild css minify] " + e3.message;
      const msgs = await (0, import_esbuild.formatMessages)(e3.errors, { kind: "error" });
      e3.frame = "\n" + msgs.join("\n");
      e3.loc = e3.errors[0].location;
    }
    throw e3;
  }
}
function resolveEsbuildMinifyOptions(options3) {
  const base2 = {
    logLevel: options3.logLevel,
    logLimit: options3.logLimit,
    logOverride: options3.logOverride
  };
  if (options3.minifyIdentifiers != null || options3.minifySyntax != null || options3.minifyWhitespace != null) {
    return {
      ...base2,
      minifyIdentifiers: options3.minifyIdentifiers ?? true,
      minifySyntax: options3.minifySyntax ?? true,
      minifyWhitespace: options3.minifyWhitespace ?? true
    };
  } else {
    return { ...base2, minify: true };
  }
}
async function hoistAtRules(css) {
  const s2 = new MagicString(css);
  const cleanCss = emptyCssComments(css);
  let match;
  const atImportRE = new RegExp(`@import(?:\\s*(?:url\\([^)]*\\)|"(?:[^"]|(?<=\\\\)")*"|'(?:[^']|(?<=\\\\)')*').*?|[^;]*);`, "g");
  while (match = atImportRE.exec(cleanCss)) {
    s2.remove(match.index, match.index + match[0].length);
    s2.appendLeft(0, match[0]);
  }
  const atCharsetRE = new RegExp(`@charset(?:\\s*(?:"(?:[^"]|(?<=\\\\)")*"|'(?:[^']|(?<=\\\\)')*').*?|[^;]*);`, "g");
  let foundCharset = false;
  while (match = atCharsetRE.exec(cleanCss)) {
    s2.remove(match.index, match.index + match[0].length);
    if (!foundCharset) {
      s2.prepend(match[0]);
      foundCharset = true;
    }
  }
  return s2.toString();
}
var loadedPreprocessors = {};
var _require$1 = (0, import_node_module.createRequire)(import.meta.url);
function loadPreprocessor(lang, root) {
  if (lang in loadedPreprocessors) {
    return loadedPreprocessors[lang];
  }
  try {
    const resolved = requireResolveFromRootWithFallback(root, lang);
    return loadedPreprocessors[lang] = _require$1(resolved);
  } catch (e3) {
    if (e3.code === "MODULE_NOT_FOUND") {
      throw new Error(`Preprocessor dependency "${lang}" not found. Did you install it?`);
    } else {
      const message = new Error(`Preprocessor dependency "${lang}" failed to load:
${e3.message}`);
      message.stack = e3.stack + "\n" + message.stack;
      throw message;
    }
  }
}
function cleanScssBugUrl(url2) {
  if (
    // check bug via `window` and `location` global
    typeof window !== "undefined" && typeof location !== "undefined"
  ) {
    const prefix = location.href.replace(/\/$/, "");
    return url2.replace(prefix, "");
  } else {
    return url2;
  }
}
function fixScssBugImportValue(data2) {
  if (
    // check bug via `window` and `location` global
    typeof window !== "undefined" && typeof location !== "undefined" && data2 && "file" in data2 && (!("contents" in data2) || data2.contents == null)
  ) {
    data2.contents = import_node_fs4.default.readFileSync(data2.file, "utf-8");
  }
  return data2;
}
var scss = async (source, root, options3, resolvers) => {
  const render = loadPreprocessor("sass", root).render;
  const internalImporter = (url2, importer2, done) => {
    importer2 = cleanScssBugUrl(importer2);
    resolvers.sass(url2, importer2).then((resolved) => {
      if (resolved) {
        rebaseUrls(resolved, options3.filename, options3.alias, "$").then((data3) => done == null ? void 0 : done(fixScssBugImportValue(data3))).catch((data3) => done == null ? void 0 : done(data3));
      } else {
        done == null ? void 0 : done(null);
      }
    });
  };
  const importer = [internalImporter];
  if (options3.importer) {
    Array.isArray(options3.importer) ? importer.unshift(...options3.importer) : importer.unshift(options3.importer);
  }
  const { content: data2, map: additionalMap } = await getSource(source, options3.filename, options3.additionalData, options3.enableSourcemap);
  const finalOptions = {
    ...options3,
    data: data2,
    file: options3.filename,
    outFile: options3.filename,
    importer,
    ...options3.enableSourcemap ? {
      sourceMap: true,
      omitSourceMapUrl: true,
      sourceMapRoot: import_node_path4.default.dirname(options3.filename)
    } : {}
  };
  try {
    const result = await new Promise((resolve4, reject) => {
      render(finalOptions, (err2, res) => {
        if (err2) {
          reject(err2);
        } else {
          resolve4(res);
        }
      });
    });
    const deps = result.stats.includedFiles.map((f2) => cleanScssBugUrl(f2));
    const map3 = result.map ? JSON.parse(result.map.toString()) : void 0;
    return {
      code: result.css.toString(),
      map: map3,
      additionalMap,
      deps
    };
  } catch (e3) {
    e3.message = `[sass] ${e3.message}`;
    e3.id = e3.file;
    e3.frame = e3.formatted;
    return { code: "", error: e3, deps: [] };
  }
};
var sass = (source, root, options3, aliasResolver) => scss(source, root, {
  ...options3,
  indentedSyntax: true
}, aliasResolver);
async function rebaseUrls(file, rootFile, alias2, variablePrefix) {
  file = import_node_path4.default.resolve(file);
  const fileDir = import_node_path4.default.dirname(file);
  const rootDir = import_node_path4.default.dirname(rootFile);
  if (fileDir === rootDir) {
    return { file };
  }
  const content = import_node_fs4.default.readFileSync(file, "utf-8");
  const hasUrls = cssUrlRE.test(content);
  const hasDataUris = cssDataUriRE.test(content);
  const hasImportCss = importCssRE.test(content);
  if (!hasUrls && !hasDataUris && !hasImportCss) {
    return { file };
  }
  let rebased;
  const rebaseFn = (url2) => {
    if (url2.startsWith("/"))
      return url2;
    if (url2.startsWith(variablePrefix))
      return url2;
    for (const { find: find2 } of alias2) {
      const matches2 = typeof find2 === "string" ? url2.startsWith(find2) : find2.test(url2);
      if (matches2) {
        return url2;
      }
    }
    const absolute = import_node_path4.default.resolve(fileDir, url2);
    const relative2 = import_node_path4.default.relative(rootDir, absolute);
    return normalizePath$3(relative2);
  };
  if (hasImportCss) {
    rebased = await rewriteImportCss(content, rebaseFn);
  }
  if (hasUrls) {
    rebased = await rewriteCssUrls(rebased || content, rebaseFn);
  }
  if (hasDataUris) {
    rebased = await rewriteCssDataUris(rebased || content, rebaseFn);
  }
  return {
    file,
    contents: rebased
  };
}
var less = async (source, root, options3, resolvers) => {
  const nodeLess = loadPreprocessor("less", root);
  const viteResolverPlugin = createViteLessPlugin(nodeLess, options3.filename, options3.alias, resolvers);
  const { content, map: additionalMap } = await getSource(source, options3.filename, options3.additionalData, options3.enableSourcemap);
  let result;
  try {
    result = await nodeLess.render(content, {
      ...options3,
      plugins: [viteResolverPlugin, ...options3.plugins || []],
      ...options3.enableSourcemap ? {
        sourceMap: {
          outputSourceFiles: true,
          sourceMapFileInline: false
        }
      } : {}
    });
  } catch (e3) {
    const error3 = e3;
    const normalizedError = new Error(`[less] ${error3.message || error3.type}`);
    normalizedError.loc = {
      file: error3.filename || options3.filename,
      line: error3.line,
      column: error3.column
    };
    return { code: "", error: normalizedError, deps: [] };
  }
  const map3 = result.map && JSON.parse(result.map);
  if (map3) {
    delete map3.sourcesContent;
  }
  return {
    code: result.css.toString(),
    map: map3,
    additionalMap,
    deps: result.imports
  };
};
var ViteLessManager;
function createViteLessPlugin(less2, rootFile, alias2, resolvers) {
  if (!ViteLessManager) {
    ViteLessManager = class ViteManager extends less2.FileManager {
      constructor(rootFile2, resolvers2, alias3) {
        super();
        this.rootFile = rootFile2;
        this.resolvers = resolvers2;
        this.alias = alias3;
      }
      supports() {
        return true;
      }
      supportsSync() {
        return false;
      }
      async loadFile(filename, dir, opts, env2) {
        const resolved = await this.resolvers.less(filename, import_node_path4.default.join(dir, "*"));
        if (resolved) {
          const result = await rebaseUrls(resolved, this.rootFile, this.alias, "@");
          let contents;
          if (result && "contents" in result) {
            contents = result.contents;
          } else {
            contents = import_node_fs4.default.readFileSync(resolved, "utf-8");
          }
          return {
            filename: import_node_path4.default.resolve(resolved),
            contents
          };
        } else {
          return super.loadFile(filename, dir, opts, env2);
        }
      }
    };
  }
  return {
    install(_, pluginManager) {
      pluginManager.addFileManager(new ViteLessManager(rootFile, resolvers, alias2));
    },
    minVersion: [3, 0, 0]
  };
}
var styl = async (source, root, options3) => {
  const nodeStylus = loadPreprocessor("stylus", root);
  const { content, map: additionalMap } = await getSource(source, options3.filename, options3.additionalData, options3.enableSourcemap, "\n");
  const importsDeps = (options3.imports ?? []).map((dep) => import_node_path4.default.resolve(dep));
  try {
    const ref2 = nodeStylus(content, options3);
    if (options3.enableSourcemap) {
      ref2.set("sourcemap", {
        comment: false,
        inline: false,
        basePath: root
      });
    }
    const result = ref2.render();
    const deps = [...ref2.deps(), ...importsDeps];
    const map3 = ref2.sourcemap;
    return {
      code: result,
      map: formatStylusSourceMap(map3, root),
      additionalMap,
      deps
    };
  } catch (e3) {
    e3.message = `[stylus] ${e3.message}`;
    return { code: "", error: e3, deps: [] };
  }
};
function formatStylusSourceMap(mapBefore, root) {
  if (!mapBefore)
    return void 0;
  const map3 = { ...mapBefore };
  const resolveFromRoot = (p2) => normalizePath$3(import_node_path4.default.resolve(root, p2));
  if (map3.file) {
    map3.file = resolveFromRoot(map3.file);
  }
  map3.sources = map3.sources.map(resolveFromRoot);
  return map3;
}
async function getSource(source, filename, additionalData, enableSourcemap, sep2 = "") {
  if (!additionalData)
    return { content: source };
  if (typeof additionalData === "function") {
    const newContent = await additionalData(source, filename);
    if (typeof newContent === "string") {
      return { content: newContent };
    }
    return newContent;
  }
  if (!enableSourcemap) {
    return { content: additionalData + sep2 + source };
  }
  const ms3 = new MagicString(source);
  ms3.appendLeft(0, sep2);
  ms3.appendLeft(0, additionalData);
  const map3 = ms3.generateMap({ hires: true });
  map3.file = filename;
  map3.sources = [filename];
  return {
    content: ms3.toString(),
    map: map3
  };
}
var preProcessors = Object.freeze({
  [
    "less"
    /* PreprocessLang.less */
  ]: less,
  [
    "sass"
    /* PreprocessLang.sass */
  ]: sass,
  [
    "scss"
    /* PreprocessLang.scss */
  ]: scss,
  [
    "styl"
    /* PreprocessLang.styl */
  ]: styl,
  [
    "stylus"
    /* PreprocessLang.stylus */
  ]: styl
});
function isPreProcessor(lang) {
  return lang && lang in preProcessors;
}
function getCssDialect(lang) {
  return lang === "sss" ? "sss" : "css";
}
function makeTest(test) {
  if (typeof test === "string") {
    return function(type) {
      return type === test;
    };
  } else if (!test) {
    return function() {
      return true;
    };
  } else {
    return test;
  }
}
var Found = function Found2(node3, state) {
  this.node = node3;
  this.state = state;
};
function findNodeAt(node3, start, end, test, baseVisitor, state) {
  if (!baseVisitor) {
    baseVisitor = base;
  }
  test = makeTest(test);
  try {
    (function c2(node4, st, override) {
      var type = override || node4.type;
      if ((start == null || node4.start <= start) && (end == null || node4.end >= end)) {
        baseVisitor[type](node4, st, c2);
      }
      if ((start == null || node4.start === start) && (end == null || node4.end === end) && test(type, node4)) {
        throw new Found(node4, st);
      }
    })(node3, state);
  } catch (e3) {
    if (e3 instanceof Found) {
      return e3;
    }
    throw e3;
  }
}
function skipThrough(node3, st, c2) {
  c2(node3, st);
}
function ignore(_node, _st, _c) {
}
var base = {};
base.Program = base.BlockStatement = base.StaticBlock = function(node3, st, c2) {
  for (var i2 = 0, list = node3.body; i2 < list.length; i2 += 1) {
    var stmt = list[i2];
    c2(stmt, st, "Statement");
  }
};
base.Statement = skipThrough;
base.EmptyStatement = ignore;
base.ExpressionStatement = base.ParenthesizedExpression = base.ChainExpression = function(node3, st, c2) {
  return c2(node3.expression, st, "Expression");
};
base.IfStatement = function(node3, st, c2) {
  c2(node3.test, st, "Expression");
  c2(node3.consequent, st, "Statement");
  if (node3.alternate) {
    c2(node3.alternate, st, "Statement");
  }
};
base.LabeledStatement = function(node3, st, c2) {
  return c2(node3.body, st, "Statement");
};
base.BreakStatement = base.ContinueStatement = ignore;
base.WithStatement = function(node3, st, c2) {
  c2(node3.object, st, "Expression");
  c2(node3.body, st, "Statement");
};
base.SwitchStatement = function(node3, st, c2) {
  c2(node3.discriminant, st, "Expression");
  for (var i$1 = 0, list$1 = node3.cases; i$1 < list$1.length; i$1 += 1) {
    var cs = list$1[i$1];
    if (cs.test) {
      c2(cs.test, st, "Expression");
    }
    for (var i2 = 0, list = cs.consequent; i2 < list.length; i2 += 1) {
      var cons = list[i2];
      c2(cons, st, "Statement");
    }
  }
};
base.SwitchCase = function(node3, st, c2) {
  if (node3.test) {
    c2(node3.test, st, "Expression");
  }
  for (var i2 = 0, list = node3.consequent; i2 < list.length; i2 += 1) {
    var cons = list[i2];
    c2(cons, st, "Statement");
  }
};
base.ReturnStatement = base.YieldExpression = base.AwaitExpression = function(node3, st, c2) {
  if (node3.argument) {
    c2(node3.argument, st, "Expression");
  }
};
base.ThrowStatement = base.SpreadElement = function(node3, st, c2) {
  return c2(node3.argument, st, "Expression");
};
base.TryStatement = function(node3, st, c2) {
  c2(node3.block, st, "Statement");
  if (node3.handler) {
    c2(node3.handler, st);
  }
  if (node3.finalizer) {
    c2(node3.finalizer, st, "Statement");
  }
};
base.CatchClause = function(node3, st, c2) {
  if (node3.param) {
    c2(node3.param, st, "Pattern");
  }
  c2(node3.body, st, "Statement");
};
base.WhileStatement = base.DoWhileStatement = function(node3, st, c2) {
  c2(node3.test, st, "Expression");
  c2(node3.body, st, "Statement");
};
base.ForStatement = function(node3, st, c2) {
  if (node3.init) {
    c2(node3.init, st, "ForInit");
  }
  if (node3.test) {
    c2(node3.test, st, "Expression");
  }
  if (node3.update) {
    c2(node3.update, st, "Expression");
  }
  c2(node3.body, st, "Statement");
};
base.ForInStatement = base.ForOfStatement = function(node3, st, c2) {
  c2(node3.left, st, "ForInit");
  c2(node3.right, st, "Expression");
  c2(node3.body, st, "Statement");
};
base.ForInit = function(node3, st, c2) {
  if (node3.type === "VariableDeclaration") {
    c2(node3, st);
  } else {
    c2(node3, st, "Expression");
  }
};
base.DebuggerStatement = ignore;
base.FunctionDeclaration = function(node3, st, c2) {
  return c2(node3, st, "Function");
};
base.VariableDeclaration = function(node3, st, c2) {
  for (var i2 = 0, list = node3.declarations; i2 < list.length; i2 += 1) {
    var decl = list[i2];
    c2(decl, st);
  }
};
base.VariableDeclarator = function(node3, st, c2) {
  c2(node3.id, st, "Pattern");
  if (node3.init) {
    c2(node3.init, st, "Expression");
  }
};
base.Function = function(node3, st, c2) {
  if (node3.id) {
    c2(node3.id, st, "Pattern");
  }
  for (var i2 = 0, list = node3.params; i2 < list.length; i2 += 1) {
    var param = list[i2];
    c2(param, st, "Pattern");
  }
  c2(node3.body, st, node3.expression ? "Expression" : "Statement");
};
base.Pattern = function(node3, st, c2) {
  if (node3.type === "Identifier") {
    c2(node3, st, "VariablePattern");
  } else if (node3.type === "MemberExpression") {
    c2(node3, st, "MemberPattern");
  } else {
    c2(node3, st);
  }
};
base.VariablePattern = ignore;
base.MemberPattern = skipThrough;
base.RestElement = function(node3, st, c2) {
  return c2(node3.argument, st, "Pattern");
};
base.ArrayPattern = function(node3, st, c2) {
  for (var i2 = 0, list = node3.elements; i2 < list.length; i2 += 1) {
    var elt = list[i2];
    if (elt) {
      c2(elt, st, "Pattern");
    }
  }
};
base.ObjectPattern = function(node3, st, c2) {
  for (var i2 = 0, list = node3.properties; i2 < list.length; i2 += 1) {
    var prop = list[i2];
    if (prop.type === "Property") {
      if (prop.computed) {
        c2(prop.key, st, "Expression");
      }
      c2(prop.value, st, "Pattern");
    } else if (prop.type === "RestElement") {
      c2(prop.argument, st, "Pattern");
    }
  }
};
base.Expression = skipThrough;
base.ThisExpression = base.Super = base.MetaProperty = ignore;
base.ArrayExpression = function(node3, st, c2) {
  for (var i2 = 0, list = node3.elements; i2 < list.length; i2 += 1) {
    var elt = list[i2];
    if (elt) {
      c2(elt, st, "Expression");
    }
  }
};
base.ObjectExpression = function(node3, st, c2) {
  for (var i2 = 0, list = node3.properties; i2 < list.length; i2 += 1) {
    var prop = list[i2];
    c2(prop, st);
  }
};
base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;
base.SequenceExpression = function(node3, st, c2) {
  for (var i2 = 0, list = node3.expressions; i2 < list.length; i2 += 1) {
    var expr = list[i2];
    c2(expr, st, "Expression");
  }
};
base.TemplateLiteral = function(node3, st, c2) {
  for (var i2 = 0, list = node3.quasis; i2 < list.length; i2 += 1) {
    var quasi = list[i2];
    c2(quasi, st);
  }
  for (var i$1 = 0, list$1 = node3.expressions; i$1 < list$1.length; i$1 += 1) {
    var expr = list$1[i$1];
    c2(expr, st, "Expression");
  }
};
base.TemplateElement = ignore;
base.UnaryExpression = base.UpdateExpression = function(node3, st, c2) {
  c2(node3.argument, st, "Expression");
};
base.BinaryExpression = base.LogicalExpression = function(node3, st, c2) {
  c2(node3.left, st, "Expression");
  c2(node3.right, st, "Expression");
};
base.AssignmentExpression = base.AssignmentPattern = function(node3, st, c2) {
  c2(node3.left, st, "Pattern");
  c2(node3.right, st, "Expression");
};
base.ConditionalExpression = function(node3, st, c2) {
  c2(node3.test, st, "Expression");
  c2(node3.consequent, st, "Expression");
  c2(node3.alternate, st, "Expression");
};
base.NewExpression = base.CallExpression = function(node3, st, c2) {
  c2(node3.callee, st, "Expression");
  if (node3.arguments) {
    for (var i2 = 0, list = node3.arguments; i2 < list.length; i2 += 1) {
      var arg = list[i2];
      c2(arg, st, "Expression");
    }
  }
};
base.MemberExpression = function(node3, st, c2) {
  c2(node3.object, st, "Expression");
  if (node3.computed) {
    c2(node3.property, st, "Expression");
  }
};
base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function(node3, st, c2) {
  if (node3.declaration) {
    c2(node3.declaration, st, node3.type === "ExportNamedDeclaration" || node3.declaration.id ? "Statement" : "Expression");
  }
  if (node3.source) {
    c2(node3.source, st, "Expression");
  }
};
base.ExportAllDeclaration = function(node3, st, c2) {
  if (node3.exported) {
    c2(node3.exported, st);
  }
  c2(node3.source, st, "Expression");
};
base.ImportDeclaration = function(node3, st, c2) {
  for (var i2 = 0, list = node3.specifiers; i2 < list.length; i2 += 1) {
    var spec = list[i2];
    c2(spec, st);
  }
  c2(node3.source, st, "Expression");
};
base.ImportExpression = function(node3, st, c2) {
  c2(node3.source, st, "Expression");
};
base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.PrivateIdentifier = base.Literal = ignore;
base.TaggedTemplateExpression = function(node3, st, c2) {
  c2(node3.tag, st, "Expression");
  c2(node3.quasi, st, "Expression");
};
base.ClassDeclaration = base.ClassExpression = function(node3, st, c2) {
  return c2(node3, st, "Class");
};
base.Class = function(node3, st, c2) {
  if (node3.id) {
    c2(node3.id, st, "Pattern");
  }
  if (node3.superClass) {
    c2(node3.superClass, st, "Expression");
  }
  c2(node3.body, st);
};
base.ClassBody = function(node3, st, c2) {
  for (var i2 = 0, list = node3.body; i2 < list.length; i2 += 1) {
    var elt = list[i2];
    c2(elt, st);
  }
};
base.MethodDefinition = base.PropertyDefinition = base.Property = function(node3, st, c2) {
  if (node3.computed) {
    c2(node3.key, st, "Expression");
  }
  if (node3.value) {
    c2(node3.value, st, "Expression");
  }
};
var { isMatch: isMatch$1, scan } = micromatch_1;
function getAffectedGlobModules(file, server2) {
  const modules = [];
  for (const [id, allGlobs] of server2._importGlobMap) {
    if (allGlobs.some((glob2) => isMatch$1(file, glob2)))
      modules.push(...server2.moduleGraph.getModulesByFile(id) || []);
  }
  modules.forEach((i2) => {
    if (i2 == null ? void 0 : i2.file)
      server2.moduleGraph.onFileChange(i2.file);
  });
  return modules;
}
function importGlobPlugin(config2) {
  let server2;
  return {
    name: "vite:import-glob",
    configureServer(_server) {
      server2 = _server;
      server2._importGlobMap.clear();
    },
    async transform(code, id) {
      if (!code.includes("import.meta.glob"))
        return;
      const result = await transformGlobImport(code, id, config2.root, (im) => this.resolve(im, id).then((i2) => (i2 == null ? void 0 : i2.id) || im), config2.isProduction, config2.experimental.importGlobRestoreExtension);
      if (result) {
        if (server2) {
          const allGlobs = result.matches.map((i2) => i2.globsResolved);
          server2._importGlobMap.set(id, allGlobs);
        }
        return transformStableResult(result.s, id, config2);
      }
    }
  };
}
var importGlobRE = /\bimport\.meta\.(glob|globEager|globEagerDefault)(?:<\w+>)?\s*\(/g;
var knownOptions = {
  as: ["string"],
  eager: ["boolean"],
  import: ["string"],
  exhaustive: ["boolean"],
  query: ["object", "string"]
};
var forceDefaultAs = ["raw", "url"];
function err$1(e3, pos) {
  const error3 = new Error(e3);
  error3.pos = pos;
  return error3;
}
function parseGlobOptions(rawOpts, optsStartIndex) {
  let opts = {};
  try {
    opts = evalValue(rawOpts);
  } catch {
    throw err$1("Vite is unable to parse the glob options as the value is not static", optsStartIndex);
  }
  if (opts == null) {
    return {};
  }
  for (const key in opts) {
    if (!(key in knownOptions)) {
      throw err$1(`Unknown glob option "${key}"`, optsStartIndex);
    }
    const allowedTypes = knownOptions[key];
    const valueType = typeof opts[key];
    if (!allowedTypes.includes(valueType)) {
      throw err$1(`Expected glob option "${key}" to be of type ${allowedTypes.join(" or ")}, but got ${valueType}`, optsStartIndex);
    }
  }
  if (typeof opts.query === "object") {
    for (const key in opts.query) {
      const value2 = opts.query[key];
      if (!["string", "number", "boolean"].includes(typeof value2)) {
        throw err$1(`Expected glob option "query.${key}" to be of type string, number, or boolean, but got ${typeof value2}`, optsStartIndex);
      }
    }
  }
  if (opts.as && forceDefaultAs.includes(opts.as)) {
    if (opts.import && opts.import !== "default" && opts.import !== "*")
      throw err$1(`Option "import" can only be "default" or "*" when "as" is "${opts.as}", but got "${opts.import}"`, optsStartIndex);
    opts.import = opts.import || "default";
  }
  if (opts.as && opts.query)
    throw err$1('Options "as" and "query" cannot be used together', optsStartIndex);
  if (opts.as)
    opts.query = opts.as;
  return opts;
}
async function parseImportGlob(code, importer, root, resolveId) {
  let cleanCode;
  try {
    cleanCode = stripLiteral(code);
  } catch (e3) {
    return [];
  }
  const matches2 = Array.from(cleanCode.matchAll(importGlobRE));
  const tasks2 = matches2.map(async (match, index2) => {
    const type = match[1];
    const start = match.index;
    const err2 = (msg) => {
      const e3 = new Error(`Invalid glob import syntax: ${msg}`);
      e3.pos = start;
      return e3;
    };
    let ast;
    let lastTokenPos;
    try {
      ast = parseExpressionAt2(code, start, {
        ecmaVersion: "latest",
        sourceType: "module",
        ranges: true,
        onToken: (token) => {
          lastTokenPos = token.end;
        }
      });
    } catch (e3) {
      const _e = e3;
      if (_e.message && _e.message.startsWith("Unterminated string constant"))
        return void 0;
      if (lastTokenPos == null || lastTokenPos <= start)
        throw _e;
      try {
        const statement = code.slice(start, lastTokenPos).replace(/[,\s]*$/, "");
        ast = parseExpressionAt2(
          " ".repeat(start) + statement,
          // to keep the ast position
          start,
          {
            ecmaVersion: "latest",
            sourceType: "module",
            ranges: true
          }
        );
      } catch {
        throw _e;
      }
    }
    const found2 = findNodeAt(ast, start, void 0, "CallExpression");
    if (!found2)
      throw err2(`Expect CallExpression, got ${ast.type}`);
    ast = found2.node;
    if (ast.arguments.length < 1 || ast.arguments.length > 2)
      throw err2(`Expected 1-2 arguments, but got ${ast.arguments.length}`);
    const arg1 = ast.arguments[0];
    const arg2 = ast.arguments[1];
    const globs = [];
    const validateLiteral = (element) => {
      if (!element)
        return;
      if (element.type === "Literal") {
        if (typeof element.value !== "string")
          throw err2(`Expected glob to be a string, but got "${typeof element.value}"`);
        globs.push(element.value);
      } else if (element.type === "TemplateLiteral") {
        if (element.expressions.length !== 0) {
          throw err2(`Expected glob to be a string, but got dynamic template literal`);
        }
        globs.push(element.quasis[0].value.raw);
      } else {
        throw err2("Could only use literals");
      }
    };
    if (arg1.type === "ArrayExpression") {
      for (const element of arg1.elements) {
        validateLiteral(element);
      }
    } else {
      validateLiteral(arg1);
    }
    let options3 = {};
    if (arg2) {
      if (arg2.type !== "ObjectExpression")
        throw err2(`Expected the second argument to be an object literal, but got "${arg2.type}"`);
      options3 = parseGlobOptions(code.slice(arg2.range[0], arg2.range[1]), arg2.range[0]);
    }
    const end = ast.range[1];
    const globsResolved = await Promise.all(globs.map((glob2) => toAbsoluteGlob(glob2, root, importer, resolveId)));
    const isRelative3 = globs.every((i2) => ".!".includes(i2[0]));
    return {
      match,
      index: index2,
      globs,
      globsResolved,
      isRelative: isRelative3,
      options: options3,
      type,
      start,
      end
    };
  });
  return (await Promise.all(tasks2)).filter(Boolean);
}
var importPrefix = "__vite_glob_";
var { basename, dirname, relative, join } = import_node_path4.posix;
var warnedCSSDefaultImportVarName = "__vite_warned_css_default_import";
var jsonStringifyInOneline = (input) => JSON.stringify(input).replace(/[{,:]/g, "$& ").replace(/\}/g, " }");
var createCssDefaultImportWarning = (globs, options3) => `if (!${warnedCSSDefaultImportVarName}) {${warnedCSSDefaultImportVarName} = true;console.warn(${JSON.stringify(`Default import of CSS without \`?inline\` is deprecated. Add the \`{ query: '?inline' }\` glob option to fix this.
For example: \`import.meta.glob(${jsonStringifyInOneline(globs.length === 1 ? globs[0] : globs)}, ${jsonStringifyInOneline({ ...options3, query: "?inline" })})\``)});}`;
async function transformGlobImport(code, id, root, resolveId, isProduction, restoreQueryExtension = false) {
  id = slash$1(id);
  root = slash$1(root);
  const isVirtual = isVirtualModule(id);
  const dir = isVirtual ? void 0 : dirname(id);
  const matches2 = await parseImportGlob(code, isVirtual ? void 0 : id, root, resolveId);
  const matchedFiles = /* @__PURE__ */ new Set();
  matches2.forEach((i2) => {
    if (i2.type === "globEager")
      i2.options.eager = true;
    if (i2.type === "globEagerDefault") {
      i2.options.eager = true;
      i2.options.import = "default";
    }
  });
  if (!matches2.length)
    return null;
  const s2 = new MagicString(code);
  const staticImports = (await Promise.all(matches2.map(async ({ globs, globsResolved, isRelative: isRelative3, options: options3, index: index2, start, end }) => {
    var _a;
    const cwd = getCommonBase(globsResolved) ?? root;
    const files = (await out(globsResolved, {
      cwd,
      absolute: true,
      dot: !!options3.exhaustive,
      ignore: options3.exhaustive ? [] : [join(cwd, "**/node_modules/**")]
    })).filter((file) => file !== id).sort();
    const objectProps = [];
    const staticImports2 = [];
    let query = !options3.query ? "" : typeof options3.query === "string" ? options3.query : stringifyQuery(options3.query);
    if (query && !query.startsWith("?"))
      query = `?${query}`;
    const resolvePaths2 = (file) => {
      if (!dir) {
        if (isRelative3)
          throw new Error("In virtual modules, all globs must start with '/'");
        const filePath2 = `/${relative(root, file)}`;
        return { filePath: filePath2, importPath: filePath2 };
      }
      let importPath = relative(dir, file);
      if (!importPath.startsWith("."))
        importPath = `./${importPath}`;
      let filePath;
      if (isRelative3) {
        filePath = importPath;
      } else {
        filePath = relative(root, file);
        if (!filePath.startsWith("."))
          filePath = `/${filePath}`;
      }
      return { filePath, importPath };
    };
    let includesCSS = false;
    files.forEach((file, i2) => {
      const paths = resolvePaths2(file);
      const filePath = paths.filePath;
      let importPath = paths.importPath;
      let importQuery = query;
      if (importQuery && importQuery !== "?raw") {
        const fileExtension = basename(file).split(".").slice(-1)[0];
        if (fileExtension && restoreQueryExtension)
          importQuery = `${importQuery}&lang.${fileExtension}`;
      }
      importPath = `${importPath}${importQuery}`;
      const isCSS = !query && isCSSRequest(file) && !isModuleCSSRequest(file);
      includesCSS || (includesCSS = isCSS);
      const importKey = options3.import && options3.import !== "*" ? options3.import : void 0;
      if (options3.eager) {
        const variableName = `${importPrefix}${index2}_${i2}`;
        const expression = importKey ? `{ ${importKey} as ${variableName} }` : `* as ${variableName}`;
        staticImports2.push(`import ${expression} from ${JSON.stringify(importPath)}`);
        if (!isProduction && isCSS) {
          objectProps.push(`get ${JSON.stringify(filePath)}() { ${createCssDefaultImportWarning(globs, options3)} return ${variableName} }`);
        } else {
          objectProps.push(`${JSON.stringify(filePath)}: ${variableName}`);
        }
      } else {
        let importStatement = `import(${JSON.stringify(importPath)})`;
        if (importKey)
          importStatement += `.then(m => m[${JSON.stringify(importKey)}])`;
        if (!isProduction && isCSS) {
          objectProps.push(`${JSON.stringify(filePath)}: () => { ${createCssDefaultImportWarning(globs, options3)} return ${importStatement}}`);
        } else {
          objectProps.push(`${JSON.stringify(filePath)}: () => ${importStatement}`);
        }
      }
    });
    files.forEach((i2) => matchedFiles.add(i2));
    const originalLineBreakCount = ((_a = code.slice(start, end).match(/\n/g)) == null ? void 0 : _a.length) ?? 0;
    const lineBreaks = originalLineBreakCount > 0 ? "\n".repeat(originalLineBreakCount) : "";
    let replacement;
    if (!isProduction && includesCSS) {
      replacement = `/* #__PURE__ */ Object.assign((() => {let ${warnedCSSDefaultImportVarName} = false;return {${objectProps.join(",")}${lineBreaks}};})())`;
    } else {
      replacement = `/* #__PURE__ */ Object.assign({${objectProps.join(",")}${lineBreaks}})`;
    }
    s2.overwrite(start, end, replacement);
    return staticImports2;
  }))).flat();
  if (staticImports.length)
    s2.prepend(`${staticImports.join(";")};`);
  return {
    s: s2,
    matches: matches2,
    files: matchedFiles
  };
}
function globSafePath(path8) {
  return out.escapePath(normalizePath$3(path8));
}
function lastNthChar(str2, n3) {
  return str2.charAt(str2.length - 1 - n3);
}
function globSafeResolvedPath(resolved, glob2) {
  let numEqual = 0;
  const maxEqual = Math.min(resolved.length, glob2.length);
  while (numEqual < maxEqual && lastNthChar(resolved, numEqual) === lastNthChar(glob2, numEqual)) {
    numEqual += 1;
  }
  const staticPartEnd = resolved.length - numEqual;
  const staticPart = resolved.slice(0, staticPartEnd);
  const dynamicPart = resolved.slice(staticPartEnd);
  return globSafePath(staticPart) + dynamicPart;
}
async function toAbsoluteGlob(glob2, root, importer, resolveId) {
  let pre = "";
  if (glob2.startsWith("!")) {
    pre = "!";
    glob2 = glob2.slice(1);
  }
  root = globSafePath(root);
  const dir = importer ? globSafePath(dirname(importer)) : root;
  if (glob2.startsWith("/"))
    return pre + import_node_path4.posix.join(root, glob2.slice(1));
  if (glob2.startsWith("./"))
    return pre + import_node_path4.posix.join(dir, glob2.slice(2));
  if (glob2.startsWith("../"))
    return pre + import_node_path4.posix.join(dir, glob2);
  if (glob2.startsWith("**"))
    return pre + glob2;
  const resolved = normalizePath$3(await resolveId(glob2, importer) || glob2);
  if ((0, import_node_path4.isAbsolute)(resolved)) {
    return pre + globSafeResolvedPath(resolved, glob2);
  }
  throw new Error(`Invalid glob: "${glob2}" (resolved: "${resolved}"). It must start with '/' or './'`);
}
function getCommonBase(globsResolved) {
  const bases = globsResolved.filter((g) => !g.startsWith("!")).map((glob2) => {
    let { base: base2 } = scan(glob2);
    if (import_node_path4.posix.basename(base2).includes("."))
      base2 = import_node_path4.posix.dirname(base2);
    return base2;
  });
  if (!bases.length)
    return null;
  let commonAncestor = "";
  const dirS = bases[0].split("/");
  for (let i2 = 0; i2 < dirS.length; i2++) {
    const candidate = dirS.slice(0, i2 + 1).join("/");
    if (bases.every((base2) => base2.startsWith(candidate)))
      commonAncestor = candidate;
    else
      break;
  }
  if (!commonAncestor)
    commonAncestor = "/";
  return commonAncestor;
}
function isVirtualModule(id) {
  return id.startsWith("virtual:") || id.startsWith("\0") || !id.includes("/");
}
var debugHmr = createDebugger("vite:hmr");
var normalizedClientDir = normalizePath$3(CLIENT_DIR);
function getShortName(file, root) {
  return file.startsWith(root + "/") ? import_node_path4.default.posix.relative(root, file) : file;
}
async function handleHMRUpdate(file, server2) {
  const { ws, config: config2, moduleGraph } = server2;
  const shortFile = getShortName(file, config2.root);
  const fileName = import_node_path4.default.basename(file);
  const isConfig = file === config2.configFile;
  const isConfigDependency = config2.configFileDependencies.some((name2) => file === name2);
  const isEnv = config2.inlineConfig.envFile !== false && (fileName === ".env" || fileName.startsWith(".env."));
  if (isConfig || isConfigDependency || isEnv) {
    debugHmr(`[config change] ${picocolorsExports.dim(shortFile)}`);
    config2.logger.info(picocolorsExports.green(`${import_node_path4.default.relative(process.cwd(), file)} changed, restarting server...`), { clear: true, timestamp: true });
    try {
      await server2.restart();
    } catch (e3) {
      config2.logger.error(picocolorsExports.red(e3));
    }
    return;
  }
  debugHmr(`[file change] ${picocolorsExports.dim(shortFile)}`);
  if (file.startsWith(normalizedClientDir)) {
    ws.send({
      type: "full-reload",
      path: "*"
    });
    return;
  }
  const mods = moduleGraph.getModulesByFile(file);
  const timestamp3 = Date.now();
  const hmrContext = {
    file,
    timestamp: timestamp3,
    modules: mods ? [...mods] : [],
    read: () => readModifiedFile(file),
    server: server2
  };
  for (const hook of config2.getSortedPluginHooks("handleHotUpdate")) {
    const filteredModules = await hook(hmrContext);
    if (filteredModules) {
      hmrContext.modules = filteredModules;
    }
  }
  if (!hmrContext.modules.length) {
    if (file.endsWith(".html")) {
      config2.logger.info(picocolorsExports.green(`page reload `) + picocolorsExports.dim(shortFile), {
        clear: true,
        timestamp: true
      });
      ws.send({
        type: "full-reload",
        path: config2.server.middlewareMode ? "*" : "/" + normalizePath$3(import_node_path4.default.relative(config2.root, file))
      });
    } else {
      debugHmr(`[no modules matched] ${picocolorsExports.dim(shortFile)}`);
    }
    return;
  }
  updateModules(shortFile, hmrContext.modules, timestamp3, server2);
}
function updateModules(file, modules, timestamp3, { config: config2, ws, moduleGraph }, afterInvalidation) {
  const updates = [];
  const invalidatedModules = /* @__PURE__ */ new Set();
  let needFullReload = false;
  for (const mod of modules) {
    moduleGraph.invalidateModule(mod, invalidatedModules, timestamp3, true);
    if (needFullReload) {
      continue;
    }
    const boundaries = /* @__PURE__ */ new Set();
    const hasDeadEnd = propagateUpdate(mod, boundaries);
    if (hasDeadEnd) {
      needFullReload = true;
      continue;
    }
    updates.push(...[...boundaries].map(({ boundary, acceptedVia }) => ({
      type: `${boundary.type}-update`,
      timestamp: timestamp3,
      path: normalizeHmrUrl(boundary.url),
      explicitImportRequired: boundary.type === "js" ? isExplicitImportRequired(acceptedVia.url) : void 0,
      acceptedPath: normalizeHmrUrl(acceptedVia.url)
    })));
  }
  if (needFullReload) {
    config2.logger.info(picocolorsExports.green(`page reload `) + picocolorsExports.dim(file), {
      clear: !afterInvalidation,
      timestamp: true
    });
    ws.send({
      type: "full-reload"
    });
    return;
  }
  if (updates.length === 0) {
    debugHmr(picocolorsExports.yellow(`no update happened `) + picocolorsExports.dim(file));
    return;
  }
  config2.logger.info(picocolorsExports.green(`hmr update `) + picocolorsExports.dim([...new Set(updates.map((u2) => u2.path))].join(", ")), { clear: !afterInvalidation, timestamp: true });
  ws.send({
    type: "update",
    updates
  });
}
async function handleFileAddUnlink(file, server2) {
  const modules = [...server2.moduleGraph.getModulesByFile(file) || []];
  modules.push(...getAffectedGlobModules(file, server2));
  if (modules.length > 0) {
    updateModules(getShortName(file, server2.config.root), unique(modules), Date.now(), server2);
  }
}
function areAllImportsAccepted(importedBindings, acceptedExports) {
  for (const binding of importedBindings) {
    if (!acceptedExports.has(binding)) {
      return false;
    }
  }
  return true;
}
function propagateUpdate(node3, boundaries, currentChain = [node3]) {
  if (node3.id && node3.isSelfAccepting === void 0) {
    debugHmr(`[propagate update] stop propagation because not analyzed: ${picocolorsExports.dim(node3.id)}`);
    return false;
  }
  if (node3.isSelfAccepting) {
    boundaries.add({
      boundary: node3,
      acceptedVia: node3
    });
    for (const importer of node3.importers) {
      if (isCSSRequest(importer.url) && !currentChain.includes(importer)) {
        propagateUpdate(importer, boundaries, currentChain.concat(importer));
      }
    }
    return false;
  }
  if (node3.acceptedHmrExports) {
    boundaries.add({
      boundary: node3,
      acceptedVia: node3
    });
  } else {
    if (!node3.importers.size) {
      return true;
    }
    if (!isCSSRequest(node3.url) && [...node3.importers].every((i2) => isCSSRequest(i2.url))) {
      return true;
    }
  }
  for (const importer of node3.importers) {
    const subChain = currentChain.concat(importer);
    if (importer.acceptedHmrDeps.has(node3)) {
      boundaries.add({
        boundary: importer,
        acceptedVia: node3
      });
      continue;
    }
    if (node3.id && node3.acceptedHmrExports && importer.importedBindings) {
      const importedBindingsFromNode = importer.importedBindings.get(node3.id);
      if (importedBindingsFromNode && areAllImportsAccepted(importedBindingsFromNode, node3.acceptedHmrExports)) {
        continue;
      }
    }
    if (currentChain.includes(importer)) {
      return true;
    }
    if (propagateUpdate(importer, boundaries, subChain)) {
      return true;
    }
  }
  return false;
}
function handlePrunedModules(mods, { ws }) {
  const t3 = Date.now();
  mods.forEach((mod) => {
    mod.lastHMRTimestamp = t3;
    debugHmr(`[dispose] ${picocolorsExports.dim(mod.file)}`);
  });
  ws.send({
    type: "prune",
    paths: [...mods].map((m) => m.url)
  });
}
function lexAcceptedHmrDeps(code, start, urls) {
  let state = 0;
  let prevState = 0;
  let currentDep = "";
  function addDep(index2) {
    urls.add({
      url: currentDep,
      start: index2 - currentDep.length - 1,
      end: index2 + 1
    });
    currentDep = "";
  }
  for (let i2 = start; i2 < code.length; i2++) {
    const char = code.charAt(i2);
    switch (state) {
      case 0:
      case 4:
        if (char === `'`) {
          prevState = state;
          state = 1;
        } else if (char === `"`) {
          prevState = state;
          state = 2;
        } else if (char === "`") {
          prevState = state;
          state = 3;
        } else if (/\s/.test(char)) {
          continue;
        } else {
          if (state === 0) {
            if (char === `[`) {
              state = 4;
            } else {
              return true;
            }
          } else if (state === 4) {
            if (char === `]`) {
              return false;
            } else if (char === ",") {
              continue;
            } else {
              error$1(i2);
            }
          }
        }
        break;
      case 1:
        if (char === `'`) {
          addDep(i2);
          if (prevState === 0) {
            return false;
          } else {
            state = prevState;
          }
        } else {
          currentDep += char;
        }
        break;
      case 2:
        if (char === `"`) {
          addDep(i2);
          if (prevState === 0) {
            return false;
          } else {
            state = prevState;
          }
        } else {
          currentDep += char;
        }
        break;
      case 3:
        if (char === "`") {
          addDep(i2);
          if (prevState === 0) {
            return false;
          } else {
            state = prevState;
          }
        } else if (char === "$" && code.charAt(i2 + 1) === "{") {
          error$1(i2);
        } else {
          currentDep += char;
        }
        break;
      default:
        throw new Error("unknown import.meta.hot lexer state");
    }
  }
  return false;
}
function lexAcceptedHmrExports(code, start, exportNames) {
  const urls = /* @__PURE__ */ new Set();
  lexAcceptedHmrDeps(code, start, urls);
  for (const { url: url2 } of urls) {
    exportNames.add(url2);
  }
  return urls.size > 0;
}
function normalizeHmrUrl(url2) {
  if (!url2.startsWith(".") && !url2.startsWith("/")) {
    url2 = wrapId(url2);
  }
  return url2;
}
function error$1(pos) {
  const err2 = new Error(`import.meta.hot.accept() can only accept string literals or an Array of string literals.`);
  err2.pos = pos;
  throw err2;
}
async function readModifiedFile(file) {
  const content = import_node_fs4.default.readFileSync(file, "utf-8");
  if (!content) {
    const mtime = import_node_fs4.default.statSync(file).mtimeMs;
    await new Promise((r3) => {
      let n3 = 0;
      const poll = async () => {
        n3++;
        const newMtime = import_node_fs4.default.statSync(file).mtimeMs;
        if (newMtime !== mtime || n3 > 10) {
          r3(0);
        } else {
          setTimeout(poll, 10);
        }
      };
      setTimeout(poll, 10);
    });
    return import_node_fs4.default.readFileSync(file, "utf-8");
  } else {
    return content;
  }
}
var etag_1 = etag;
var crypto = import_crypto.default;
var Stats = import_fs.default.Stats;
var toString = Object.prototype.toString;
function entitytag(entity) {
  if (entity.length === 0) {
    return '"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk"';
  }
  var hash2 = crypto.createHash("sha1").update(entity, "utf8").digest("base64").substring(0, 27);
  var len = typeof entity === "string" ? Buffer.byteLength(entity, "utf8") : entity.length;
  return '"' + len.toString(16) + "-" + hash2 + '"';
}
function etag(entity, options3) {
  if (entity == null) {
    throw new TypeError("argument entity is required");
  }
  var isStats = isstats(entity);
  var weak = options3 && typeof options3.weak === "boolean" ? options3.weak : isStats;
  if (!isStats && typeof entity !== "string" && !Buffer.isBuffer(entity)) {
    throw new TypeError("argument entity must be string, Buffer, or fs.Stats");
  }
  var tag = isStats ? stattag(entity) : entitytag(entity);
  return weak ? "W/" + tag : tag;
}
function isstats(obj) {
  if (typeof Stats === "function" && obj instanceof Stats) {
    return true;
  }
  return obj && typeof obj === "object" && "ctime" in obj && toString.call(obj.ctime) === "[object Date]" && "mtime" in obj && toString.call(obj.mtime) === "[object Date]" && "ino" in obj && typeof obj.ino === "number" && "size" in obj && typeof obj.size === "number";
}
function stattag(stat2) {
  var mtime = stat2.mtime.getTime().toString(16);
  var size = stat2.size.toString(16);
  return '"' + size + "-" + mtime + '"';
}
var convertSourceMap = {};
(function(exports3) {
  Object.defineProperty(exports3, "commentRegex", {
    get: function getCommentRegex() {
      return /^\s*?\/[\/\*][@#]\s+?sourceMappingURL=data:(((?:application|text)\/json)(?:;charset=([^;,]+?)?)?)?(?:;(base64))?,(.*?)$/mg;
    }
  });
  Object.defineProperty(exports3, "mapFileCommentRegex", {
    get: function getMapFileCommentRegex() {
      return /(?:\/\/[@#][ \t]+?sourceMappingURL=([^\s'"`]+?)[ \t]*?$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^*]+?)[ \t]*?(?:\*\/){1}[ \t]*?$)/mg;
    }
  });
  var decodeBase64;
  if (typeof Buffer !== "undefined") {
    if (typeof Buffer.from === "function") {
      decodeBase64 = decodeBase64WithBufferFrom;
    } else {
      decodeBase64 = decodeBase64WithNewBuffer;
    }
  } else {
    decodeBase64 = decodeBase64WithAtob;
  }
  function decodeBase64WithBufferFrom(base64) {
    return Buffer.from(base64, "base64").toString();
  }
  function decodeBase64WithNewBuffer(base64) {
    if (typeof value === "number") {
      throw new TypeError("The value to decode must not be of type number.");
    }
    return new Buffer(base64, "base64").toString();
  }
  function decodeBase64WithAtob(base64) {
    return decodeURIComponent(escape(atob(base64)));
  }
  function stripComment(sm) {
    return sm.split(",").pop();
  }
  function readFromFileMap(sm, read2) {
    var r3 = exports3.mapFileCommentRegex.exec(sm);
    var filename = r3[1] || r3[2];
    try {
      var sm = read2(filename);
      if (sm != null && typeof sm.catch === "function") {
        return sm.catch(throwError);
      } else {
        return sm;
      }
    } catch (e3) {
      throwError(e3);
    }
    function throwError(e3) {
      throw new Error("An error occurred while trying to read the map file at " + filename + "\n" + e3.stack);
    }
  }
  function Converter(sm, opts) {
    opts = opts || {};
    if (opts.hasComment) {
      sm = stripComment(sm);
    }
    if (opts.encoding === "base64") {
      sm = decodeBase64(sm);
    } else if (opts.encoding === "uri") {
      sm = decodeURIComponent(sm);
    }
    if (opts.isJSON || opts.encoding) {
      sm = JSON.parse(sm);
    }
    this.sourcemap = sm;
  }
  Converter.prototype.toJSON = function(space) {
    return JSON.stringify(this.sourcemap, null, space);
  };
  if (typeof Buffer !== "undefined") {
    if (typeof Buffer.from === "function") {
      Converter.prototype.toBase64 = encodeBase64WithBufferFrom;
    } else {
      Converter.prototype.toBase64 = encodeBase64WithNewBuffer;
    }
  } else {
    Converter.prototype.toBase64 = encodeBase64WithBtoa;
  }
  function encodeBase64WithBufferFrom() {
    var json2 = this.toJSON();
    return Buffer.from(json2, "utf8").toString("base64");
  }
  function encodeBase64WithNewBuffer() {
    var json2 = this.toJSON();
    if (typeof json2 === "number") {
      throw new TypeError("The json to encode must not be of type number.");
    }
    return new Buffer(json2, "utf8").toString("base64");
  }
  function encodeBase64WithBtoa() {
    var json2 = this.toJSON();
    return btoa(unescape(encodeURIComponent(json2)));
  }
  Converter.prototype.toURI = function() {
    var json2 = this.toJSON();
    return encodeURIComponent(json2);
  };
  Converter.prototype.toComment = function(options3) {
    var encoding, content, data2;
    if (options3 != null && options3.encoding === "uri") {
      encoding = "";
      content = this.toURI();
    } else {
      encoding = ";base64";
      content = this.toBase64();
    }
    data2 = "sourceMappingURL=data:application/json;charset=utf-8" + encoding + "," + content;
    return options3 != null && options3.multiline ? "/*# " + data2 + " */" : "//# " + data2;
  };
  Converter.prototype.toObject = function() {
    return JSON.parse(this.toJSON());
  };
  Converter.prototype.addProperty = function(key, value2) {
    if (this.sourcemap.hasOwnProperty(key))
      throw new Error('property "' + key + '" already exists on the sourcemap, use set property instead');
    return this.setProperty(key, value2);
  };
  Converter.prototype.setProperty = function(key, value2) {
    this.sourcemap[key] = value2;
    return this;
  };
  Converter.prototype.getProperty = function(key) {
    return this.sourcemap[key];
  };
  exports3.fromObject = function(obj) {
    return new Converter(obj);
  };
  exports3.fromJSON = function(json2) {
    return new Converter(json2, { isJSON: true });
  };
  exports3.fromURI = function(uri) {
    return new Converter(uri, { encoding: "uri" });
  };
  exports3.fromBase64 = function(base64) {
    return new Converter(base64, { encoding: "base64" });
  };
  exports3.fromComment = function(comment2) {
    var m, encoding;
    comment2 = comment2.replace(/^\/\*/g, "//").replace(/\*\/$/g, "");
    m = exports3.commentRegex.exec(comment2);
    encoding = m && m[4] || "uri";
    return new Converter(comment2, { encoding, hasComment: true });
  };
  function makeConverter(sm) {
    return new Converter(sm, { isJSON: true });
  }
  exports3.fromMapFileComment = function(comment2, read2) {
    if (typeof read2 === "string") {
      throw new Error(
        "String directory paths are no longer supported with `fromMapFileComment`\nPlease review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading"
      );
    }
    var sm = readFromFileMap(comment2, read2);
    if (sm != null && typeof sm.then === "function") {
      return sm.then(makeConverter);
    } else {
      return makeConverter(sm);
    }
  };
  exports3.fromSource = function(content) {
    var m = content.match(exports3.commentRegex);
    return m ? exports3.fromComment(m.pop()) : null;
  };
  exports3.fromMapFileSource = function(content, read2) {
    if (typeof read2 === "string") {
      throw new Error(
        "String directory paths are no longer supported with `fromMapFileSource`\nPlease review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading"
      );
    }
    var m = content.match(exports3.mapFileCommentRegex);
    return m ? exports3.fromMapFileComment(m.pop(), read2) : null;
  };
  exports3.removeComments = function(src3) {
    return src3.replace(exports3.commentRegex, "");
  };
  exports3.removeMapFileComments = function(src3) {
    return src3.replace(exports3.mapFileCommentRegex, "");
  };
  exports3.generateMapFileComment = function(file, options3) {
    var data2 = "sourceMappingURL=" + file;
    return options3 && options3.multiline ? "/*# " + data2 + " */" : "//# " + data2;
  };
})(convertSourceMap);
function totalist(dir, callback, pre = "") {
  dir = (0, import_path.resolve)(".", dir);
  let arr = (0, import_fs.readdirSync)(dir);
  let i2 = 0, abs, stats;
  for (; i2 < arr.length; i2++) {
    abs = (0, import_path.join)(dir, arr[i2]);
    stats = (0, import_fs.statSync)(abs);
    stats.isDirectory() ? totalist(abs, callback, (0, import_path.join)(pre, arr[i2])) : callback((0, import_path.join)(pre, arr[i2]), abs, stats);
  }
}
function parse$9(req2) {
  let raw = req2.url;
  if (raw == null)
    return;
  let prev = req2._parsedUrl;
  if (prev && prev.raw === raw)
    return prev;
  let pathname = raw, search = "", query;
  if (raw.length > 1) {
    let idx = raw.indexOf("?", 1);
    if (idx !== -1) {
      search = raw.substring(idx);
      pathname = raw.substring(0, idx);
      if (search.length > 1) {
        query = qs.parse(search.substring(1));
      }
    }
  }
  return req2._parsedUrl = { pathname, search, query, raw };
}
var noop$2 = () => {
};
function isMatch(uri, arr) {
  for (let i2 = 0; i2 < arr.length; i2++) {
    if (arr[i2].test(uri))
      return true;
  }
}
function toAssume(uri, extns) {
  let i2 = 0, x, len = uri.length - 1;
  if (uri.charCodeAt(len) === 47) {
    uri = uri.substring(0, len);
  }
  let arr = [], tmp = `${uri}/index`;
  for (; i2 < extns.length; i2++) {
    x = extns[i2] ? `.${extns[i2]}` : "";
    if (uri)
      arr.push(uri + x);
    arr.push(tmp + x);
  }
  return arr;
}
function viaCache(cache2, uri, extns) {
  let i2 = 0, data2, arr = toAssume(uri, extns);
  for (; i2 < arr.length; i2++) {
    if (data2 = cache2[arr[i2]])
      return data2;
  }
}
function viaLocal(dir, isEtag, uri, extns, shouldServe) {
  let i2 = 0, arr = toAssume(uri, extns);
  let abs, stats, name2, headers;
  for (; i2 < arr.length; i2++) {
    abs = (0, import_path.normalize)((0, import_path.join)(dir, name2 = arr[i2]));
    if (abs.startsWith(dir) && require$$0$2.existsSync(abs)) {
      stats = require$$0$2.statSync(abs);
      if (stats.isDirectory())
        continue;
      if (shouldServe && !shouldServe(abs))
        continue;
      headers = toHeaders(name2, stats, isEtag);
      headers["Cache-Control"] = isEtag ? "no-cache" : "no-store";
      return { abs, stats, headers };
    }
  }
}
function is404(req2, res) {
  return res.statusCode = 404, res.end();
}
function send$2(req2, res, file, stats, headers) {
  let code = 200, tmp, opts = {};
  headers = { ...headers };
  for (let key in headers) {
    tmp = res.getHeader(key);
    if (tmp)
      headers[key] = tmp;
  }
  if (tmp = res.getHeader("content-type")) {
    headers["Content-Type"] = tmp;
  }
  if (req2.headers.range) {
    code = 206;
    let [x, y] = req2.headers.range.replace("bytes=", "").split("-");
    let end = opts.end = parseInt(y, 10) || stats.size - 1;
    let start = opts.start = parseInt(x, 10) || 0;
    if (start >= stats.size || end >= stats.size) {
      res.setHeader("Content-Range", `bytes */${stats.size}`);
      res.statusCode = 416;
      return res.end();
    }
    headers["Content-Range"] = `bytes ${start}-${end}/${stats.size}`;
    headers["Content-Length"] = end - start + 1;
    headers["Accept-Ranges"] = "bytes";
  }
  res.writeHead(code, headers);
  require$$0$2.createReadStream(file, opts).pipe(res);
}
var ENCODING = {
  ".br": "br",
  ".gz": "gzip"
};
function toHeaders(name2, stats, isEtag) {
  let enc = ENCODING[name2.slice(-3)];
  let ctype = lookup(name2.slice(0, enc && -3)) || "";
  if (ctype === "text/html")
    ctype += ";charset=utf-8";
  let headers = {
    "Content-Length": stats.size,
    "Content-Type": ctype,
    "Last-Modified": stats.mtime.toUTCString()
  };
  if (enc)
    headers["Content-Encoding"] = enc;
  if (isEtag)
    headers["ETag"] = `W/"${stats.size}-${stats.mtime.getTime()}"`;
  return headers;
}
function sirv(dir, opts = {}) {
  dir = (0, import_path.resolve)(dir || ".");
  let isNotFound = opts.onNoMatch || is404;
  let setHeaders2 = opts.setHeaders || noop$2;
  let extensions2 = opts.extensions || ["html", "htm"];
  let gzips = opts.gzip && extensions2.map((x) => `${x}.gz`).concat("gz");
  let brots = opts.brotli && extensions2.map((x) => `${x}.br`).concat("br");
  const FILES = {};
  let fallback = "/";
  let isEtag = !!opts.etag;
  let isSPA = !!opts.single;
  if (typeof opts.single === "string") {
    let idx = opts.single.lastIndexOf(".");
    fallback += !!~idx ? opts.single.substring(0, idx) : opts.single;
  }
  let ignores = [];
  if (opts.ignores !== false) {
    ignores.push(/[/]([A-Za-z\s\d~$._-]+\.\w+){1,}$/);
    if (opts.dotfiles)
      ignores.push(/\/\.\w/);
    else
      ignores.push(/\/\.well-known/);
    [].concat(opts.ignores || []).forEach((x) => {
      ignores.push(new RegExp(x, "i"));
    });
  }
  let cc = opts.maxAge != null && `public,max-age=${opts.maxAge}`;
  if (cc && opts.immutable)
    cc += ",immutable";
  else if (cc && opts.maxAge === 0)
    cc += ",must-revalidate";
  if (!opts.dev) {
    totalist(dir, (name2, abs, stats) => {
      if (/\.well-known[\\+\/]/.test(name2))
        ;
      else if (!opts.dotfiles && /(^\.|[\\+|\/+]\.)/.test(name2))
        return;
      let headers = toHeaders(name2, stats, isEtag);
      if (cc)
        headers["Cache-Control"] = cc;
      FILES["/" + name2.normalize().replace(/\\+/g, "/")] = { abs, stats, headers };
    });
  }
  let lookup2 = opts.dev ? viaLocal.bind(0, dir, isEtag) : viaCache.bind(0, FILES);
  return function(req2, res, next) {
    let extns = [""];
    let pathname = parse$9(req2).pathname;
    let val = req2.headers["accept-encoding"] || "";
    if (gzips && val.includes("gzip"))
      extns.unshift(...gzips);
    if (brots && /(br|brotli)/i.test(val))
      extns.unshift(...brots);
    extns.push(...extensions2);
    if (pathname.indexOf("%") !== -1) {
      try {
        pathname = decodeURIComponent(pathname);
      } catch (err2) {
      }
    }
    let data2 = lookup2(pathname, extns, opts.shouldServe) || isSPA && !isMatch(pathname, ignores) && lookup2(fallback, extns, opts.shouldServe);
    if (!data2)
      return next ? next() : isNotFound(req2, res);
    if (isEtag && req2.headers["if-none-match"] === data2.headers["ETag"]) {
      res.writeHead(304);
      return res.end();
    }
    if (gzips || brots) {
      res.setHeader("Vary", "Accept-Encoding");
    }
    setHeaders2(res, pathname, data2.stats);
    send$2(req2, res, data2.abs, data2.stats, data2.headers);
  };
}
var sirvOptions = ({ headers, shouldServe }) => {
  return {
    dev: true,
    etag: true,
    extensions: [],
    setHeaders(res, pathname) {
      if (/\.[tj]sx?$/.test(pathname)) {
        res.setHeader("Content-Type", "application/javascript");
      }
      if (headers) {
        for (const name2 in headers) {
          res.setHeader(name2, headers[name2]);
        }
      }
    },
    shouldServe
  };
};
function servePublicMiddleware(dir, headers) {
  const serve = sirv(dir, sirvOptions({
    headers,
    shouldServe: (filePath) => shouldServeFile(filePath, dir)
  }));
  return function viteServePublicMiddleware(req2, res, next) {
    if (isImportRequest(req2.url) || isInternalRequest(req2.url)) {
      return next();
    }
    serve(req2, res, next);
  };
}
function serveStaticMiddleware(dir, server2) {
  const serve = sirv(dir, sirvOptions({
    headers: server2.config.server.headers
  }));
  return function viteServeStaticMiddleware(req2, res, next) {
    const cleanedUrl = cleanUrl(req2.url);
    if (cleanedUrl.endsWith("/") || import_node_path4.default.extname(cleanedUrl) === ".html" || isInternalRequest(req2.url)) {
      return next();
    }
    const url2 = new URL(req2.url, "http://example.com");
    const pathname = decodeURIComponent(url2.pathname);
    let redirectedPathname;
    for (const { find: find2, replacement } of server2.config.resolve.alias) {
      const matches2 = typeof find2 === "string" ? pathname.startsWith(find2) : find2.test(pathname);
      if (matches2) {
        redirectedPathname = pathname.replace(find2, replacement);
        break;
      }
    }
    if (redirectedPathname) {
      if (redirectedPathname.startsWith(dir)) {
        redirectedPathname = redirectedPathname.slice(dir.length);
      }
    }
    const resolvedPathname = redirectedPathname || pathname;
    let fileUrl = import_node_path4.default.resolve(dir, resolvedPathname.replace(/^\//, ""));
    if (resolvedPathname.endsWith("/") && !fileUrl.endsWith("/")) {
      fileUrl = fileUrl + "/";
    }
    if (!ensureServingAccess(fileUrl, server2, res, next)) {
      return;
    }
    if (redirectedPathname) {
      url2.pathname = encodeURIComponent(redirectedPathname);
      req2.url = url2.href.slice(url2.origin.length);
    }
    serve(req2, res, next);
  };
}
function serveRawFsMiddleware(server2) {
  const serveFromRoot = sirv("/", sirvOptions({ headers: server2.config.server.headers }));
  return function viteServeRawFsMiddleware(req2, res, next) {
    const url2 = new URL(req2.url, "http://example.com");
    if (url2.pathname.startsWith(FS_PREFIX)) {
      const pathname = decodeURIComponent(url2.pathname);
      if (!ensureServingAccess(slash$1(import_node_path4.default.resolve(fsPathFromId(pathname))), server2, res, next)) {
        return;
      }
      let newPathname = pathname.slice(FS_PREFIX.length);
      if (isWindows$4)
        newPathname = newPathname.replace(/^[A-Z]:/i, "");
      url2.pathname = encodeURIComponent(newPathname);
      req2.url = url2.href.slice(url2.origin.length);
      serveFromRoot(req2, res, next);
    } else {
      next();
    }
  };
}
function isFileServingAllowed(url2, server2) {
  if (!server2.config.server.fs.strict)
    return true;
  const file = fsPathFromUrl(url2);
  if (server2._fsDenyGlob(file))
    return false;
  if (server2.moduleGraph.safeModulesPath.has(file))
    return true;
  if (server2.config.server.fs.allow.some((dir) => isParentDirectory(dir, file)))
    return true;
  return false;
}
function ensureServingAccess(url2, server2, res, next) {
  if (isFileServingAllowed(url2, server2)) {
    return true;
  }
  if (isFileReadable(cleanUrl(url2))) {
    const urlMessage = `The request url "${url2}" is outside of Vite serving allow list.`;
    const hintMessage = `
${server2.config.server.fs.allow.map((i2) => `- ${i2}`).join("\n")}

Refer to docs https://vitejs.dev/config/server-options.html#server-fs-allow for configurations and more details.`;
    server2.config.logger.error(urlMessage);
    server2.config.logger.warnOnce(hintMessage + "\n");
    res.statusCode = 403;
    res.write(renderRestrictedErrorHTML(urlMessage + "\n" + hintMessage));
    res.end();
  } else {
    next();
  }
  return false;
}
function renderRestrictedErrorHTML(msg) {
  const html = String.raw;
  return html`
    <body>
      <h1>403 Restricted</h1>
      <p>${msg.replace(/\n/g, "<br/>")}</p>
      <style>
        body {
          padding: 1em 2em;
        }
      </style>
    </body>
  `;
}
var ERR_LOAD_URL = "ERR_LOAD_URL";
var ERR_LOAD_PUBLIC_URL = "ERR_LOAD_PUBLIC_URL";
var debugLoad = createDebugger("vite:load");
var debugTransform = createDebugger("vite:transform");
var debugCache$1 = createDebugger("vite:cache");
var isDebug$2 = !!process.env.DEBUG;
function transformRequest(url2, server2, options3 = {}) {
  const cacheKey = (options3.ssr ? "ssr:" : options3.html ? "html:" : "") + url2;
  const timestamp3 = Date.now();
  const pending = server2._pendingRequests.get(cacheKey);
  if (pending) {
    return server2.moduleGraph.getModuleByUrl(removeTimestampQuery(url2), options3.ssr).then((module2) => {
      if (!module2 || pending.timestamp > module2.lastInvalidationTimestamp) {
        return pending.request;
      } else {
        pending.abort();
        return transformRequest(url2, server2, options3);
      }
    });
  }
  const request = doTransform(url2, server2, options3, timestamp3);
  let cleared = false;
  const clearCache = () => {
    if (!cleared) {
      server2._pendingRequests.delete(cacheKey);
      cleared = true;
    }
  };
  server2._pendingRequests.set(cacheKey, {
    request,
    timestamp: timestamp3,
    abort: clearCache
  });
  request.then(clearCache, clearCache);
  return request;
}
async function doTransform(url2, server2, options3, timestamp3) {
  var _a, _b;
  url2 = removeTimestampQuery(url2);
  const { config: config2, pluginContainer } = server2;
  const prettyUrl = isDebug$2 ? prettifyUrl(url2, config2.root) : "";
  const ssr = !!options3.ssr;
  const module2 = await server2.moduleGraph.getModuleByUrl(url2, ssr);
  const cached = module2 && (ssr ? module2.ssrTransformResult : module2.transformResult);
  if (cached) {
    isDebug$2 && debugCache$1(`[memory] ${prettyUrl}`);
    return cached;
  }
  const id = ((_a = await pluginContainer.resolveId(url2, void 0, { ssr })) == null ? void 0 : _a.id) || url2;
  const result = loadAndTransform(id, url2, server2, options3, timestamp3);
  (_b = getDepsOptimizer(config2, ssr)) == null ? void 0 : _b.delayDepsOptimizerUntil(id, () => result);
  return result;
}
async function loadAndTransform(id, url2, server2, options3, timestamp3) {
  var _a, _b;
  const { config: config2, pluginContainer, moduleGraph, watcher } = server2;
  const { root, logger: logger2 } = config2;
  const prettyUrl = isDebug$2 ? prettifyUrl(url2, config2.root) : "";
  const ssr = !!options3.ssr;
  const file = cleanUrl(id);
  let code = null;
  let map3 = null;
  const loadStart = isDebug$2 ? import_node_perf_hooks.performance.now() : 0;
  const loadResult = await pluginContainer.load(id, { ssr });
  if (loadResult == null) {
    if (options3.html && !id.endsWith(".html")) {
      return null;
    }
    if (options3.ssr || isFileServingAllowed(file, server2)) {
      try {
        code = await import_node_fs4.promises.readFile(file, "utf-8");
        isDebug$2 && debugLoad(`${timeFrom(loadStart)} [fs] ${prettyUrl}`);
      } catch (e3) {
        if (e3.code !== "ENOENT") {
          throw e3;
        }
      }
    }
    if (code) {
      try {
        map3 = (_a = convertSourceMap.fromSource(code) || await convertSourceMap.fromMapFileSource(code, createConvertSourceMapReadMap(file))) == null ? void 0 : _a.toObject();
        code = code.replace(convertSourceMap.mapFileCommentRegex, blankReplacer);
      } catch (e3) {
        logger2.warn(`Failed to load source map for ${url2}.`, {
          timestamp: true
        });
      }
    }
  } else {
    isDebug$2 && debugLoad(`${timeFrom(loadStart)} [plugin] ${prettyUrl}`);
    if (isObject$1(loadResult)) {
      code = loadResult.code;
      map3 = loadResult.map;
    } else {
      code = loadResult;
    }
  }
  if (code == null) {
    const isPublicFile = checkPublicFile(url2, config2);
    const msg = isPublicFile ? `This file is in /public and will be copied as-is during build without going through the plugin transforms, and therefore should not be imported from source code. It can only be referenced via HTML tags.` : `Does the file exist?`;
    const importerMod = (_b = server2.moduleGraph.idToModuleMap.get(id)) == null ? void 0 : _b.importers.values().next().value;
    const importer = (importerMod == null ? void 0 : importerMod.file) || (importerMod == null ? void 0 : importerMod.url);
    const err2 = new Error(`Failed to load url ${url2} (resolved id: ${id})${importer ? ` in ${importer}` : ""}. ${msg}`);
    err2.code = isPublicFile ? ERR_LOAD_PUBLIC_URL : ERR_LOAD_URL;
    throw err2;
  }
  const mod = await moduleGraph.ensureEntryFromUrl(url2, ssr);
  ensureWatchedFile(watcher, mod.file, root);
  const transformStart = isDebug$2 ? import_node_perf_hooks.performance.now() : 0;
  const transformResult = await pluginContainer.transform(code, id, {
    inMap: map3,
    ssr
  });
  const originalCode = code;
  if (transformResult == null || isObject$1(transformResult) && transformResult.code == null) {
    isDebug$2 && debugTransform(timeFrom(transformStart) + picocolorsExports.dim(` [skipped] ${prettyUrl}`));
  } else {
    isDebug$2 && debugTransform(`${timeFrom(transformStart)} ${prettyUrl}`);
    code = transformResult.code;
    map3 = transformResult.map;
  }
  if (map3 && mod.file) {
    map3 = typeof map3 === "string" ? JSON.parse(map3) : map3;
    if (map3.mappings && !map3.sourcesContent) {
      await injectSourcesContent(map3, mod.file, logger2);
    }
  }
  const result = ssr && !server2.config.experimental.skipSsrTransform ? await server2.ssrTransform(code, map3, url2, originalCode) : {
    code,
    map: map3,
    etag: etag_1(code, { weak: true })
  };
  if (timestamp3 > mod.lastInvalidationTimestamp) {
    if (ssr)
      mod.ssrTransformResult = result;
    else
      mod.transformResult = result;
  }
  return result;
}
function createConvertSourceMapReadMap(originalFileName) {
  return (filename) => {
    return import_node_fs4.promises.readFile(import_node_path4.default.resolve(import_node_path4.default.dirname(originalFileName), filename), "utf-8");
  };
}
var isDebug$1 = !!process.env.DEBUG;
var debug$9 = createDebugger("vite:import-analysis");
var clientDir = normalizePath$3(CLIENT_DIR);
var skipRE = /\.(?:map|json)(?:$|\?)/;
var canSkipImportAnalysis = (id) => skipRE.test(id) || isDirectCSSRequest(id);
var optimizedDepChunkRE$1 = /\/chunk-[A-Z\d]{8}\.js/;
var optimizedDepDynamicRE$1 = /-[A-Z\d]{8}\.js/;
function isExplicitImportRequired(url2) {
  return !isJSRequest(cleanUrl(url2)) && !isCSSRequest(url2);
}
function markExplicitImport(url2) {
  if (isExplicitImportRequired(url2)) {
    return injectQuery(url2, "import");
  }
  return url2;
}
function extractImportedBindings(id, source, importSpec, importedBindings) {
  let bindings = importedBindings.get(id);
  if (!bindings) {
    bindings = /* @__PURE__ */ new Set();
    importedBindings.set(id, bindings);
  }
  const isDynamic = importSpec.d > -1;
  const isMeta = importSpec.d === -2;
  if (isDynamic || isMeta) {
    bindings.add("*");
    return;
  }
  const exp = source.slice(importSpec.ss, importSpec.se);
  const [match0] = findStaticImports(exp);
  if (!match0) {
    return;
  }
  const parsed = parseStaticImport(match0);
  if (!parsed) {
    return;
  }
  if (parsed.namespacedImport) {
    bindings.add("*");
  }
  if (parsed.defaultImport) {
    bindings.add("default");
  }
  if (parsed.namedImports) {
    for (const name2 of Object.keys(parsed.namedImports)) {
      bindings.add(name2);
    }
  }
}
function importAnalysisPlugin(config2) {
  var _a;
  const { root, base: base2 } = config2;
  const clientPublicPath = import_node_path4.default.posix.join(base2, CLIENT_PUBLIC_PATH);
  const enablePartialAccept = (_a = config2.experimental) == null ? void 0 : _a.hmrPartialAccept;
  let server2;
  return {
    name: "vite:import-analysis",
    configureServer(_server) {
      server2 = _server;
    },
    async transform(source, importer, options3) {
      var _a2;
      if (!server2) {
        return null;
      }
      const ssr = (options3 == null ? void 0 : options3.ssr) === true;
      const prettyImporter = prettifyUrl(importer, root);
      if (canSkipImportAnalysis(importer)) {
        isDebug$1 && debug$9(picocolorsExports.dim(`[skipped] ${prettyImporter}`));
        return null;
      }
      const start = import_node_perf_hooks.performance.now();
      await init;
      let imports;
      let exports3;
      source = stripBomTag(source);
      try {
        [imports, exports3] = parse$e(source);
      } catch (e3) {
        const isVue = importer.endsWith(".vue");
        const maybeJSX = !isVue && isJSRequest(importer);
        const msg = isVue ? `Install @vitejs/plugin-vue to handle .vue files.` : maybeJSX ? `If you are using JSX, make sure to name the file with the .jsx or .tsx extension.` : `You may need to install appropriate plugins to handle the ${import_node_path4.default.extname(importer)} file format, or if it's an asset, add "**/*${import_node_path4.default.extname(importer)}" to \`assetsInclude\` in your configuration.`;
        this.error(`Failed to parse source for import analysis because the content contains invalid JS syntax. ` + msg, e3.idx);
      }
      const depsOptimizer = getDepsOptimizer(config2, ssr);
      const { moduleGraph } = server2;
      const importerModule = moduleGraph.getModuleById(importer);
      if (!importerModule && (depsOptimizer == null ? void 0 : depsOptimizer.isOptimizedDepFile(importer))) {
        throwOutdatedRequest(importer);
      }
      if (!imports.length && !this._addedImports) {
        importerModule.isSelfAccepting = false;
        isDebug$1 && debug$9(`${timeFrom(start)} ${picocolorsExports.dim(`[no imports] ${prettyImporter}`)}`);
        return source;
      }
      let hasHMR = false;
      let isSelfAccepting = false;
      let hasEnv = false;
      let needQueryInjectHelper = false;
      let s2;
      const str2 = () => s2 || (s2 = new MagicString(source));
      const importedUrls = /* @__PURE__ */ new Set();
      const staticImportedUrls = /* @__PURE__ */ new Set();
      const acceptedUrls = /* @__PURE__ */ new Set();
      let isPartiallySelfAccepting = false;
      const acceptedExports = /* @__PURE__ */ new Set();
      const importedBindings = enablePartialAccept ? /* @__PURE__ */ new Map() : null;
      const toAbsoluteUrl = (url2) => import_node_path4.default.posix.resolve(import_node_path4.default.posix.dirname(importerModule.url), url2);
      const normalizeUrl = async (url2, pos, forceSkipImportAnalysis = false) => {
        url2 = stripBase(url2, base2);
        let importerFile = importer;
        const optimizeDeps2 = getDepOptimizationConfig(config2, ssr);
        if (moduleListContains(optimizeDeps2 == null ? void 0 : optimizeDeps2.exclude, url2)) {
          if (depsOptimizer) {
            await depsOptimizer.scanProcessing;
            for (const optimizedModule of depsOptimizer.metadata.depInfoList) {
              if (!optimizedModule.src)
                continue;
              if (optimizedModule.file === importerModule.file) {
                importerFile = optimizedModule.src;
              }
            }
          }
        }
        const resolved = await this.resolve(url2, importerFile);
        if (!resolved) {
          if (ssr) {
            return [url2, url2];
          }
          importerModule.isSelfAccepting = false;
          return this.error(`Failed to resolve import "${url2}" from "${import_node_path4.default.relative(process.cwd(), importerFile)}". Does the file exist?`, pos);
        }
        const isRelative3 = url2.startsWith(".");
        const isSelfImport = !isRelative3 && cleanUrl(url2) === cleanUrl(importer);
        if (resolved.id.startsWith(root + "/")) {
          url2 = resolved.id.slice(root.length);
        } else if (resolved.id.startsWith(getDepsCacheDirPrefix(config2)) || import_node_fs4.default.existsSync(cleanUrl(resolved.id))) {
          url2 = import_node_path4.default.posix.join(FS_PREFIX, resolved.id);
        } else {
          url2 = resolved.id;
        }
        if (isExternalUrl(url2)) {
          return [url2, url2];
        }
        if (!url2.startsWith(".") && !url2.startsWith("/")) {
          url2 = wrapId(resolved.id);
        }
        if (!ssr) {
          url2 = markExplicitImport(url2);
          if ((isRelative3 || isSelfImport) && !/[?&]import=?\b/.test(url2) && !url2.match(DEP_VERSION_RE)) {
            const versionMatch = importer.match(DEP_VERSION_RE);
            if (versionMatch) {
              url2 = injectQuery(url2, versionMatch[1]);
            }
          }
          try {
            const depModule = await moduleGraph.ensureEntryFromUrl(unwrapId(url2), ssr, canSkipImportAnalysis(url2) || forceSkipImportAnalysis);
            if (depModule.lastHMRTimestamp > 0) {
              url2 = injectQuery(url2, `t=${depModule.lastHMRTimestamp}`);
            }
          } catch (e3) {
            e3.pos = pos;
            throw e3;
          }
          url2 = joinUrlSegments(base2, url2);
        }
        return [url2, resolved.id];
      };
      for (let index2 = 0; index2 < imports.length; index2++) {
        const {
          s: start2,
          e: end,
          ss: expStart,
          se: expEnd,
          d: dynamicIndex,
          // #2083 User may use escape path,
          // so use imports[index].n to get the unescaped string
          n: specifier,
          a: assertIndex
        } = imports[index2];
        const rawUrl = source.slice(start2, end);
        if (rawUrl === "import.meta") {
          const prop = source.slice(end, end + 4);
          if (prop === ".hot") {
            hasHMR = true;
            const endHot = end + 4 + (source[end + 4] === "?" ? 1 : 0);
            if (source.slice(endHot, endHot + 7) === ".accept") {
              if (source.slice(endHot, endHot + 14) === ".acceptExports") {
                lexAcceptedHmrExports(source, source.indexOf("(", endHot + 14) + 1, acceptedExports);
                isPartiallySelfAccepting = true;
              } else if (lexAcceptedHmrDeps(source, source.indexOf("(", endHot + 7) + 1, acceptedUrls)) {
                isSelfAccepting = true;
              }
            }
          } else if (prop === ".env") {
            hasEnv = true;
          }
          continue;
        }
        const isDynamicImport = dynamicIndex > -1;
        if (!isDynamicImport && assertIndex > -1) {
          str2().remove(end + 1, expEnd);
        }
        if (specifier) {
          if (isExternalUrl(specifier) || isDataUrl(specifier)) {
            continue;
          }
          if (ssr) {
            if ((_a2 = config2.legacy) == null ? void 0 : _a2.buildSsrCjsExternalHeuristics) {
              if (cjsShouldExternalizeForSSR(specifier, server2._ssrExternals)) {
                continue;
              }
            } else if (shouldExternalizeForSSR(specifier, config2)) {
              continue;
            }
            if (isBuiltin(specifier)) {
              continue;
            }
          }
          if (specifier === clientPublicPath) {
            continue;
          }
          if (specifier.startsWith("/") && !config2.assetsInclude(cleanUrl(specifier)) && !specifier.endsWith(".json") && checkPublicFile(specifier, config2)) {
            throw new Error(`Cannot import non-asset file ${specifier} which is inside /public.JS/CSS files inside /public are copied as-is on build and can only be referenced via <script src> or <link href> in html.`);
          }
          const [url2, resolvedId] = await normalizeUrl(specifier, start2);
          if (!isDynamicImport && specifier && !specifier.includes("?") && // ignore custom queries
          isCSSRequest(resolvedId) && !isModuleCSSRequest(resolvedId)) {
            const sourceExp = source.slice(expStart, start2);
            if (sourceExp.includes("from") && // check default and named imports
            !sourceExp.includes("__vite_glob_")) {
              const newImport = sourceExp + specifier + `?inline` + source.slice(end, expEnd);
              this.warn(`
` + picocolorsExports.cyan(importerModule.file) + `
` + picocolorsExports.reset(generateCodeFrame(source, start2)) + `
` + picocolorsExports.yellow(`Default and named imports from CSS files are deprecated. Use the ?inline query instead. For example: ${newImport}`));
            }
          }
          server2 == null ? void 0 : server2.moduleGraph.safeModulesPath.add(fsPathFromUrl(url2));
          if (url2 !== specifier) {
            let rewriteDone = false;
            if ((depsOptimizer == null ? void 0 : depsOptimizer.isOptimizedDepFile(resolvedId)) && !resolvedId.match(optimizedDepChunkRE$1)) {
              const file = cleanUrl(resolvedId);
              const needsInterop2 = await optimizedDepNeedsInterop(depsOptimizer.metadata, file, config2, ssr);
              if (needsInterop2 === void 0) {
                if (!file.match(optimizedDepDynamicRE$1)) {
                  config2.logger.error(picocolorsExports.red(`Vite Error, ${url2} optimized info should be defined`));
                }
              } else if (needsInterop2) {
                debug$9(`${url2} needs interop`);
                interopNamedImports(str2(), imports[index2], url2, index2);
                rewriteDone = true;
              }
            } else if (url2.includes(browserExternalId) && source.slice(expStart, start2).includes("{")) {
              interopNamedImports(str2(), imports[index2], url2, index2);
              rewriteDone = true;
            }
            if (!rewriteDone) {
              let rewrittenUrl = JSON.stringify(url2);
              if (!isDynamicImport)
                rewrittenUrl = rewrittenUrl.slice(1, -1);
              str2().overwrite(start2, end, rewrittenUrl, {
                contentOnly: true
              });
            }
          }
          const hmrUrl = unwrapId(stripBase(url2, base2));
          importedUrls.add(hmrUrl);
          if (enablePartialAccept && importedBindings) {
            extractImportedBindings(resolvedId, source, imports[index2], importedBindings);
          }
          if (!isDynamicImport) {
            staticImportedUrls.add({ url: hmrUrl, id: resolvedId });
          }
        } else if (!importer.startsWith(clientDir)) {
          if (!importer.includes("node_modules")) {
            const hasViteIgnore = /\/\*\s*@vite-ignore\s*\*\//.test(
              // complete expression inside parens
              source.slice(dynamicIndex + 1, end)
            );
            if (!hasViteIgnore) {
              this.warn(`
` + picocolorsExports.cyan(importerModule.file) + `
` + picocolorsExports.reset(generateCodeFrame(source, start2)) + picocolorsExports.yellow(`
The above dynamic import cannot be analyzed by Vite.
See ${picocolorsExports.blue(`https://github.com/rollup/plugins/tree/master/packages/dynamic-import-vars#limitations`)} for supported dynamic import formats. If this is intended to be left as-is, you can use the /* @vite-ignore */ comment inside the import() call to suppress this warning.
`));
            }
          }
          if (!ssr) {
            const url2 = rawUrl.replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm, "").trim();
            if (!/^(?:'.*'|".*"|`.*`)$/.test(url2) || isExplicitImportRequired(url2.slice(1, -1))) {
              needQueryInjectHelper = true;
              str2().overwrite(start2, end, `__vite__injectQuery(${url2}, 'import')`, { contentOnly: true });
            }
          }
        }
      }
      if (hasEnv) {
        let env2 = `import.meta.env = ${JSON.stringify({
          ...config2.env,
          SSR: !!ssr
        })};`;
        for (const key in config2.define) {
          if (key.startsWith(`import.meta.env.`)) {
            const val = config2.define[key];
            env2 += `${key} = ${typeof val === "string" ? val : JSON.stringify(val)};`;
          }
        }
        str2().prepend(env2);
      }
      if (hasHMR && !ssr) {
        debugHmr(`${isSelfAccepting ? `[self-accepts]` : isPartiallySelfAccepting ? `[accepts-exports]` : acceptedUrls.size ? `[accepts-deps]` : `[detected api usage]`} ${prettyImporter}`);
        str2().prepend(`import { createHotContext as __vite__createHotContext } from "${clientPublicPath}";import.meta.hot = __vite__createHotContext(${JSON.stringify(normalizeHmrUrl(importerModule.url))});`);
      }
      if (needQueryInjectHelper) {
        str2().prepend(`import { injectQuery as __vite__injectQuery } from "${clientPublicPath}";`);
      }
      const normalizedAcceptedUrls = /* @__PURE__ */ new Set();
      for (const { url: url2, start: start2, end } of acceptedUrls) {
        const [normalized] = await moduleGraph.resolveUrl(toAbsoluteUrl(markExplicitImport(url2)), ssr);
        normalizedAcceptedUrls.add(normalized);
        str2().overwrite(start2, end, JSON.stringify(normalized), {
          contentOnly: true
        });
      }
      if (!isCSSRequest(importer)) {
        const pluginImports = this._addedImports;
        if (pluginImports) {
          (await Promise.all([...pluginImports].map((id) => normalizeUrl(id, 0, true)))).forEach(([url2]) => importedUrls.add(url2));
        }
        if (ssr && importerModule.isSelfAccepting) {
          isSelfAccepting = true;
        }
        if (!isSelfAccepting && isPartiallySelfAccepting && acceptedExports.size >= exports3.length && exports3.every((e3) => acceptedExports.has(e3.n))) {
          isSelfAccepting = true;
        }
        const prunedImports = await moduleGraph.updateModuleInfo(importerModule, importedUrls, importedBindings, normalizedAcceptedUrls, isPartiallySelfAccepting ? acceptedExports : null, isSelfAccepting, ssr);
        if (hasHMR && prunedImports) {
          handlePrunedModules(prunedImports, server2);
        }
      }
      isDebug$1 && debug$9(`${timeFrom(start)} ${picocolorsExports.dim(`[${importedUrls.size} imports rewritten] ${prettyImporter}`)}`);
      if (config2.server.preTransformRequests && staticImportedUrls.size) {
        staticImportedUrls.forEach(({ url: url2 }) => {
          url2 = removeImportQuery(url2);
          transformRequest(url2, server2, { ssr }).catch((e3) => {
            if ((e3 == null ? void 0 : e3.code) === ERR_OUTDATED_OPTIMIZED_DEP) {
              return;
            }
            config2.logger.error(e3.message);
          });
        });
      }
      if (s2) {
        return transformStableResult(s2, importer, config2);
      } else {
        return source;
      }
    }
  };
}
function interopNamedImports(str2, importSpecifier, rewrittenUrl, importIndex) {
  const source = str2.original;
  const { s: start, e: end, ss: expStart, se: expEnd, d: dynamicIndex } = importSpecifier;
  if (dynamicIndex > -1) {
    str2.overwrite(expStart, expEnd, `import('${rewrittenUrl}').then(m => m.default && m.default.__esModule ? m.default : ({ ...m.default, default: m.default }))`, { contentOnly: true });
  } else {
    const exp = source.slice(expStart, expEnd);
    const rawUrl = source.slice(start, end);
    const rewritten = transformCjsImport(exp, rewrittenUrl, rawUrl, importIndex);
    if (rewritten) {
      str2.overwrite(expStart, expEnd, rewritten, { contentOnly: true });
    } else {
      str2.overwrite(start, end, rewrittenUrl, { contentOnly: true });
    }
  }
}
function transformCjsImport(importExp, url2, rawUrl, importIndex) {
  const node3 = parse$d(importExp, {
    ecmaVersion: "latest",
    sourceType: "module"
  }).body[0];
  if (node3.type === "ImportDeclaration" || node3.type === "ExportNamedDeclaration") {
    if (!node3.specifiers.length) {
      return `import "${url2}"`;
    }
    const importNames = [];
    const exportNames = [];
    let defaultExports = "";
    for (const spec of node3.specifiers) {
      if (spec.type === "ImportSpecifier" && spec.imported.type === "Identifier") {
        const importedName = spec.imported.name;
        const localName = spec.local.name;
        importNames.push({ importedName, localName });
      } else if (spec.type === "ImportDefaultSpecifier") {
        importNames.push({
          importedName: "default",
          localName: spec.local.name
        });
      } else if (spec.type === "ImportNamespaceSpecifier") {
        importNames.push({ importedName: "*", localName: spec.local.name });
      } else if (spec.type === "ExportSpecifier" && spec.exported.type === "Identifier") {
        const importedName = spec.local.name;
        const exportedName = spec.exported.name;
        if (exportedName === "default") {
          defaultExports = makeLegalIdentifier(`__vite__cjsExportDefault_${importIndex}`);
          importNames.push({ importedName, localName: defaultExports });
        } else {
          const localName = makeLegalIdentifier(`__vite__cjsExport_${exportedName}`);
          importNames.push({ importedName, localName });
          exportNames.push(`${localName} as ${exportedName}`);
        }
      }
    }
    const cjsModuleName = makeLegalIdentifier(`__vite__cjsImport${importIndex}_${rawUrl}`);
    const lines = [`import ${cjsModuleName} from "${url2}"`];
    importNames.forEach(({ importedName, localName }) => {
      if (importedName === "*") {
        lines.push(`const ${localName} = ${cjsModuleName}`);
      } else if (importedName === "default") {
        lines.push(`const ${localName} = ${cjsModuleName}.__esModule ? ${cjsModuleName}.default : ${cjsModuleName}`);
      } else {
        lines.push(`const ${localName} = ${cjsModuleName}["${importedName}"]`);
      }
    });
    if (defaultExports) {
      lines.push(`export default ${defaultExports}`);
    }
    if (exportNames.length) {
      lines.push(`export { ${exportNames.join(", ")} }`);
    }
    return lines.join("; ");
  }
}
var normalizedClientEntry = normalizePath$3(CLIENT_ENTRY);
var normalizedEnvEntry = normalizePath$3(ENV_ENTRY);
function clientInjectionsPlugin(config2) {
  return {
    name: "vite:client-inject",
    async transform(code, id, options3) {
      var _a;
      if (id === normalizedClientEntry || id === normalizedEnvEntry) {
        const resolvedServerHostname = (await resolveHostname(config2.server.host)).name;
        const resolvedServerPort = config2.server.port;
        const devBase = config2.base;
        const serverHost = `${resolvedServerHostname}:${resolvedServerPort}${devBase}`;
        let hmrConfig = config2.server.hmr;
        hmrConfig = isObject$1(hmrConfig) ? hmrConfig : void 0;
        const host = (hmrConfig == null ? void 0 : hmrConfig.host) || null;
        const protocol = (hmrConfig == null ? void 0 : hmrConfig.protocol) || null;
        const timeout2 = (hmrConfig == null ? void 0 : hmrConfig.timeout) || 3e4;
        const overlay = (hmrConfig == null ? void 0 : hmrConfig.overlay) !== false;
        const isHmrServerSpecified = !!(hmrConfig == null ? void 0 : hmrConfig.server);
        let port = (hmrConfig == null ? void 0 : hmrConfig.clientPort) || (hmrConfig == null ? void 0 : hmrConfig.port) || null;
        if (config2.server.middlewareMode && !isHmrServerSpecified) {
          port || (port = 24678);
        }
        let directTarget = (hmrConfig == null ? void 0 : hmrConfig.host) || resolvedServerHostname;
        directTarget += `:${(hmrConfig == null ? void 0 : hmrConfig.port) || resolvedServerPort}`;
        directTarget += devBase;
        let hmrBase = devBase;
        if (hmrConfig == null ? void 0 : hmrConfig.path) {
          hmrBase = import_node_path4.default.posix.join(hmrBase, hmrConfig.path);
        }
        return code.replace(`__MODE__`, JSON.stringify(config2.mode)).replace(/__BASE__/g, JSON.stringify(devBase)).replace(`__DEFINES__`, serializeDefine(config2.define || {})).replace(`__SERVER_HOST__`, JSON.stringify(serverHost)).replace(`__HMR_PROTOCOL__`, JSON.stringify(protocol)).replace(`__HMR_HOSTNAME__`, JSON.stringify(host)).replace(`__HMR_PORT__`, JSON.stringify(port)).replace(`__HMR_DIRECT_TARGET__`, JSON.stringify(directTarget)).replace(`__HMR_BASE__`, JSON.stringify(hmrBase)).replace(`__HMR_TIMEOUT__`, JSON.stringify(timeout2)).replace(`__HMR_ENABLE_OVERLAY__`, JSON.stringify(overlay));
      } else if (!(options3 == null ? void 0 : options3.ssr) && code.includes("process.env.NODE_ENV")) {
        return code.replace(/\bprocess\.env\.NODE_ENV\b/g, ((_a = config2.define) == null ? void 0 : _a["process.env.NODE_ENV"]) || JSON.stringify("development"));
      }
    }
  };
}
function serializeDefine(define2) {
  let res = `{`;
  for (const key in define2) {
    const val = define2[key];
    res += `${JSON.stringify(key)}: ${typeof val === "string" ? `(${val})` : JSON.stringify(val)}, `;
  }
  return res + `}`;
}
var wasmHelperId = "\0vite/wasm-helper";
var wasmHelper = async (opts = {}, url2) => {
  let result;
  if (url2.startsWith("data:")) {
    const urlContent = url2.replace(/^data:.*?base64,/, "");
    let bytes;
    if (typeof Buffer === "function" && typeof Buffer.from === "function") {
      bytes = Buffer.from(urlContent, "base64");
    } else if (typeof atob === "function") {
      const binaryString = atob(urlContent);
      bytes = new Uint8Array(binaryString.length);
      for (let i2 = 0; i2 < binaryString.length; i2++) {
        bytes[i2] = binaryString.charCodeAt(i2);
      }
    } else {
      throw new Error("Failed to decode base64-encoded data URL, Buffer and atob are not supported");
    }
    result = await WebAssembly.instantiate(bytes, opts);
  } else {
    const response = await fetch(url2);
    const contentType = response.headers.get("Content-Type") || "";
    if ("instantiateStreaming" in WebAssembly && contentType.startsWith("application/wasm")) {
      result = await WebAssembly.instantiateStreaming(response, opts);
    } else {
      const buffer = await response.arrayBuffer();
      result = await WebAssembly.instantiate(buffer, opts);
    }
  }
  return result.instance;
};
var wasmHelperCode = wasmHelper.toString();
var wasmHelperPlugin = (config2) => {
  return {
    name: "vite:wasm-helper",
    resolveId(id) {
      if (id === wasmHelperId) {
        return id;
      }
    },
    async load(id) {
      if (id === wasmHelperId) {
        return `export default ${wasmHelperCode}`;
      }
      if (!id.endsWith(".wasm?init")) {
        return;
      }
      const url2 = await fileToUrl(id, config2, this);
      return `
import initWasm from "${wasmHelperId}"
export default opts => initWasm(opts, ${JSON.stringify(url2)})
`;
    }
  };
};
var wasmFallbackPlugin = () => {
  return {
    name: "vite:wasm-fallback",
    async load(id) {
      if (!id.endsWith(".wasm")) {
        return;
      }
      throw new Error('"ESM integration proposal for Wasm" is not supported currently. Use vite-plugin-wasm or other community plugins to handle this. Alternatively, you can use `.wasm?init` or `.wasm?url`. See https://vitejs.dev/guide/features.html#webassembly for more details.');
    }
  };
};
function preAliasPlugin(config2) {
  const findPatterns = getAliasPatterns(config2.resolve.alias);
  const isConfiguredAsExternal = createIsConfiguredAsSsrExternal(config2);
  const isBuild = config2.command === "build";
  return {
    name: "vite:pre-alias",
    async resolveId(id, importer, options3) {
      var _a;
      const ssr = (options3 == null ? void 0 : options3.ssr) === true;
      const depsOptimizer = getDepsOptimizer(config2, ssr);
      if (importer && depsOptimizer && bareImportRE.test(id) && !(options3 == null ? void 0 : options3.scan) && id !== "@vite/client" && id !== "@vite/env") {
        if (findPatterns.find((pattern2) => matches(pattern2, id))) {
          const optimizedId = await tryOptimizedResolve(depsOptimizer, id, importer);
          if (optimizedId) {
            return optimizedId;
          }
          const resolved = await this.resolve(id, importer, {
            skipSelf: true,
            ...options3
          });
          if (resolved && !depsOptimizer.isOptimizedDepFile(resolved.id)) {
            const optimizeDeps2 = depsOptimizer.options;
            const resolvedId = cleanUrl(resolved.id);
            const isVirtual = resolvedId === id || resolvedId.includes("\0");
            if (!isVirtual && import_node_fs4.default.existsSync(resolvedId) && !moduleListContains(optimizeDeps2.exclude, id) && import_node_path4.default.isAbsolute(resolvedId) && (resolvedId.includes("node_modules") || ((_a = optimizeDeps2.include) == null ? void 0 : _a.includes(id))) && isOptimizable(resolvedId, optimizeDeps2) && !(isBuild && ssr && isConfiguredAsExternal(id)) && (!ssr || optimizeAliasReplacementForSSR(resolvedId, optimizeDeps2))) {
              const optimizedInfo = depsOptimizer.registerMissingImport(id, resolvedId);
              return { id: depsOptimizer.getOptimizedDepId(optimizedInfo) };
            }
          }
          return resolved;
        }
      }
    }
  };
}
function optimizeAliasReplacementForSSR(id, optimizeDeps2) {
  var _a;
  if ((_a = optimizeDeps2.include) == null ? void 0 : _a.includes(id)) {
    return true;
  }
  return false;
}
function matches(pattern2, importee) {
  if (pattern2 instanceof RegExp) {
    return pattern2.test(importee);
  }
  if (importee.length < pattern2.length) {
    return false;
  }
  if (importee === pattern2) {
    return true;
  }
  return importee.startsWith(pattern2 + "/");
}
function getAliasPatterns(entries) {
  if (!entries) {
    return [];
  }
  if (Array.isArray(entries)) {
    return entries.map((entry2) => entry2.find);
  }
  return Object.entries(entries).map(([find2]) => find2);
}
var nonJsRe = /\.json(?:$|\?)/;
var metaEnvRe = /import\.meta\.env\.(.+)/;
var isNonJsRequest = (request) => nonJsRe.test(request);
function definePlugin(config2) {
  const isBuild = config2.command === "build";
  const isBuildLib = isBuild && config2.build.lib;
  const processEnv = {};
  const processNodeEnv = {};
  if (!isBuildLib) {
    const nodeEnv = "development";
    Object.assign(processEnv, {
      "process.env.": `({}).`,
      "global.process.env.": `({}).`,
      "globalThis.process.env.": `({}).`
    });
    Object.assign(processNodeEnv, {
      "process.env.NODE_ENV": JSON.stringify(nodeEnv),
      "global.process.env.NODE_ENV": JSON.stringify(nodeEnv),
      "globalThis.process.env.NODE_ENV": JSON.stringify(nodeEnv),
      __vite_process_env_NODE_ENV: JSON.stringify(nodeEnv)
    });
  }
  const userDefine = {};
  const userDefineEnv = {};
  for (const key in config2.define) {
    const val = config2.define[key];
    userDefine[key] = typeof val === "string" ? val : JSON.stringify(val);
    if (isBuild) {
      const match = key.match(metaEnvRe);
      if (match) {
        userDefineEnv[match[1]] = // test if value is raw identifier to wrap with __vite__ so when
        // stringified for `import.meta.env`, we can remove the quotes and
        // retain being an identifier
        typeof val === "string" && /^[\p{L}_$]/u.test(val.trim()) ? `__vite__${val}__vite__` : val;
      }
    }
  }
  const importMetaKeys = {};
  const importMetaFallbackKeys = {};
  if (isBuild) {
    const env2 = {
      ...config2.env,
      SSR: !!config2.build.ssr
    };
    importMetaKeys["import.meta.hot"] = `undefined`;
    for (const key in env2) {
      importMetaKeys[`import.meta.env.${key}`] = JSON.stringify(env2[key]);
    }
    Object.assign(importMetaFallbackKeys, {
      "import.meta.env.": `({}).`,
      "import.meta.env": JSON.stringify({ ...env2, ...userDefineEnv }).replace(/"__vite__(.+?)__vite__"/g, (_, val) => val)
    });
  }
  function generatePattern(ssr) {
    var _a;
    const replaceProcessEnv = !ssr || ((_a = config2.ssr) == null ? void 0 : _a.target) === "webworker";
    const replacements = {
      ...replaceProcessEnv ? processNodeEnv : {},
      ...importMetaKeys,
      ...userDefine,
      ...importMetaFallbackKeys,
      ...replaceProcessEnv ? processEnv : {}
    };
    if (isBuild && !replaceProcessEnv) {
      replacements["__vite_process_env_NODE_ENV"] = "process.env.NODE_ENV";
    }
    const replacementsKeys = Object.keys(replacements);
    const pattern2 = replacementsKeys.length ? new RegExp(
      // Mustn't be preceded by a char that can be part of an identifier
      // or a '.' that isn't part of a spread operator
      "(?<![\\p{L}\\p{N}_$]|(?<!\\.\\.)\\.)(" + replacementsKeys.map((str2) => {
        return str2.replace(/[-[\]/{}()*+?.\\^$|]/g, "\\$&");
      }).join("|") + // Mustn't be followed by a char that can be part of an identifier
      // or an assignment (but allow equality operators)
      ")(?:(?<=\\.)|(?![\\p{L}\\p{N}_$]|\\s*?=[^=]))",
      "gu"
    ) : null;
    return [replacements, pattern2];
  }
  const defaultPattern = generatePattern(false);
  const ssrPattern = generatePattern(true);
  return {
    name: "vite:define",
    transform(code, id, options3) {
      const ssr = (options3 == null ? void 0 : options3.ssr) === true;
      if (!ssr && !isBuild) {
        return;
      }
      if (
        // exclude html, css and static assets for performance
        isHTMLRequest(id) || isCSSRequest(id) || isNonJsRequest(id) || config2.assetsInclude(id)
      ) {
        return;
      }
      const [replacements, pattern2] = ssr ? ssrPattern : defaultPattern;
      if (!pattern2) {
        return null;
      }
      if (ssr && !isBuild) {
        return code.replace(pattern2, (_, match2) => {
          return "" + replacements[match2];
        });
      }
      const s2 = new MagicString(code);
      let hasReplaced = false;
      let match;
      while (match = pattern2.exec(code)) {
        hasReplaced = true;
        const start = match.index;
        const end = start + match[0].length;
        const replacement = "" + replacements[match[1]];
        s2.update(start, end, replacement);
      }
      if (!hasReplaced) {
        return null;
      }
      return transformStableResult(s2, id, config2);
    }
  };
}
var ignoreFlagRE = /\/\*\s*@vite-ignore\s*\*\//;
function err(e3, pos) {
  const error3 = new Error(e3);
  error3.pos = pos;
  return error3;
}
function parseWorkerOptions(rawOpts, optsStartIndex) {
  let opts = {};
  try {
    opts = evalValue(rawOpts);
  } catch {
    throw err("Vite is unable to parse the worker options as the value is not static.To ignore this error, please use /* @vite-ignore */ in the worker options.", optsStartIndex);
  }
  if (opts == null) {
    return {};
  }
  if (typeof opts !== "object") {
    throw err(`Expected worker options to be an object, got ${typeof opts}`, optsStartIndex);
  }
  return opts;
}
function getWorkerType(raw, clean, i2) {
  const commaIndex = clean.indexOf(",", i2);
  if (commaIndex === -1) {
    return "classic";
  }
  const endIndex = clean.indexOf(")", i2);
  if (commaIndex > endIndex) {
    return "classic";
  }
  const workerOptString = raw.substring(commaIndex + 1, endIndex).replace(/\}[\s\S]*,/g, "}");
  const hasViteIgnore = ignoreFlagRE.test(workerOptString);
  if (hasViteIgnore) {
    return "ignore";
  }
  const cleanWorkerOptString = clean.substring(commaIndex + 1, endIndex).trim();
  if (!cleanWorkerOptString.length) {
    return "classic";
  }
  const workerOpts = parseWorkerOptions(workerOptString, commaIndex + 1);
  if (workerOpts.type && ["classic", "module"].includes(workerOpts.type)) {
    return workerOpts.type;
  }
  return "classic";
}
function workerImportMetaUrlPlugin(config2) {
  const isBuild = config2.command === "build";
  let workerResolver;
  return {
    name: "vite:worker-import-meta-url",
    async transform(code, id, options3) {
      var _a;
      const ssr = (options3 == null ? void 0 : options3.ssr) === true;
      if (!(options3 == null ? void 0 : options3.ssr) && (code.includes("new Worker") || code.includes("new SharedWorker")) && code.includes("new URL") && code.includes(`import.meta.url`)) {
        const query = parseRequest(id);
        let s2;
        const cleanString = stripLiteral(code);
        const workerImportMetaUrlRE = /\bnew\s+(?:Worker|SharedWorker)\s*\(\s*(new\s+URL\s*\(\s*('[^']+'|"[^"]+"|`[^`]+`)\s*,\s*import\.meta\.url\s*\))/g;
        let match;
        while (match = workerImportMetaUrlRE.exec(cleanString)) {
          const { 0: allExp, 1: exp, 2: emptyUrl, index: index2 } = match;
          const urlIndex = allExp.indexOf(exp) + index2;
          const urlStart = cleanString.indexOf(emptyUrl, index2);
          const urlEnd = urlStart + emptyUrl.length;
          const rawUrl = code.slice(urlStart, urlEnd);
          if (rawUrl[0] === "`" && /\$\{/.test(rawUrl)) {
            this.error(`\`new URL(url, import.meta.url)\` is not supported in dynamic template string.`, urlIndex);
          }
          s2 || (s2 = new MagicString(code));
          const workerType = getWorkerType(code, cleanString, index2 + allExp.length);
          const url2 = rawUrl.slice(1, -1);
          let file;
          if (url2.startsWith(".")) {
            file = import_node_path4.default.resolve(import_node_path4.default.dirname(id), url2);
          } else {
            workerResolver ?? (workerResolver = config2.createResolver({
              extensions: [],
              tryIndex: false,
              preferRelative: true
            }));
            file = await workerResolver(url2, id);
            file ?? (file = url2.startsWith("/") ? slash$1(import_node_path4.default.join(config2.publicDir, url2)) : slash$1(import_node_path4.default.resolve(import_node_path4.default.dirname(id), url2)));
          }
          let builtUrl;
          if (isBuild) {
            (_a = getDepsOptimizer(config2, ssr)) == null ? void 0 : _a.registerWorkersSource(id);
            builtUrl = await workerFileToUrl(config2, file, query);
          } else {
            builtUrl = await fileToUrl(cleanUrl(file), config2, this);
            builtUrl = injectQuery(builtUrl, WORKER_FILE_ID);
            builtUrl = injectQuery(builtUrl, `type=${workerType}`);
          }
          s2.update(urlIndex, urlIndex + exp.length, `new URL(${JSON.stringify(builtUrl)}, self.location)`);
        }
        if (s2) {
          return transformStableResult(s2, id, config2);
        }
        return null;
      }
    }
  };
}
function assetImportMetaUrlPlugin(config2) {
  const normalizedPublicDir = normalizePath$3(config2.publicDir);
  let assetResolver;
  return {
    name: "vite:asset-import-meta-url",
    async transform(code, id, options3) {
      if (!(options3 == null ? void 0 : options3.ssr) && id !== preloadHelperId && code.includes("new URL") && code.includes(`import.meta.url`)) {
        let s2;
        const assetImportMetaUrlRE = /\bnew\s+URL\s*\(\s*('[^']+'|"[^"]+"|`[^`]+`)\s*,\s*import\.meta\.url\s*(?:,\s*)?\)/g;
        const cleanString = stripLiteral(code);
        let match;
        while (match = assetImportMetaUrlRE.exec(cleanString)) {
          const { 0: exp, 1: emptyUrl, index: index2 } = match;
          const urlStart = cleanString.indexOf(emptyUrl, index2);
          const urlEnd = urlStart + emptyUrl.length;
          const rawUrl = code.slice(urlStart, urlEnd);
          if (!s2)
            s2 = new MagicString(code);
          if (rawUrl[0] === "`" && /\$\{/.test(rawUrl)) {
            const ast = this.parse(rawUrl);
            const templateLiteral = ast.body[0].expression;
            if (templateLiteral.expressions.length) {
              const pattern2 = JSON.stringify(buildGlobPattern(templateLiteral));
              s2.update(index2, index2 + exp.length, `new URL((import.meta.glob(${pattern2}, { eager: true, import: 'default', as: 'url' }))[${rawUrl}], self.location)`);
              continue;
            }
          }
          const url2 = rawUrl.slice(1, -1);
          let file;
          if (url2.startsWith(".")) {
            file = slash$1(import_node_path4.default.resolve(import_node_path4.default.dirname(id), url2));
          } else {
            assetResolver ?? (assetResolver = config2.createResolver({
              extensions: [],
              mainFields: [],
              tryIndex: false,
              preferRelative: true
            }));
            file = await assetResolver(url2, id);
            file ?? (file = url2.startsWith("/") ? slash$1(import_node_path4.default.join(config2.publicDir, url2)) : slash$1(import_node_path4.default.resolve(import_node_path4.default.dirname(id), url2)));
          }
          let builtUrl;
          if (file) {
            try {
              if (isParentDirectory(normalizedPublicDir, file)) {
                const publicPath = "/" + import_node_path4.default.posix.relative(normalizedPublicDir, file);
                builtUrl = await fileToUrl(publicPath, config2, this);
              } else {
                builtUrl = await fileToUrl(file, config2, this);
              }
            } catch {
            }
          }
          if (!builtUrl) {
            const rawExp = code.slice(index2, index2 + exp.length);
            config2.logger.warnOnce(`
${rawExp} doesn't exist at build time, it will remain unchanged to be resolved at runtime`);
            builtUrl = url2;
          }
          s2.update(index2, index2 + exp.length, `new URL(${JSON.stringify(builtUrl)}, self.location)`);
        }
        if (s2) {
          return transformStableResult(s2, id, config2);
        }
      }
      return null;
    }
  };
}
function buildGlobPattern(ast) {
  let pattern2 = "";
  let lastElementIndex = -1;
  for (const exp of ast.expressions) {
    for (let i2 = lastElementIndex + 1; i2 < ast.quasis.length; i2++) {
      const el = ast.quasis[i2];
      if (el.end < exp.start) {
        pattern2 += el.value.raw;
        lastElementIndex = i2;
      }
    }
    pattern2 += "**";
  }
  for (let i2 = lastElementIndex + 1; i2 < ast.quasis.length; i2++) {
    pattern2 += ast.quasis[i2].value.raw;
  }
  return pattern2;
}
function ensureWatchPlugin() {
  return {
    name: "vite:ensure-watch",
    load(id) {
      if (queryRE.test(id)) {
        this.addWatchFile(cleanUrl(id));
      }
      return null;
    }
  };
}
function metadataPlugin() {
  return {
    name: "vite:build-metadata",
    async renderChunk(_code, chunk) {
      chunk.viteMetadata = {
        importedAssets: /* @__PURE__ */ new Set(),
        importedCss: /* @__PURE__ */ new Set()
      };
      return null;
    }
  };
}
var VariableDynamicImportError = class extends Error {
};
var example = "For example: import(`./foo/${bar}.js`).";
function sanitizeString(str2) {
  if (str2.includes("*")) {
    throw new VariableDynamicImportError("A dynamic import cannot contain * characters.");
  }
  return str2;
}
function templateLiteralToGlob(node3) {
  let glob2 = "";
  for (let i2 = 0; i2 < node3.quasis.length; i2 += 1) {
    glob2 += sanitizeString(node3.quasis[i2].value.raw);
    if (node3.expressions[i2]) {
      glob2 += expressionToGlob(node3.expressions[i2]);
    }
  }
  return glob2;
}
function callExpressionToGlob(node3) {
  const { callee } = node3;
  if (callee.type === "MemberExpression" && callee.property.type === "Identifier" && callee.property.name === "concat") {
    return `${expressionToGlob(callee.object)}${node3.arguments.map(expressionToGlob).join("")}`;
  }
  return "*";
}
function binaryExpressionToGlob(node3) {
  if (node3.operator !== "+") {
    throw new VariableDynamicImportError(`${node3.operator} operator is not supported.`);
  }
  return `${expressionToGlob(node3.left)}${expressionToGlob(node3.right)}`;
}
function expressionToGlob(node3) {
  switch (node3.type) {
    case "TemplateLiteral":
      return templateLiteralToGlob(node3);
    case "CallExpression":
      return callExpressionToGlob(node3);
    case "BinaryExpression":
      return binaryExpressionToGlob(node3);
    case "Literal": {
      return sanitizeString(node3.value);
    }
    default:
      return "*";
  }
}
var defaultProtocol = "file:";
var ignoredProtocols = ["data:", "http:", "https:"];
function shouldIgnore(glob2) {
  const containsAsterisk = glob2.includes("*");
  const globURL = new URL(glob2, defaultProtocol);
  const containsIgnoredProtocol = ignoredProtocols.some(
    (ignoredProtocol) => ignoredProtocol === globURL.protocol
  );
  return !containsAsterisk || containsIgnoredProtocol;
}
function dynamicImportToGlob(node3, sourceString) {
  let glob2 = expressionToGlob(node3);
  if (shouldIgnore(glob2)) {
    return null;
  }
  glob2 = glob2.replace(/\*\*/g, "*");
  if (glob2.startsWith("*")) {
    throw new VariableDynamicImportError(
      `invalid import "${sourceString}". It cannot be statically analyzed. Variable dynamic imports must start with ./ and be limited to a specific directory. ${example}`
    );
  }
  if (glob2.startsWith("/")) {
    throw new VariableDynamicImportError(
      `invalid import "${sourceString}". Variable absolute imports are not supported, imports must start with ./ in the static part of the import. ${example}`
    );
  }
  if (!glob2.startsWith("./") && !glob2.startsWith("../")) {
    throw new VariableDynamicImportError(
      `invalid import "${sourceString}". Variable bare imports are not supported, imports must start with ./ in the static part of the import. ${example}`
    );
  }
  const ownDirectoryStarExtension = /^\.\/\*\.[\w]+$/;
  if (ownDirectoryStarExtension.test(glob2)) {
    throw new VariableDynamicImportError(
      `${`invalid import "${sourceString}". Variable imports cannot import their own directory, place imports in a separate directory or make the import filename more specific. `}${example}`
    );
  }
  if (import_path.default.extname(glob2) === "") {
    throw new VariableDynamicImportError(
      `invalid import "${sourceString}". A file extension must be included in the static part of the import. ${example}`
    );
  }
  return glob2;
}
var dynamicImportHelperId = "\0vite/dynamic-import-helper";
var dynamicImportHelper = (glob2, path8) => {
  const v = glob2[path8];
  if (v) {
    return typeof v === "function" ? v() : Promise.resolve(v);
  }
  return new Promise((_, reject) => {
    (typeof queueMicrotask === "function" ? queueMicrotask : setTimeout)(reject.bind(null, new Error("Unknown variable dynamic import: " + path8)));
  });
};
function parseDynamicImportPattern(strings) {
  const filename = strings.slice(1, -1);
  const rawQuery = parseRequest(filename);
  let globParams = null;
  const ast = parse$d(strings, {
    ecmaVersion: "latest",
    sourceType: "module"
  }).body[0].expression;
  const userPatternQuery = dynamicImportToGlob(ast, filename);
  if (!userPatternQuery) {
    return null;
  }
  const [userPattern] = userPatternQuery.split(requestQuerySplitRE, 2);
  const [rawPattern] = filename.split(requestQuerySplitRE, 2);
  if ((rawQuery == null ? void 0 : rawQuery.raw) !== void 0) {
    globParams = { as: "raw" };
  }
  if ((rawQuery == null ? void 0 : rawQuery.url) !== void 0) {
    globParams = { as: "url" };
  }
  if ((rawQuery == null ? void 0 : rawQuery.worker) !== void 0) {
    globParams = { as: "worker" };
  }
  return {
    globParams,
    userPattern,
    rawPattern
  };
}
async function transformDynamicImport(importSource, importer, resolve4, root) {
  if (importSource[1] !== "." && importSource[1] !== "/") {
    const resolvedFileName = await resolve4(importSource.slice(1, -1), importer);
    if (!resolvedFileName) {
      return null;
    }
    const relativeFileName = import_node_path4.posix.relative(import_node_path4.posix.dirname(normalizePath$3(importer)), normalizePath$3(resolvedFileName));
    importSource = normalizePath$3("`" + (relativeFileName[0] === "." ? "" : "./") + relativeFileName + "`");
  }
  const dynamicImportPattern = parseDynamicImportPattern(importSource);
  if (!dynamicImportPattern) {
    return null;
  }
  const { globParams, rawPattern, userPattern } = dynamicImportPattern;
  const params = globParams ? `, ${JSON.stringify({ ...globParams, import: "*" })}` : "";
  let newRawPattern = import_node_path4.posix.relative(import_node_path4.posix.dirname(importer), await toAbsoluteGlob(rawPattern, root, importer, resolve4));
  if (!/^\.{1,2}\//.test(newRawPattern)) {
    newRawPattern = `./${newRawPattern}`;
  }
  const exp = `(import.meta.glob(${JSON.stringify(userPattern)}${params}))`;
  return {
    rawPattern: newRawPattern,
    pattern: userPattern,
    glob: exp
  };
}
function dynamicImportVarsPlugin(config2) {
  const resolve4 = config2.createResolver({
    preferRelative: true,
    tryIndex: false,
    extensions: []
  });
  const { include, exclude, warnOnError } = config2.build.dynamicImportVarsOptions;
  const filter2 = createFilter2(include, exclude);
  return {
    name: "vite:dynamic-import-vars",
    resolveId(id) {
      if (id === dynamicImportHelperId) {
        return id;
      }
    },
    load(id) {
      if (id === dynamicImportHelperId) {
        return "export default " + dynamicImportHelper.toString();
      }
    },
    async transform(source, importer) {
      if (!filter2(importer)) {
        return;
      }
      await init;
      let imports = [];
      try {
        imports = parse$e(source)[0];
      } catch (e3) {
        return null;
      }
      if (!imports.length) {
        return null;
      }
      let s2;
      let needDynamicImportHelper = false;
      for (let index2 = 0; index2 < imports.length; index2++) {
        const { s: start, e: end, ss: expStart, se: expEnd, d: dynamicIndex } = imports[index2];
        if (dynamicIndex === -1 || source[start] !== "`") {
          continue;
        }
        s2 || (s2 = new MagicString(source));
        let result;
        try {
          const importSource = removeComments(source.slice(start, end)).trim();
          result = await transformDynamicImport(importSource, importer, resolve4, config2.root);
        } catch (error3) {
          if (warnOnError) {
            this.warn(error3);
          } else {
            this.error(error3);
          }
        }
        if (!result) {
          continue;
        }
        const { rawPattern, glob: glob2 } = result;
        needDynamicImportHelper = true;
        s2.overwrite(expStart, expEnd, `__variableDynamicImportRuntimeHelper(${glob2}, \`${rawPattern}\`)`);
      }
      if (s2) {
        if (needDynamicImportHelper) {
          s2.prepend(`import __variableDynamicImportRuntimeHelper from "${dynamicImportHelperId}";`);
        }
        return transformStableResult(s2, importer, config2);
      }
    }
  };
}
async function resolvePlugins(config2, prePlugins, normalPlugins, postPlugins) {
  var _a;
  const isBuild = config2.command === "build";
  const isWatch = isBuild && !!config2.build.watch;
  const buildPlugins = isBuild ? await (await Promise.resolve().then(function() {
    return build$1;
  })).resolveBuildPlugins(config2) : { pre: [], post: [] };
  const { modulePreload } = config2.build;
  return [
    isWatch ? ensureWatchPlugin() : null,
    isBuild ? metadataPlugin() : null,
    preAliasPlugin(config2),
    alias$1({ entries: config2.resolve.alias }),
    ...prePlugins,
    modulePreload === true || typeof modulePreload === "object" && modulePreload.polyfill ? modulePreloadPolyfillPlugin(config2) : null,
    ...isDepsOptimizerEnabled(config2, false) || isDepsOptimizerEnabled(config2, true) ? [
      isBuild ? optimizedDepsBuildPlugin(config2) : optimizedDepsPlugin(config2)
    ] : [],
    resolvePlugin({
      ...config2.resolve,
      root: config2.root,
      isProduction: config2.isProduction,
      isBuild,
      packageCache: config2.packageCache,
      ssrConfig: config2.ssr,
      asSrc: true,
      getDepsOptimizer: (ssr) => getDepsOptimizer(config2, ssr),
      shouldExternalize: isBuild && config2.build.ssr && ((_a = config2.ssr) == null ? void 0 : _a.format) !== "cjs" ? (id) => shouldExternalizeForSSR(id, config2) : void 0
    }),
    htmlInlineProxyPlugin(config2),
    cssPlugin(config2),
    config2.esbuild !== false ? esbuildPlugin(config2.esbuild) : null,
    jsonPlugin({
      namedExports: true,
      ...config2.json
    }, isBuild),
    wasmHelperPlugin(config2),
    webWorkerPlugin(config2),
    assetPlugin(config2),
    ...normalPlugins,
    wasmFallbackPlugin(),
    definePlugin(config2),
    cssPostPlugin(config2),
    isBuild && buildHtmlPlugin(config2),
    workerImportMetaUrlPlugin(config2),
    assetImportMetaUrlPlugin(config2),
    ...buildPlugins.pre,
    dynamicImportVarsPlugin(config2),
    importGlobPlugin(config2),
    ...postPlugins,
    ...buildPlugins.post,
    // internal server-only plugins are always applied after everything else
    ...isBuild ? [] : [clientInjectionsPlugin(config2), importAnalysisPlugin(config2)]
  ].filter(Boolean);
}
function createPluginHookUtils(plugins2) {
  const sortedPluginsCache = /* @__PURE__ */ new Map();
  function getSortedPlugins(hookName) {
    if (sortedPluginsCache.has(hookName))
      return sortedPluginsCache.get(hookName);
    const sorted = getSortedPluginsByHook(hookName, plugins2);
    sortedPluginsCache.set(hookName, sorted);
    return sorted;
  }
  function getSortedPluginHooks(hookName) {
    const plugins3 = getSortedPlugins(hookName);
    return plugins3.map((p2) => {
      const hook = p2[hookName];
      return typeof hook === "object" && "handler" in hook ? hook.handler : hook;
    }).filter(Boolean);
  }
  return {
    getSortedPlugins,
    getSortedPluginHooks
  };
}
function getSortedPluginsByHook(hookName, plugins2) {
  const pre = [];
  const normal = [];
  const post = [];
  for (const plugin of plugins2) {
    const hook = plugin[hookName];
    if (hook) {
      if (typeof hook === "object") {
        if (hook.order === "pre") {
          pre.push(plugin);
          continue;
        }
        if (hook.order === "post") {
          post.push(plugin);
          continue;
        }
      }
      normal.push(plugin);
    }
  }
  return [...pre, ...normal, ...post];
}
function ansiRegex2({ onlyFirst = false } = {}) {
  const pattern2 = [
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
  ].join("|");
  return new RegExp(pattern2, onlyFirst ? void 0 : "g");
}
function stripAnsi2(string3) {
  if (typeof string3 !== "string") {
    throw new TypeError(`Expected a \`string\`, got \`${typeof string3}\``);
  }
  return string3.replace(ansiRegex2(), "");
}
function prepareError(err2) {
  return {
    message: stripAnsi2(err2.message),
    stack: stripAnsi2(cleanStack(err2.stack || "")),
    id: err2.id,
    frame: stripAnsi2(err2.frame || ""),
    plugin: err2.plugin,
    pluginCode: err2.pluginCode,
    loc: err2.loc
  };
}
function buildErrorMessage(err2, args = [], includeStack = true) {
  if (err2.plugin)
    args.push(`  Plugin: ${picocolorsExports.magenta(err2.plugin)}`);
  const loc = err2.loc ? `:${err2.loc.line}:${err2.loc.column}` : "";
  if (err2.id)
    args.push(`  File: ${picocolorsExports.cyan(err2.id)}${loc}`);
  if (err2.frame)
    args.push(picocolorsExports.yellow(pad$1(err2.frame)));
  if (includeStack && err2.stack)
    args.push(pad$1(cleanStack(err2.stack)));
  return args.join("\n");
}
function cleanStack(stack) {
  return stack.split(/\n/g).filter((l2) => /^\s*at/.test(l2)).join("\n");
}
function logError(server2, err2) {
  const msg = buildErrorMessage(err2, [
    picocolorsExports.red(`Internal server error: ${err2.message}`)
  ]);
  server2.config.logger.error(msg, {
    clear: true,
    timestamp: true,
    error: err2
  });
  server2.ws.send({
    type: "error",
    err: prepareError(err2)
  });
}
function errorMiddleware(server2, allowNext = false) {
  return function viteErrorMiddleware(err2, _req, res, next) {
    logError(server2, err2);
    if (allowNext) {
      next();
    } else {
      res.statusCode = 500;
      res.end(`
        <!DOCTYPE html>
        <html lang="en">
          <head>
            <meta charset="UTF-8" />
            <title>Error</title>
            <script type="module">
              import { ErrorOverlay } from '/@vite/client'
              document.body.appendChild(new ErrorOverlay(${JSON.stringify(prepareError(err2)).replace(/</g, "\\u003c")}))
            <\/script>
          </head>
          <body>
          </body>
        </html>
      `);
    }
  };
}
var parser = Parser$1;
async function createPluginContainer(config2, moduleGraph, watcher) {
  var _a;
  const isDebug2 = process.env.DEBUG;
  const { plugins: plugins2, logger: logger2, root, build: { rollupOptions } } = config2;
  const { getSortedPluginHooks, getSortedPlugins } = createPluginHookUtils(plugins2);
  const seenResolves = {};
  const debugResolve = createDebugger("vite:resolve");
  const debugPluginResolve = createDebugger("vite:plugin-resolve", {
    onlyWhenFocused: "vite:plugin"
  });
  const debugPluginTransform = createDebugger("vite:plugin-transform", {
    onlyWhenFocused: "vite:plugin"
  });
  const debugSourcemapCombineFlag = "vite:sourcemap-combine";
  const isDebugSourcemapCombineFocused = (_a = process.env.DEBUG) == null ? void 0 : _a.includes(debugSourcemapCombineFlag);
  const debugSourcemapCombineFilter = process.env.DEBUG_VITE_SOURCEMAP_COMBINE_FILTER;
  const debugSourcemapCombine = createDebugger("vite:sourcemap-combine", {
    onlyWhenFocused: true
  });
  const watchFiles = /* @__PURE__ */ new Set();
  const minimalContext = {
    meta: {
      rollupVersion: version$1,
      watchMode: true
    }
  };
  function warnIncompatibleMethod(method, plugin) {
    logger2.warn(picocolorsExports.cyan(`[plugin:${plugin}] `) + picocolorsExports.yellow(`context method ${picocolorsExports.bold(`${method}()`)} is not supported in serve mode. This plugin is likely not vite-compatible.`));
  }
  async function hookParallel(hookName, context, args) {
    const parallelPromises = [];
    for (const plugin of getSortedPlugins(hookName)) {
      const hook = plugin[hookName];
      if (!hook)
        continue;
      const handler = "handler" in hook ? hook.handler : hook;
      if (hook.sequential) {
        await Promise.all(parallelPromises);
        parallelPromises.length = 0;
        await handler.apply(context(plugin), args(plugin));
      } else {
        parallelPromises.push(handler.apply(context(plugin), args(plugin)));
      }
    }
    await Promise.all(parallelPromises);
  }
  const ModuleInfoProxy = {
    get(info3, key) {
      if (key in info3) {
        return info3[key];
      }
      throw Error(`[vite] The "${key}" property of ModuleInfo is not supported.`);
    }
  };
  const EMPTY_OBJECT = Object.freeze({});
  function getModuleInfo(id) {
    const module2 = moduleGraph == null ? void 0 : moduleGraph.getModuleById(id);
    if (!module2) {
      return null;
    }
    if (!module2.info) {
      module2.info = new Proxy({ id, meta: module2.meta || EMPTY_OBJECT }, ModuleInfoProxy);
    }
    return module2.info;
  }
  function updateModuleInfo(id, { meta }) {
    if (meta) {
      const moduleInfo = getModuleInfo(id);
      if (moduleInfo) {
        moduleInfo.meta = { ...moduleInfo.meta, ...meta };
      }
    }
  }
  class Context {
    constructor(initialPlugin) {
      this.meta = minimalContext.meta;
      this.ssr = false;
      this._scan = false;
      this._activeId = null;
      this._activeCode = null;
      this._addedImports = null;
      this._activePlugin = initialPlugin || null;
    }
    parse(code, opts = {}) {
      return parser.parse(code, {
        sourceType: "module",
        ecmaVersion: "latest",
        locations: true,
        ...opts
      });
    }
    async resolve(id, importer, options3) {
      let skip;
      if ((options3 == null ? void 0 : options3.skipSelf) && this._activePlugin) {
        skip = new Set(this._resolveSkips);
        skip.add(this._activePlugin);
      }
      let out2 = await container.resolveId(id, importer, {
        assertions: options3 == null ? void 0 : options3.assertions,
        custom: options3 == null ? void 0 : options3.custom,
        isEntry: !!(options3 == null ? void 0 : options3.isEntry),
        skip,
        ssr: this.ssr,
        scan: this._scan
      });
      if (typeof out2 === "string")
        out2 = { id: out2 };
      return out2;
    }
    getModuleInfo(id) {
      return getModuleInfo(id);
    }
    getModuleIds() {
      return moduleGraph ? moduleGraph.idToModuleMap.keys() : Array.prototype[Symbol.iterator]();
    }
    addWatchFile(id) {
      watchFiles.add(id);
      (this._addedImports || (this._addedImports = /* @__PURE__ */ new Set())).add(id);
      if (watcher)
        ensureWatchedFile(watcher, id, root);
    }
    getWatchFiles() {
      return [...watchFiles];
    }
    emitFile(assetOrFile) {
      warnIncompatibleMethod(`emitFile`, this._activePlugin.name);
      return "";
    }
    setAssetSource() {
      warnIncompatibleMethod(`setAssetSource`, this._activePlugin.name);
    }
    getFileName() {
      warnIncompatibleMethod(`getFileName`, this._activePlugin.name);
      return "";
    }
    warn(e3, position) {
      const err2 = formatError(e3, position, this);
      const msg = buildErrorMessage(err2, [picocolorsExports.yellow(`warning: ${err2.message}`)], false);
      logger2.warn(msg, {
        clear: true,
        timestamp: true
      });
    }
    error(e3, position) {
      throw formatError(e3, position, this);
    }
  }
  function formatError(e3, position, ctx2) {
    const err2 = typeof e3 === "string" ? new Error(e3) : e3;
    if (err2.pluginCode) {
      return err2;
    }
    if (err2.file && err2.name === "CssSyntaxError") {
      err2.id = normalizePath$3(err2.file);
    }
    if (ctx2._activePlugin)
      err2.plugin = ctx2._activePlugin.name;
    if (ctx2._activeId && !err2.id)
      err2.id = ctx2._activeId;
    if (ctx2._activeCode) {
      err2.pluginCode = ctx2._activeCode;
      const pos = position ?? err2.pos ?? err2.position;
      if (pos != null) {
        let errLocation;
        try {
          errLocation = numberToPos(ctx2._activeCode, pos);
        } catch (err22) {
          logger2.error(
            picocolorsExports.red(`Error in error handler:
${err22.stack || err22.message}
`),
            // print extra newline to separate the two errors
            { error: err22 }
          );
          throw err2;
        }
        err2.loc = err2.loc || {
          file: err2.id,
          ...errLocation
        };
        err2.frame = err2.frame || generateCodeFrame(ctx2._activeCode, pos);
      } else if (err2.loc) {
        if (!err2.frame) {
          let code = ctx2._activeCode;
          if (err2.loc.file) {
            err2.id = normalizePath$3(err2.loc.file);
            try {
              code = import_node_fs4.default.readFileSync(err2.loc.file, "utf-8");
            } catch {
            }
          }
          err2.frame = generateCodeFrame(code, err2.loc);
        }
      } else if (err2.line && err2.column) {
        err2.loc = {
          file: err2.id,
          line: err2.line,
          column: err2.column
        };
        err2.frame = err2.frame || generateCodeFrame(err2.id, err2.loc);
      }
      if (err2.loc && ctx2 instanceof TransformContext) {
        const rawSourceMap = ctx2._getCombinedSourcemap();
        if (rawSourceMap) {
          const traced = new TraceMap(rawSourceMap);
          const { source, line, column } = originalPositionFor$1(traced, {
            line: Number(err2.loc.line),
            column: Number(err2.loc.column)
          });
          if (source && line != null && column != null) {
            err2.loc = { file: source, line, column };
          }
        }
      }
    } else if (err2.loc) {
      if (!err2.frame) {
        let code = err2.pluginCode;
        if (err2.loc.file) {
          err2.id = normalizePath$3(err2.loc.file);
          if (!code) {
            try {
              code = import_node_fs4.default.readFileSync(err2.loc.file, "utf-8");
            } catch {
            }
          }
        }
        if (code) {
          err2.frame = generateCodeFrame(code, err2.loc);
        }
      }
    }
    return err2;
  }
  class TransformContext extends Context {
    constructor(filename, code, inMap) {
      super();
      this.originalSourcemap = null;
      this.sourcemapChain = [];
      this.combinedMap = null;
      this.filename = filename;
      this.originalCode = code;
      if (inMap) {
        if (isDebugSourcemapCombineFocused) {
          inMap.name = "$inMap";
        }
        this.sourcemapChain.push(inMap);
      }
    }
    _getCombinedSourcemap(createIfNull = false) {
      if (debugSourcemapCombineFilter && this.filename.includes(debugSourcemapCombineFilter)) {
        debugSourcemapCombine("----------", this.filename);
        debugSourcemapCombine(this.combinedMap);
        debugSourcemapCombine(this.sourcemapChain);
        debugSourcemapCombine("----------");
      }
      let combinedMap = this.combinedMap;
      for (let m of this.sourcemapChain) {
        if (typeof m === "string")
          m = JSON.parse(m);
        if (!("version" in m)) {
          combinedMap = this.combinedMap = null;
          this.sourcemapChain.length = 0;
          break;
        }
        if (!combinedMap) {
          combinedMap = m;
        } else {
          combinedMap = combineSourcemaps(cleanUrl(this.filename), [
            {
              ...m,
              sourcesContent: combinedMap.sourcesContent
            },
            combinedMap
          ]);
        }
      }
      if (!combinedMap) {
        return createIfNull ? new MagicString(this.originalCode).generateMap({
          includeContent: true,
          hires: true,
          source: cleanUrl(this.filename)
        }) : null;
      }
      if (combinedMap !== this.combinedMap) {
        this.combinedMap = combinedMap;
        this.sourcemapChain.length = 0;
      }
      return this.combinedMap;
    }
    getCombinedSourcemap() {
      return this._getCombinedSourcemap(true);
    }
  }
  let closed = false;
  const container = {
    options: await (async () => {
      let options3 = rollupOptions;
      for (const optionsHook of getSortedPluginHooks("options")) {
        options3 = await optionsHook.call(minimalContext, options3) || options3;
      }
      if (options3.acornInjectPlugins) {
        parser = Parser$1.extend(...arraify(options3.acornInjectPlugins));
      }
      return {
        acorn,
        acornInjectPlugins: [],
        ...options3
      };
    })(),
    getModuleInfo,
    async buildStart() {
      await hookParallel("buildStart", (plugin) => new Context(plugin), () => [container.options]);
    },
    async resolveId(rawId, importer = (0, import_node_path4.join)(root, "index.html"), options3) {
      const skip = options3 == null ? void 0 : options3.skip;
      const ssr = options3 == null ? void 0 : options3.ssr;
      const scan2 = !!(options3 == null ? void 0 : options3.scan);
      const ctx2 = new Context();
      ctx2.ssr = !!ssr;
      ctx2._scan = scan2;
      ctx2._resolveSkips = skip;
      const resolveStart = isDebug2 ? import_node_perf_hooks.performance.now() : 0;
      let id = null;
      const partial2 = {};
      for (const plugin of getSortedPlugins("resolveId")) {
        if (!plugin.resolveId)
          continue;
        if (skip == null ? void 0 : skip.has(plugin))
          continue;
        ctx2._activePlugin = plugin;
        const pluginResolveStart = isDebug2 ? import_node_perf_hooks.performance.now() : 0;
        const handler = "handler" in plugin.resolveId ? plugin.resolveId.handler : plugin.resolveId;
        const result = await handler.call(ctx2, rawId, importer, {
          assertions: (options3 == null ? void 0 : options3.assertions) ?? {},
          custom: options3 == null ? void 0 : options3.custom,
          isEntry: !!(options3 == null ? void 0 : options3.isEntry),
          ssr,
          scan: scan2
        });
        if (!result)
          continue;
        if (typeof result === "string") {
          id = result;
        } else {
          id = result.id;
          Object.assign(partial2, result);
        }
        isDebug2 && debugPluginResolve(timeFrom(pluginResolveStart), plugin.name, prettifyUrl(id, root));
        break;
      }
      if (isDebug2 && rawId !== id && !rawId.startsWith(FS_PREFIX)) {
        const key = rawId + id;
        if (!seenResolves[key]) {
          seenResolves[key] = true;
          debugResolve(`${timeFrom(resolveStart)} ${picocolorsExports.cyan(rawId)} -> ${picocolorsExports.dim(id)}`);
        }
      }
      if (id) {
        partial2.id = isExternalUrl(id) ? id : normalizePath$3(id);
        return partial2;
      } else {
        return null;
      }
    },
    async load(id, options3) {
      const ssr = options3 == null ? void 0 : options3.ssr;
      const ctx2 = new Context();
      ctx2.ssr = !!ssr;
      for (const plugin of getSortedPlugins("load")) {
        if (!plugin.load)
          continue;
        ctx2._activePlugin = plugin;
        const handler = "handler" in plugin.load ? plugin.load.handler : plugin.load;
        const result = await handler.call(ctx2, id, { ssr });
        if (result != null) {
          if (isObject$1(result)) {
            updateModuleInfo(id, result);
          }
          return result;
        }
      }
      return null;
    },
    async transform(code, id, options3) {
      const inMap = options3 == null ? void 0 : options3.inMap;
      const ssr = options3 == null ? void 0 : options3.ssr;
      const ctx2 = new TransformContext(id, code, inMap);
      ctx2.ssr = !!ssr;
      for (const plugin of getSortedPlugins("transform")) {
        if (!plugin.transform)
          continue;
        ctx2._activePlugin = plugin;
        ctx2._activeId = id;
        ctx2._activeCode = code;
        const start = isDebug2 ? import_node_perf_hooks.performance.now() : 0;
        let result;
        const handler = "handler" in plugin.transform ? plugin.transform.handler : plugin.transform;
        try {
          result = await handler.call(ctx2, code, id, { ssr });
        } catch (e3) {
          ctx2.error(e3);
        }
        if (!result)
          continue;
        isDebug2 && debugPluginTransform(timeFrom(start), plugin.name, prettifyUrl(id, root));
        if (isObject$1(result)) {
          if (result.code !== void 0) {
            code = result.code;
            if (result.map) {
              if (isDebugSourcemapCombineFocused) {
                result.map.name = plugin.name;
              }
              ctx2.sourcemapChain.push(result.map);
            }
          }
          updateModuleInfo(id, result);
        } else {
          code = result;
        }
      }
      return {
        code,
        map: ctx2._getCombinedSourcemap()
      };
    },
    async close() {
      if (closed)
        return;
      const ctx2 = new Context();
      await hookParallel("buildEnd", () => ctx2, () => []);
      await hookParallel("closeBundle", () => ctx2, () => []);
      closed = true;
    }
  };
  return container;
}
var debug$8 = createDebugger("vite:deps");
var htmlTypesRE = /\.(html|vue|svelte|astro|imba)$/;
var importsRE = new RegExp(`(?<!\\/\\/.*)(?<=^|;|\\*\\/)\\s*import(?!\\s+type)(?:[\\w*{}\\n\\r\\t, ]+from)?\\s*("[^"]+"|'[^']+')\\s*(?=$|;|\\/\\/|\\/\\*)`, "gm");
async function scanImports(config2) {
  var _a, _b;
  const start = import_node_perf_hooks.performance.now();
  let entries = [];
  const explicitEntryPatterns = config2.optimizeDeps.entries;
  const buildInput = (_a = config2.build.rollupOptions) == null ? void 0 : _a.input;
  if (explicitEntryPatterns) {
    entries = await globEntries(explicitEntryPatterns, config2);
  } else if (buildInput) {
    const resolvePath = (p2) => import_node_path4.default.resolve(config2.root, p2);
    if (typeof buildInput === "string") {
      entries = [resolvePath(buildInput)];
    } else if (Array.isArray(buildInput)) {
      entries = buildInput.map(resolvePath);
    } else if (isObject$1(buildInput)) {
      entries = Object.values(buildInput).map(resolvePath);
    } else {
      throw new Error("invalid rollupOptions.input value.");
    }
  } else {
    entries = await globEntries("**/*.html", config2);
  }
  entries = entries.filter((entry2) => isScannable(entry2) && import_node_fs4.default.existsSync(entry2));
  if (!entries.length) {
    if (!explicitEntryPatterns && !config2.optimizeDeps.include) {
      config2.logger.warn(picocolorsExports.yellow("(!) Could not auto-determine entry point from rollupOptions or html files and there are no explicit optimizeDeps.include patterns. Skipping dependency pre-bundling."));
    }
    return { deps: {}, missing: {} };
  } else {
    debug$8(`Crawling dependencies using entries:
  ${entries.join("\n  ")}`);
  }
  const deps = {};
  const missing = {};
  const container = await createPluginContainer(config2);
  const plugin = esbuildScanPlugin(config2, container, deps, missing, entries);
  const { plugins: plugins2 = [], ...esbuildOptions } = ((_b = config2.optimizeDeps) == null ? void 0 : _b.esbuildOptions) ?? {};
  await (0, import_esbuild.build)({
    absWorkingDir: process.cwd(),
    write: false,
    stdin: {
      contents: entries.map((e3) => `import ${JSON.stringify(e3)}`).join("\n"),
      loader: "js"
    },
    bundle: true,
    format: "esm",
    logLevel: "error",
    plugins: [...plugins2, plugin],
    ...esbuildOptions
  });
  debug$8(`Scan completed in ${(import_node_perf_hooks.performance.now() - start).toFixed(2)}ms:`, deps);
  return {
    // Ensure a fixed order so hashes are stable and improve logs
    deps: orderedDependencies(deps),
    missing
  };
}
function orderedDependencies(deps) {
  const depsList = Object.entries(deps);
  depsList.sort((a2, b) => a2[0].localeCompare(b[0]));
  return Object.fromEntries(depsList);
}
function globEntries(pattern2, config2) {
  return out(pattern2, {
    cwd: config2.root,
    ignore: [
      "**/node_modules/**",
      `**/${config2.build.outDir}/**`,
      // if there aren't explicit entries, also ignore other common folders
      ...config2.optimizeDeps.entries ? [] : [`**/__tests__/**`, `**/coverage/**`]
    ],
    absolute: true,
    suppressErrors: true
    // suppress EACCES errors
  });
}
var scriptModuleRE = /(<script\b[^>]+type\s*=\s*(?:"module"|'module')[^>]*>)(.*?)<\/script>/gis;
var scriptRE = /(<script(?:\s[^>]*>|>))(.*?)<\/script>/gis;
var commentRE = /<!--.*?-->/gs;
var srcRE = /\bsrc\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/i;
var typeRE = /\btype\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/i;
var langRE = /\blang\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/i;
var contextRE = /\bcontext\s*=\s*(?:"([^"]+)"|'([^']+)'|([^\s'">]+))/i;
function esbuildScanPlugin(config2, container, depImports, missing, entries) {
  var _a, _b;
  const seen2 = /* @__PURE__ */ new Map();
  const resolve4 = async (id, importer, options3) => {
    const key = id + (importer && import_node_path4.default.dirname(importer));
    if (seen2.has(key)) {
      return seen2.get(key);
    }
    const resolved = await container.resolveId(id, importer && normalizePath$3(importer), {
      ...options3,
      scan: true
    });
    const res = resolved == null ? void 0 : resolved.id;
    seen2.set(key, res);
    return res;
  };
  const include = (_a = config2.optimizeDeps) == null ? void 0 : _a.include;
  const exclude = [
    ...((_b = config2.optimizeDeps) == null ? void 0 : _b.exclude) || [],
    "@vite/client",
    "@vite/env"
  ];
  const externalUnlessEntry = ({ path: path8 }) => ({
    path: path8,
    external: !entries.includes(path8)
  });
  const doTransformGlobImport = async (contents, id, loader) => {
    let transpiledContents;
    if (loader !== "js") {
      transpiledContents = (await (0, import_esbuild.transform)(contents, { loader })).code;
    } else {
      transpiledContents = contents;
    }
    const result = await transformGlobImport(transpiledContents, id, config2.root, resolve4, config2.isProduction);
    return (result == null ? void 0 : result.s.toString()) || transpiledContents;
  };
  return {
    name: "vite:dep-scan",
    setup(build4) {
      const scripts2 = {};
      build4.onResolve({ filter: externalRE }, ({ path: path8 }) => ({
        path: path8,
        external: true
      }));
      build4.onResolve({ filter: dataUrlRE }, ({ path: path8 }) => ({
        path: path8,
        external: true
      }));
      build4.onResolve({ filter: virtualModuleRE }, ({ path: path8 }) => {
        return {
          // strip prefix to get valid filesystem path so esbuild can resolve imports in the file
          path: path8.replace(virtualModulePrefix, ""),
          namespace: "script"
        };
      });
      build4.onLoad({ filter: /.*/, namespace: "script" }, ({ path: path8 }) => {
        return scripts2[path8];
      });
      build4.onResolve({ filter: htmlTypesRE }, async ({ path: path8, importer }) => {
        const resolved = await resolve4(path8, importer);
        if (!resolved)
          return;
        if (resolved.includes("node_modules") && isOptimizable(resolved, config2.optimizeDeps))
          return;
        return {
          path: resolved,
          namespace: "html"
        };
      });
      build4.onLoad({ filter: htmlTypesRE, namespace: "html" }, async ({ path: path8 }) => {
        let raw = import_node_fs4.default.readFileSync(path8, "utf-8");
        raw = raw.replace(commentRE, "<!---->");
        const isHtml = path8.endsWith(".html");
        const regex = isHtml ? scriptModuleRE : scriptRE;
        regex.lastIndex = 0;
        let js = "";
        let scriptId = 0;
        let match;
        while (match = regex.exec(raw)) {
          const [, openTag, content] = match;
          const typeMatch = openTag.match(typeRE);
          const type = typeMatch && (typeMatch[1] || typeMatch[2] || typeMatch[3]);
          const langMatch = openTag.match(langRE);
          const lang = langMatch && (langMatch[1] || langMatch[2] || langMatch[3]);
          if (type && !(type.includes("javascript") || type.includes("ecmascript") || type === "module")) {
            continue;
          }
          let loader = "js";
          if (lang === "ts" || lang === "tsx" || lang === "jsx") {
            loader = lang;
          } else if (path8.endsWith(".astro")) {
            loader = "ts";
          }
          const srcMatch = openTag.match(srcRE);
          if (srcMatch) {
            const src3 = srcMatch[1] || srcMatch[2] || srcMatch[3];
            js += `import ${JSON.stringify(src3)}
`;
          } else if (content.trim()) {
            const contents = content + (loader.startsWith("ts") ? extractImportPaths(content) : "");
            const key = `${path8}?id=${scriptId++}`;
            if (contents.includes("import.meta.glob")) {
              scripts2[key] = {
                loader: "js",
                contents: await doTransformGlobImport(contents, path8, loader),
                pluginData: {
                  htmlType: { loader }
                }
              };
            } else {
              scripts2[key] = {
                loader,
                contents,
                pluginData: {
                  htmlType: { loader }
                }
              };
            }
            const virtualModulePath = JSON.stringify(virtualModulePrefix + key);
            const contextMatch = openTag.match(contextRE);
            const context = contextMatch && (contextMatch[1] || contextMatch[2] || contextMatch[3]);
            if (path8.endsWith(".svelte") && context !== "module") {
              js += `import ${virtualModulePath}
`;
            } else {
              js += `export * from ${virtualModulePath}
`;
            }
          }
        }
        if (!path8.endsWith(".vue") || !js.includes("export default")) {
          js += "\nexport default {}";
        }
        return {
          loader: "js",
          contents: js
        };
      });
      build4.onResolve({
        // avoid matching windows volume
        filter: /^[\w@][^:]/
      }, async ({ path: id, importer, pluginData }) => {
        var _a2;
        if (moduleListContains(exclude, id)) {
          return externalUnlessEntry({ path: id });
        }
        if (depImports[id]) {
          return externalUnlessEntry({ path: id });
        }
        const resolved = await resolve4(id, importer, {
          custom: {
            depScan: { loader: (_a2 = pluginData == null ? void 0 : pluginData.htmlType) == null ? void 0 : _a2.loader }
          }
        });
        if (resolved) {
          if (shouldExternalizeDep(resolved, id)) {
            return externalUnlessEntry({ path: id });
          }
          if (resolved.includes("node_modules") || (include == null ? void 0 : include.includes(id))) {
            if (isOptimizable(resolved, config2.optimizeDeps)) {
              depImports[id] = resolved;
            }
            return externalUnlessEntry({ path: id });
          } else if (isScannable(resolved)) {
            const namespace = htmlTypesRE.test(resolved) ? "html" : void 0;
            return {
              path: import_node_path4.default.resolve(resolved),
              namespace
            };
          } else {
            return externalUnlessEntry({ path: id });
          }
        } else {
          missing[id] = normalizePath$3(importer);
        }
      });
      build4.onResolve({ filter: CSS_LANGS_RE }, externalUnlessEntry);
      build4.onResolve({ filter: /\.(json|json5|wasm)$/ }, externalUnlessEntry);
      build4.onResolve({
        filter: new RegExp(`\\.(${KNOWN_ASSET_TYPES.join("|")})$`)
      }, externalUnlessEntry);
      build4.onResolve({ filter: SPECIAL_QUERY_RE }, ({ path: path8 }) => ({
        path: path8,
        external: true
      }));
      build4.onResolve({
        filter: /.*/
      }, async ({ path: id, importer, pluginData }) => {
        var _a2;
        const resolved = await resolve4(id, importer, {
          custom: {
            depScan: { loader: (_a2 = pluginData == null ? void 0 : pluginData.htmlType) == null ? void 0 : _a2.loader }
          }
        });
        if (resolved) {
          if (shouldExternalizeDep(resolved, id) || !isScannable(resolved)) {
            return externalUnlessEntry({ path: id });
          }
          const namespace = htmlTypesRE.test(resolved) ? "html" : void 0;
          return {
            path: import_node_path4.default.resolve(cleanUrl(resolved)),
            namespace
          };
        } else {
          return externalUnlessEntry({ path: id });
        }
      });
      build4.onLoad({ filter: JS_TYPES_RE }, async ({ path: id }) => {
        var _a2, _b2, _c;
        let ext2 = import_node_path4.default.extname(id).slice(1);
        if (ext2 === "mjs")
          ext2 = "js";
        let contents = import_node_fs4.default.readFileSync(id, "utf-8");
        if (ext2.endsWith("x") && config2.esbuild && config2.esbuild.jsxInject) {
          contents = config2.esbuild.jsxInject + `
` + contents;
        }
        const loader = ((_c = (_b2 = (_a2 = config2.optimizeDeps) == null ? void 0 : _a2.esbuildOptions) == null ? void 0 : _b2.loader) == null ? void 0 : _c[`.${ext2}`]) || ext2;
        if (contents.includes("import.meta.glob")) {
          return {
            loader: "js",
            contents: await doTransformGlobImport(contents, id, loader)
          };
        }
        return {
          loader,
          contents
        };
      });
    }
  };
}
function extractImportPaths(code) {
  code = code.replace(multilineCommentsRE$1, "/* */").replace(singlelineCommentsRE$1, "");
  let js = "";
  let m;
  importsRE.lastIndex = 0;
  while ((m = importsRE.exec(code)) != null) {
    js += `
import ${m[1]}`;
  }
  return js;
}
function shouldExternalizeDep(resolvedId, rawId) {
  if (!import_node_path4.default.isAbsolute(resolvedId)) {
    return true;
  }
  if (resolvedId === rawId || resolvedId.includes("\0")) {
    return true;
  }
  return false;
}
function isScannable(id) {
  return JS_TYPES_RE.test(id) || htmlTypesRE.test(id);
}
var isDebugEnabled$1 = _debug("vite:deps").enabled;
var debounceMs = 100;
var depsOptimizerMap = /* @__PURE__ */ new WeakMap();
var devSsrDepsOptimizerMap = /* @__PURE__ */ new WeakMap();
function getDepsOptimizer(config2, ssr) {
  const isDevSsr = ssr && config2.command !== "build";
  return (isDevSsr ? devSsrDepsOptimizerMap : depsOptimizerMap).get(config2.mainConfig || config2);
}
async function initDepsOptimizer(config2, server2) {
  const ssr = config2.command === "build" && !!config2.build.ssr;
  if (!getDepsOptimizer(config2, ssr)) {
    await createDepsOptimizer(config2, server2);
  }
}
var creatingDevSsrOptimizer;
async function initDevSsrDepsOptimizer(config2, server2) {
  if (getDepsOptimizer(config2, true)) {
    return;
  }
  if (creatingDevSsrOptimizer) {
    return creatingDevSsrOptimizer;
  }
  creatingDevSsrOptimizer = async function() {
    const ssr = false;
    if (!getDepsOptimizer(config2, ssr)) {
      await initDepsOptimizer(config2, server2);
    }
    await getDepsOptimizer(config2, ssr).scanProcessing;
    await createDevSsrDepsOptimizer(config2);
    creatingDevSsrOptimizer = void 0;
  }();
  return await creatingDevSsrOptimizer;
}
async function createDepsOptimizer(config2, server2) {
  const { logger: logger2 } = config2;
  const isBuild = config2.command === "build";
  const ssr = isBuild && !!config2.build.ssr;
  const sessionTimestamp = Date.now().toString();
  const cachedMetadata = loadCachedDepOptimizationMetadata(config2, ssr);
  let handle2;
  let closed = false;
  let metadata = cachedMetadata || initDepsOptimizerMetadata(config2, ssr, sessionTimestamp);
  const depsOptimizer = {
    metadata,
    registerMissingImport,
    run: () => debouncedProcessing(0),
    isOptimizedDepFile: (id) => isOptimizedDepFile(id, config2),
    isOptimizedDepUrl: createIsOptimizedDepUrl(config2),
    getOptimizedDepId: (depInfo) => isBuild ? depInfo.file : `${depInfo.file}?v=${depInfo.browserHash}`,
    registerWorkersSource,
    delayDepsOptimizerUntil,
    resetRegisteredIds,
    ensureFirstRun,
    close: close2,
    options: getDepOptimizationConfig(config2, ssr)
  };
  depsOptimizerMap.set(config2, depsOptimizer);
  let newDepsDiscovered = false;
  let newDepsToLog = [];
  let newDepsToLogHandle;
  const logNewlyDiscoveredDeps = () => {
    if (newDepsToLog.length) {
      config2.logger.info(picocolorsExports.green(`✨ new dependencies optimized: ${depsLogString(newDepsToLog)}`), {
        timestamp: true
      });
      newDepsToLog = [];
    }
  };
  let depOptimizationProcessing = newDepOptimizationProcessing();
  let depOptimizationProcessingQueue = [];
  const resolveEnqueuedProcessingPromises = () => {
    for (const processing2 of depOptimizationProcessingQueue) {
      processing2.resolve();
    }
    depOptimizationProcessingQueue = [];
  };
  let enqueuedRerun;
  let currentlyProcessing = false;
  let firstRunCalled = !!cachedMetadata;
  let postScanOptimizationResult;
  let optimizingNewDeps;
  async function close2() {
    closed = true;
    await Promise.allSettled([
      depsOptimizer.scanProcessing,
      postScanOptimizationResult,
      optimizingNewDeps
    ]);
  }
  if (!cachedMetadata) {
    currentlyProcessing = true;
    const deps = {};
    await addManuallyIncludedOptimizeDeps(deps, config2, ssr);
    const discovered = await toDiscoveredDependencies(config2, deps, ssr, sessionTimestamp);
    for (const depInfo of Object.values(discovered)) {
      addOptimizedDepInfo(metadata, "discovered", {
        ...depInfo,
        processing: depOptimizationProcessing.promise
      });
      newDepsDiscovered = true;
    }
    if (!isBuild) {
      depsOptimizer.scanProcessing = new Promise((resolve4) => {
        setTimeout(async () => {
          try {
            debuggerViteDeps(picocolorsExports.green(`scanning for dependencies...`));
            const deps2 = await discoverProjectDependencies(config2);
            debuggerViteDeps(picocolorsExports.green(Object.keys(deps2).length > 0 ? `dependencies found by scanner: ${depsLogString(Object.keys(deps2))}` : `no dependencies found by scanner`));
            for (const id of Object.keys(deps2)) {
              if (!metadata.discovered[id]) {
                addMissingDep(id, deps2[id]);
              }
            }
            const knownDeps = prepareKnownDeps();
            postScanOptimizationResult = runOptimizeDeps(config2, knownDeps);
          } catch (e3) {
            logger2.error(e3.message);
          } finally {
            resolve4();
            depsOptimizer.scanProcessing = void 0;
          }
        }, 0);
      });
    }
  }
  function startNextDiscoveredBatch() {
    newDepsDiscovered = false;
    depOptimizationProcessingQueue.push(depOptimizationProcessing);
    depOptimizationProcessing = newDepOptimizationProcessing();
  }
  async function optimizeNewDeps() {
    const knownDeps = prepareKnownDeps();
    startNextDiscoveredBatch();
    return await runOptimizeDeps(config2, knownDeps);
  }
  function prepareKnownDeps() {
    const knownDeps = {};
    for (const dep of Object.keys(metadata.optimized)) {
      knownDeps[dep] = { ...metadata.optimized[dep] };
    }
    for (const dep of Object.keys(metadata.discovered)) {
      const { processing: processing2, ...info3 } = metadata.discovered[dep];
      knownDeps[dep] = info3;
    }
    return knownDeps;
  }
  async function runOptimizer(preRunResult) {
    const isRerun = firstRunCalled;
    firstRunCalled = true;
    enqueuedRerun = void 0;
    if (handle2)
      clearTimeout(handle2);
    if (closed || Object.keys(metadata.discovered).length === 0) {
      currentlyProcessing = false;
      return;
    }
    currentlyProcessing = true;
    try {
      const processingResult = preRunResult ?? await (optimizingNewDeps = optimizeNewDeps());
      optimizingNewDeps = void 0;
      if (closed) {
        currentlyProcessing = false;
        processingResult.cancel();
        resolveEnqueuedProcessingPromises();
        return;
      }
      const newData = processingResult.metadata;
      const needsInteropMismatch = findInteropMismatches(metadata.discovered, newData.optimized);
      const needsReload = needsInteropMismatch.length > 0 || metadata.hash !== newData.hash || Object.keys(metadata.optimized).some((dep) => {
        return metadata.optimized[dep].fileHash !== newData.optimized[dep].fileHash;
      });
      const commitProcessing = async () => {
        await processingResult.commit();
        for (const id in metadata.discovered) {
          if (!newData.optimized[id]) {
            addOptimizedDepInfo(newData, "discovered", metadata.discovered[id]);
          }
        }
        if (!needsReload) {
          newData.browserHash = metadata.browserHash;
          for (const dep in newData.chunks) {
            newData.chunks[dep].browserHash = metadata.browserHash;
          }
          for (const dep in newData.optimized) {
            newData.optimized[dep].browserHash = (metadata.optimized[dep] || metadata.discovered[dep]).browserHash;
          }
        }
        for (const o3 in newData.optimized) {
          const discovered = metadata.discovered[o3];
          if (discovered) {
            const optimized = newData.optimized[o3];
            discovered.browserHash = optimized.browserHash;
            discovered.fileHash = optimized.fileHash;
            discovered.needsInterop = optimized.needsInterop;
            discovered.processing = void 0;
          }
        }
        if (isRerun) {
          newDepsToLog.push(...Object.keys(newData.optimized).filter((dep) => !metadata.optimized[dep]));
        }
        metadata = depsOptimizer.metadata = newData;
        resolveEnqueuedProcessingPromises();
      };
      if (!needsReload) {
        await commitProcessing();
        if (!isDebugEnabled$1) {
          if (newDepsToLogHandle)
            clearTimeout(newDepsToLogHandle);
          newDepsToLogHandle = setTimeout(() => {
            newDepsToLogHandle = void 0;
            logNewlyDiscoveredDeps();
          }, 2 * debounceMs);
        } else {
          debuggerViteDeps(picocolorsExports.green(`✨ ${!isRerun ? `dependencies optimized` : `optimized dependencies unchanged`}`));
        }
      } else {
        if (newDepsDiscovered) {
          processingResult.cancel();
          debuggerViteDeps(picocolorsExports.green(`✨ delaying reload as new dependencies have been found...`));
        } else {
          await commitProcessing();
          if (!isDebugEnabled$1) {
            if (newDepsToLogHandle)
              clearTimeout(newDepsToLogHandle);
            newDepsToLogHandle = void 0;
            logNewlyDiscoveredDeps();
          }
          logger2.info(picocolorsExports.green(`✨ optimized dependencies changed. reloading`), {
            timestamp: true
          });
          if (needsInteropMismatch.length > 0) {
            config2.logger.warn(`Mixed ESM and CJS detected in ${picocolorsExports.yellow(needsInteropMismatch.join(", "))}, add ${needsInteropMismatch.length === 1 ? "it" : "them"} to optimizeDeps.needsInterop to speed up cold start`, {
              timestamp: true
            });
          }
          fullReload();
        }
      }
    } catch (e3) {
      logger2.error(picocolorsExports.red(`error while updating dependencies:
${e3.stack}`), { timestamp: true, error: e3 });
      resolveEnqueuedProcessingPromises();
      metadata.discovered = {};
    }
    currentlyProcessing = false;
    enqueuedRerun == null ? void 0 : enqueuedRerun();
  }
  function fullReload() {
    if (server2) {
      server2.moduleGraph.invalidateAll();
      server2.ws.send({
        type: "full-reload",
        path: "*"
      });
    }
  }
  async function rerun() {
    const deps = Object.keys(metadata.discovered);
    const depsString = depsLogString(deps);
    debuggerViteDeps(picocolorsExports.green(`new dependencies found: ${depsString}`));
    runOptimizer();
  }
  function getDiscoveredBrowserHash(hash2, deps, missing) {
    return getHash(hash2 + JSON.stringify(deps) + JSON.stringify(missing) + sessionTimestamp);
  }
  function registerMissingImport(id, resolved) {
    const optimized = metadata.optimized[id];
    if (optimized) {
      return optimized;
    }
    const chunk = metadata.chunks[id];
    if (chunk) {
      return chunk;
    }
    let missing = metadata.discovered[id];
    if (missing) {
      return missing;
    }
    missing = addMissingDep(id, resolved);
    if (firstRunCalled) {
      debouncedProcessing();
    }
    return missing;
  }
  function addMissingDep(id, resolved) {
    newDepsDiscovered = true;
    return addOptimizedDepInfo(metadata, "discovered", {
      id,
      file: getOptimizedDepPath(id, config2, ssr),
      src: resolved,
      // Adding a browserHash to this missing dependency that is unique to
      // the current state of known + missing deps. If its optimizeDeps run
      // doesn't alter the bundled files of previous known dependencies,
      // we don't need a full reload and this browserHash will be kept
      browserHash: getDiscoveredBrowserHash(metadata.hash, depsFromOptimizedDepInfo(metadata.optimized), depsFromOptimizedDepInfo(metadata.discovered)),
      // loading of this pre-bundled dep needs to await for its processing
      // promise to be resolved
      processing: depOptimizationProcessing.promise,
      exportsData: extractExportsData(resolved, config2, ssr)
    });
  }
  function debouncedProcessing(timeout2 = debounceMs) {
    if (!newDepsDiscovered) {
      return;
    }
    enqueuedRerun = void 0;
    if (handle2)
      clearTimeout(handle2);
    if (newDepsToLogHandle)
      clearTimeout(newDepsToLogHandle);
    newDepsToLogHandle = void 0;
    handle2 = setTimeout(() => {
      handle2 = void 0;
      enqueuedRerun = rerun;
      if (!currentlyProcessing) {
        enqueuedRerun();
      }
    }, timeout2);
  }
  async function onCrawlEnd() {
    debuggerViteDeps(picocolorsExports.green(`✨ static imports crawl ended`));
    if (firstRunCalled) {
      return;
    }
    currentlyProcessing = false;
    const crawlDeps = Object.keys(metadata.discovered);
    await depsOptimizer.scanProcessing;
    if (!isBuild && postScanOptimizationResult) {
      const result = await postScanOptimizationResult;
      postScanOptimizationResult = void 0;
      const scanDeps = Object.keys(result.metadata.optimized);
      if (scanDeps.length === 0 && crawlDeps.length === 0) {
        debuggerViteDeps(picocolorsExports.green(`✨ no dependencies found by the scanner or crawling static imports`));
        result.cancel();
        firstRunCalled = true;
        return;
      }
      const needsInteropMismatch = findInteropMismatches(metadata.discovered, result.metadata.optimized);
      const scannerMissedDeps = crawlDeps.some((dep) => !scanDeps.includes(dep));
      const outdatedResult = needsInteropMismatch.length > 0 || scannerMissedDeps;
      if (outdatedResult) {
        result.cancel();
        for (const dep of scanDeps) {
          if (!crawlDeps.includes(dep)) {
            addMissingDep(dep, result.metadata.optimized[dep].src);
          }
        }
        if (scannerMissedDeps) {
          debuggerViteDeps(picocolorsExports.yellow(`✨ new dependencies were found while crawling that weren't detected by the scanner`));
        }
        debuggerViteDeps(picocolorsExports.green(`✨ re-running optimizer`));
        debouncedProcessing(0);
      } else {
        debuggerViteDeps(picocolorsExports.green(`✨ using post-scan optimizer result, the scanner found every used dependency`));
        startNextDiscoveredBatch();
        runOptimizer(result);
      }
    } else {
      if (crawlDeps.length === 0) {
        debuggerViteDeps(picocolorsExports.green(`✨ no dependencies found while crawling the static imports`));
        firstRunCalled = true;
      } else {
        debouncedProcessing(0);
      }
    }
  }
  const runOptimizerIfIdleAfterMs = 100;
  let registeredIds = [];
  let seenIds = /* @__PURE__ */ new Set();
  let workersSources = /* @__PURE__ */ new Set();
  let waitingOn;
  let firstRunEnsured = false;
  function resetRegisteredIds() {
    registeredIds = [];
    seenIds = /* @__PURE__ */ new Set();
    workersSources = /* @__PURE__ */ new Set();
    waitingOn = void 0;
    firstRunEnsured = false;
  }
  function ensureFirstRun() {
    if (!firstRunEnsured && !firstRunCalled && registeredIds.length === 0) {
      setTimeout(() => {
        if (!closed && registeredIds.length === 0) {
          onCrawlEnd();
        }
      }, runOptimizerIfIdleAfterMs);
    }
    firstRunEnsured = true;
  }
  function registerWorkersSource(id) {
    workersSources.add(id);
    registeredIds = registeredIds.filter((registered) => registered.id !== id);
    if (waitingOn === id) {
      waitingOn = void 0;
      runOptimizerWhenIdle();
    }
  }
  function delayDepsOptimizerUntil(id, done) {
    if (!depsOptimizer.isOptimizedDepFile(id) && !seenIds.has(id)) {
      seenIds.add(id);
      registeredIds.push({ id, done });
      runOptimizerWhenIdle();
    }
  }
  function runOptimizerWhenIdle() {
    if (!waitingOn) {
      const next = registeredIds.pop();
      if (next) {
        waitingOn = next.id;
        const afterLoad = () => {
          waitingOn = void 0;
          if (!closed && !workersSources.has(next.id)) {
            if (registeredIds.length > 0) {
              runOptimizerWhenIdle();
            } else {
              onCrawlEnd();
            }
          }
        };
        next.done().then(() => {
          setTimeout(afterLoad, registeredIds.length > 0 ? 0 : runOptimizerIfIdleAfterMs);
        }).catch(afterLoad);
      }
    }
  }
}
async function createDevSsrDepsOptimizer(config2) {
  const metadata = await optimizeServerSsrDeps(config2);
  const depsOptimizer = {
    metadata,
    isOptimizedDepFile: (id) => isOptimizedDepFile(id, config2),
    isOptimizedDepUrl: createIsOptimizedDepUrl(config2),
    getOptimizedDepId: (depInfo) => `${depInfo.file}?v=${depInfo.browserHash}`,
    registerMissingImport: () => {
      throw new Error("Vite Internal Error: registerMissingImport is not supported in dev SSR");
    },
    // noop, there is no scanning during dev SSR
    // the optimizer blocks the server start
    run: () => {
    },
    registerWorkersSource: (id) => {
    },
    delayDepsOptimizerUntil: (id, done) => {
    },
    resetRegisteredIds: () => {
    },
    ensureFirstRun: () => {
    },
    close: async () => {
    },
    options: config2.ssr.optimizeDeps
  };
  devSsrDepsOptimizerMap.set(config2, depsOptimizer);
}
function findInteropMismatches(discovered, optimized) {
  const needsInteropMismatch = [];
  for (const dep in discovered) {
    const discoveredDepInfo = discovered[dep];
    const depInfo = optimized[dep];
    if (depInfo) {
      if (discoveredDepInfo.needsInterop !== void 0 && depInfo.needsInterop !== discoveredDepInfo.needsInterop) {
        needsInteropMismatch.push(dep);
        debuggerViteDeps(picocolorsExports.cyan(`✨ needsInterop mismatch detected for ${dep}`));
      }
    }
  }
  return needsInteropMismatch;
}
var debuggerViteDeps = createDebugger("vite:deps");
var debug$7 = debuggerViteDeps;
var isDebugEnabled = _debug("vite:deps").enabled;
var jsExtensionRE = /\.js$/i;
var jsMapExtensionRE = /\.js\.map$/i;
async function optimizeDeps(config2, force = config2.optimizeDeps.force, asCommand = false) {
  const log8 = asCommand ? config2.logger.info : debug$7;
  const ssr = config2.command === "build" && !!config2.build.ssr;
  const cachedMetadata = loadCachedDepOptimizationMetadata(config2, ssr, force, asCommand);
  if (cachedMetadata) {
    return cachedMetadata;
  }
  const deps = await discoverProjectDependencies(config2);
  const depsString = depsLogString(Object.keys(deps));
  log8(picocolorsExports.green(`Optimizing dependencies:
  ${depsString}`));
  await addManuallyIncludedOptimizeDeps(deps, config2, ssr);
  const depsInfo = toDiscoveredDependencies(config2, deps, ssr);
  const result = await runOptimizeDeps(config2, depsInfo);
  await result.commit();
  return result.metadata;
}
async function optimizeServerSsrDeps(config2) {
  var _a;
  const ssr = true;
  const cachedMetadata = loadCachedDepOptimizationMetadata(config2, ssr, config2.optimizeDeps.force, false);
  if (cachedMetadata) {
    return cachedMetadata;
  }
  let alsoInclude;
  let noExternalFilter;
  const { exclude } = getDepOptimizationConfig(config2, ssr);
  const noExternal = (_a = config2.ssr) == null ? void 0 : _a.noExternal;
  if (noExternal) {
    alsoInclude = arraify(noExternal).filter((ne) => typeof ne === "string");
    noExternalFilter = noExternal === true ? (dep) => true : createFilter$1(void 0, exclude, {
      resolve: false
    });
  }
  const deps = {};
  await addManuallyIncludedOptimizeDeps(deps, config2, ssr, alsoInclude, noExternalFilter);
  const depsInfo = toDiscoveredDependencies(config2, deps, true);
  const result = await runOptimizeDeps(config2, depsInfo, true);
  await result.commit();
  return result.metadata;
}
function initDepsOptimizerMetadata(config2, ssr, timestamp3) {
  const hash2 = getDepHash(config2, ssr);
  return {
    hash: hash2,
    browserHash: getOptimizedBrowserHash(hash2, {}, timestamp3),
    optimized: {},
    chunks: {},
    discovered: {},
    depInfoList: []
  };
}
function addOptimizedDepInfo(metadata, type, depInfo) {
  metadata[type][depInfo.id] = depInfo;
  metadata.depInfoList.push(depInfo);
  return depInfo;
}
function loadCachedDepOptimizationMetadata(config2, ssr, force = config2.optimizeDeps.force, asCommand = false) {
  const log8 = asCommand ? config2.logger.info : debug$7;
  if (import_node_fs4.default.existsSync(import_node_path4.default.join(config2.cacheDir, "_metadata.json"))) {
    emptyDir(config2.cacheDir);
  }
  const depsCacheDir = getDepsCacheDir(config2, ssr);
  if (!force) {
    let cachedMetadata;
    try {
      const cachedMetadataPath = import_node_path4.default.join(depsCacheDir, "_metadata.json");
      cachedMetadata = parseDepsOptimizerMetadata(import_node_fs4.default.readFileSync(cachedMetadataPath, "utf-8"), depsCacheDir);
    } catch (e3) {
    }
    if (cachedMetadata && cachedMetadata.hash === getDepHash(config2, ssr)) {
      log8("Hash is consistent. Skipping. Use --force to override.");
      return cachedMetadata;
    }
  } else {
    config2.logger.info("Forced re-optimization of dependencies");
  }
  import_node_fs4.default.rmSync(depsCacheDir, { recursive: true, force: true });
}
async function discoverProjectDependencies(config2) {
  const { deps, missing } = await scanImports(config2);
  const missingIds = Object.keys(missing);
  if (missingIds.length) {
    throw new Error(`The following dependencies are imported but could not be resolved:

  ${missingIds.map((id) => `${picocolorsExports.cyan(id)} ${picocolorsExports.white(picocolorsExports.dim(`(imported by ${missing[id]})`))}`).join(`
  `)}

Are they installed?`);
  }
  return deps;
}
function toDiscoveredDependencies(config2, deps, ssr, timestamp3) {
  const browserHash = getOptimizedBrowserHash(getDepHash(config2, ssr), deps, timestamp3);
  const discovered = {};
  for (const id in deps) {
    const src3 = deps[id];
    discovered[id] = {
      id,
      file: getOptimizedDepPath(id, config2, ssr),
      src: src3,
      browserHash,
      exportsData: extractExportsData(src3, config2, ssr)
    };
  }
  return discovered;
}
function depsLogString(qualifiedIds) {
  if (isDebugEnabled) {
    return picocolorsExports.yellow(qualifiedIds.join(`, `));
  } else {
    const total = qualifiedIds.length;
    const maxListed = 5;
    const listed = Math.min(total, maxListed);
    const extra = Math.max(0, total - maxListed);
    return picocolorsExports.yellow(qualifiedIds.slice(0, listed).join(`, `) + (extra > 0 ? `, ...and ${extra} more` : ``));
  }
}
async function runOptimizeDeps(resolvedConfig, depsInfo, ssr = resolvedConfig.command === "build" && !!resolvedConfig.build.ssr) {
  var _a, _b, _c;
  const isBuild = resolvedConfig.command === "build";
  const config2 = {
    ...resolvedConfig,
    command: "build"
  };
  const depsCacheDir = getDepsCacheDir(resolvedConfig, ssr);
  const processingCacheDir = getProcessingDepsCacheDir(resolvedConfig, ssr);
  if (import_node_fs4.default.existsSync(processingCacheDir)) {
    emptyDir(processingCacheDir);
  } else {
    import_node_fs4.default.mkdirSync(processingCacheDir, { recursive: true });
  }
  writeFile(import_node_path4.default.resolve(processingCacheDir, "package.json"), JSON.stringify({ type: "module" }));
  const metadata = initDepsOptimizerMetadata(config2, ssr);
  metadata.browserHash = getOptimizedBrowserHash(metadata.hash, depsFromOptimizedDepInfo(depsInfo));
  const qualifiedIds = Object.keys(depsInfo);
  const processingResult = {
    metadata,
    async commit() {
      await removeDir(depsCacheDir);
      await renameDir(processingCacheDir, depsCacheDir);
    },
    cancel() {
      import_node_fs4.default.rmSync(processingCacheDir, { recursive: true, force: true });
    }
  };
  if (!qualifiedIds.length) {
    return processingResult;
  }
  const flatIdDeps = {};
  const idToExports = {};
  const optimizeDeps2 = getDepOptimizationConfig(config2, ssr);
  const { plugins: pluginsFromConfig = [], ...esbuildOptions } = (optimizeDeps2 == null ? void 0 : optimizeDeps2.esbuildOptions) ?? {};
  for (const id in depsInfo) {
    const src3 = depsInfo[id].src;
    const exportsData = await (depsInfo[id].exportsData ?? extractExportsData(src3, config2, ssr));
    if (exportsData.jsxLoader) {
      esbuildOptions.loader = {
        ".js": "jsx",
        ...esbuildOptions.loader
      };
    }
    const flatId = flattenId(id);
    flatIdDeps[flatId] = src3;
    idToExports[id] = exportsData;
  }
  const define2 = {
    "process.env.NODE_ENV": isBuild ? "__vite_process_env_NODE_ENV" : JSON.stringify("development")
  };
  const platform2 = ssr && ((_a = config2.ssr) == null ? void 0 : _a.target) !== "webworker" ? "node" : "browser";
  const external = [...(optimizeDeps2 == null ? void 0 : optimizeDeps2.exclude) ?? []];
  if (isBuild) {
    let rollupOptionsExternal = (_c = (_b = config2 == null ? void 0 : config2.build) == null ? void 0 : _b.rollupOptions) == null ? void 0 : _c.external;
    if (rollupOptionsExternal) {
      if (typeof rollupOptionsExternal === "string") {
        rollupOptionsExternal = [rollupOptionsExternal];
      }
      if (!Array.isArray(rollupOptionsExternal) || rollupOptionsExternal.some((ext2) => typeof ext2 !== "string")) {
        throw new Error(`[vite] 'build.rollupOptions.external' can only be an array of strings or a string when using esbuild optimization at build time.`);
      }
      external.push(...rollupOptionsExternal);
    }
  }
  const plugins2 = [...pluginsFromConfig];
  if (external.length) {
    plugins2.push(esbuildCjsExternalPlugin(external, platform2));
  }
  plugins2.push(esbuildDepPlugin(flatIdDeps, external, config2, ssr));
  const start = import_node_perf_hooks.performance.now();
  const result = await (0, import_esbuild.build)({
    absWorkingDir: process.cwd(),
    entryPoints: Object.keys(flatIdDeps),
    bundle: true,
    // We can't use platform 'neutral', as esbuild has custom handling
    // when the platform is 'node' or 'browser' that can't be emulated
    // by using mainFields and conditions
    platform: platform2,
    define: define2,
    format: "esm",
    // See https://github.com/evanw/esbuild/issues/1921#issuecomment-1152991694
    banner: platform2 === "node" ? {
      js: `import { createRequire } from 'module';const require = createRequire(import.meta.url);`
    } : void 0,
    target: isBuild ? config2.build.target || void 0 : ESBUILD_MODULES_TARGET,
    external,
    logLevel: "error",
    splitting: true,
    sourcemap: true,
    outdir: processingCacheDir,
    ignoreAnnotations: !isBuild,
    metafile: true,
    plugins: plugins2,
    charset: "utf8",
    ...esbuildOptions,
    supported: {
      "dynamic-import": true,
      "import-meta": true,
      ...esbuildOptions.supported
    }
  });
  const meta = result.metafile;
  const processingCacheDirOutputPath = import_node_path4.default.relative(process.cwd(), processingCacheDir);
  for (const id in depsInfo) {
    const output = esbuildOutputFromId(meta.outputs, id, processingCacheDir);
    const { exportsData, ...info3 } = depsInfo[id];
    addOptimizedDepInfo(metadata, "optimized", {
      ...info3,
      // We only need to hash the output.imports in to check for stability, but adding the hash
      // and file path gives us a unique hash that may be useful for other things in the future
      fileHash: getHash(metadata.hash + depsInfo[id].file + JSON.stringify(output.imports)),
      browserHash: metadata.browserHash,
      // After bundling we have more information and can warn the user about legacy packages
      // that require manual configuration
      needsInterop: needsInterop(config2, ssr, id, idToExports[id], output)
    });
  }
  for (const o3 of Object.keys(meta.outputs)) {
    if (!o3.match(jsMapExtensionRE)) {
      const id = import_node_path4.default.relative(processingCacheDirOutputPath, o3).replace(jsExtensionRE, "");
      const file = getOptimizedDepPath(id, resolvedConfig, ssr);
      if (!findOptimizedDepInfoInRecord(metadata.optimized, (depInfo) => depInfo.file === file)) {
        addOptimizedDepInfo(metadata, "chunks", {
          id,
          file,
          needsInterop: false,
          browserHash: metadata.browserHash
        });
      }
    }
  }
  const dataPath = import_node_path4.default.join(processingCacheDir, "_metadata.json");
  writeFile(dataPath, stringifyDepsOptimizerMetadata(metadata, depsCacheDir));
  debug$7(`deps bundled in ${(import_node_perf_hooks.performance.now() - start).toFixed(2)}ms`);
  return processingResult;
}
async function findKnownImports(config2, ssr) {
  const deps = (await scanImports(config2)).deps;
  await addManuallyIncludedOptimizeDeps(deps, config2, ssr);
  return Object.keys(deps);
}
async function addManuallyIncludedOptimizeDeps(deps, config2, ssr, extra = [], filter2) {
  const { logger: logger2 } = config2;
  const optimizeDeps2 = getDepOptimizationConfig(config2, ssr);
  const optimizeDepsInclude = (optimizeDeps2 == null ? void 0 : optimizeDeps2.include) ?? [];
  if (optimizeDepsInclude.length || extra.length) {
    const unableToOptimize = (id, msg) => {
      if (optimizeDepsInclude.includes(id)) {
        logger2.warn(`${msg}: ${picocolorsExports.cyan(id)}, present in '${ssr ? "ssr." : ""}optimizeDeps.include'`);
      }
    };
    const resolve4 = config2.createResolver({
      asSrc: false,
      scan: true,
      ssrOptimizeCheck: ssr,
      ssrConfig: config2.ssr
    });
    for (const id of [...optimizeDepsInclude, ...extra]) {
      const normalizedId = normalizeId(id);
      if (!deps[normalizedId] && (filter2 == null ? void 0 : filter2(normalizedId)) !== false) {
        const entry2 = await resolve4(id, void 0, void 0, ssr);
        if (entry2) {
          if (isOptimizable(entry2, optimizeDeps2)) {
            if (!entry2.endsWith("?__vite_skip_optimization")) {
              deps[normalizedId] = entry2;
            }
          } else {
            unableToOptimize(entry2, "Cannot optimize dependency");
          }
        } else {
          unableToOptimize(id, "Failed to resolve dependency");
        }
      }
    }
  }
}
function newDepOptimizationProcessing() {
  let resolve4;
  const promise2 = new Promise((_resolve) => {
    resolve4 = _resolve;
  });
  return { promise: promise2, resolve: resolve4 };
}
function depsFromOptimizedDepInfo(depsInfo) {
  return Object.fromEntries(Object.entries(depsInfo).map((d2) => [d2[0], d2[1].src]));
}
function getOptimizedDepPath(id, config2, ssr) {
  return normalizePath$3(import_node_path4.default.resolve(getDepsCacheDir(config2, ssr), flattenId(id) + ".js"));
}
function getDepsCacheSuffix(config2, ssr) {
  let suffix = "";
  if (config2.command === "build") {
    const { outDir } = config2.build;
    const buildId = outDir.length > 8 || outDir.includes("/") ? getHash(outDir) : outDir;
    suffix += `_build-${buildId}`;
  }
  if (ssr) {
    suffix += "_ssr";
  }
  return suffix;
}
function getDepsCacheDir(config2, ssr) {
  return getDepsCacheDirPrefix(config2) + getDepsCacheSuffix(config2, ssr);
}
function getProcessingDepsCacheDir(config2, ssr) {
  return getDepsCacheDirPrefix(config2) + getDepsCacheSuffix(config2, ssr) + "_temp";
}
function getDepsCacheDirPrefix(config2) {
  return normalizePath$3(import_node_path4.default.resolve(config2.cacheDir, "deps"));
}
function isOptimizedDepFile(id, config2) {
  return id.startsWith(getDepsCacheDirPrefix(config2));
}
function createIsOptimizedDepUrl(config2) {
  const { root } = config2;
  const depsCacheDir = getDepsCacheDirPrefix(config2);
  const depsCacheDirRelative = normalizePath$3(import_node_path4.default.relative(root, depsCacheDir));
  const depsCacheDirPrefix = depsCacheDirRelative.startsWith("../") ? (
    // if the cache directory is outside root, the url prefix would be something
    // like '/@fs/absolute/path/to/node_modules/.vite'
    `/@fs/${normalizePath$3(depsCacheDir).replace(/^\//, "")}`
  ) : (
    // if the cache directory is inside root, the url prefix would be something
    // like '/node_modules/.vite'
    `/${depsCacheDirRelative}`
  );
  return function isOptimizedDepUrl(url2) {
    return url2.startsWith(depsCacheDirPrefix);
  };
}
function parseDepsOptimizerMetadata(jsonMetadata, depsCacheDir) {
  const { hash: hash2, browserHash, optimized, chunks } = JSON.parse(jsonMetadata, (key, value2) => {
    if (key === "file" || key === "src") {
      return normalizePath$3(import_node_path4.default.resolve(depsCacheDir, value2));
    }
    return value2;
  });
  if (!chunks || Object.values(optimized).some((depInfo) => !depInfo.fileHash)) {
    return;
  }
  const metadata = {
    hash: hash2,
    browserHash,
    optimized: {},
    discovered: {},
    chunks: {},
    depInfoList: []
  };
  for (const id of Object.keys(optimized)) {
    addOptimizedDepInfo(metadata, "optimized", {
      ...optimized[id],
      id,
      browserHash
    });
  }
  for (const id of Object.keys(chunks)) {
    addOptimizedDepInfo(metadata, "chunks", {
      ...chunks[id],
      id,
      browserHash,
      needsInterop: false
    });
  }
  return metadata;
}
function stringifyDepsOptimizerMetadata(metadata, depsCacheDir) {
  const { hash: hash2, browserHash, optimized, chunks } = metadata;
  return JSON.stringify({
    hash: hash2,
    browserHash,
    optimized: Object.fromEntries(Object.values(optimized).map(({ id, src: src3, file, fileHash, needsInterop: needsInterop2 }) => [
      id,
      {
        src: src3,
        file,
        fileHash,
        needsInterop: needsInterop2
      }
    ])),
    chunks: Object.fromEntries(Object.values(chunks).map(({ id, file }) => [id, { file }]))
  }, (key, value2) => {
    if (key === "file" || key === "src") {
      return normalizePath$3(import_node_path4.default.relative(depsCacheDir, value2));
    }
    return value2;
  }, 2);
}
function esbuildOutputFromId(outputs, id, cacheDirOutputPath) {
  const cwd = process.cwd();
  const flatId = flattenId(id) + ".js";
  const normalizedOutputPath = normalizePath$3(import_node_path4.default.relative(cwd, import_node_path4.default.join(cacheDirOutputPath, flatId)));
  const output = outputs[normalizedOutputPath];
  if (output) {
    return output;
  }
  for (const [key, value2] of Object.entries(outputs)) {
    if (normalizePath$3(import_node_path4.default.relative(cwd, key)) === normalizedOutputPath) {
      return value2;
    }
  }
}
async function extractExportsData(filePath, config2, ssr) {
  var _a, _b;
  await init;
  const optimizeDeps2 = getDepOptimizationConfig(config2, ssr);
  const esbuildOptions = (optimizeDeps2 == null ? void 0 : optimizeDeps2.esbuildOptions) ?? {};
  if ((_a = optimizeDeps2.extensions) == null ? void 0 : _a.some((ext2) => filePath.endsWith(ext2))) {
    const result = await (0, import_esbuild.build)({
      ...esbuildOptions,
      entryPoints: [filePath],
      write: false,
      format: "esm"
    });
    const [imports2, exports4, facade2] = parse$e(result.outputFiles[0].text);
    return {
      hasImports: imports2.length > 0,
      exports: exports4.map((e3) => e3.n),
      facade: facade2
    };
  }
  let parseResult;
  let usedJsxLoader = false;
  const entryContent = import_node_fs4.default.readFileSync(filePath, "utf-8");
  try {
    parseResult = parse$e(entryContent);
  } catch {
    const loader = ((_b = esbuildOptions.loader) == null ? void 0 : _b[import_node_path4.default.extname(filePath)]) || "jsx";
    debug$7(`Unable to parse: ${filePath}.
 Trying again with a ${loader} transform.`);
    const transformed = await transformWithEsbuild(entryContent, filePath, {
      loader
    });
    esbuildOptions.loader = {
      ".js": "jsx",
      ...esbuildOptions.loader
    };
    parseResult = parse$e(transformed.code);
    usedJsxLoader = true;
  }
  const [imports, exports3, facade] = parseResult;
  const exportsData = {
    hasImports: imports.length > 0,
    exports: exports3.map((e3) => e3.n),
    facade,
    hasReExports: imports.some(({ ss, se }) => {
      const exp = entryContent.slice(ss, se);
      return /export\s+\*\s+from/.test(exp);
    }),
    jsxLoader: usedJsxLoader
  };
  return exportsData;
}
function needsInterop(config2, ssr, id, exportsData, output) {
  var _a, _b;
  if ((_b = (_a = getDepOptimizationConfig(config2, ssr)) == null ? void 0 : _a.needsInterop) == null ? void 0 : _b.includes(id)) {
    return true;
  }
  const { hasImports, exports: exports3 } = exportsData;
  if (!exports3.length && !hasImports) {
    return true;
  }
  if (output) {
    const generatedExports = output.exports;
    if (!generatedExports || isSingleDefaultExport(generatedExports) && !isSingleDefaultExport(exports3)) {
      return true;
    }
  }
  return false;
}
function isSingleDefaultExport(exports3) {
  return exports3.length === 1 && exports3[0] === "default";
}
var lockfileFormats = [
  { name: "package-lock.json", checkPatches: true },
  { name: "yarn.lock", checkPatches: true },
  { name: "pnpm-lock.yaml", checkPatches: false },
  { name: "bun.lockb", checkPatches: true }
];
function getDepHash(config2, ssr) {
  var _a, _b;
  const lockfilePath = lookupFile(config2.root, lockfileFormats.map((l2) => l2.name), { pathOnly: true });
  let content = lockfilePath ? import_node_fs4.default.readFileSync(lockfilePath, "utf-8") : "";
  if (lockfilePath) {
    const lockfileName = import_node_path4.default.basename(lockfilePath);
    const { checkPatches } = lockfileFormats.find((f2) => f2.name === lockfileName);
    if (checkPatches) {
      const fullPath = import_node_path4.default.join(import_node_path4.default.dirname(lockfilePath), "patches");
      if (import_node_fs4.default.existsSync(fullPath)) {
        const stats = import_node_fs4.default.statSync(fullPath);
        if (stats.isDirectory()) {
          content += stats.mtimeMs.toString();
        }
      }
    }
  }
  const optimizeDeps2 = getDepOptimizationConfig(config2, ssr);
  content += JSON.stringify({
    mode: "development",
    root: config2.root,
    resolve: config2.resolve,
    buildTarget: config2.build.target,
    assetsInclude: config2.assetsInclude,
    plugins: config2.plugins.map((p2) => p2.name),
    optimizeDeps: {
      include: optimizeDeps2 == null ? void 0 : optimizeDeps2.include,
      exclude: optimizeDeps2 == null ? void 0 : optimizeDeps2.exclude,
      esbuildOptions: {
        ...optimizeDeps2 == null ? void 0 : optimizeDeps2.esbuildOptions,
        plugins: (_b = (_a = optimizeDeps2 == null ? void 0 : optimizeDeps2.esbuildOptions) == null ? void 0 : _a.plugins) == null ? void 0 : _b.map((p2) => p2.name)
      }
    }
  }, (_, value2) => {
    if (typeof value2 === "function" || value2 instanceof RegExp) {
      return value2.toString();
    }
    return value2;
  });
  return getHash(content);
}
function getOptimizedBrowserHash(hash2, deps, timestamp3 = "") {
  return getHash(hash2 + JSON.stringify(deps) + timestamp3);
}
function optimizedDepInfoFromId(metadata, id) {
  return metadata.optimized[id] || metadata.discovered[id] || metadata.chunks[id];
}
function optimizedDepInfoFromFile(metadata, file) {
  return metadata.depInfoList.find((depInfo) => depInfo.file === file);
}
function findOptimizedDepInfoInRecord(dependenciesInfo, callbackFn) {
  for (const o3 of Object.keys(dependenciesInfo)) {
    const info3 = dependenciesInfo[o3];
    if (callbackFn(info3, o3)) {
      return info3;
    }
  }
}
async function optimizedDepNeedsInterop(metadata, file, config2, ssr) {
  const depInfo = optimizedDepInfoFromFile(metadata, file);
  if ((depInfo == null ? void 0 : depInfo.src) && depInfo.needsInterop === void 0) {
    depInfo.exportsData ?? (depInfo.exportsData = extractExportsData(depInfo.src, config2, ssr));
    depInfo.needsInterop = needsInterop(config2, ssr, depInfo.id, await depInfo.exportsData);
  }
  return depInfo == null ? void 0 : depInfo.needsInterop;
}
var index$1 = {
  __proto__: null,
  addManuallyIncludedOptimizeDeps,
  addOptimizedDepInfo,
  createIsOptimizedDepUrl,
  debuggerViteDeps,
  depsFromOptimizedDepInfo,
  depsLogString,
  discoverProjectDependencies,
  extractExportsData,
  findKnownImports,
  getDepHash,
  getDepsCacheDir,
  getDepsCacheDirPrefix,
  getDepsOptimizer,
  getOptimizedDepPath,
  initDepsOptimizer,
  initDepsOptimizerMetadata,
  initDevSsrDepsOptimizer,
  isOptimizedDepFile,
  loadCachedDepOptimizationMetadata,
  newDepOptimizationProcessing,
  optimizeDeps,
  optimizeServerSsrDeps,
  optimizedDepInfoFromFile,
  optimizedDepInfoFromId,
  optimizedDepNeedsInterop,
  runOptimizeDeps,
  toDiscoveredDependencies
};
var isModernFlag = `__VITE_IS_MODERN__`;
var preloadMethod = `__vitePreload`;
var preloadMarker = `__VITE_PRELOAD__`;
var preloadHelperId = "\0vite/preload-helper";
var preloadMarkerWithQuote = `"${preloadMarker}"`;
var dynamicImportPrefixRE = /import\s*\(/;
var optimizedDepChunkRE = /\/chunk-[A-Z\d]{8}\.js/;
var optimizedDepDynamicRE = /-[A-Z\d]{8}\.js/;
function toRelativePath2(filename, importer) {
  const relPath = import_node_path4.default.relative(import_node_path4.default.dirname(importer), filename);
  return relPath.startsWith(".") ? relPath : `./${relPath}`;
}
function detectScriptRel() {
  const relList = document.createElement("link").relList;
  return relList && relList.supports && relList.supports("modulepreload") ? "modulepreload" : "preload";
}
function preload(baseModule, deps, importerUrl) {
  if (!__VITE_IS_MODERN__ || !deps || deps.length === 0) {
    return baseModule();
  }
  const links = document.getElementsByTagName("link");
  return Promise.all(deps.map((dep) => {
    dep = assetsURL(dep, importerUrl);
    if (dep in seen)
      return;
    seen[dep] = true;
    const isCss = dep.endsWith(".css");
    const cssSelector = isCss ? '[rel="stylesheet"]' : "";
    const isBaseRelative = !!importerUrl;
    if (isBaseRelative) {
      for (let i2 = links.length - 1; i2 >= 0; i2--) {
        const link2 = links[i2];
        if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
          return;
        }
      }
    } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
      return;
    }
    const link = document.createElement("link");
    link.rel = isCss ? "stylesheet" : scriptRel;
    if (!isCss) {
      link.as = "script";
      link.crossOrigin = "";
    }
    link.href = dep;
    document.head.appendChild(link);
    if (isCss) {
      return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
      });
    }
  })).then(() => baseModule());
}
function buildImportAnalysisPlugin(config2) {
  const ssr = !!config2.build.ssr;
  const isWorker = config2.isWorker;
  const insertPreload = !(ssr || !!config2.build.lib || isWorker || config2.build.modulePreload === false);
  const resolveModulePreloadDependencies = config2.build.modulePreload && config2.build.modulePreload.resolveDependencies;
  const renderBuiltUrl = config2.experimental.renderBuiltUrl;
  const customModulePreloadPaths = !!(resolveModulePreloadDependencies || renderBuiltUrl);
  const isRelativeBase = config2.base === "./" || config2.base === "";
  const optimizeModulePreloadRelativePaths = isRelativeBase && !customModulePreloadPaths;
  const { modulePreload } = config2.build;
  const scriptRel2 = modulePreload && modulePreload.polyfill ? `'modulepreload'` : `(${detectScriptRel.toString()})()`;
  const assetsURL2 = customModulePreloadPaths ? (
    // If `experimental.renderBuiltUrl` or `build.modulePreload.resolveDependencies` are used
    // the dependencies are already resolved. To avoid the need for `new URL(dep, import.meta.url)`
    // a helper `__vitePreloadRelativeDep` is used to resolve from relative paths which can be minimized.
    `function(dep, importerUrl) { return dep.startsWith('.') ? new URL(dep, importerUrl).href : dep }`
  ) : optimizeModulePreloadRelativePaths ? (
    // If there isn't custom resolvers affecting the deps list, deps in the list are relative
    // to the current chunk and are resolved to absolute URL by the __vitePreload helper itself.
    // The importerUrl is passed as third parameter to __vitePreload in this case
    `function(dep, importerUrl) { return new URL(dep, importerUrl).href }`
  ) : (
    // If the base isn't relative, then the deps are relative to the projects `outDir` and the base
    // is appended inside __vitePreload too.
    `function(dep) { return ${JSON.stringify(config2.base)}+dep }`
  );
  const preloadCode = `const scriptRel = ${scriptRel2};const assetsURL = ${assetsURL2};const seen = {};export const ${preloadMethod} = ${preload.toString()}`;
  return {
    name: "vite:build-import-analysis",
    resolveId(id) {
      if (id === preloadHelperId) {
        return id;
      }
    },
    load(id) {
      if (id === preloadHelperId) {
        return preloadCode;
      }
    },
    async transform(source, importer) {
      if (importer.includes("node_modules") && !dynamicImportPrefixRE.test(source)) {
        return;
      }
      await init;
      let imports = [];
      try {
        imports = parse$e(source)[0];
      } catch (e3) {
        this.error(e3, e3.idx);
      }
      if (!imports.length) {
        return null;
      }
      const { root } = config2;
      const depsOptimizer = getDepsOptimizer(config2, ssr);
      const normalizeUrl = async (url2, pos) => {
        let importerFile = importer;
        const optimizeDeps2 = getDepOptimizationConfig(config2, ssr);
        if (moduleListContains(optimizeDeps2 == null ? void 0 : optimizeDeps2.exclude, url2)) {
          if (depsOptimizer) {
            await depsOptimizer.scanProcessing;
            for (const optimizedModule of depsOptimizer.metadata.depInfoList) {
              if (!optimizedModule.src)
                continue;
              if (optimizedModule.file === importer) {
                importerFile = optimizedModule.src;
              }
            }
          }
        }
        const resolved = await this.resolve(url2, importerFile);
        if (!resolved) {
          if (ssr) {
            return [url2, url2];
          }
          return this.error(`Failed to resolve import "${url2}" from "${import_node_path4.default.relative(process.cwd(), importerFile)}". Does the file exist?`, pos);
        }
        if (resolved.id.startsWith(root + "/")) {
          url2 = resolved.id.slice(root.length);
        } else {
          url2 = resolved.id;
        }
        if (isExternalUrl(url2)) {
          return [url2, url2];
        }
        return [url2, resolved.id];
      };
      let s2;
      const str2 = () => s2 || (s2 = new MagicString(source));
      let needPreloadHelper = false;
      for (let index2 = 0; index2 < imports.length; index2++) {
        const { s: start, e: end, ss: expStart, se: expEnd, n: specifier, d: dynamicIndex, a: assertIndex } = imports[index2];
        const isDynamicImport = dynamicIndex > -1;
        if (!isDynamicImport && assertIndex > -1) {
          str2().remove(end + 1, expEnd);
        }
        if (isDynamicImport && insertPreload) {
          needPreloadHelper = true;
          str2().prependLeft(expStart, `${preloadMethod}(() => `);
          str2().appendRight(expEnd, `,${isModernFlag}?"${preloadMarker}":void 0${optimizeModulePreloadRelativePaths || customModulePreloadPaths ? ",import.meta.url" : ""})`);
        }
        if (depsOptimizer && specifier) {
          if (isExternalUrl(specifier) || isDataUrl(specifier)) {
            continue;
          }
          const [url2, resolvedId] = await normalizeUrl(specifier, start);
          if (url2 !== specifier) {
            if (depsOptimizer.isOptimizedDepFile(resolvedId) && !resolvedId.match(optimizedDepChunkRE)) {
              const file = cleanUrl(resolvedId);
              const needsInterop2 = await optimizedDepNeedsInterop(depsOptimizer.metadata, file, config2, ssr);
              let rewriteDone = false;
              if (needsInterop2 === void 0) {
                if (!file.match(optimizedDepDynamicRE)) {
                  config2.logger.error(picocolorsExports.red(`Vite Error, ${url2} optimized info should be defined`));
                }
              } else if (needsInterop2) {
                interopNamedImports(str2(), imports[index2], url2, index2);
                rewriteDone = true;
              }
              if (!rewriteDone) {
                let rewrittenUrl = JSON.stringify(file);
                if (!isDynamicImport)
                  rewrittenUrl = rewrittenUrl.slice(1, -1);
                str2().update(start, end, rewrittenUrl);
              }
            }
          }
        }
        if (specifier && isCSSRequest(specifier) && // always inject ?used query when it is a dynamic import
        // because there is no way to check whether the default export is used
        (source.slice(expStart, start).includes("from") || isDynamicImport) && // already has ?used query (by import.meta.glob)
        !specifier.match(/\?used(&|$)/) && // edge case for package names ending with .css (e.g normalize.css)
        !(bareImportRE.test(specifier) && !specifier.includes("/"))) {
          const url2 = specifier.replace(/\?|$/, (m) => `?used${m ? "&" : ""}`);
          str2().update(start, end, isDynamicImport ? `'${url2}'` : url2);
        }
      }
      if (needPreloadHelper && insertPreload && !source.includes(`const ${preloadMethod} =`)) {
        str2().prepend(`import { ${preloadMethod} } from "${preloadHelperId}";`);
      }
      if (s2) {
        return {
          code: s2.toString(),
          map: config2.build.sourcemap ? s2.generateMap({ hires: true }) : null
        };
      }
    },
    renderChunk(code, _, { format: format2 }) {
      if (code.indexOf(isModernFlag) > -1) {
        const re = new RegExp(isModernFlag, "g");
        const isModern = String(format2 === "es");
        if (config2.build.sourcemap) {
          const s2 = new MagicString(code);
          let match;
          while (match = re.exec(code)) {
            s2.update(match.index, match.index + isModernFlag.length, isModern);
          }
          return {
            code: s2.toString(),
            map: s2.generateMap({ hires: true })
          };
        } else {
          return code.replace(re, isModern);
        }
      }
      return null;
    },
    generateBundle({ format: format2 }, bundle) {
      if (format2 !== "es" || ssr || isWorker || config2.build.modulePreload === false) {
        return;
      }
      for (const file in bundle) {
        const chunk = bundle[file];
        if (chunk.type === "chunk" && chunk.code.indexOf(preloadMarker) > -1) {
          const code = chunk.code;
          let imports;
          try {
            imports = parse$e(code)[0].filter((i2) => i2.d > -1);
          } catch (e3) {
            this.error(e3, e3.idx);
          }
          const s2 = new MagicString(code);
          const rewroteMarkerStartPos = /* @__PURE__ */ new Set();
          if (imports.length) {
            for (let index2 = 0; index2 < imports.length; index2++) {
              const { n: name2, s: start, e: end, ss: expStart, se: expEnd } = imports[index2];
              let url2 = name2;
              if (!url2) {
                const rawUrl = code.slice(start, end);
                if (rawUrl[0] === `"` && rawUrl[rawUrl.length - 1] === `"`)
                  url2 = rawUrl.slice(1, -1);
              }
              const deps = /* @__PURE__ */ new Set();
              let hasRemovedPureCssChunk = false;
              let normalizedFile = void 0;
              if (url2) {
                normalizedFile = import_node_path4.default.posix.join(import_node_path4.default.posix.dirname(chunk.fileName), url2);
                const ownerFilename = chunk.fileName;
                const analyzed = /* @__PURE__ */ new Set();
                const addDeps = (filename) => {
                  if (filename === ownerFilename)
                    return;
                  if (analyzed.has(filename))
                    return;
                  analyzed.add(filename);
                  const chunk2 = bundle[filename];
                  if (chunk2) {
                    deps.add(chunk2.fileName);
                    chunk2.imports.forEach(addDeps);
                    chunk2.viteMetadata.importedCss.forEach((file2) => {
                      deps.add(file2);
                    });
                  } else {
                    const removedPureCssFiles = removedPureCssFilesCache.get(config2);
                    const chunk3 = removedPureCssFiles.get(filename);
                    if (chunk3) {
                      if (chunk3.viteMetadata.importedCss.size) {
                        chunk3.viteMetadata.importedCss.forEach((file2) => {
                          deps.add(file2);
                        });
                        hasRemovedPureCssChunk = true;
                      }
                      s2.update(expStart, expEnd, "Promise.resolve({})");
                    }
                  }
                };
                addDeps(normalizedFile);
              }
              let markerStartPos2 = code.indexOf(preloadMarkerWithQuote, end);
              if (markerStartPos2 === -1 && imports.length === 1) {
                markerStartPos2 = code.indexOf(preloadMarkerWithQuote);
              }
              if (markerStartPos2 > 0) {
                const depsArray = deps.size > 1 || // main chunk is removed
                hasRemovedPureCssChunk && deps.size > 0 ? [...deps] : [];
                let renderedDeps;
                if (normalizedFile && customModulePreloadPaths) {
                  const { modulePreload: modulePreload2 } = config2.build;
                  const resolveDependencies = modulePreload2 && modulePreload2.resolveDependencies;
                  let resolvedDeps;
                  if (resolveDependencies) {
                    const cssDeps = [];
                    const otherDeps = [];
                    for (const dep of depsArray) {
                      (dep.endsWith(".css") ? cssDeps : otherDeps).push(dep);
                    }
                    resolvedDeps = [
                      ...resolveDependencies(normalizedFile, otherDeps, {
                        hostId: file,
                        hostType: "js"
                      }),
                      ...cssDeps
                    ];
                  } else {
                    resolvedDeps = depsArray;
                  }
                  renderedDeps = resolvedDeps.map((dep) => {
                    const replacement = toOutputFilePathInJS(dep, "asset", chunk.fileName, "js", config2, toRelativePath2);
                    const replacementString = typeof replacement === "string" ? JSON.stringify(replacement) : replacement.runtime;
                    return replacementString;
                  });
                } else {
                  renderedDeps = depsArray.map((d2) => (
                    // Don't include the assets dir if the default asset file names
                    // are used, the path will be reconstructed by the import preload helper
                    JSON.stringify(optimizeModulePreloadRelativePaths ? toRelativePath2(d2, file) : d2)
                  ));
                }
                s2.update(markerStartPos2, markerStartPos2 + preloadMarkerWithQuote.length, `[${renderedDeps.join(",")}]`);
                rewroteMarkerStartPos.add(markerStartPos2);
              }
            }
          }
          let markerStartPos = code.indexOf(preloadMarkerWithQuote);
          while (markerStartPos >= 0) {
            if (!rewroteMarkerStartPos.has(markerStartPos)) {
              s2.update(markerStartPos, markerStartPos + preloadMarkerWithQuote.length, "void 0");
            }
            markerStartPos = code.indexOf(preloadMarkerWithQuote, markerStartPos + preloadMarkerWithQuote.length);
          }
          if (s2.hasChanged()) {
            chunk.code = s2.toString();
            if (config2.build.sourcemap && chunk.map) {
              const nextMap = s2.generateMap({
                source: chunk.fileName,
                hires: true
              });
              const map3 = combineSourcemaps(chunk.fileName, [nextMap, chunk.map], false);
              map3.toUrl = () => genSourceMapUrl(map3);
              chunk.map = map3;
            }
          }
        }
      }
    }
  };
}
function ssrManifestPlugin(config2) {
  const ssrManifest = {};
  const base2 = config2.base;
  return {
    name: "vite:ssr-manifest",
    generateBundle(_options2, bundle) {
      for (const file in bundle) {
        const chunk = bundle[file];
        if (chunk.type === "chunk") {
          for (const id in chunk.modules) {
            const normalizedId = normalizePath$3((0, import_node_path4.relative)(config2.root, id));
            const mappedChunks = ssrManifest[normalizedId] ?? (ssrManifest[normalizedId] = []);
            if (!chunk.isEntry) {
              mappedChunks.push(joinUrlSegments(base2, chunk.fileName));
              chunk.viteMetadata.importedCss.forEach((file2) => {
                mappedChunks.push(joinUrlSegments(base2, file2));
              });
            }
            chunk.viteMetadata.importedAssets.forEach((file2) => {
              mappedChunks.push(joinUrlSegments(base2, file2));
            });
          }
          if (chunk.code.includes(preloadMethod)) {
            const code = chunk.code;
            let imports;
            try {
              imports = parse$e(code)[0].filter((i2) => i2.n && i2.d > -1);
            } catch (e3) {
              this.error(e3, e3.idx);
            }
            if (imports.length) {
              for (let index2 = 0; index2 < imports.length; index2++) {
                const { s: start, e: end, n: name2 } = imports[index2];
                const url2 = code.slice(start, end);
                const deps = [];
                const ownerFilename = chunk.fileName;
                const analyzed = /* @__PURE__ */ new Set();
                const addDeps = (filename) => {
                  if (filename === ownerFilename)
                    return;
                  if (analyzed.has(filename))
                    return;
                  analyzed.add(filename);
                  const chunk2 = bundle[filename];
                  if (chunk2) {
                    chunk2.viteMetadata.importedCss.forEach((file2) => {
                      deps.push(joinUrlSegments(base2, file2));
                    });
                    chunk2.imports.forEach(addDeps);
                  }
                };
                const normalizedFile = normalizePath$3((0, import_node_path4.join)((0, import_node_path4.dirname)(chunk.fileName), url2.slice(1, -1)));
                addDeps(normalizedFile);
                ssrManifest[(0, import_node_path4.basename)(name2)] = deps;
              }
            }
          }
        }
      }
      this.emitFile({
        fileName: typeof config2.build.ssrManifest === "string" ? config2.build.ssrManifest : "ssr-manifest.json",
        type: "asset",
        source: jsonStableStringify(ssrManifest, { space: 2 })
      });
    }
  };
}
function loadFallbackPlugin() {
  return {
    name: "vite:load-fallback",
    async load(id) {
      try {
        return await import_node_fs4.promises.readFile(cleanUrl(id), "utf-8");
      } catch (e3) {
        return import_node_fs4.promises.readFile(id, "utf-8");
      }
    }
  };
}
function resolveChokidarOptions(config2, options3) {
  const { ignored = [], ...otherOptions } = options3 ?? {};
  const resolvedWatchOptions = {
    ignored: [
      "**/.git/**",
      "**/node_modules/**",
      "**/test-results/**",
      out.escapePath(config2.cacheDir) + "/**",
      ...Array.isArray(ignored) ? ignored : [ignored]
    ],
    ignoreInitial: true,
    ignorePermissionErrors: true,
    ...otherOptions
  };
  return resolvedWatchOptions;
}
function completeSystemWrapPlugin() {
  const SystemJSWrapRE = /System.register\(.*(\(exports\)|\(\))/g;
  return {
    name: "vite:force-systemjs-wrap-complete",
    renderChunk(code, chunk, opts) {
      if (opts.format === "system") {
        return {
          code: code.replace(SystemJSWrapRE, (s2, s1) => s2.replace(s1, "(exports, module)")),
          map: null
        };
      }
    }
  };
}
var alias = {
  js: "application/javascript",
  css: "text/css",
  html: "text/html",
  json: "application/json"
};
function send$1(req2, res, content, type, options3) {
  const { etag: etag2 = etag_1(content, { weak: true }), cacheControl = "no-cache", headers, map: map3 } = options3;
  if (res.writableEnded) {
    return;
  }
  if (req2.headers["if-none-match"] === etag2) {
    res.statusCode = 304;
    res.end();
    return;
  }
  res.setHeader("Content-Type", alias[type] || type);
  res.setHeader("Cache-Control", cacheControl);
  res.setHeader("Etag", etag2);
  if (headers) {
    for (const name2 in headers) {
      res.setHeader(name2, headers[name2]);
    }
  }
  if (map3 && map3.mappings) {
    if (type === "js" || type === "css") {
      content = getCodeWithSourcemap(type, content.toString(), map3);
    }
  }
  res.statusCode = 200;
  res.end(content);
  return;
}
var ROOT_FILES = [
  // '.git',
  // https://pnpm.js.org/workspaces/
  "pnpm-workspace.yaml",
  // https://rushjs.io/pages/advanced/config_files/
  // 'rush.json',
  // https://nx.dev/latest/react/getting-started/nx-setup
  // 'workspace.json',
  // 'nx.json',
  // https://github.com/lerna/lerna#lernajson
  "lerna.json"
];
function hasWorkspacePackageJSON(root) {
  const path8 = (0, import_node_path4.join)(root, "package.json");
  if (!isFileReadable(path8)) {
    return false;
  }
  const content = JSON.parse(import_node_fs4.default.readFileSync(path8, "utf-8")) || {};
  return !!content.workspaces;
}
function hasRootFile(root) {
  return ROOT_FILES.some((file) => import_node_fs4.default.existsSync((0, import_node_path4.join)(root, file)));
}
function hasPackageJSON(root) {
  const path8 = (0, import_node_path4.join)(root, "package.json");
  return import_node_fs4.default.existsSync(path8);
}
function searchForPackageRoot(current2, root = current2) {
  if (hasPackageJSON(current2))
    return current2;
  const dir = (0, import_node_path4.dirname)(current2);
  if (!dir || dir === current2)
    return root;
  return searchForPackageRoot(dir, root);
}
function searchForWorkspaceRoot(current2, root = searchForPackageRoot(current2)) {
  if (hasRootFile(current2))
    return current2;
  if (hasWorkspacePackageJSON(current2))
    return current2;
  const dir = (0, import_node_path4.dirname)(current2);
  if (!dir || dir === current2)
    return root;
  return searchForWorkspaceRoot(dir, root);
}
var mainExports = {};
var main$1 = {
  get exports() {
    return mainExports;
  },
  set exports(v) {
    mainExports = v;
  }
};
var name = "dotenv";
var version$12 = "16.0.3";
var description = "Loads environment variables from .env file";
var main = "lib/main.js";
var types = "lib/main.d.ts";
var exports2 = {
  ".": {
    require: "./lib/main.js",
    types: "./lib/main.d.ts",
    "default": "./lib/main.js"
  },
  "./config": "./config.js",
  "./config.js": "./config.js",
  "./lib/env-options": "./lib/env-options.js",
  "./lib/env-options.js": "./lib/env-options.js",
  "./lib/cli-options": "./lib/cli-options.js",
  "./lib/cli-options.js": "./lib/cli-options.js",
  "./package.json": "./package.json"
};
var scripts = {
  "dts-check": "tsc --project tests/types/tsconfig.json",
  lint: "standard",
  "lint-readme": "standard-markdown",
  pretest: "npm run lint && npm run dts-check",
  test: "tap tests/*.js --100 -Rspec",
  prerelease: "npm test",
  release: "standard-version"
};
var repository = {
  type: "git",
  url: "git://github.com/motdotla/dotenv.git"
};
var keywords = [
  "dotenv",
  "env",
  ".env",
  "environment",
  "variables",
  "config",
  "settings"
];
var readmeFilename = "README.md";
var license = "BSD-2-Clause";
var devDependencies = {
  "@types/node": "^17.0.9",
  decache: "^4.6.1",
  dtslint: "^3.7.0",
  sinon: "^12.0.1",
  standard: "^16.0.4",
  "standard-markdown": "^7.1.0",
  "standard-version": "^9.3.2",
  tap: "^15.1.6",
  tar: "^6.1.11",
  typescript: "^4.5.4"
};
var engines2 = {
  node: ">=12"
};
var require$$3 = {
  name,
  version: version$12,
  description,
  main,
  types,
  exports: exports2,
  scripts,
  repository,
  keywords,
  readmeFilename,
  license,
  devDependencies,
  engines: engines2
};
var fs$9 = import_fs.default;
var path$9 = import_path.default;
var os$2 = import_os.default;
var packageJson = require$$3;
var version2 = packageJson.version;
var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
function parse$8(src3) {
  const obj = {};
  let lines = src3.toString();
  lines = lines.replace(/\r\n?/mg, "\n");
  let match;
  while ((match = LINE.exec(lines)) != null) {
    const key = match[1];
    let value2 = match[2] || "";
    value2 = value2.trim();
    const maybeQuote = value2[0];
    value2 = value2.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
    if (maybeQuote === '"') {
      value2 = value2.replace(/\\n/g, "\n");
      value2 = value2.replace(/\\r/g, "\r");
    }
    obj[key] = value2;
  }
  return obj;
}
function _log(message) {
  console.log(`[dotenv@${version2}][DEBUG] ${message}`);
}
function _resolveHome(envPath) {
  return envPath[0] === "~" ? path$9.join(os$2.homedir(), envPath.slice(1)) : envPath;
}
function config(options3) {
  let dotenvPath = path$9.resolve(process.cwd(), ".env");
  let encoding = "utf8";
  const debug4 = Boolean(options3 && options3.debug);
  const override = Boolean(options3 && options3.override);
  if (options3) {
    if (options3.path != null) {
      dotenvPath = _resolveHome(options3.path);
    }
    if (options3.encoding != null) {
      encoding = options3.encoding;
    }
  }
  try {
    const parsed = DotenvModule.parse(fs$9.readFileSync(dotenvPath, { encoding }));
    Object.keys(parsed).forEach(function(key) {
      if (!Object.prototype.hasOwnProperty.call(process.env, key)) {
        process.env[key] = parsed[key];
      } else {
        if (override === true) {
          process.env[key] = parsed[key];
        }
        if (debug4) {
          if (override === true) {
            _log(`"${key}" is already defined in \`process.env\` and WAS overwritten`);
          } else {
            _log(`"${key}" is already defined in \`process.env\` and was NOT overwritten`);
          }
        }
      }
    });
    return { parsed };
  } catch (e3) {
    if (debug4) {
      _log(`Failed to load ${dotenvPath} ${e3.message}`);
    }
    return { error: e3 };
  }
}
var DotenvModule = {
  config,
  parse: parse$8
};
mainExports.config = DotenvModule.config;
var parse_1$1 = mainExports.parse = DotenvModule.parse;
main$1.exports = DotenvModule;
function _interpolate(envValue, environment, config2) {
  const matches2 = envValue.match(/(.?\${*[\w]*(?::-[\w/]*)?}*)/g) || [];
  return matches2.reduce(function(newEnv, match, index2) {
    const parts = /(.?)\${*([\w]*(?::-[\w/]*)?)?}*/g.exec(match);
    if (!parts || parts.length === 0) {
      return newEnv;
    }
    const prefix = parts[1];
    let value2, replacePart;
    if (prefix === "\\") {
      replacePart = parts[0];
      value2 = replacePart.replace("\\$", "$");
    } else {
      if (!parts[2]) {
        return newEnv;
      }
      const keyParts = parts[2].split(":-");
      const key = keyParts[0];
      replacePart = parts[0].substring(prefix.length);
      value2 = Object.prototype.hasOwnProperty.call(environment, key) ? environment[key] : config2.parsed[key] || keyParts[1] || "";
      if (keyParts.length > 1 && value2) {
        const replaceNested = matches2[index2 + 1];
        matches2[index2 + 1] = "";
        newEnv = newEnv.replace(replaceNested, "");
      }
      value2 = _interpolate(value2, environment, config2);
    }
    return newEnv.replace(replacePart, value2);
  }, envValue);
}
function expand(config2) {
  const environment = config2.ignoreProcessEnv ? {} : process.env;
  for (const configKey in config2.parsed) {
    const value2 = Object.prototype.hasOwnProperty.call(environment, configKey) ? environment[configKey] : config2.parsed[configKey];
    config2.parsed[configKey] = _interpolate(value2, environment, config2);
  }
  return config2;
}
var expand_1 = expand;
function loadEnv(mode2, envDir, prefixes = "VITE_") {
  if (mode2 === "local") {
    throw new Error(`"local" cannot be used as a mode name because it conflicts with the .local postfix for .env files.`);
  }
  prefixes = arraify(prefixes);
  const env2 = {};
  const envFiles = [
    /** default file */
    `.env`,
    /** local file */
    `.env.local`,
    /** mode file */
    `.env.${mode2}`,
    /** mode local file */
    `.env.${mode2}.local`
  ];
  const parsed = Object.fromEntries(envFiles.flatMap((file) => {
    const path8 = lookupFile(envDir, [file], {
      pathOnly: true,
      rootDir: envDir
    });
    if (!path8)
      return [];
    return Object.entries(parse_1$1(import_node_fs4.default.readFileSync(path8)));
  }));
  if (parsed.NODE_ENV && process.env.VITE_USER_NODE_ENV === void 0) {
    process.env.VITE_USER_NODE_ENV = parsed.NODE_ENV;
  }
  if (parsed.BROWSER && process.env.BROWSER === void 0) {
    process.env.BROWSER = parsed.BROWSER;
  }
  if (parsed.BROWSER_ARGS && process.env.BROWSER_ARGS === void 0) {
    process.env.BROWSER_ARGS = parsed.BROWSER_ARGS;
  }
  expand_1({ parsed });
  for (const [key, value2] of Object.entries(parsed)) {
    if (prefixes.some((prefix) => key.startsWith(prefix))) {
      env2[key] = value2;
    }
  }
  for (const key in process.env) {
    if (prefixes.some((prefix) => key.startsWith(prefix))) {
      env2[key] = process.env[key];
    }
  }
  return env2;
}
function resolveEnvPrefix({ envPrefix = "VITE_" }) {
  envPrefix = arraify(envPrefix);
  if (envPrefix.some((prefix) => prefix === "")) {
    throw new Error(`envPrefix option contains value '', which could lead unexpected exposure of sensitive information.`);
  }
  return envPrefix;
}
function resolveBuildOptions(raw, logger2) {
  const deprecatedPolyfillModulePreload = raw == null ? void 0 : raw.polyfillModulePreload;
  if (raw) {
    const { polyfillModulePreload, ...rest } = raw;
    raw = rest;
    if (deprecatedPolyfillModulePreload !== void 0) {
      logger2.warn("polyfillModulePreload is deprecated. Use modulePreload.polyfill instead.");
    }
    if (deprecatedPolyfillModulePreload === false && raw.modulePreload === void 0) {
      raw.modulePreload = { polyfill: false };
    }
  }
  const modulePreload = raw == null ? void 0 : raw.modulePreload;
  const defaultModulePreload = {
    polyfill: true
  };
  const defaultBuildOptions = {
    outDir: "dist",
    assetsDir: "assets",
    assetsInlineLimit: 4096,
    cssCodeSplit: !(raw == null ? void 0 : raw.lib),
    sourcemap: false,
    rollupOptions: {},
    minify: (raw == null ? void 0 : raw.ssr) ? false : "esbuild",
    terserOptions: {},
    write: true,
    emptyOutDir: null,
    copyPublicDir: true,
    manifest: false,
    lib: false,
    ssr: false,
    ssrManifest: false,
    ssrEmitAssets: false,
    reportCompressedSize: true,
    chunkSizeWarningLimit: 500,
    watch: null
  };
  const userBuildOptions = raw ? mergeConfig(defaultBuildOptions, raw) : defaultBuildOptions;
  const resolved = {
    target: "modules",
    cssTarget: false,
    ...userBuildOptions,
    commonjsOptions: {
      include: [/node_modules/],
      extensions: [".js", ".cjs"],
      ...userBuildOptions.commonjsOptions
    },
    dynamicImportVarsOptions: {
      warnOnError: true,
      exclude: [/node_modules/],
      ...userBuildOptions.dynamicImportVarsOptions
    },
    // Resolve to false | object
    modulePreload: modulePreload === false ? false : typeof modulePreload === "object" ? {
      ...defaultModulePreload,
      ...modulePreload
    } : defaultModulePreload
  };
  if (resolved.target === "modules") {
    resolved.target = ESBUILD_MODULES_TARGET;
  } else if (resolved.target === "esnext" && resolved.minify === "terser") {
    resolved.target = "es2021";
  }
  if (!resolved.cssTarget) {
    resolved.cssTarget = resolved.target;
  }
  if (resolved.minify === "false") {
    resolved.minify = false;
  }
  if (resolved.minify === true) {
    resolved.minify = "esbuild";
  }
  return resolved;
}
async function resolveBuildPlugins(config2) {
  const options3 = config2.build;
  const { commonjsOptions } = options3;
  const usePluginCommonjs = !Array.isArray(commonjsOptions == null ? void 0 : commonjsOptions.include) || (commonjsOptions == null ? void 0 : commonjsOptions.include.length) !== 0;
  const rollupOptionsPlugins = options3.rollupOptions.plugins;
  return {
    pre: [
      completeSystemWrapPlugin(),
      ...options3.watch ? [ensureWatchPlugin()] : [],
      watchPackageDataPlugin(config2),
      ...usePluginCommonjs ? [commonjs(options3.commonjsOptions)] : [],
      dataURIPlugin(),
      ...(await asyncFlatten(Array.isArray(rollupOptionsPlugins) ? rollupOptionsPlugins : [rollupOptionsPlugins])).filter(Boolean)
    ],
    post: [
      buildImportAnalysisPlugin(config2),
      ...config2.esbuild !== false ? [buildEsbuildPlugin(config2)] : [],
      ...options3.minify ? [terserPlugin(config2)] : [],
      ...options3.manifest ? [manifestPlugin(config2)] : [],
      ...options3.ssrManifest ? [ssrManifestPlugin(config2)] : [],
      ...!config2.isWorker ? [buildReporterPlugin(config2)] : [],
      loadFallbackPlugin()
    ]
  };
}
async function build(inlineConfig = {}) {
  var _a, _b, _c, _d, _e;
  const config2 = await resolveConfig(inlineConfig, "build", "production", "production");
  const options3 = config2.build;
  const ssr = !!options3.ssr;
  const libOptions = options3.lib;
  config2.logger.info(picocolorsExports.cyan(`vite v${VERSION} ${picocolorsExports.green(`building ${ssr ? `SSR bundle ` : ``}for ${config2.mode}...`)}`));
  const resolve4 = (p2) => import_node_path4.default.resolve(config2.root, p2);
  const input = libOptions ? ((_a = options3.rollupOptions) == null ? void 0 : _a.input) || (typeof libOptions.entry === "string" ? resolve4(libOptions.entry) : Array.isArray(libOptions.entry) ? libOptions.entry.map(resolve4) : Object.fromEntries(Object.entries(libOptions.entry).map(([alias2, file]) => [
    alias2,
    resolve4(file)
  ]))) : typeof options3.ssr === "string" ? resolve4(options3.ssr) : ((_b = options3.rollupOptions) == null ? void 0 : _b.input) || resolve4("index.html");
  if (ssr && typeof input === "string" && input.endsWith(".html")) {
    throw new Error(`rollupOptions.input should not be an html file when building for SSR. Please specify a dedicated SSR entry.`);
  }
  const outDir = resolve4(options3.outDir);
  const plugins2 = ssr ? config2.plugins.map((p2) => injectSsrFlagToHooks(p2)) : config2.plugins;
  const userExternal = (_c = options3.rollupOptions) == null ? void 0 : _c.external;
  let external = userExternal;
  if (ssr && ((_d = config2.legacy) == null ? void 0 : _d.buildSsrCjsExternalHeuristics)) {
    external = await cjsSsrResolveExternal(config2, userExternal);
  }
  if (isDepsOptimizerEnabled(config2, ssr)) {
    await initDepsOptimizer(config2);
  }
  const rollupOptions = {
    context: "globalThis",
    preserveEntrySignatures: ssr ? "allow-extension" : libOptions ? "strict" : false,
    cache: config2.build.watch ? void 0 : false,
    ...options3.rollupOptions,
    input,
    plugins: plugins2,
    external,
    onwarn(warning, warn4) {
      onRollupWarning(warning, warn4, config2);
    }
  };
  const outputBuildError = (e3) => {
    let msg = picocolorsExports.red((e3.plugin ? `[${e3.plugin}] ` : "") + e3.message);
    if (e3.id) {
      msg += `
file: ${picocolorsExports.cyan(e3.id + (e3.loc ? `:${e3.loc.line}:${e3.loc.column}` : ""))}`;
    }
    if (e3.frame) {
      msg += `
` + picocolorsExports.yellow(e3.frame);
    }
    config2.logger.error(msg, { error: e3 });
  };
  let bundle;
  try {
    const buildOutputOptions = (output = {}) => {
      var _a2;
      if (output.output) {
        config2.logger.warn(`You've set "rollupOptions.output.output" in your config. This is deprecated and will override all Vite.js default output options. Please use "rollupOptions.output" instead.`);
      }
      const ssrNodeBuild = ssr && config2.ssr.target === "node";
      const ssrWorkerBuild = ssr && config2.ssr.target === "webworker";
      const cjsSsrBuild = ssr && config2.ssr.format === "cjs";
      const format2 = output.format || (cjsSsrBuild ? "cjs" : "es");
      const jsExt = ssrNodeBuild || libOptions ? resolveOutputJsExtension(format2, (_a2 = getPkgJson(config2.root)) == null ? void 0 : _a2.type) : "js";
      return {
        dir: outDir,
        // Default format is 'es' for regular and for SSR builds
        format: format2,
        exports: cjsSsrBuild ? "named" : "auto",
        sourcemap: options3.sourcemap,
        name: libOptions ? libOptions.name : void 0,
        // es2015 enables `generatedCode.symbols`
        // - #764 add `Symbol.toStringTag` when build es module into cjs chunk
        // - #1048 add `Symbol.toStringTag` for module default export
        generatedCode: "es2015",
        entryFileNames: ssr ? `[name].${jsExt}` : libOptions ? ({ name: name2 }) => resolveLibFilename(libOptions, format2, name2, config2.root, jsExt) : import_node_path4.default.posix.join(options3.assetsDir, `[name]-[hash].${jsExt}`),
        chunkFileNames: libOptions ? `[name]-[hash].${jsExt}` : import_node_path4.default.posix.join(options3.assetsDir, `[name]-[hash].${jsExt}`),
        assetFileNames: libOptions ? `[name].[ext]` : import_node_path4.default.posix.join(options3.assetsDir, `[name]-[hash].[ext]`),
        inlineDynamicImports: output.format === "umd" || output.format === "iife" || ssrWorkerBuild && (typeof input === "string" || Object.keys(input).length === 1),
        ...output
      };
    };
    const outputs = resolveBuildOutputs((_e = options3.rollupOptions) == null ? void 0 : _e.output, libOptions, config2.logger);
    const normalizedOutputs = [];
    if (Array.isArray(outputs)) {
      for (const resolvedOutput of outputs) {
        normalizedOutputs.push(buildOutputOptions(resolvedOutput));
      }
    } else {
      normalizedOutputs.push(buildOutputOptions(outputs));
    }
    const outDirs = normalizedOutputs.map(({ dir }) => resolve4(dir));
    if (config2.build.watch) {
      config2.logger.info(picocolorsExports.cyan(`
watching for file changes...`));
      const resolvedChokidarOptions = resolveChokidarOptions(config2, config2.build.watch.chokidar);
      const { watch: watch2 } = await import("./rollup-GAFC2Y2B.js");
      const watcher = watch2({
        ...rollupOptions,
        output: normalizedOutputs,
        watch: {
          ...config2.build.watch,
          chokidar: resolvedChokidarOptions
        }
      });
      watcher.on("event", (event) => {
        if (event.code === "BUNDLE_START") {
          config2.logger.info(picocolorsExports.cyan(`
build started...`));
          if (options3.write) {
            prepareOutDir(outDirs, options3.emptyOutDir, config2);
          }
        } else if (event.code === "BUNDLE_END") {
          event.result.close();
          config2.logger.info(picocolorsExports.cyan(`built in ${event.duration}ms.`));
        } else if (event.code === "ERROR") {
          outputBuildError(event.error);
        }
      });
      return watcher;
    }
    const { rollup } = await import("./rollup-GAFC2Y2B.js");
    bundle = await rollup(rollupOptions);
    if (options3.write) {
      prepareOutDir(outDirs, options3.emptyOutDir, config2);
    }
    const res = [];
    for (const output of normalizedOutputs) {
      res.push(await bundle[options3.write ? "write" : "generate"](output));
    }
    return Array.isArray(outputs) ? res : res[0];
  } catch (e3) {
    outputBuildError(e3);
    throw e3;
  } finally {
    if (bundle)
      await bundle.close();
  }
}
function prepareOutDir(outDirs, emptyOutDir, config2) {
  const nonDuplicateDirs = new Set(outDirs);
  let outside = false;
  if (emptyOutDir == null) {
    for (const outDir of nonDuplicateDirs) {
      if (import_node_fs4.default.existsSync(outDir) && !normalizePath$3(outDir).startsWith(config2.root + "/")) {
        config2.logger.warn(picocolorsExports.yellow(`
${picocolorsExports.bold(`(!)`)} outDir ${picocolorsExports.white(picocolorsExports.dim(outDir))} is not inside project root and will not be emptied.
Use --emptyOutDir to override.
`));
        outside = true;
        break;
      }
    }
  }
  for (const outDir of nonDuplicateDirs) {
    if (!outside && emptyOutDir !== false && import_node_fs4.default.existsSync(outDir)) {
      const skipDirs = outDirs.map((dir) => {
        const relative2 = import_node_path4.default.relative(outDir, dir);
        if (relative2 && !relative2.startsWith("..") && !import_node_path4.default.isAbsolute(relative2)) {
          return relative2;
        }
        return "";
      }).filter(Boolean);
      emptyDir(outDir, [...skipDirs, ".git"]);
    }
    if (config2.build.copyPublicDir && config2.publicDir && import_node_fs4.default.existsSync(config2.publicDir)) {
      copyDir(config2.publicDir, outDir);
    }
  }
}
function getPkgJson(root) {
  return JSON.parse(lookupFile(root, ["package.json"]) || `{}`);
}
function getPkgName(name2) {
  return (name2 == null ? void 0 : name2.startsWith("@")) ? name2.split("/")[1] : name2;
}
function resolveOutputJsExtension(format2, type = "commonjs") {
  if (type === "module") {
    return format2 === "cjs" || format2 === "umd" ? "cjs" : "js";
  } else {
    return format2 === "es" ? "mjs" : "js";
  }
}
function resolveLibFilename(libOptions, format2, entryName, root, extension2) {
  if (typeof libOptions.fileName === "function") {
    return libOptions.fileName(format2, entryName);
  }
  const packageJson2 = getPkgJson(root);
  const name2 = libOptions.fileName || (typeof libOptions.entry === "string" ? getPkgName(packageJson2.name) : entryName);
  if (!name2)
    throw new Error('Name in package.json is required if option "build.lib.fileName" is not provided.');
  extension2 ?? (extension2 = resolveOutputJsExtension(format2, packageJson2.type));
  if (format2 === "cjs" || format2 === "es") {
    return `${name2}.${extension2}`;
  }
  return `${name2}.${format2}.${extension2}`;
}
function resolveBuildOutputs(outputs, libOptions, logger2) {
  if (libOptions) {
    const libHasMultipleEntries = typeof libOptions.entry !== "string" && Object.values(libOptions.entry).length > 1;
    const libFormats = libOptions.formats || (libHasMultipleEntries ? ["es", "cjs"] : ["es", "umd"]);
    if (!Array.isArray(outputs)) {
      if (libFormats.includes("umd") || libFormats.includes("iife")) {
        if (libHasMultipleEntries) {
          throw new Error('Multiple entry points are not supported when output formats include "umd" or "iife".');
        }
        if (!libOptions.name) {
          throw new Error('Option "build.lib.name" is required when output formats include "umd" or "iife".');
        }
      }
      return libFormats.map((format2) => ({ ...outputs, format: format2 }));
    }
    if (libOptions.formats) {
      logger2.warn(picocolorsExports.yellow('"build.lib.formats" will be ignored because "build.rollupOptions.output" is already an array format.'));
    }
    outputs.forEach((output) => {
      if (["umd", "iife"].includes(output.format) && !output.name) {
        throw new Error('Entries in "build.rollupOptions.output" must specify "name" when the format is "umd" or "iife".');
      }
    });
  }
  return outputs;
}
var warningIgnoreList = [`CIRCULAR_DEPENDENCY`, `THIS_IS_UNDEFINED`];
var dynamicImportWarningIgnoreList = [
  `Unsupported expression`,
  `statically analyzed`
];
function onRollupWarning(warning, warn4, config2) {
  var _a;
  if (warning.code === "UNRESOLVED_IMPORT") {
    const id = warning.id;
    const exporter = warning.exporter;
    if (!id || !/\?commonjs-external$/.test(id)) {
      throw new Error(`[vite]: Rollup failed to resolve import "${exporter}" from "${id}".
This is most likely unintended because it can break your application at runtime.
If you do want to externalize this module explicitly add it to
\`build.rollupOptions.external\``);
    }
  }
  if (warning.plugin === "rollup-plugin-dynamic-import-variables" && dynamicImportWarningIgnoreList.some((msg) => warning.message.includes(msg))) {
    return;
  }
  if (!warningIgnoreList.includes(warning.code)) {
    const userOnWarn = (_a = config2.build.rollupOptions) == null ? void 0 : _a.onwarn;
    if (userOnWarn) {
      userOnWarn(warning, warn4);
    } else if (warning.code === "PLUGIN_WARNING") {
      config2.logger.warn(`${picocolorsExports.bold(picocolorsExports.yellow(`[plugin:${warning.plugin}]`))} ${picocolorsExports.yellow(warning.message)}`);
    } else {
      warn4(warning);
    }
  }
}
async function cjsSsrResolveExternal(config2, user) {
  let knownImports;
  const dataPath = import_node_path4.default.join(getDepsCacheDir(config2, false), "_metadata.json");
  try {
    const data2 = JSON.parse(import_node_fs4.default.readFileSync(dataPath, "utf-8"));
    knownImports = Object.keys(data2.optimized);
  } catch (e3) {
  }
  if (!knownImports) {
    knownImports = await findKnownImports(config2, false);
  }
  const ssrExternals = cjsSsrResolveExternals(config2, knownImports);
  return (id, parentId, isResolved) => {
    const isExternal2 = cjsShouldExternalizeForSSR(id, ssrExternals);
    if (isExternal2) {
      return true;
    }
    if (user) {
      return resolveUserExternal(user, id, parentId, isResolved);
    }
  };
}
function resolveUserExternal(user, id, parentId, isResolved) {
  if (typeof user === "function") {
    return user(id, parentId, isResolved);
  } else if (Array.isArray(user)) {
    return user.some((test) => isExternal(id, test));
  } else {
    return isExternal(id, user);
  }
}
function isExternal(id, test) {
  if (typeof test === "string") {
    return id === test;
  } else {
    return test.test(id);
  }
}
function injectSsrFlagToHooks(plugin) {
  const { resolveId, load: load2, transform: transform2 } = plugin;
  return {
    ...plugin,
    resolveId: wrapSsrResolveId(resolveId),
    load: wrapSsrLoad(load2),
    transform: wrapSsrTransform(transform2)
  };
}
function wrapSsrResolveId(hook) {
  if (!hook)
    return;
  const fn = "handler" in hook ? hook.handler : hook;
  const handler = function(id, importer, options3) {
    return fn.call(this, id, importer, injectSsrFlag(options3));
  };
  if ("handler" in hook) {
    return {
      ...hook,
      handler
    };
  } else {
    return handler;
  }
}
function wrapSsrLoad(hook) {
  if (!hook)
    return;
  const fn = "handler" in hook ? hook.handler : hook;
  const handler = function(id, ...args) {
    return fn.call(this, id, injectSsrFlag(args[0]));
  };
  if ("handler" in hook) {
    return {
      ...hook,
      handler
    };
  } else {
    return handler;
  }
}
function wrapSsrTransform(hook) {
  if (!hook)
    return;
  const fn = "handler" in hook ? hook.handler : hook;
  const handler = function(code, importer, ...args) {
    return fn.call(this, code, importer, injectSsrFlag(args[0]));
  };
  if ("handler" in hook) {
    return {
      ...hook,
      handler
    };
  } else {
    return handler;
  }
}
function injectSsrFlag(options3) {
  return { ...options3 ?? {}, ssr: true };
}
var getResolveUrl = (path8, URL2 = "URL") => `new ${URL2}(${path8}).href`;
var getRelativeUrlFromDocument = (relativePath, umd = false) => getResolveUrl(`'${relativePath}', ${umd ? `typeof document === 'undefined' ? location.href : ` : ""}document.currentScript && document.currentScript.src || document.baseURI`);
var relativeUrlMechanisms = {
  amd: (relativePath) => {
    if (relativePath[0] !== ".")
      relativePath = "./" + relativePath;
    return getResolveUrl(`require.toUrl('${relativePath}'), document.baseURI`);
  },
  cjs: (relativePath) => `(typeof document === 'undefined' ? ${getResolveUrl(`'file:' + __dirname + '/${relativePath}'`, `(require('u' + 'rl').URL)`)} : ${getRelativeUrlFromDocument(relativePath)})`,
  es: (relativePath) => getResolveUrl(`'${relativePath}', import.meta.url`),
  iife: (relativePath) => getRelativeUrlFromDocument(relativePath),
  // NOTE: make sure rollup generate `module` params
  system: (relativePath) => getResolveUrl(`'${relativePath}', module.meta.url`),
  umd: (relativePath) => `(typeof document === 'undefined' && typeof location === 'undefined' ? ${getResolveUrl(`'file:' + __dirname + '/${relativePath}'`, `(require('u' + 'rl').URL)`)} : ${getRelativeUrlFromDocument(relativePath, true)})`
};
function toOutputFilePathInJS(filename, type, hostId, hostType, config2, toRelative) {
  const { renderBuiltUrl } = config2.experimental;
  let relative2 = config2.base === "" || config2.base === "./";
  if (renderBuiltUrl) {
    const result = renderBuiltUrl(filename, {
      hostId,
      hostType,
      type,
      ssr: !!config2.build.ssr
    });
    if (typeof result === "object") {
      if (result.runtime) {
        return { runtime: result.runtime };
      }
      if (typeof result.relative === "boolean") {
        relative2 = result.relative;
      }
    } else if (result) {
      return result;
    }
  }
  if (relative2 && !config2.build.ssr) {
    return toRelative(filename, hostId);
  }
  return joinUrlSegments(config2.base, filename);
}
function createToImportMetaURLBasedRelativeRuntime(format2) {
  const toRelativePath3 = relativeUrlMechanisms[format2];
  return (filename, importer) => ({
    runtime: toRelativePath3(import_node_path4.default.posix.relative(import_node_path4.default.dirname(importer), filename))
  });
}
function toOutputFilePathWithoutRuntime(filename, type, hostId, hostType, config2, toRelative) {
  const { renderBuiltUrl } = config2.experimental;
  let relative2 = config2.base === "" || config2.base === "./";
  if (renderBuiltUrl) {
    const result = renderBuiltUrl(filename, {
      hostId,
      hostType,
      type,
      ssr: !!config2.build.ssr
    });
    if (typeof result === "object") {
      if (result.runtime) {
        throw new Error(`{ runtime: "${result.runtime}" } is not supported for assets in ${hostType} files: ${filename}`);
      }
      if (typeof result.relative === "boolean") {
        relative2 = result.relative;
      }
    } else if (result) {
      return result;
    }
  }
  if (relative2 && !config2.build.ssr) {
    return toRelative(filename, hostId);
  } else {
    return joinUrlSegments(config2.base, filename);
  }
}
var toOutputFilePathInCss = toOutputFilePathWithoutRuntime;
var toOutputFilePathInHtml = toOutputFilePathWithoutRuntime;
var build$1 = {
  __proto__: null,
  build,
  createToImportMetaURLBasedRelativeRuntime,
  onRollupWarning,
  resolveBuildOptions,
  resolveBuildOutputs,
  resolveBuildPlugins,
  resolveLibFilename,
  toOutputFilePathInCss,
  toOutputFilePathInHtml,
  toOutputFilePathInJS,
  toOutputFilePathWithoutRuntime
};
var srcExports = {};
var src = {
  get exports() {
    return srcExports;
  },
  set exports(v) {
    srcExports = v;
  }
};
var browserExports = {};
var browser = {
  get exports() {
    return browserExports;
  },
  set exports(v) {
    browserExports = v;
  }
};
var debugExports = {};
var debug$6 = {
  get exports() {
    return debugExports;
  },
  set exports(v) {
    debugExports = v;
  }
};
var ms;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs)
    return ms;
  hasRequiredMs = 1;
  var s2 = 1e3;
  var m = s2 * 60;
  var h = m * 60;
  var d2 = h * 24;
  var y = d2 * 365.25;
  ms = function(val, options3) {
    options3 = options3 || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse7(val);
    } else if (type === "number" && isNaN(val) === false) {
      return options3.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse7(str2) {
    str2 = String(str2);
    if (str2.length > 100) {
      return;
    }
    var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
      str2
    );
    if (!match) {
      return;
    }
    var n3 = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n3 * y;
      case "days":
      case "day":
      case "d":
        return n3 * d2;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n3 * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n3 * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n3 * s2;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n3;
      default:
        return void 0;
    }
  }
  function fmtShort(ms3) {
    if (ms3 >= d2) {
      return Math.round(ms3 / d2) + "d";
    }
    if (ms3 >= h) {
      return Math.round(ms3 / h) + "h";
    }
    if (ms3 >= m) {
      return Math.round(ms3 / m) + "m";
    }
    if (ms3 >= s2) {
      return Math.round(ms3 / s2) + "s";
    }
    return ms3 + "ms";
  }
  function fmtLong(ms3) {
    return plural(ms3, d2, "day") || plural(ms3, h, "hour") || plural(ms3, m, "minute") || plural(ms3, s2, "second") || ms3 + " ms";
  }
  function plural(ms3, n3, name2) {
    if (ms3 < n3) {
      return;
    }
    if (ms3 < n3 * 1.5) {
      return Math.floor(ms3 / n3) + " " + name2;
    }
    return Math.ceil(ms3 / n3) + " " + name2 + "s";
  }
  return ms;
}
var hasRequiredDebug;
function requireDebug() {
  if (hasRequiredDebug)
    return debugExports;
  hasRequiredDebug = 1;
  (function(module2, exports3) {
    exports3 = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports3.coerce = coerce;
    exports3.disable = disable;
    exports3.enable = enable;
    exports3.enabled = enabled;
    exports3.humanize = requireMs();
    exports3.names = [];
    exports3.skips = [];
    exports3.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash2 = 0, i2;
      for (i2 in namespace) {
        hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i2);
        hash2 |= 0;
      }
      return exports3.colors[Math.abs(hash2) % exports3.colors.length];
    }
    function createDebug(namespace) {
      function debug4() {
        if (!debug4.enabled)
          return;
        var self2 = debug4;
        var curr = +new Date();
        var ms3 = curr - (prevTime || curr);
        self2.diff = ms3;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i2 = 0; i2 < args.length; i2++) {
          args[i2] = arguments[i2];
        }
        args[0] = exports3.coerce(args[0]);
        if ("string" !== typeof args[0]) {
          args.unshift("%O");
        }
        var index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format2) {
          if (match === "%%")
            return match;
          index2++;
          var formatter2 = exports3.formatters[format2];
          if ("function" === typeof formatter2) {
            var val = args[index2];
            match = formatter2.call(self2, val);
            args.splice(index2, 1);
            index2--;
          }
          return match;
        });
        exports3.formatArgs.call(self2, args);
        var logFn = debug4.log || exports3.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug4.namespace = namespace;
      debug4.enabled = exports3.enabled(namespace);
      debug4.useColors = exports3.useColors();
      debug4.color = selectColor(namespace);
      if ("function" === typeof exports3.init) {
        exports3.init(debug4);
      }
      return debug4;
    }
    function enable(namespaces) {
      exports3.save(namespaces);
      exports3.names = [];
      exports3.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i2 = 0; i2 < len; i2++) {
        if (!split[i2])
          continue;
        namespaces = split[i2].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports3.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports3.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports3.enable("");
    }
    function enabled(name2) {
      var i2, len;
      for (i2 = 0, len = exports3.skips.length; i2 < len; i2++) {
        if (exports3.skips[i2].test(name2)) {
          return false;
        }
      }
      for (i2 = 0, len = exports3.names.length; i2 < len; i2++) {
        if (exports3.names[i2].test(name2)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  })(debug$6, debugExports);
  return debugExports;
}
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser)
    return browserExports;
  hasRequiredBrowser = 1;
  (function(module2, exports3) {
    exports3 = module2.exports = requireDebug();
    exports3.log = log8;
    exports3.formatArgs = formatArgs;
    exports3.save = save;
    exports3.load = load2;
    exports3.useColors = useColors;
    exports3.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
    exports3.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports3.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err2) {
        return "[UnexpectedJSONParseError]: " + err2.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports3.humanize(this.diff);
      if (!useColors2)
        return;
      var c2 = "color: " + this.color;
      args.splice(1, 0, c2, "color: inherit");
      var index2 = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if ("%%" === match)
          return;
        index2++;
        if ("%c" === match) {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c2);
    }
    function log8() {
      return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports3.storage.removeItem("debug");
        } else {
          exports3.storage.debug = namespaces;
        }
      } catch (e3) {
      }
    }
    function load2() {
      var r3;
      try {
        r3 = exports3.storage.debug;
      } catch (e3) {
      }
      if (!r3 && typeof process !== "undefined" && "env" in process) {
        r3 = process.env.DEBUG;
      }
      return r3;
    }
    exports3.enable(load2());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e3) {
      }
    }
  })(browser, browserExports);
  return browserExports;
}
var nodeExports = {};
var node = {
  get exports() {
    return nodeExports;
  },
  set exports(v) {
    nodeExports = v;
  }
};
var hasRequiredNode;
function requireNode() {
  if (hasRequiredNode)
    return nodeExports;
  hasRequiredNode = 1;
  (function(module2, exports3) {
    var tty2 = import_tty.default;
    var util2 = import_util.default;
    exports3 = module2.exports = requireDebug();
    exports3.init = init2;
    exports3.log = log8;
    exports3.formatArgs = formatArgs;
    exports3.save = save;
    exports3.load = load2;
    exports3.useColors = useColors;
    exports3.colors = [6, 2, 3, 4, 5, 1];
    exports3.inspectOpts = Object.keys(process.env).filter(function(key) {
      return /^debug_/i.test(key);
    }).reduce(function(obj, key) {
      var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
        return k.toUpperCase();
      });
      var val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val))
        val = true;
      else if (/^(no|off|false|disabled)$/i.test(val))
        val = false;
      else if (val === "null")
        val = null;
      else
        val = Number(val);
      obj[prop] = val;
      return obj;
    }, {});
    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    if (1 !== fd && 2 !== fd) {
      util2.deprecate(function() {
      }, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
    }
    var stream4 = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);
    function useColors() {
      return "colors" in exports3.inspectOpts ? Boolean(exports3.inspectOpts.colors) : tty2.isatty(fd);
    }
    exports3.formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map(function(str2) {
        return str2.trim();
      }).join(" ");
    };
    exports3.formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
    function formatArgs(args) {
      var name2 = this.namespace;
      var useColors2 = this.useColors;
      if (useColors2) {
        var c2 = this.color;
        var prefix = "  \x1B[3" + c2 + ";1m" + name2 + " \x1B[0m";
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push("\x1B[3" + c2 + "m+" + exports3.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = new Date().toUTCString() + " " + name2 + " " + args[0];
      }
    }
    function log8() {
      return stream4.write(util2.format.apply(util2, arguments) + "\n");
    }
    function save(namespaces) {
      if (null == namespaces) {
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    function load2() {
      return process.env.DEBUG;
    }
    function createWritableStdioStream(fd2) {
      var stream5;
      var tty_wrap = process.binding("tty_wrap");
      switch (tty_wrap.guessHandleType(fd2)) {
        case "TTY":
          stream5 = new tty2.WriteStream(fd2);
          stream5._type = "tty";
          if (stream5._handle && stream5._handle.unref) {
            stream5._handle.unref();
          }
          break;
        case "FILE":
          var fs6 = import_fs.default;
          stream5 = new fs6.SyncWriteStream(fd2, { autoClose: false });
          stream5._type = "fs";
          break;
        case "PIPE":
        case "TCP":
          var net2 = import_net.default;
          stream5 = new net2.Socket({
            fd: fd2,
            readable: false,
            writable: true
          });
          stream5.readable = false;
          stream5.read = null;
          stream5._type = "pipe";
          if (stream5._handle && stream5._handle.unref) {
            stream5._handle.unref();
          }
          break;
        default:
          throw new Error("Implement me. Unknown stream file type!");
      }
      stream5.fd = fd2;
      stream5._isStdio = true;
      return stream5;
    }
    function init2(debug4) {
      debug4.inspectOpts = {};
      var keys = Object.keys(exports3.inspectOpts);
      for (var i2 = 0; i2 < keys.length; i2++) {
        debug4.inspectOpts[keys[i2]] = exports3.inspectOpts[keys[i2]];
      }
    }
    exports3.enable(load2());
  })(node, nodeExports);
  return nodeExports;
}
(function(module2) {
  if (typeof process !== "undefined" && process.type === "renderer") {
    module2.exports = requireBrowser();
  } else {
    module2.exports = requireNode();
  }
})(src);
var encodeurl = encodeUrl$1;
var ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
var UNMATCHED_SURROGATE_PAIR_REPLACE = "$1�$2";
function encodeUrl$1(url2) {
  return String(url2).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
}
var matchHtmlRegExp = /["'&<>]/;
var escapeHtml_1 = escapeHtml$1;
function escapeHtml$1(string3) {
  var str2 = "" + string3;
  var match = matchHtmlRegExp.exec(str2);
  if (!match) {
    return str2;
  }
  var escape2;
  var html = "";
  var index2 = 0;
  var lastIndex = 0;
  for (index2 = match.index; index2 < str2.length; index2++) {
    switch (str2.charCodeAt(index2)) {
      case 34:
        escape2 = "&quot;";
        break;
      case 38:
        escape2 = "&amp;";
        break;
      case 39:
        escape2 = "&#39;";
        break;
      case 60:
        escape2 = "&lt;";
        break;
      case 62:
        escape2 = "&gt;";
        break;
      default:
        continue;
    }
    if (lastIndex !== index2) {
      html += str2.substring(lastIndex, index2);
    }
    lastIndex = index2 + 1;
    html += escape2;
  }
  return lastIndex !== index2 ? html + str2.substring(lastIndex, index2) : html;
}
var onFinishedExports = {};
var onFinished$2 = {
  get exports() {
    return onFinishedExports;
  },
  set exports(v) {
    onFinishedExports = v;
  }
};
var eeFirst = first$1;
function first$1(stuff, done) {
  if (!Array.isArray(stuff))
    throw new TypeError("arg must be an array of [ee, events...] arrays");
  var cleanups = [];
  for (var i2 = 0; i2 < stuff.length; i2++) {
    var arr = stuff[i2];
    if (!Array.isArray(arr) || arr.length < 2)
      throw new TypeError("each array member must be [ee, events...]");
    var ee = arr[0];
    for (var j = 1; j < arr.length; j++) {
      var event = arr[j];
      var fn = listener(event, callback);
      ee.on(event, fn);
      cleanups.push({
        ee,
        event,
        fn
      });
    }
  }
  function callback() {
    cleanup();
    done.apply(null, arguments);
  }
  function cleanup() {
    var x;
    for (var i3 = 0; i3 < cleanups.length; i3++) {
      x = cleanups[i3];
      x.ee.removeListener(x.event, x.fn);
    }
  }
  function thunk(fn2) {
    done = fn2;
  }
  thunk.cancel = cleanup;
  return thunk;
}
function listener(event, done) {
  return function onevent(arg1) {
    var args = new Array(arguments.length);
    var ee = this;
    var err2 = event === "error" ? arg1 : null;
    for (var i2 = 0; i2 < args.length; i2++) {
      args[i2] = arguments[i2];
    }
    done(err2, ee, event, args);
  };
}
onFinished$2.exports = onFinished$1;
onFinishedExports.isFinished = isFinished$1;
var first = eeFirst;
var defer$2 = typeof setImmediate === "function" ? setImmediate : function(fn) {
  process.nextTick(fn.bind.apply(fn, arguments));
};
function onFinished$1(msg, listener2) {
  if (isFinished$1(msg) !== false) {
    defer$2(listener2, null, msg);
    return msg;
  }
  attachListener(msg, listener2);
  return msg;
}
function isFinished$1(msg) {
  var socket = msg.socket;
  if (typeof msg.finished === "boolean") {
    return Boolean(msg.finished || socket && !socket.writable);
  }
  if (typeof msg.complete === "boolean") {
    return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);
  }
  return void 0;
}
function attachFinishedListener(msg, callback) {
  var eeMsg;
  var eeSocket;
  var finished = false;
  function onFinish(error3) {
    eeMsg.cancel();
    eeSocket.cancel();
    finished = true;
    callback(error3);
  }
  eeMsg = eeSocket = first([[msg, "end", "finish"]], onFinish);
  function onSocket(socket) {
    msg.removeListener("socket", onSocket);
    if (finished)
      return;
    if (eeMsg !== eeSocket)
      return;
    eeSocket = first([[socket, "error", "close"]], onFinish);
  }
  if (msg.socket) {
    onSocket(msg.socket);
    return;
  }
  msg.on("socket", onSocket);
  if (msg.socket === void 0) {
    patchAssignSocket(msg, onSocket);
  }
}
function attachListener(msg, listener2) {
  var attached = msg.__onFinished;
  if (!attached || !attached.queue) {
    attached = msg.__onFinished = createListener(msg);
    attachFinishedListener(msg, attached);
  }
  attached.queue.push(listener2);
}
function createListener(msg) {
  function listener2(err2) {
    if (msg.__onFinished === listener2)
      msg.__onFinished = null;
    if (!listener2.queue)
      return;
    var queue2 = listener2.queue;
    listener2.queue = null;
    for (var i2 = 0; i2 < queue2.length; i2++) {
      queue2[i2](err2, msg);
    }
  }
  listener2.queue = [];
  return listener2;
}
function patchAssignSocket(res, callback) {
  var assignSocket = res.assignSocket;
  if (typeof assignSocket !== "function")
    return;
  res.assignSocket = function _assignSocket(socket) {
    assignSocket.call(this, socket);
    callback(socket);
  };
}
var parseurlExports = {};
var parseurl$1 = {
  get exports() {
    return parseurlExports;
  },
  set exports(v) {
    parseurlExports = v;
  }
};
var url$3 = import_url3.default;
var parse$7 = url$3.parse;
var Url = url$3.Url;
parseurl$1.exports = parseurl;
parseurlExports.original = originalurl;
function parseurl(req2) {
  var url2 = req2.url;
  if (url2 === void 0) {
    return void 0;
  }
  var parsed = req2._parsedUrl;
  if (fresh(url2, parsed)) {
    return parsed;
  }
  parsed = fastparse(url2);
  parsed._raw = url2;
  return req2._parsedUrl = parsed;
}
function originalurl(req2) {
  var url2 = req2.originalUrl;
  if (typeof url2 !== "string") {
    return parseurl(req2);
  }
  var parsed = req2._parsedOriginalUrl;
  if (fresh(url2, parsed)) {
    return parsed;
  }
  parsed = fastparse(url2);
  parsed._raw = url2;
  return req2._parsedOriginalUrl = parsed;
}
function fastparse(str2) {
  if (typeof str2 !== "string" || str2.charCodeAt(0) !== 47) {
    return parse$7(str2);
  }
  var pathname = str2;
  var query = null;
  var search = null;
  for (var i2 = 1; i2 < str2.length; i2++) {
    switch (str2.charCodeAt(i2)) {
      case 63:
        if (search === null) {
          pathname = str2.substring(0, i2);
          query = str2.substring(i2 + 1);
          search = str2.substring(i2);
        }
        break;
      case 9:
      case 10:
      case 12:
      case 13:
      case 32:
      case 35:
      case 160:
      case 65279:
        return parse$7(str2);
    }
  }
  var url2 = Url !== void 0 ? new Url() : {};
  url2.path = str2;
  url2.href = str2;
  url2.pathname = pathname;
  if (search !== null) {
    url2.query = query;
    url2.search = search;
  }
  return url2;
}
function fresh(url2, parsedUrl) {
  return typeof parsedUrl === "object" && parsedUrl !== null && (Url === void 0 || parsedUrl instanceof Url) && parsedUrl._raw === url2;
}
var require$$0$1 = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "103": "Early Hints",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "306": "(Unused)",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Unordered Collection",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
};
var codes = require$$0$1;
var statuses$1 = status;
status.STATUS_CODES = codes;
status.codes = populateStatusesMap(status, codes);
status.redirect = {
  300: true,
  301: true,
  302: true,
  303: true,
  305: true,
  307: true,
  308: true
};
status.empty = {
  204: true,
  205: true,
  304: true
};
status.retry = {
  502: true,
  503: true,
  504: true
};
function populateStatusesMap(statuses2, codes2) {
  var arr = [];
  Object.keys(codes2).forEach(function forEachCode(code) {
    var message = codes2[code];
    var status2 = Number(code);
    statuses2[status2] = message;
    statuses2[message] = status2;
    statuses2[message.toLowerCase()] = status2;
    arr.push(status2);
  });
  return arr;
}
function status(code) {
  if (typeof code === "number") {
    if (!status[code])
      throw new Error("invalid status code: " + code);
    return code;
  }
  if (typeof code !== "string") {
    throw new TypeError("code must be a number or string");
  }
  var n3 = parseInt(code, 10);
  if (!isNaN(n3)) {
    if (!status[n3])
      throw new Error("invalid status code: " + n3);
    return n3;
  }
  n3 = status[code.toLowerCase()];
  if (!n3)
    throw new Error('invalid status message: "' + code + '"');
  return n3;
}
var unpipe_1 = unpipe$1;
function hasPipeDataListeners(stream4) {
  var listeners = stream4.listeners("data");
  for (var i2 = 0; i2 < listeners.length; i2++) {
    if (listeners[i2].name === "ondata") {
      return true;
    }
  }
  return false;
}
function unpipe$1(stream4) {
  if (!stream4) {
    throw new TypeError("argument stream is required");
  }
  if (typeof stream4.unpipe === "function") {
    stream4.unpipe();
    return;
  }
  if (!hasPipeDataListeners(stream4)) {
    return;
  }
  var listener2;
  var listeners = stream4.listeners("close");
  for (var i2 = 0; i2 < listeners.length; i2++) {
    listener2 = listeners[i2];
    if (listener2.name !== "cleanup" && listener2.name !== "onclose") {
      continue;
    }
    listener2.call(stream4);
  }
}
var debug$5 = srcExports("finalhandler");
var encodeUrl = encodeurl;
var escapeHtml = escapeHtml_1;
var onFinished = onFinishedExports;
var parseUrl$1 = parseurlExports;
var statuses = statuses$1;
var unpipe = unpipe_1;
var DOUBLE_SPACE_REGEXP = /\x20{2}/g;
var NEWLINE_REGEXP = /\n/g;
var defer$1 = typeof setImmediate === "function" ? setImmediate : function(fn) {
  process.nextTick(fn.bind.apply(fn, arguments));
};
var isFinished = onFinished.isFinished;
function createHtmlDocument(message) {
  var body = escapeHtml(message).replace(NEWLINE_REGEXP, "<br>").replace(DOUBLE_SPACE_REGEXP, " &nbsp;");
  return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>Error</title>\n</head>\n<body>\n<pre>' + body + "</pre>\n</body>\n</html>\n";
}
var finalhandler_1 = finalhandler$1;
function finalhandler$1(req2, res, options3) {
  var opts = options3 || {};
  var env2 = opts.env || "development";
  var onerror = opts.onerror;
  return function(err2) {
    var headers;
    var msg;
    var status2;
    if (!err2 && headersSent(res)) {
      debug$5("cannot 404 after headers sent");
      return;
    }
    if (err2) {
      status2 = getErrorStatusCode(err2);
      if (status2 === void 0) {
        status2 = getResponseStatusCode(res);
      } else {
        headers = getErrorHeaders(err2);
      }
      msg = getErrorMessage(err2, status2, env2);
    } else {
      status2 = 404;
      msg = "Cannot " + req2.method + " " + encodeUrl(getResourceName(req2));
    }
    debug$5("default %s", status2);
    if (err2 && onerror) {
      defer$1(onerror, err2, req2, res);
    }
    if (headersSent(res)) {
      debug$5("cannot %d after headers sent", status2);
      req2.socket.destroy();
      return;
    }
    send(req2, res, status2, headers, msg);
  };
}
function getErrorHeaders(err2) {
  if (!err2.headers || typeof err2.headers !== "object") {
    return void 0;
  }
  var headers = /* @__PURE__ */ Object.create(null);
  var keys = Object.keys(err2.headers);
  for (var i2 = 0; i2 < keys.length; i2++) {
    var key = keys[i2];
    headers[key] = err2.headers[key];
  }
  return headers;
}
function getErrorMessage(err2, status2, env2) {
  var msg;
  if (env2 !== "production") {
    msg = err2.stack;
    if (!msg && typeof err2.toString === "function") {
      msg = err2.toString();
    }
  }
  return msg || statuses[status2];
}
function getErrorStatusCode(err2) {
  if (typeof err2.status === "number" && err2.status >= 400 && err2.status < 600) {
    return err2.status;
  }
  if (typeof err2.statusCode === "number" && err2.statusCode >= 400 && err2.statusCode < 600) {
    return err2.statusCode;
  }
  return void 0;
}
function getResourceName(req2) {
  try {
    return parseUrl$1.original(req2).pathname;
  } catch (e3) {
    return "resource";
  }
}
function getResponseStatusCode(res) {
  var status2 = res.statusCode;
  if (typeof status2 !== "number" || status2 < 400 || status2 > 599) {
    status2 = 500;
  }
  return status2;
}
function headersSent(res) {
  return typeof res.headersSent !== "boolean" ? Boolean(res._header) : res.headersSent;
}
function send(req2, res, status2, headers, message) {
  function write() {
    var body = createHtmlDocument(message);
    res.statusCode = status2;
    res.statusMessage = statuses[status2];
    setHeaders(res, headers);
    res.setHeader("Content-Security-Policy", "default-src 'none'");
    res.setHeader("X-Content-Type-Options", "nosniff");
    res.setHeader("Content-Type", "text/html; charset=utf-8");
    res.setHeader("Content-Length", Buffer.byteLength(body, "utf8"));
    if (req2.method === "HEAD") {
      res.end();
      return;
    }
    res.end(body, "utf8");
  }
  if (isFinished(req2)) {
    write();
    return;
  }
  unpipe(req2);
  onFinished(req2, write);
  req2.resume();
}
function setHeaders(res, headers) {
  if (!headers) {
    return;
  }
  var keys = Object.keys(headers);
  for (var i2 = 0; i2 < keys.length; i2++) {
    var key = keys[i2];
    res.setHeader(key, headers[key]);
  }
}
var utilsMergeExports = {};
var utilsMerge = {
  get exports() {
    return utilsMergeExports;
  },
  set exports(v) {
    utilsMergeExports = v;
  }
};
(function(module2, exports3) {
  module2.exports = function(a2, b) {
    if (a2 && b) {
      for (var key in b) {
        a2[key] = b[key];
      }
    }
    return a2;
  };
})(utilsMerge);
var debug$4 = srcExports("connect:dispatcher");
var EventEmitter$3 = import_events.default.EventEmitter;
var finalhandler = finalhandler_1;
var http$4 = import_http.default;
var merge = utilsMergeExports;
var parseUrl = parseurlExports;
var connect = createServer$1;
var env = "development";
var proto2 = {};
var defer = typeof setImmediate === "function" ? setImmediate : function(fn) {
  process.nextTick(fn.bind.apply(fn, arguments));
};
function createServer$1() {
  function app(req2, res, next) {
    app.handle(req2, res, next);
  }
  merge(app, proto2);
  merge(app, EventEmitter$3.prototype);
  app.route = "/";
  app.stack = [];
  return app;
}
proto2.use = function use(route, fn) {
  var handle2 = fn;
  var path8 = route;
  if (typeof route !== "string") {
    handle2 = route;
    path8 = "/";
  }
  if (typeof handle2.handle === "function") {
    var server2 = handle2;
    server2.route = path8;
    handle2 = function(req2, res, next) {
      server2.handle(req2, res, next);
    };
  }
  if (handle2 instanceof http$4.Server) {
    handle2 = handle2.listeners("request")[0];
  }
  if (path8[path8.length - 1] === "/") {
    path8 = path8.slice(0, -1);
  }
  debug$4("use %s %s", path8 || "/", handle2.name || "anonymous");
  this.stack.push({ route: path8, handle: handle2 });
  return this;
};
proto2.handle = function handle(req2, res, out2) {
  var index2 = 0;
  var protohost = getProtohost(req2.url) || "";
  var removed = "";
  var slashAdded = false;
  var stack = this.stack;
  var done = out2 || finalhandler(req2, res, {
    env,
    onerror: logerror
  });
  req2.originalUrl = req2.originalUrl || req2.url;
  function next(err2) {
    if (slashAdded) {
      req2.url = req2.url.substr(1);
      slashAdded = false;
    }
    if (removed.length !== 0) {
      req2.url = protohost + removed + req2.url.substr(protohost.length);
      removed = "";
    }
    var layer = stack[index2++];
    if (!layer) {
      defer(done, err2);
      return;
    }
    var path8 = parseUrl(req2).pathname || "/";
    var route = layer.route;
    if (path8.toLowerCase().substr(0, route.length) !== route.toLowerCase()) {
      return next(err2);
    }
    var c2 = path8.length > route.length && path8[route.length];
    if (c2 && c2 !== "/" && c2 !== ".") {
      return next(err2);
    }
    if (route.length !== 0 && route !== "/") {
      removed = route;
      req2.url = protohost + req2.url.substr(protohost.length + removed.length);
      if (!protohost && req2.url[0] !== "/") {
        req2.url = "/" + req2.url;
        slashAdded = true;
      }
    }
    call(layer.handle, route, err2, req2, res, next);
  }
  next();
};
proto2.listen = function listen() {
  var server2 = http$4.createServer(this);
  return server2.listen.apply(server2, arguments);
};
function call(handle2, route, err2, req2, res, next) {
  var arity = handle2.length;
  var error3 = err2;
  var hasError = Boolean(err2);
  debug$4("%s %s : %s", handle2.name || "<anonymous>", route, req2.originalUrl);
  try {
    if (hasError && arity === 4) {
      handle2(err2, req2, res, next);
      return;
    } else if (!hasError && arity < 4) {
      handle2(req2, res, next);
      return;
    }
  } catch (e3) {
    error3 = e3;
  }
  next(error3);
}
function logerror(err2) {
  if (env !== "test")
    console.error(err2.stack || err2.toString());
}
function getProtohost(url2) {
  if (url2.length === 0 || url2[0] === "/") {
    return void 0;
  }
  var fqdnIndex = url2.indexOf("://");
  return fqdnIndex !== -1 && url2.lastIndexOf("?", fqdnIndex) === -1 ? url2.substr(0, url2.indexOf("/", 3 + fqdnIndex)) : void 0;
}
var libExports$1 = {};
var lib$1 = {
  get exports() {
    return libExports$1;
  },
  set exports(v) {
    libExports$1 = v;
  }
};
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
  if (val === null || val === void 0) {
    throw new TypeError("Object.assign cannot be called with null or undefined");
  }
  return Object(val);
}
function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    }
    var test1 = new String("abc");
    test1[5] = "de";
    if (Object.getOwnPropertyNames(test1)[0] === "5") {
      return false;
    }
    var test2 = {};
    for (var i2 = 0; i2 < 10; i2++) {
      test2["_" + String.fromCharCode(i2)] = i2;
    }
    var order2 = Object.getOwnPropertyNames(test2).map(function(n3) {
      return test2[n3];
    });
    if (order2.join("") !== "0123456789") {
      return false;
    }
    var test3 = {};
    "abcdefghijklmnopqrst".split("").forEach(function(letter) {
      test3[letter] = letter;
    });
    if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
      return false;
    }
    return true;
  } catch (err2) {
    return false;
  }
}
var objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
  var from;
  var to = toObject(target);
  var symbols;
  for (var s2 = 1; s2 < arguments.length; s2++) {
    from = Object(arguments[s2]);
    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }
    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);
      for (var i2 = 0; i2 < symbols.length; i2++) {
        if (propIsEnumerable.call(from, symbols[i2])) {
          to[symbols[i2]] = from[symbols[i2]];
        }
      }
    }
  }
  return to;
};
var varyExports = {};
var vary$1 = {
  get exports() {
    return varyExports;
  },
  set exports(v) {
    varyExports = v;
  }
};
vary$1.exports = vary;
varyExports.append = append;
var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
function append(header, field) {
  if (typeof header !== "string") {
    throw new TypeError("header argument is required");
  }
  if (!field) {
    throw new TypeError("field argument is required");
  }
  var fields = !Array.isArray(field) ? parse$6(String(field)) : field;
  for (var j = 0; j < fields.length; j++) {
    if (!FIELD_NAME_REGEXP.test(fields[j])) {
      throw new TypeError("field argument contains an invalid header name");
    }
  }
  if (header === "*") {
    return header;
  }
  var val = header;
  var vals = parse$6(header.toLowerCase());
  if (fields.indexOf("*") !== -1 || vals.indexOf("*") !== -1) {
    return "*";
  }
  for (var i2 = 0; i2 < fields.length; i2++) {
    var fld = fields[i2].toLowerCase();
    if (vals.indexOf(fld) === -1) {
      vals.push(fld);
      val = val ? val + ", " + fields[i2] : fields[i2];
    }
  }
  return val;
}
function parse$6(header) {
  var end = 0;
  var list = [];
  var start = 0;
  for (var i2 = 0, len = header.length; i2 < len; i2++) {
    switch (header.charCodeAt(i2)) {
      case 32:
        if (start === end) {
          start = end = i2 + 1;
        }
        break;
      case 44:
        list.push(header.substring(start, end));
        start = end = i2 + 1;
        break;
      default:
        end = i2 + 1;
        break;
    }
  }
  list.push(header.substring(start, end));
  return list;
}
function vary(res, field) {
  if (!res || !res.getHeader || !res.setHeader) {
    throw new TypeError("res argument is required");
  }
  var val = res.getHeader("Vary") || "";
  var header = Array.isArray(val) ? val.join(", ") : String(val);
  if (val = append(header, field)) {
    res.setHeader("Vary", val);
  }
}
(function() {
  var assign = objectAssign;
  var vary2 = varyExports;
  var defaults = {
    origin: "*",
    methods: "GET,HEAD,PUT,PATCH,POST,DELETE",
    preflightContinue: false,
    optionsSuccessStatus: 204
  };
  function isString3(s2) {
    return typeof s2 === "string" || s2 instanceof String;
  }
  function isOriginAllowed(origin, allowedOrigin) {
    if (Array.isArray(allowedOrigin)) {
      for (var i2 = 0; i2 < allowedOrigin.length; ++i2) {
        if (isOriginAllowed(origin, allowedOrigin[i2])) {
          return true;
        }
      }
      return false;
    } else if (isString3(allowedOrigin)) {
      return origin === allowedOrigin;
    } else if (allowedOrigin instanceof RegExp) {
      return allowedOrigin.test(origin);
    } else {
      return !!allowedOrigin;
    }
  }
  function configureOrigin(options3, req2) {
    var requestOrigin = req2.headers.origin, headers = [], isAllowed;
    if (!options3.origin || options3.origin === "*") {
      headers.push([{
        key: "Access-Control-Allow-Origin",
        value: "*"
      }]);
    } else if (isString3(options3.origin)) {
      headers.push([{
        key: "Access-Control-Allow-Origin",
        value: options3.origin
      }]);
      headers.push([{
        key: "Vary",
        value: "Origin"
      }]);
    } else {
      isAllowed = isOriginAllowed(requestOrigin, options3.origin);
      headers.push([{
        key: "Access-Control-Allow-Origin",
        value: isAllowed ? requestOrigin : false
      }]);
      headers.push([{
        key: "Vary",
        value: "Origin"
      }]);
    }
    return headers;
  }
  function configureMethods(options3) {
    var methods = options3.methods;
    if (methods.join) {
      methods = options3.methods.join(",");
    }
    return {
      key: "Access-Control-Allow-Methods",
      value: methods
    };
  }
  function configureCredentials(options3) {
    if (options3.credentials === true) {
      return {
        key: "Access-Control-Allow-Credentials",
        value: "true"
      };
    }
    return null;
  }
  function configureAllowedHeaders(options3, req2) {
    var allowedHeaders = options3.allowedHeaders || options3.headers;
    var headers = [];
    if (!allowedHeaders) {
      allowedHeaders = req2.headers["access-control-request-headers"];
      headers.push([{
        key: "Vary",
        value: "Access-Control-Request-Headers"
      }]);
    } else if (allowedHeaders.join) {
      allowedHeaders = allowedHeaders.join(",");
    }
    if (allowedHeaders && allowedHeaders.length) {
      headers.push([{
        key: "Access-Control-Allow-Headers",
        value: allowedHeaders
      }]);
    }
    return headers;
  }
  function configureExposedHeaders(options3) {
    var headers = options3.exposedHeaders;
    if (!headers) {
      return null;
    } else if (headers.join) {
      headers = headers.join(",");
    }
    if (headers && headers.length) {
      return {
        key: "Access-Control-Expose-Headers",
        value: headers
      };
    }
    return null;
  }
  function configureMaxAge(options3) {
    var maxAge = (typeof options3.maxAge === "number" || options3.maxAge) && options3.maxAge.toString();
    if (maxAge && maxAge.length) {
      return {
        key: "Access-Control-Max-Age",
        value: maxAge
      };
    }
    return null;
  }
  function applyHeaders(headers, res) {
    for (var i2 = 0, n3 = headers.length; i2 < n3; i2++) {
      var header = headers[i2];
      if (header) {
        if (Array.isArray(header)) {
          applyHeaders(header, res);
        } else if (header.key === "Vary" && header.value) {
          vary2(res, header.value);
        } else if (header.value) {
          res.setHeader(header.key, header.value);
        }
      }
    }
  }
  function cors(options3, req2, res, next) {
    var headers = [], method = req2.method && req2.method.toUpperCase && req2.method.toUpperCase();
    if (method === "OPTIONS") {
      headers.push(configureOrigin(options3, req2));
      headers.push(configureCredentials(options3));
      headers.push(configureMethods(options3));
      headers.push(configureAllowedHeaders(options3, req2));
      headers.push(configureMaxAge(options3));
      headers.push(configureExposedHeaders(options3));
      applyHeaders(headers, res);
      if (options3.preflightContinue) {
        next();
      } else {
        res.statusCode = options3.optionsSuccessStatus;
        res.setHeader("Content-Length", "0");
        res.end();
      }
    } else {
      headers.push(configureOrigin(options3, req2));
      headers.push(configureCredentials(options3));
      headers.push(configureExposedHeaders(options3));
      applyHeaders(headers, res);
      next();
    }
  }
  function middlewareWrapper(o3) {
    var optionsCallback = null;
    if (typeof o3 === "function") {
      optionsCallback = o3;
    } else {
      optionsCallback = function(req2, cb) {
        cb(null, o3);
      };
    }
    return function corsMiddleware(req2, res, next) {
      optionsCallback(req2, function(err2, options3) {
        if (err2) {
          next(err2);
        } else {
          var corsOptions = assign({}, defaults, options3);
          var originCallback = null;
          if (corsOptions.origin && typeof corsOptions.origin === "function") {
            originCallback = corsOptions.origin;
          } else if (corsOptions.origin) {
            originCallback = function(origin, cb) {
              cb(null, corsOptions.origin);
            };
          }
          if (originCallback) {
            originCallback(req2.headers.origin, function(err22, origin) {
              if (err22 || !origin) {
                next(err22);
              } else {
                corsOptions.origin = origin;
                cors(corsOptions, req2, res, next);
              }
            });
          } else {
            next();
          }
        }
      });
    };
  }
  lib$1.exports = middlewareWrapper;
})();
var chokidar = {};
var fs$8 = import_fs.default;
var { Readable } = import_stream.default;
var sysPath$3 = import_path.default;
var { promisify: promisify$3 } = import_util.default;
var picomatch$1 = picomatchExports;
var readdir$1 = promisify$3(fs$8.readdir);
var stat$3 = promisify$3(fs$8.stat);
var lstat$2 = promisify$3(fs$8.lstat);
var realpath$1 = promisify$3(fs$8.realpath);
var BANG$2 = "!";
var RECURSIVE_ERROR_CODE = "READDIRP_RECURSIVE_ERROR";
var NORMAL_FLOW_ERRORS = /* @__PURE__ */ new Set(["ENOENT", "EPERM", "EACCES", "ELOOP", RECURSIVE_ERROR_CODE]);
var FILE_TYPE = "files";
var DIR_TYPE = "directories";
var FILE_DIR_TYPE = "files_directories";
var EVERYTHING_TYPE = "all";
var ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];
var isNormalFlowError = (error3) => NORMAL_FLOW_ERRORS.has(error3.code);
var [maj, min] = process.versions.node.split(".").slice(0, 2).map((n3) => Number.parseInt(n3, 10));
var wantBigintFsStats = process.platform === "win32" && (maj > 10 || maj === 10 && min >= 5);
var normalizeFilter = (filter2) => {
  if (filter2 === void 0)
    return;
  if (typeof filter2 === "function")
    return filter2;
  if (typeof filter2 === "string") {
    const glob2 = picomatch$1(filter2.trim());
    return (entry2) => glob2(entry2.basename);
  }
  if (Array.isArray(filter2)) {
    const positive = [];
    const negative = [];
    for (const item of filter2) {
      const trimmed = item.trim();
      if (trimmed.charAt(0) === BANG$2) {
        negative.push(picomatch$1(trimmed.slice(1)));
      } else {
        positive.push(picomatch$1(trimmed));
      }
    }
    if (negative.length > 0) {
      if (positive.length > 0) {
        return (entry2) => positive.some((f2) => f2(entry2.basename)) && !negative.some((f2) => f2(entry2.basename));
      }
      return (entry2) => !negative.some((f2) => f2(entry2.basename));
    }
    return (entry2) => positive.some((f2) => f2(entry2.basename));
  }
};
var ReaddirpStream = class extends Readable {
  static get defaultOptions() {
    return {
      root: ".",
      /* eslint-disable no-unused-vars */
      fileFilter: (path8) => true,
      directoryFilter: (path8) => true,
      /* eslint-enable no-unused-vars */
      type: FILE_TYPE,
      lstat: false,
      depth: 2147483648,
      alwaysStat: false
    };
  }
  constructor(options3 = {}) {
    super({
      objectMode: true,
      autoDestroy: true,
      highWaterMark: options3.highWaterMark || 4096
    });
    const opts = { ...ReaddirpStream.defaultOptions, ...options3 };
    const { root, type } = opts;
    this._fileFilter = normalizeFilter(opts.fileFilter);
    this._directoryFilter = normalizeFilter(opts.directoryFilter);
    const statMethod = opts.lstat ? lstat$2 : stat$3;
    if (wantBigintFsStats) {
      this._stat = (path8) => statMethod(path8, { bigint: true });
    } else {
      this._stat = statMethod;
    }
    this._maxDepth = opts.depth;
    this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
    this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
    this._wantsEverything = type === EVERYTHING_TYPE;
    this._root = sysPath$3.resolve(root);
    this._isDirent = "Dirent" in fs$8 && !opts.alwaysStat;
    this._statsProp = this._isDirent ? "dirent" : "stats";
    this._rdOptions = { encoding: "utf8", withFileTypes: this._isDirent };
    this.parents = [this._exploreDir(root, 1)];
    this.reading = false;
    this.parent = void 0;
  }
  async _read(batch) {
    if (this.reading)
      return;
    this.reading = true;
    try {
      while (!this.destroyed && batch > 0) {
        const { path: path8, depth: depth2, files = [] } = this.parent || {};
        if (files.length > 0) {
          const slice2 = files.splice(0, batch).map((dirent) => this._formatEntry(dirent, path8));
          for (const entry2 of await Promise.all(slice2)) {
            if (this.destroyed)
              return;
            const entryType = await this._getEntryType(entry2);
            if (entryType === "directory" && this._directoryFilter(entry2)) {
              if (depth2 <= this._maxDepth) {
                this.parents.push(this._exploreDir(entry2.fullPath, depth2 + 1));
              }
              if (this._wantsDir) {
                this.push(entry2);
                batch--;
              }
            } else if ((entryType === "file" || this._includeAsFile(entry2)) && this._fileFilter(entry2)) {
              if (this._wantsFile) {
                this.push(entry2);
                batch--;
              }
            }
          }
        } else {
          const parent = this.parents.pop();
          if (!parent) {
            this.push(null);
            break;
          }
          this.parent = await parent;
          if (this.destroyed)
            return;
        }
      }
    } catch (error3) {
      this.destroy(error3);
    } finally {
      this.reading = false;
    }
  }
  async _exploreDir(path8, depth2) {
    let files;
    try {
      files = await readdir$1(path8, this._rdOptions);
    } catch (error3) {
      this._onError(error3);
    }
    return { files, depth: depth2, path: path8 };
  }
  async _formatEntry(dirent, path8) {
    let entry2;
    try {
      const basename2 = this._isDirent ? dirent.name : dirent;
      const fullPath = sysPath$3.resolve(sysPath$3.join(path8, basename2));
      entry2 = { path: sysPath$3.relative(this._root, fullPath), fullPath, basename: basename2 };
      entry2[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);
    } catch (err2) {
      this._onError(err2);
    }
    return entry2;
  }
  _onError(err2) {
    if (isNormalFlowError(err2) && !this.destroyed) {
      this.emit("warn", err2);
    } else {
      this.destroy(err2);
    }
  }
  async _getEntryType(entry2) {
    const stats = entry2 && entry2[this._statsProp];
    if (!stats) {
      return;
    }
    if (stats.isFile()) {
      return "file";
    }
    if (stats.isDirectory()) {
      return "directory";
    }
    if (stats && stats.isSymbolicLink()) {
      const full = entry2.fullPath;
      try {
        const entryRealPath = await realpath$1(full);
        const entryRealPathStats = await lstat$2(entryRealPath);
        if (entryRealPathStats.isFile()) {
          return "file";
        }
        if (entryRealPathStats.isDirectory()) {
          const len = entryRealPath.length;
          if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath$3.sep) {
            const recursiveError = new Error(
              `Circular symlink detected: "${full}" points to "${entryRealPath}"`
            );
            recursiveError.code = RECURSIVE_ERROR_CODE;
            return this._onError(recursiveError);
          }
          return "directory";
        }
      } catch (error3) {
        this._onError(error3);
      }
    }
  }
  _includeAsFile(entry2) {
    const stats = entry2 && entry2[this._statsProp];
    return stats && this._wantsEverything && !stats.isDirectory();
  }
};
var readdirp$1 = (root, options3 = {}) => {
  let type = options3.entryType || options3.type;
  if (type === "both")
    type = FILE_DIR_TYPE;
  if (type)
    options3.type = type;
  if (!root) {
    throw new Error("readdirp: root argument is required. Usage: readdirp(root, options)");
  } else if (typeof root !== "string") {
    throw new TypeError("readdirp: root argument must be a string. Usage: readdirp(root, options)");
  } else if (type && !ALL_TYPES.includes(type)) {
    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(", ")}`);
  }
  options3.root = root;
  return new ReaddirpStream(options3);
};
var readdirpPromise = (root, options3 = {}) => {
  return new Promise((resolve4, reject) => {
    const files = [];
    readdirp$1(root, options3).on("data", (entry2) => files.push(entry2)).on("end", () => resolve4(files)).on("error", (error3) => reject(error3));
  });
};
readdirp$1.promise = readdirpPromise;
readdirp$1.ReaddirpStream = ReaddirpStream;
readdirp$1.default = readdirp$1;
var readdirp_1 = readdirp$1;
var anymatchExports = {};
var anymatch$2 = {
  get exports() {
    return anymatchExports;
  },
  set exports(v) {
    anymatchExports = v;
  }
};
var normalizePath$2 = function(path8, stripTrailing) {
  if (typeof path8 !== "string") {
    throw new TypeError("expected path to be a string");
  }
  if (path8 === "\\" || path8 === "/")
    return "/";
  var len = path8.length;
  if (len <= 1)
    return path8;
  var prefix = "";
  if (len > 4 && path8[3] === "\\") {
    var ch = path8[2];
    if ((ch === "?" || ch === ".") && path8.slice(0, 2) === "\\\\") {
      path8 = path8.slice(2);
      prefix = "//";
    }
  }
  var segs = path8.split(/[/\\]+/);
  if (stripTrailing !== false && segs[segs.length - 1] === "") {
    segs.pop();
  }
  return prefix + segs.join("/");
};
Object.defineProperty(anymatchExports, "__esModule", { value: true });
var picomatch = picomatchExports;
var normalizePath$1 = normalizePath$2;
var BANG$1 = "!";
var DEFAULT_OPTIONS = { returnIndex: false };
var arrify$1 = (item) => Array.isArray(item) ? item : [item];
var createPattern = (matcher2, options3) => {
  if (typeof matcher2 === "function") {
    return matcher2;
  }
  if (typeof matcher2 === "string") {
    const glob2 = picomatch(matcher2, options3);
    return (string3) => matcher2 === string3 || glob2(string3);
  }
  if (matcher2 instanceof RegExp) {
    return (string3) => matcher2.test(string3);
  }
  return (string3) => false;
};
var matchPatterns = (patterns2, negPatterns, args, returnIndex) => {
  const isList = Array.isArray(args);
  const _path = isList ? args[0] : args;
  if (!isList && typeof _path !== "string") {
    throw new TypeError("anymatch: second argument must be a string: got " + Object.prototype.toString.call(_path));
  }
  const path8 = normalizePath$1(_path);
  for (let index2 = 0; index2 < negPatterns.length; index2++) {
    const nglob = negPatterns[index2];
    if (nglob(path8)) {
      return returnIndex ? -1 : false;
    }
  }
  const applied = isList && [path8].concat(args.slice(1));
  for (let index2 = 0; index2 < patterns2.length; index2++) {
    const pattern2 = patterns2[index2];
    if (isList ? pattern2(...applied) : pattern2(path8)) {
      return returnIndex ? index2 : true;
    }
  }
  return returnIndex ? -1 : false;
};
var anymatch$1 = (matchers, testString, options3 = DEFAULT_OPTIONS) => {
  if (matchers == null) {
    throw new TypeError("anymatch: specify first argument");
  }
  const opts = typeof options3 === "boolean" ? { returnIndex: options3 } : options3;
  const returnIndex = opts.returnIndex || false;
  const mtchers = arrify$1(matchers);
  const negatedGlobs = mtchers.filter((item) => typeof item === "string" && item.charAt(0) === BANG$1).map((item) => item.slice(1)).map((item) => picomatch(item, opts));
  const patterns2 = mtchers.filter((item) => typeof item !== "string" || typeof item === "string" && item.charAt(0) !== BANG$1).map((matcher2) => createPattern(matcher2, opts));
  if (testString == null) {
    return (testString2, ri = false) => {
      const returnIndex2 = typeof ri === "boolean" ? ri : false;
      return matchPatterns(patterns2, negatedGlobs, testString2, returnIndex2);
    };
  }
  return matchPatterns(patterns2, negatedGlobs, testString, returnIndex);
};
anymatch$1.default = anymatch$1;
anymatch$2.exports = anymatch$1;
var binaryExtensionsExports = {};
var binaryExtensions$1 = {
  get exports() {
    return binaryExtensionsExports;
  },
  set exports(v) {
    binaryExtensionsExports = v;
  }
};
var require$$0 = [
  "3dm",
  "3ds",
  "3g2",
  "3gp",
  "7z",
  "a",
  "aac",
  "adp",
  "ai",
  "aif",
  "aiff",
  "alz",
  "ape",
  "apk",
  "appimage",
  "ar",
  "arj",
  "asf",
  "au",
  "avi",
  "bak",
  "baml",
  "bh",
  "bin",
  "bk",
  "bmp",
  "btif",
  "bz2",
  "bzip2",
  "cab",
  "caf",
  "cgm",
  "class",
  "cmx",
  "cpio",
  "cr2",
  "cur",
  "dat",
  "dcm",
  "deb",
  "dex",
  "djvu",
  "dll",
  "dmg",
  "dng",
  "doc",
  "docm",
  "docx",
  "dot",
  "dotm",
  "dra",
  "DS_Store",
  "dsk",
  "dts",
  "dtshd",
  "dvb",
  "dwg",
  "dxf",
  "ecelp4800",
  "ecelp7470",
  "ecelp9600",
  "egg",
  "eol",
  "eot",
  "epub",
  "exe",
  "f4v",
  "fbs",
  "fh",
  "fla",
  "flac",
  "flatpak",
  "fli",
  "flv",
  "fpx",
  "fst",
  "fvt",
  "g3",
  "gh",
  "gif",
  "graffle",
  "gz",
  "gzip",
  "h261",
  "h263",
  "h264",
  "icns",
  "ico",
  "ief",
  "img",
  "ipa",
  "iso",
  "jar",
  "jpeg",
  "jpg",
  "jpgv",
  "jpm",
  "jxr",
  "key",
  "ktx",
  "lha",
  "lib",
  "lvp",
  "lz",
  "lzh",
  "lzma",
  "lzo",
  "m3u",
  "m4a",
  "m4v",
  "mar",
  "mdi",
  "mht",
  "mid",
  "midi",
  "mj2",
  "mka",
  "mkv",
  "mmr",
  "mng",
  "mobi",
  "mov",
  "movie",
  "mp3",
  "mp4",
  "mp4a",
  "mpeg",
  "mpg",
  "mpga",
  "mxu",
  "nef",
  "npx",
  "numbers",
  "nupkg",
  "o",
  "odp",
  "ods",
  "odt",
  "oga",
  "ogg",
  "ogv",
  "otf",
  "ott",
  "pages",
  "pbm",
  "pcx",
  "pdb",
  "pdf",
  "pea",
  "pgm",
  "pic",
  "png",
  "pnm",
  "pot",
  "potm",
  "potx",
  "ppa",
  "ppam",
  "ppm",
  "pps",
  "ppsm",
  "ppsx",
  "ppt",
  "pptm",
  "pptx",
  "psd",
  "pya",
  "pyc",
  "pyo",
  "pyv",
  "qt",
  "rar",
  "ras",
  "raw",
  "resources",
  "rgb",
  "rip",
  "rlc",
  "rmf",
  "rmvb",
  "rpm",
  "rtf",
  "rz",
  "s3m",
  "s7z",
  "scpt",
  "sgi",
  "shar",
  "snap",
  "sil",
  "sketch",
  "slk",
  "smv",
  "snk",
  "so",
  "stl",
  "suo",
  "sub",
  "swf",
  "tar",
  "tbz",
  "tbz2",
  "tga",
  "tgz",
  "thmx",
  "tif",
  "tiff",
  "tlz",
  "ttc",
  "ttf",
  "txz",
  "udf",
  "uvh",
  "uvi",
  "uvm",
  "uvp",
  "uvs",
  "uvu",
  "viv",
  "vob",
  "war",
  "wav",
  "wax",
  "wbmp",
  "wdp",
  "weba",
  "webm",
  "webp",
  "whl",
  "wim",
  "wm",
  "wma",
  "wmv",
  "wmx",
  "woff",
  "woff2",
  "wrm",
  "wvx",
  "xbm",
  "xif",
  "xla",
  "xlam",
  "xls",
  "xlsb",
  "xlsm",
  "xlsx",
  "xlt",
  "xltm",
  "xltx",
  "xm",
  "xmind",
  "xpi",
  "xpm",
  "xwd",
  "xz",
  "z",
  "zip",
  "zipx"
];
(function(module2) {
  module2.exports = require$$0;
})(binaryExtensions$1);
var path$8 = import_path.default;
var binaryExtensions = binaryExtensionsExports;
var extensions = new Set(binaryExtensions);
var isBinaryPath$1 = (filePath) => extensions.has(path$8.extname(filePath).slice(1).toLowerCase());
var constants$1 = {};
(function(exports3) {
  const { sep: sep2 } = import_path.default;
  const { platform: platform2 } = process;
  const os2 = import_os.default;
  exports3.EV_ALL = "all";
  exports3.EV_READY = "ready";
  exports3.EV_ADD = "add";
  exports3.EV_CHANGE = "change";
  exports3.EV_ADD_DIR = "addDir";
  exports3.EV_UNLINK = "unlink";
  exports3.EV_UNLINK_DIR = "unlinkDir";
  exports3.EV_RAW = "raw";
  exports3.EV_ERROR = "error";
  exports3.STR_DATA = "data";
  exports3.STR_END = "end";
  exports3.STR_CLOSE = "close";
  exports3.FSEVENT_CREATED = "created";
  exports3.FSEVENT_MODIFIED = "modified";
  exports3.FSEVENT_DELETED = "deleted";
  exports3.FSEVENT_MOVED = "moved";
  exports3.FSEVENT_CLONED = "cloned";
  exports3.FSEVENT_UNKNOWN = "unknown";
  exports3.FSEVENT_TYPE_FILE = "file";
  exports3.FSEVENT_TYPE_DIRECTORY = "directory";
  exports3.FSEVENT_TYPE_SYMLINK = "symlink";
  exports3.KEY_LISTENERS = "listeners";
  exports3.KEY_ERR = "errHandlers";
  exports3.KEY_RAW = "rawEmitters";
  exports3.HANDLER_KEYS = [exports3.KEY_LISTENERS, exports3.KEY_ERR, exports3.KEY_RAW];
  exports3.DOT_SLASH = `.${sep2}`;
  exports3.BACK_SLASH_RE = /\\/g;
  exports3.DOUBLE_SLASH_RE = /\/\//;
  exports3.SLASH_OR_BACK_SLASH_RE = /[/\\]/;
  exports3.DOT_RE = /\..*\.(sw[px])$|~$|\.subl.*\.tmp/;
  exports3.REPLACER_RE = /^\.[/\\]/;
  exports3.SLASH = "/";
  exports3.SLASH_SLASH = "//";
  exports3.BRACE_START = "{";
  exports3.BANG = "!";
  exports3.ONE_DOT = ".";
  exports3.TWO_DOTS = "..";
  exports3.STAR = "*";
  exports3.GLOBSTAR = "**";
  exports3.ROOT_GLOBSTAR = "/**/*";
  exports3.SLASH_GLOBSTAR = "/**";
  exports3.DIR_SUFFIX = "Dir";
  exports3.ANYMATCH_OPTS = { dot: true };
  exports3.STRING_TYPE = "string";
  exports3.FUNCTION_TYPE = "function";
  exports3.EMPTY_STR = "";
  exports3.EMPTY_FN = () => {
  };
  exports3.IDENTITY_FN = (val) => val;
  exports3.isWindows = platform2 === "win32";
  exports3.isMacos = platform2 === "darwin";
  exports3.isLinux = platform2 === "linux";
  exports3.isIBMi = os2.type() === "OS400";
})(constants$1);
var fs$7 = import_fs.default;
var sysPath$2 = import_path.default;
var { promisify: promisify$2 } = import_util.default;
var isBinaryPath = isBinaryPath$1;
var {
  isWindows: isWindows$2,
  isLinux,
  EMPTY_FN: EMPTY_FN$2,
  EMPTY_STR: EMPTY_STR$1,
  KEY_LISTENERS,
  KEY_ERR,
  KEY_RAW,
  HANDLER_KEYS,
  EV_CHANGE: EV_CHANGE$2,
  EV_ADD: EV_ADD$2,
  EV_ADD_DIR: EV_ADD_DIR$2,
  EV_ERROR: EV_ERROR$2,
  STR_DATA: STR_DATA$1,
  STR_END: STR_END$2,
  BRACE_START: BRACE_START$1,
  STAR
} = constants$1;
var THROTTLE_MODE_WATCH = "watch";
var open$1 = promisify$2(fs$7.open);
var stat$2 = promisify$2(fs$7.stat);
var lstat$1 = promisify$2(fs$7.lstat);
var close = promisify$2(fs$7.close);
var fsrealpath = promisify$2(fs$7.realpath);
var statMethods$1 = { lstat: lstat$1, stat: stat$2 };
var foreach = (val, fn) => {
  if (val instanceof Set) {
    val.forEach(fn);
  } else {
    fn(val);
  }
};
var addAndConvert = (main2, prop, item) => {
  let container = main2[prop];
  if (!(container instanceof Set)) {
    main2[prop] = container = /* @__PURE__ */ new Set([container]);
  }
  container.add(item);
};
var clearItem = (cont) => (key) => {
  const set3 = cont[key];
  if (set3 instanceof Set) {
    set3.clear();
  } else {
    delete cont[key];
  }
};
var delFromSet = (main2, prop, item) => {
  const container = main2[prop];
  if (container instanceof Set) {
    container.delete(item);
  } else if (container === item) {
    delete main2[prop];
  }
};
var isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;
var FsWatchInstances = /* @__PURE__ */ new Map();
function createFsWatchInstance(path8, options3, listener2, errHandler, emitRaw) {
  const handleEvent = (rawEvent, evPath) => {
    listener2(path8);
    emitRaw(rawEvent, evPath, { watchedPath: path8 });
    if (evPath && path8 !== evPath) {
      fsWatchBroadcast(
        sysPath$2.resolve(path8, evPath),
        KEY_LISTENERS,
        sysPath$2.join(path8, evPath)
      );
    }
  };
  try {
    return fs$7.watch(path8, options3, handleEvent);
  } catch (error3) {
    errHandler(error3);
  }
}
var fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {
  const cont = FsWatchInstances.get(fullPath);
  if (!cont)
    return;
  foreach(cont[type], (listener2) => {
    listener2(val1, val2, val3);
  });
};
var setFsWatchListener = (path8, fullPath, options3, handlers) => {
  const { listener: listener2, errHandler, rawEmitter } = handlers;
  let cont = FsWatchInstances.get(fullPath);
  let watcher;
  if (!options3.persistent) {
    watcher = createFsWatchInstance(
      path8,
      options3,
      listener2,
      errHandler,
      rawEmitter
    );
    return watcher.close.bind(watcher);
  }
  if (cont) {
    addAndConvert(cont, KEY_LISTENERS, listener2);
    addAndConvert(cont, KEY_ERR, errHandler);
    addAndConvert(cont, KEY_RAW, rawEmitter);
  } else {
    watcher = createFsWatchInstance(
      path8,
      options3,
      fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS),
      errHandler,
      // no need to use broadcast here
      fsWatchBroadcast.bind(null, fullPath, KEY_RAW)
    );
    if (!watcher)
      return;
    watcher.on(EV_ERROR$2, async (error3) => {
      const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);
      cont.watcherUnusable = true;
      if (isWindows$2 && error3.code === "EPERM") {
        try {
          const fd = await open$1(path8, "r");
          await close(fd);
          broadcastErr(error3);
        } catch (err2) {
        }
      } else {
        broadcastErr(error3);
      }
    });
    cont = {
      listeners: listener2,
      errHandlers: errHandler,
      rawEmitters: rawEmitter,
      watcher
    };
    FsWatchInstances.set(fullPath, cont);
  }
  return () => {
    delFromSet(cont, KEY_LISTENERS, listener2);
    delFromSet(cont, KEY_ERR, errHandler);
    delFromSet(cont, KEY_RAW, rawEmitter);
    if (isEmptySet(cont.listeners)) {
      cont.watcher.close();
      FsWatchInstances.delete(fullPath);
      HANDLER_KEYS.forEach(clearItem(cont));
      cont.watcher = void 0;
      Object.freeze(cont);
    }
  };
};
var FsWatchFileInstances = /* @__PURE__ */ new Map();
var setFsWatchFileListener = (path8, fullPath, options3, handlers) => {
  const { listener: listener2, rawEmitter } = handlers;
  let cont = FsWatchFileInstances.get(fullPath);
  const copts = cont && cont.options;
  if (copts && (copts.persistent < options3.persistent || copts.interval > options3.interval)) {
    fs$7.unwatchFile(fullPath);
    cont = void 0;
  }
  if (cont) {
    addAndConvert(cont, KEY_LISTENERS, listener2);
    addAndConvert(cont, KEY_RAW, rawEmitter);
  } else {
    cont = {
      listeners: listener2,
      rawEmitters: rawEmitter,
      options: options3,
      watcher: fs$7.watchFile(fullPath, options3, (curr, prev) => {
        foreach(cont.rawEmitters, (rawEmitter2) => {
          rawEmitter2(EV_CHANGE$2, fullPath, { curr, prev });
        });
        const currmtime = curr.mtimeMs;
        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {
          foreach(cont.listeners, (listener3) => listener3(path8, curr));
        }
      })
    };
    FsWatchFileInstances.set(fullPath, cont);
  }
  return () => {
    delFromSet(cont, KEY_LISTENERS, listener2);
    delFromSet(cont, KEY_RAW, rawEmitter);
    if (isEmptySet(cont.listeners)) {
      FsWatchFileInstances.delete(fullPath);
      fs$7.unwatchFile(fullPath);
      cont.options = cont.watcher = void 0;
      Object.freeze(cont);
    }
  };
};
var NodeFsHandler$1 = class NodeFsHandler {
  /**
   * @param {import("../index").FSWatcher} fsW
   */
  constructor(fsW) {
    this.fsw = fsW;
    this._boundHandleError = (error3) => fsW._handleError(error3);
  }
  /**
   * Watch file for changes with fs_watchFile or fs_watch.
   * @param {String} path to file or dir
   * @param {Function} listener on fs change
   * @returns {Function} closer for the watcher instance
   */
  _watchWithNodeFs(path8, listener2) {
    const opts = this.fsw.options;
    const directory = sysPath$2.dirname(path8);
    const basename2 = sysPath$2.basename(path8);
    const parent = this.fsw._getWatchedDir(directory);
    parent.add(basename2);
    const absolutePath = sysPath$2.resolve(path8);
    const options3 = { persistent: opts.persistent };
    if (!listener2)
      listener2 = EMPTY_FN$2;
    let closer;
    if (opts.usePolling) {
      options3.interval = opts.enableBinaryInterval && isBinaryPath(basename2) ? opts.binaryInterval : opts.interval;
      closer = setFsWatchFileListener(path8, absolutePath, options3, {
        listener: listener2,
        rawEmitter: this.fsw._emitRaw
      });
    } else {
      closer = setFsWatchListener(path8, absolutePath, options3, {
        listener: listener2,
        errHandler: this._boundHandleError,
        rawEmitter: this.fsw._emitRaw
      });
    }
    return closer;
  }
  /**
   * Watch a file and emit add event if warranted.
   * @param {Path} file Path
   * @param {fs.Stats} stats result of fs_stat
   * @param {Boolean} initialAdd was the file added at watch instantiation?
   * @returns {Function} closer for the watcher instance
   */
  _handleFile(file, stats, initialAdd) {
    if (this.fsw.closed) {
      return;
    }
    const dirname2 = sysPath$2.dirname(file);
    const basename2 = sysPath$2.basename(file);
    const parent = this.fsw._getWatchedDir(dirname2);
    let prevStats = stats;
    if (parent.has(basename2))
      return;
    const listener2 = async (path8, newStats) => {
      if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5))
        return;
      if (!newStats || newStats.mtimeMs === 0) {
        try {
          const newStats2 = await stat$2(file);
          if (this.fsw.closed)
            return;
          const at2 = newStats2.atimeMs;
          const mt = newStats2.mtimeMs;
          if (!at2 || at2 <= mt || mt !== prevStats.mtimeMs) {
            this.fsw._emit(EV_CHANGE$2, file, newStats2);
          }
          if (isLinux && prevStats.ino !== newStats2.ino) {
            this.fsw._closeFile(path8);
            prevStats = newStats2;
            this.fsw._addPathCloser(path8, this._watchWithNodeFs(file, listener2));
          } else {
            prevStats = newStats2;
          }
        } catch (error3) {
          this.fsw._remove(dirname2, basename2);
        }
      } else if (parent.has(basename2)) {
        const at2 = newStats.atimeMs;
        const mt = newStats.mtimeMs;
        if (!at2 || at2 <= mt || mt !== prevStats.mtimeMs) {
          this.fsw._emit(EV_CHANGE$2, file, newStats);
        }
        prevStats = newStats;
      }
    };
    const closer = this._watchWithNodeFs(file, listener2);
    if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {
      if (!this.fsw._throttle(EV_ADD$2, file, 0))
        return;
      this.fsw._emit(EV_ADD$2, file, stats);
    }
    return closer;
  }
  /**
   * Handle symlinks encountered while reading a dir.
   * @param {Object} entry returned by readdirp
   * @param {String} directory path of dir being read
   * @param {String} path of this item
   * @param {String} item basename of this item
   * @returns {Promise<Boolean>} true if no more processing is needed for this entry.
   */
  async _handleSymlink(entry2, directory, path8, item) {
    if (this.fsw.closed) {
      return;
    }
    const full = entry2.fullPath;
    const dir = this.fsw._getWatchedDir(directory);
    if (!this.fsw.options.followSymlinks) {
      this.fsw._incrReadyCount();
      let linkPath;
      try {
        linkPath = await fsrealpath(path8);
      } catch (e3) {
        this.fsw._emitReady();
        return true;
      }
      if (this.fsw.closed)
        return;
      if (dir.has(item)) {
        if (this.fsw._symlinkPaths.get(full) !== linkPath) {
          this.fsw._symlinkPaths.set(full, linkPath);
          this.fsw._emit(EV_CHANGE$2, path8, entry2.stats);
        }
      } else {
        dir.add(item);
        this.fsw._symlinkPaths.set(full, linkPath);
        this.fsw._emit(EV_ADD$2, path8, entry2.stats);
      }
      this.fsw._emitReady();
      return true;
    }
    if (this.fsw._symlinkPaths.has(full)) {
      return true;
    }
    this.fsw._symlinkPaths.set(full, true);
  }
  _handleRead(directory, initialAdd, wh, target, dir, depth2, throttler) {
    directory = sysPath$2.join(directory, EMPTY_STR$1);
    if (!wh.hasGlob) {
      throttler = this.fsw._throttle("readdir", directory, 1e3);
      if (!throttler)
        return;
    }
    const previous = this.fsw._getWatchedDir(wh.path);
    const current2 = /* @__PURE__ */ new Set();
    let stream4 = this.fsw._readdirp(directory, {
      fileFilter: (entry2) => wh.filterPath(entry2),
      directoryFilter: (entry2) => wh.filterDir(entry2),
      depth: 0
    }).on(STR_DATA$1, async (entry2) => {
      if (this.fsw.closed) {
        stream4 = void 0;
        return;
      }
      const item = entry2.path;
      let path8 = sysPath$2.join(directory, item);
      current2.add(item);
      if (entry2.stats.isSymbolicLink() && await this._handleSymlink(entry2, directory, path8, item)) {
        return;
      }
      if (this.fsw.closed) {
        stream4 = void 0;
        return;
      }
      if (item === target || !target && !previous.has(item)) {
        this.fsw._incrReadyCount();
        path8 = sysPath$2.join(dir, sysPath$2.relative(dir, path8));
        this._addToNodeFs(path8, initialAdd, wh, depth2 + 1);
      }
    }).on(EV_ERROR$2, this._boundHandleError);
    return new Promise(
      (resolve4) => stream4.once(STR_END$2, () => {
        if (this.fsw.closed) {
          stream4 = void 0;
          return;
        }
        const wasThrottled = throttler ? throttler.clear() : false;
        resolve4();
        previous.getChildren().filter((item) => {
          return item !== directory && !current2.has(item) && // in case of intersecting globs;
          // a path may have been filtered out of this readdir, but
          // shouldn't be removed because it matches a different glob
          (!wh.hasGlob || wh.filterPath({
            fullPath: sysPath$2.resolve(directory, item)
          }));
        }).forEach((item) => {
          this.fsw._remove(directory, item);
        });
        stream4 = void 0;
        if (wasThrottled)
          this._handleRead(directory, false, wh, target, dir, depth2, throttler);
      })
    );
  }
  /**
   * Read directory to add / remove files from `@watched` list and re-read it on change.
   * @param {String} dir fs path
   * @param {fs.Stats} stats
   * @param {Boolean} initialAdd
   * @param {Number} depth relative to user-supplied path
   * @param {String} target child path targeted for watch
   * @param {Object} wh Common watch helpers for this path
   * @param {String} realpath
   * @returns {Promise<Function>} closer for the watcher instance.
   */
  async _handleDir(dir, stats, initialAdd, depth2, target, wh, realpath3) {
    const parentDir = this.fsw._getWatchedDir(sysPath$2.dirname(dir));
    const tracked = parentDir.has(sysPath$2.basename(dir));
    if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {
      if (!wh.hasGlob || wh.globFilter(dir))
        this.fsw._emit(EV_ADD_DIR$2, dir, stats);
    }
    parentDir.add(sysPath$2.basename(dir));
    this.fsw._getWatchedDir(dir);
    let throttler;
    let closer;
    const oDepth = this.fsw.options.depth;
    if ((oDepth == null || depth2 <= oDepth) && !this.fsw._symlinkPaths.has(realpath3)) {
      if (!target) {
        await this._handleRead(dir, initialAdd, wh, target, dir, depth2, throttler);
        if (this.fsw.closed)
          return;
      }
      closer = this._watchWithNodeFs(dir, (dirPath, stats2) => {
        if (stats2 && stats2.mtimeMs === 0)
          return;
        this._handleRead(dirPath, false, wh, target, dir, depth2, throttler);
      });
    }
    return closer;
  }
  /**
   * Handle added file, directory, or glob pattern.
   * Delegates call to _handleFile / _handleDir after checks.
   * @param {String} path to file or ir
   * @param {Boolean} initialAdd was the file added at watch instantiation?
   * @param {Object} priorWh depth relative to user-supplied path
   * @param {Number} depth Child path actually targeted for watch
   * @param {String=} target Child path actually targeted for watch
   * @returns {Promise}
   */
  async _addToNodeFs(path8, initialAdd, priorWh, depth2, target) {
    const ready = this.fsw._emitReady;
    if (this.fsw._isIgnored(path8) || this.fsw.closed) {
      ready();
      return false;
    }
    const wh = this.fsw._getWatchHelpers(path8, depth2);
    if (!wh.hasGlob && priorWh) {
      wh.hasGlob = priorWh.hasGlob;
      wh.globFilter = priorWh.globFilter;
      wh.filterPath = (entry2) => priorWh.filterPath(entry2);
      wh.filterDir = (entry2) => priorWh.filterDir(entry2);
    }
    try {
      const stats = await statMethods$1[wh.statMethod](wh.watchPath);
      if (this.fsw.closed)
        return;
      if (this.fsw._isIgnored(wh.watchPath, stats)) {
        ready();
        return false;
      }
      const follow = this.fsw.options.followSymlinks && !path8.includes(STAR) && !path8.includes(BRACE_START$1);
      let closer;
      if (stats.isDirectory()) {
        const absPath = sysPath$2.resolve(path8);
        const targetPath = follow ? await fsrealpath(path8) : path8;
        if (this.fsw.closed)
          return;
        closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth2, target, wh, targetPath);
        if (this.fsw.closed)
          return;
        if (absPath !== targetPath && targetPath !== void 0) {
          this.fsw._symlinkPaths.set(absPath, targetPath);
        }
      } else if (stats.isSymbolicLink()) {
        const targetPath = follow ? await fsrealpath(path8) : path8;
        if (this.fsw.closed)
          return;
        const parent = sysPath$2.dirname(wh.watchPath);
        this.fsw._getWatchedDir(parent).add(wh.watchPath);
        this.fsw._emit(EV_ADD$2, wh.watchPath, stats);
        closer = await this._handleDir(parent, stats, initialAdd, depth2, path8, wh, targetPath);
        if (this.fsw.closed)
          return;
        if (targetPath !== void 0) {
          this.fsw._symlinkPaths.set(sysPath$2.resolve(path8), targetPath);
        }
      } else {
        closer = this._handleFile(wh.watchPath, stats, initialAdd);
      }
      ready();
      this.fsw._addPathCloser(path8, closer);
      return false;
    } catch (error3) {
      if (this.fsw._handleError(error3)) {
        ready();
        return path8;
      }
    }
  }
};
var nodefsHandler = NodeFsHandler$1;
var fseventsHandlerExports = {};
var fseventsHandler = {
  get exports() {
    return fseventsHandlerExports;
  },
  set exports(v) {
    fseventsHandlerExports = v;
  }
};
var fs$6 = import_fs.default;
var sysPath$1 = import_path.default;
var { promisify: promisify$1 } = import_util.default;
var fsevents;
try {
  fsevents = __require2("fsevents");
} catch (error3) {
  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR)
    console.error(error3);
}
if (fsevents) {
  const mtch = process.version.match(/v(\d+)\.(\d+)/);
  if (mtch && mtch[1] && mtch[2]) {
    const maj2 = Number.parseInt(mtch[1], 10);
    const min2 = Number.parseInt(mtch[2], 10);
    if (maj2 === 8 && min2 < 16) {
      fsevents = void 0;
    }
  }
}
var {
  EV_ADD: EV_ADD$1,
  EV_CHANGE: EV_CHANGE$1,
  EV_ADD_DIR: EV_ADD_DIR$1,
  EV_UNLINK: EV_UNLINK$1,
  EV_ERROR: EV_ERROR$1,
  STR_DATA,
  STR_END: STR_END$1,
  FSEVENT_CREATED,
  FSEVENT_MODIFIED,
  FSEVENT_DELETED,
  FSEVENT_MOVED,
  // FSEVENT_CLONED,
  FSEVENT_UNKNOWN,
  FSEVENT_TYPE_FILE,
  FSEVENT_TYPE_DIRECTORY,
  FSEVENT_TYPE_SYMLINK,
  ROOT_GLOBSTAR,
  DIR_SUFFIX,
  DOT_SLASH,
  FUNCTION_TYPE: FUNCTION_TYPE$1,
  EMPTY_FN: EMPTY_FN$1,
  IDENTITY_FN
} = constants$1;
var Depth = (value2) => isNaN(value2) ? {} : { depth: value2 };
var stat$1 = promisify$1(fs$6.stat);
var lstat = promisify$1(fs$6.lstat);
var realpath2 = promisify$1(fs$6.realpath);
var statMethods = { stat: stat$1, lstat };
var FSEventsWatchers = /* @__PURE__ */ new Map();
var consolidateThreshhold = 10;
var wrongEventFlags = /* @__PURE__ */ new Set([
  69888,
  70400,
  71424,
  72704,
  73472,
  131328,
  131840,
  262912
]);
var createFSEventsInstance = (path8, callback) => {
  const stop = fsevents.watch(path8, callback);
  return { stop };
};
function setFSEventsListener(path8, realPath, listener2, rawEmitter) {
  let watchPath = sysPath$1.extname(realPath) ? sysPath$1.dirname(realPath) : realPath;
  const parentPath = sysPath$1.dirname(watchPath);
  let cont = FSEventsWatchers.get(watchPath);
  if (couldConsolidate(parentPath)) {
    watchPath = parentPath;
  }
  const resolvedPath = sysPath$1.resolve(path8);
  const hasSymlink = resolvedPath !== realPath;
  const filteredListener = (fullPath, flags, info3) => {
    if (hasSymlink)
      fullPath = fullPath.replace(realPath, resolvedPath);
    if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath$1.sep))
      listener2(fullPath, flags, info3);
  };
  let watchedParent = false;
  for (const watchedPath of FSEventsWatchers.keys()) {
    if (realPath.indexOf(sysPath$1.resolve(watchedPath) + sysPath$1.sep) === 0) {
      watchPath = watchedPath;
      cont = FSEventsWatchers.get(watchPath);
      watchedParent = true;
      break;
    }
  }
  if (cont || watchedParent) {
    cont.listeners.add(filteredListener);
  } else {
    cont = {
      listeners: /* @__PURE__ */ new Set([filteredListener]),
      rawEmitter,
      watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {
        if (!cont.listeners.size)
          return;
        const info3 = fsevents.getInfo(fullPath, flags);
        cont.listeners.forEach((list) => {
          list(fullPath, flags, info3);
        });
        cont.rawEmitter(info3.event, fullPath, info3);
      })
    };
    FSEventsWatchers.set(watchPath, cont);
  }
  return () => {
    const lst = cont.listeners;
    lst.delete(filteredListener);
    if (!lst.size) {
      FSEventsWatchers.delete(watchPath);
      if (cont.watcher)
        return cont.watcher.stop().then(() => {
          cont.rawEmitter = cont.watcher = void 0;
          Object.freeze(cont);
        });
    }
  };
}
var couldConsolidate = (path8) => {
  let count = 0;
  for (const watchPath of FSEventsWatchers.keys()) {
    if (watchPath.indexOf(path8) === 0) {
      count++;
      if (count >= consolidateThreshhold) {
        return true;
      }
    }
  }
  return false;
};
var canUse = () => fsevents && FSEventsWatchers.size < 128;
var calcDepth = (path8, root) => {
  let i2 = 0;
  while (!path8.indexOf(root) && (path8 = sysPath$1.dirname(path8)) !== root)
    i2++;
  return i2;
};
var sameTypes = (info3, stats) => info3.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() || info3.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() || info3.type === FSEVENT_TYPE_FILE && stats.isFile();
var FsEventsHandler$1 = class FsEventsHandler {
  /**
   * @param {import('../index').FSWatcher} fsw
   */
  constructor(fsw) {
    this.fsw = fsw;
  }
  checkIgnored(path8, stats) {
    const ipaths = this.fsw._ignoredPaths;
    if (this.fsw._isIgnored(path8, stats)) {
      ipaths.add(path8);
      if (stats && stats.isDirectory()) {
        ipaths.add(path8 + ROOT_GLOBSTAR);
      }
      return true;
    }
    ipaths.delete(path8);
    ipaths.delete(path8 + ROOT_GLOBSTAR);
  }
  addOrChange(path8, fullPath, realPath, parent, watchedDir, item, info3, opts) {
    const event = watchedDir.has(item) ? EV_CHANGE$1 : EV_ADD$1;
    this.handleEvent(event, path8, fullPath, realPath, parent, watchedDir, item, info3, opts);
  }
  async checkExists(path8, fullPath, realPath, parent, watchedDir, item, info3, opts) {
    try {
      const stats = await stat$1(path8);
      if (this.fsw.closed)
        return;
      if (sameTypes(info3, stats)) {
        this.addOrChange(path8, fullPath, realPath, parent, watchedDir, item, info3, opts);
      } else {
        this.handleEvent(EV_UNLINK$1, path8, fullPath, realPath, parent, watchedDir, item, info3, opts);
      }
    } catch (error3) {
      if (error3.code === "EACCES") {
        this.addOrChange(path8, fullPath, realPath, parent, watchedDir, item, info3, opts);
      } else {
        this.handleEvent(EV_UNLINK$1, path8, fullPath, realPath, parent, watchedDir, item, info3, opts);
      }
    }
  }
  handleEvent(event, path8, fullPath, realPath, parent, watchedDir, item, info3, opts) {
    if (this.fsw.closed || this.checkIgnored(path8))
      return;
    if (event === EV_UNLINK$1) {
      const isDirectory2 = info3.type === FSEVENT_TYPE_DIRECTORY;
      if (isDirectory2 || watchedDir.has(item)) {
        this.fsw._remove(parent, item, isDirectory2);
      }
    } else {
      if (event === EV_ADD$1) {
        if (info3.type === FSEVENT_TYPE_DIRECTORY)
          this.fsw._getWatchedDir(path8);
        if (info3.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {
          const curDepth = opts.depth === void 0 ? void 0 : calcDepth(fullPath, realPath) + 1;
          return this._addToFsEvents(path8, false, true, curDepth);
        }
        this.fsw._getWatchedDir(parent).add(item);
      }
      const eventName = info3.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;
      this.fsw._emit(eventName, path8);
      if (eventName === EV_ADD_DIR$1)
        this._addToFsEvents(path8, false, true);
    }
  }
  /**
   * Handle symlinks encountered during directory scan
   * @param {String} watchPath  - file/dir path to be watched with fsevents
   * @param {String} realPath   - real path (in case of symlinks)
   * @param {Function} transform  - path transformer
   * @param {Function} globFilter - path filter in case a glob pattern was provided
   * @returns {Function} closer for the watcher instance
  */
  _watchWithFsEvents(watchPath, realPath, transform2, globFilter) {
    if (this.fsw.closed || this.fsw._isIgnored(watchPath))
      return;
    const opts = this.fsw.options;
    const watchCallback = async (fullPath, flags, info3) => {
      if (this.fsw.closed)
        return;
      if (opts.depth !== void 0 && calcDepth(fullPath, realPath) > opts.depth)
        return;
      const path8 = transform2(sysPath$1.join(
        watchPath,
        sysPath$1.relative(watchPath, fullPath)
      ));
      if (globFilter && !globFilter(path8))
        return;
      const parent = sysPath$1.dirname(path8);
      const item = sysPath$1.basename(path8);
      const watchedDir = this.fsw._getWatchedDir(
        info3.type === FSEVENT_TYPE_DIRECTORY ? path8 : parent
      );
      if (wrongEventFlags.has(flags) || info3.event === FSEVENT_UNKNOWN) {
        if (typeof opts.ignored === FUNCTION_TYPE$1) {
          let stats;
          try {
            stats = await stat$1(path8);
          } catch (error3) {
          }
          if (this.fsw.closed)
            return;
          if (this.checkIgnored(path8, stats))
            return;
          if (sameTypes(info3, stats)) {
            this.addOrChange(path8, fullPath, realPath, parent, watchedDir, item, info3, opts);
          } else {
            this.handleEvent(EV_UNLINK$1, path8, fullPath, realPath, parent, watchedDir, item, info3, opts);
          }
        } else {
          this.checkExists(path8, fullPath, realPath, parent, watchedDir, item, info3, opts);
        }
      } else {
        switch (info3.event) {
          case FSEVENT_CREATED:
          case FSEVENT_MODIFIED:
            return this.addOrChange(path8, fullPath, realPath, parent, watchedDir, item, info3, opts);
          case FSEVENT_DELETED:
          case FSEVENT_MOVED:
            return this.checkExists(path8, fullPath, realPath, parent, watchedDir, item, info3, opts);
        }
      }
    };
    const closer = setFSEventsListener(
      watchPath,
      realPath,
      watchCallback,
      this.fsw._emitRaw
    );
    this.fsw._emitReady();
    return closer;
  }
  /**
   * Handle symlinks encountered during directory scan
   * @param {String} linkPath path to symlink
   * @param {String} fullPath absolute path to the symlink
   * @param {Function} transform pre-existing path transformer
   * @param {Number} curDepth level of subdirectories traversed to where symlink is
   * @returns {Promise<void>}
   */
  async _handleFsEventsSymlink(linkPath, fullPath, transform2, curDepth) {
    if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath))
      return;
    this.fsw._symlinkPaths.set(fullPath, true);
    this.fsw._incrReadyCount();
    try {
      const linkTarget = await realpath2(linkPath);
      if (this.fsw.closed)
        return;
      if (this.fsw._isIgnored(linkTarget)) {
        return this.fsw._emitReady();
      }
      this.fsw._incrReadyCount();
      this._addToFsEvents(linkTarget || linkPath, (path8) => {
        let aliasedPath = linkPath;
        if (linkTarget && linkTarget !== DOT_SLASH) {
          aliasedPath = path8.replace(linkTarget, linkPath);
        } else if (path8 !== DOT_SLASH) {
          aliasedPath = sysPath$1.join(linkPath, path8);
        }
        return transform2(aliasedPath);
      }, false, curDepth);
    } catch (error3) {
      if (this.fsw._handleError(error3)) {
        return this.fsw._emitReady();
      }
    }
  }
  /**
   *
   * @param {Path} newPath
   * @param {fs.Stats} stats
   */
  emitAdd(newPath, stats, processPath, opts, forceAdd) {
    const pp2 = processPath(newPath);
    const isDir = stats.isDirectory();
    const dirObj = this.fsw._getWatchedDir(sysPath$1.dirname(pp2));
    const base2 = sysPath$1.basename(pp2);
    if (isDir)
      this.fsw._getWatchedDir(pp2);
    if (dirObj.has(base2))
      return;
    dirObj.add(base2);
    if (!opts.ignoreInitial || forceAdd === true) {
      this.fsw._emit(isDir ? EV_ADD_DIR$1 : EV_ADD$1, pp2, stats);
    }
  }
  initWatch(realPath, path8, wh, processPath) {
    if (this.fsw.closed)
      return;
    const closer = this._watchWithFsEvents(
      wh.watchPath,
      sysPath$1.resolve(realPath || wh.watchPath),
      processPath,
      wh.globFilter
    );
    this.fsw._addPathCloser(path8, closer);
  }
  /**
   * Handle added path with fsevents
   * @param {String} path file/dir path or glob pattern
   * @param {Function|Boolean=} transform converts working path to what the user expects
   * @param {Boolean=} forceAdd ensure add is emitted
   * @param {Number=} priorDepth Level of subdirectories already traversed.
   * @returns {Promise<void>}
   */
  async _addToFsEvents(path8, transform2, forceAdd, priorDepth) {
    if (this.fsw.closed) {
      return;
    }
    const opts = this.fsw.options;
    const processPath = typeof transform2 === FUNCTION_TYPE$1 ? transform2 : IDENTITY_FN;
    const wh = this.fsw._getWatchHelpers(path8);
    try {
      const stats = await statMethods[wh.statMethod](wh.watchPath);
      if (this.fsw.closed)
        return;
      if (this.fsw._isIgnored(wh.watchPath, stats)) {
        throw null;
      }
      if (stats.isDirectory()) {
        if (!wh.globFilter)
          this.emitAdd(processPath(path8), stats, processPath, opts, forceAdd);
        if (priorDepth && priorDepth > opts.depth)
          return;
        this.fsw._readdirp(wh.watchPath, {
          fileFilter: (entry2) => wh.filterPath(entry2),
          directoryFilter: (entry2) => wh.filterDir(entry2),
          ...Depth(opts.depth - (priorDepth || 0))
        }).on(STR_DATA, (entry2) => {
          if (this.fsw.closed) {
            return;
          }
          if (entry2.stats.isDirectory() && !wh.filterPath(entry2))
            return;
          const joinedPath = sysPath$1.join(wh.watchPath, entry2.path);
          const { fullPath } = entry2;
          if (wh.followSymlinks && entry2.stats.isSymbolicLink()) {
            const curDepth = opts.depth === void 0 ? void 0 : calcDepth(joinedPath, sysPath$1.resolve(wh.watchPath)) + 1;
            this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);
          } else {
            this.emitAdd(joinedPath, entry2.stats, processPath, opts, forceAdd);
          }
        }).on(EV_ERROR$1, EMPTY_FN$1).on(STR_END$1, () => {
          this.fsw._emitReady();
        });
      } else {
        this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);
        this.fsw._emitReady();
      }
    } catch (error3) {
      if (!error3 || this.fsw._handleError(error3)) {
        this.fsw._emitReady();
        this.fsw._emitReady();
      }
    }
    if (opts.persistent && forceAdd !== true) {
      if (typeof transform2 === FUNCTION_TYPE$1) {
        this.initWatch(void 0, path8, wh, processPath);
      } else {
        let realPath;
        try {
          realPath = await realpath2(wh.watchPath);
        } catch (e3) {
        }
        this.initWatch(realPath, path8, wh, processPath);
      }
    }
  }
};
fseventsHandler.exports = FsEventsHandler$1;
fseventsHandlerExports.canUse = canUse;
var { EventEmitter: EventEmitter$2 } = import_events.default;
var fs$5 = import_fs.default;
var sysPath = import_path.default;
var { promisify } = import_util.default;
var readdirp = readdirp_1;
var anymatch = anymatchExports.default;
var globParent2 = globParent$2;
var isGlob2 = isGlob$2;
var braces = braces_1;
var normalizePath2 = normalizePath$2;
var NodeFsHandler2 = nodefsHandler;
var FsEventsHandler2 = fseventsHandlerExports;
var {
  EV_ALL,
  EV_READY,
  EV_ADD,
  EV_CHANGE,
  EV_UNLINK,
  EV_ADD_DIR,
  EV_UNLINK_DIR,
  EV_RAW,
  EV_ERROR,
  STR_CLOSE,
  STR_END,
  BACK_SLASH_RE,
  DOUBLE_SLASH_RE,
  SLASH_OR_BACK_SLASH_RE,
  DOT_RE,
  REPLACER_RE,
  SLASH,
  SLASH_SLASH,
  BRACE_START,
  BANG,
  ONE_DOT,
  TWO_DOTS,
  GLOBSTAR,
  SLASH_GLOBSTAR,
  ANYMATCH_OPTS,
  STRING_TYPE,
  FUNCTION_TYPE,
  EMPTY_STR,
  EMPTY_FN,
  isWindows: isWindows$1,
  isMacos,
  isIBMi
} = constants$1;
var stat = promisify(fs$5.stat);
var readdir = promisify(fs$5.readdir);
var arrify = (value2 = []) => Array.isArray(value2) ? value2 : [value2];
var flatten = (list, result = []) => {
  list.forEach((item) => {
    if (Array.isArray(item)) {
      flatten(item, result);
    } else {
      result.push(item);
    }
  });
  return result;
};
var unifyPaths = (paths_) => {
  const paths = flatten(arrify(paths_));
  if (!paths.every((p2) => typeof p2 === STRING_TYPE)) {
    throw new TypeError(`Non-string provided as watch path: ${paths}`);
  }
  return paths.map(normalizePathToUnix);
};
var toUnix = (string3) => {
  let str2 = string3.replace(BACK_SLASH_RE, SLASH);
  let prepend = false;
  if (str2.startsWith(SLASH_SLASH)) {
    prepend = true;
  }
  while (str2.match(DOUBLE_SLASH_RE)) {
    str2 = str2.replace(DOUBLE_SLASH_RE, SLASH);
  }
  if (prepend) {
    str2 = SLASH + str2;
  }
  return str2;
};
var normalizePathToUnix = (path8) => toUnix(sysPath.normalize(toUnix(path8)));
var normalizeIgnored = (cwd = EMPTY_STR) => (path8) => {
  if (typeof path8 !== STRING_TYPE)
    return path8;
  return normalizePathToUnix(sysPath.isAbsolute(path8) ? path8 : sysPath.join(cwd, path8));
};
var getAbsolutePath = (path8, cwd) => {
  if (sysPath.isAbsolute(path8)) {
    return path8;
  }
  if (path8.startsWith(BANG)) {
    return BANG + sysPath.join(cwd, path8.slice(1));
  }
  return sysPath.join(cwd, path8);
};
var undef = (opts, key) => opts[key] === void 0;
var DirEntry = class {
  /**
   * @param {Path} dir
   * @param {Function} removeWatcher
   */
  constructor(dir, removeWatcher) {
    this.path = dir;
    this._removeWatcher = removeWatcher;
    this.items = /* @__PURE__ */ new Set();
  }
  add(item) {
    const { items } = this;
    if (!items)
      return;
    if (item !== ONE_DOT && item !== TWO_DOTS)
      items.add(item);
  }
  async remove(item) {
    const { items } = this;
    if (!items)
      return;
    items.delete(item);
    if (items.size > 0)
      return;
    const dir = this.path;
    try {
      await readdir(dir);
    } catch (err2) {
      if (this._removeWatcher) {
        this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));
      }
    }
  }
  has(item) {
    const { items } = this;
    if (!items)
      return;
    return items.has(item);
  }
  /**
   * @returns {Array<String>}
   */
  getChildren() {
    const { items } = this;
    if (!items)
      return;
    return [...items.values()];
  }
  dispose() {
    this.items.clear();
    delete this.path;
    delete this._removeWatcher;
    delete this.items;
    Object.freeze(this);
  }
};
var STAT_METHOD_F = "stat";
var STAT_METHOD_L = "lstat";
var WatchHelper = class {
  constructor(path8, watchPath, follow, fsw) {
    this.fsw = fsw;
    this.path = path8 = path8.replace(REPLACER_RE, EMPTY_STR);
    this.watchPath = watchPath;
    this.fullWatchPath = sysPath.resolve(watchPath);
    this.hasGlob = watchPath !== path8;
    if (path8 === EMPTY_STR)
      this.hasGlob = false;
    this.globSymlink = this.hasGlob && follow ? void 0 : false;
    this.globFilter = this.hasGlob ? anymatch(path8, void 0, ANYMATCH_OPTS) : false;
    this.dirParts = this.getDirParts(path8);
    this.dirParts.forEach((parts) => {
      if (parts.length > 1)
        parts.pop();
    });
    this.followSymlinks = follow;
    this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;
  }
  checkGlobSymlink(entry2) {
    if (this.globSymlink === void 0) {
      this.globSymlink = entry2.fullParentDir === this.fullWatchPath ? false : { realPath: entry2.fullParentDir, linkPath: this.fullWatchPath };
    }
    if (this.globSymlink) {
      return entry2.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);
    }
    return entry2.fullPath;
  }
  entryPath(entry2) {
    return sysPath.join(
      this.watchPath,
      sysPath.relative(this.watchPath, this.checkGlobSymlink(entry2))
    );
  }
  filterPath(entry2) {
    const { stats } = entry2;
    if (stats && stats.isSymbolicLink())
      return this.filterDir(entry2);
    const resolvedPath = this.entryPath(entry2);
    const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ? this.globFilter(resolvedPath) : true;
    return matchesGlob && this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);
  }
  getDirParts(path8) {
    if (!this.hasGlob)
      return [];
    const parts = [];
    const expandedPath = path8.includes(BRACE_START) ? braces.expand(path8) : [path8];
    expandedPath.forEach((path9) => {
      parts.push(sysPath.relative(this.watchPath, path9).split(SLASH_OR_BACK_SLASH_RE));
    });
    return parts;
  }
  filterDir(entry2) {
    if (this.hasGlob) {
      const entryParts = this.getDirParts(this.checkGlobSymlink(entry2));
      let globstar = false;
      this.unmatchedGlob = !this.dirParts.some((parts) => {
        return parts.every((part, i2) => {
          if (part === GLOBSTAR)
            globstar = true;
          return globstar || !entryParts[0][i2] || anymatch(part, entryParts[0][i2], ANYMATCH_OPTS);
        });
      });
    }
    return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry2), entry2.stats);
  }
};
var FSWatcher = class extends EventEmitter$2 {
  // Not indenting methods for history sake; for now.
  constructor(_opts) {
    super();
    const opts = {};
    if (_opts)
      Object.assign(opts, _opts);
    this._watched = /* @__PURE__ */ new Map();
    this._closers = /* @__PURE__ */ new Map();
    this._ignoredPaths = /* @__PURE__ */ new Set();
    this._throttled = /* @__PURE__ */ new Map();
    this._symlinkPaths = /* @__PURE__ */ new Map();
    this._streams = /* @__PURE__ */ new Set();
    this.closed = false;
    if (undef(opts, "persistent"))
      opts.persistent = true;
    if (undef(opts, "ignoreInitial"))
      opts.ignoreInitial = false;
    if (undef(opts, "ignorePermissionErrors"))
      opts.ignorePermissionErrors = false;
    if (undef(opts, "interval"))
      opts.interval = 100;
    if (undef(opts, "binaryInterval"))
      opts.binaryInterval = 300;
    if (undef(opts, "disableGlobbing"))
      opts.disableGlobbing = false;
    opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;
    if (undef(opts, "useFsEvents"))
      opts.useFsEvents = !opts.usePolling;
    const canUseFsEvents = FsEventsHandler2.canUse();
    if (!canUseFsEvents)
      opts.useFsEvents = false;
    if (undef(opts, "usePolling") && !opts.useFsEvents) {
      opts.usePolling = isMacos;
    }
    if (isIBMi) {
      opts.usePolling = true;
    }
    const envPoll = process.env.CHOKIDAR_USEPOLLING;
    if (envPoll !== void 0) {
      const envLower = envPoll.toLowerCase();
      if (envLower === "false" || envLower === "0") {
        opts.usePolling = false;
      } else if (envLower === "true" || envLower === "1") {
        opts.usePolling = true;
      } else {
        opts.usePolling = !!envLower;
      }
    }
    const envInterval = process.env.CHOKIDAR_INTERVAL;
    if (envInterval) {
      opts.interval = Number.parseInt(envInterval, 10);
    }
    if (undef(opts, "atomic"))
      opts.atomic = !opts.usePolling && !opts.useFsEvents;
    if (opts.atomic)
      this._pendingUnlinks = /* @__PURE__ */ new Map();
    if (undef(opts, "followSymlinks"))
      opts.followSymlinks = true;
    if (undef(opts, "awaitWriteFinish"))
      opts.awaitWriteFinish = false;
    if (opts.awaitWriteFinish === true)
      opts.awaitWriteFinish = {};
    const awf = opts.awaitWriteFinish;
    if (awf) {
      if (!awf.stabilityThreshold)
        awf.stabilityThreshold = 2e3;
      if (!awf.pollInterval)
        awf.pollInterval = 100;
      this._pendingWrites = /* @__PURE__ */ new Map();
    }
    if (opts.ignored)
      opts.ignored = arrify(opts.ignored);
    let readyCalls = 0;
    this._emitReady = () => {
      readyCalls++;
      if (readyCalls >= this._readyCount) {
        this._emitReady = EMPTY_FN;
        this._readyEmitted = true;
        process.nextTick(() => this.emit(EV_READY));
      }
    };
    this._emitRaw = (...args) => this.emit(EV_RAW, ...args);
    this._readyEmitted = false;
    this.options = opts;
    if (opts.useFsEvents) {
      this._fsEventsHandler = new FsEventsHandler2(this);
    } else {
      this._nodeFsHandler = new NodeFsHandler2(this);
    }
    Object.freeze(opts);
  }
  // Public methods
  /**
   * Adds paths to be watched on an existing FSWatcher instance
   * @param {Path|Array<Path>} paths_
   * @param {String=} _origAdd private; for handling non-existent paths to be watched
   * @param {Boolean=} _internal private; indicates a non-user add
   * @returns {FSWatcher} for chaining
   */
  add(paths_, _origAdd, _internal) {
    const { cwd, disableGlobbing } = this.options;
    this.closed = false;
    let paths = unifyPaths(paths_);
    if (cwd) {
      paths = paths.map((path8) => {
        const absPath = getAbsolutePath(path8, cwd);
        if (disableGlobbing || !isGlob2(path8)) {
          return absPath;
        }
        return normalizePath2(absPath);
      });
    }
    paths = paths.filter((path8) => {
      if (path8.startsWith(BANG)) {
        this._ignoredPaths.add(path8.slice(1));
        return false;
      }
      this._ignoredPaths.delete(path8);
      this._ignoredPaths.delete(path8 + SLASH_GLOBSTAR);
      this._userIgnored = void 0;
      return true;
    });
    if (this.options.useFsEvents && this._fsEventsHandler) {
      if (!this._readyCount)
        this._readyCount = paths.length;
      if (this.options.persistent)
        this._readyCount *= 2;
      paths.forEach((path8) => this._fsEventsHandler._addToFsEvents(path8));
    } else {
      if (!this._readyCount)
        this._readyCount = 0;
      this._readyCount += paths.length;
      Promise.all(
        paths.map(async (path8) => {
          const res = await this._nodeFsHandler._addToNodeFs(path8, !_internal, 0, 0, _origAdd);
          if (res)
            this._emitReady();
          return res;
        })
      ).then((results) => {
        if (this.closed)
          return;
        results.filter((item) => item).forEach((item) => {
          this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
        });
      });
    }
    return this;
  }
  /**
   * Close watchers or start ignoring events from specified paths.
   * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs
   * @returns {FSWatcher} for chaining
  */
  unwatch(paths_) {
    if (this.closed)
      return this;
    const paths = unifyPaths(paths_);
    const { cwd } = this.options;
    paths.forEach((path8) => {
      if (!sysPath.isAbsolute(path8) && !this._closers.has(path8)) {
        if (cwd)
          path8 = sysPath.join(cwd, path8);
        path8 = sysPath.resolve(path8);
      }
      this._closePath(path8);
      this._ignoredPaths.add(path8);
      if (this._watched.has(path8)) {
        this._ignoredPaths.add(path8 + SLASH_GLOBSTAR);
      }
      this._userIgnored = void 0;
    });
    return this;
  }
  /**
   * Close watchers and remove all listeners from watched paths.
   * @returns {Promise<void>}.
  */
  close() {
    if (this.closed)
      return this._closePromise;
    this.closed = true;
    this.removeAllListeners();
    const closers = [];
    this._closers.forEach((closerList) => closerList.forEach((closer) => {
      const promise2 = closer();
      if (promise2 instanceof Promise)
        closers.push(promise2);
    }));
    this._streams.forEach((stream4) => stream4.destroy());
    this._userIgnored = void 0;
    this._readyCount = 0;
    this._readyEmitted = false;
    this._watched.forEach((dirent) => dirent.dispose());
    ["closers", "watched", "streams", "symlinkPaths", "throttled"].forEach((key) => {
      this[`_${key}`].clear();
    });
    this._closePromise = closers.length ? Promise.all(closers).then(() => void 0) : Promise.resolve();
    return this._closePromise;
  }
  /**
   * Expose list of watched paths
   * @returns {Object} for chaining
  */
  getWatched() {
    const watchList = {};
    this._watched.forEach((entry2, dir) => {
      const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;
      watchList[key || ONE_DOT] = entry2.getChildren().sort();
    });
    return watchList;
  }
  emitWithAll(event, args) {
    this.emit(...args);
    if (event !== EV_ERROR)
      this.emit(EV_ALL, ...args);
  }
  // Common helpers
  // --------------
  /**
   * Normalize and emit events.
   * Calling _emit DOES NOT MEAN emit() would be called!
   * @param {EventName} event Type of event
   * @param {Path} path File or directory path
   * @param {*=} val1 arguments to be passed with event
   * @param {*=} val2
   * @param {*=} val3
   * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag
   */
  async _emit(event, path8, val1, val2, val3) {
    if (this.closed)
      return;
    const opts = this.options;
    if (isWindows$1)
      path8 = sysPath.normalize(path8);
    if (opts.cwd)
      path8 = sysPath.relative(opts.cwd, path8);
    const args = [event, path8];
    if (val3 !== void 0)
      args.push(val1, val2, val3);
    else if (val2 !== void 0)
      args.push(val1, val2);
    else if (val1 !== void 0)
      args.push(val1);
    const awf = opts.awaitWriteFinish;
    let pw;
    if (awf && (pw = this._pendingWrites.get(path8))) {
      pw.lastChange = new Date();
      return this;
    }
    if (opts.atomic) {
      if (event === EV_UNLINK) {
        this._pendingUnlinks.set(path8, args);
        setTimeout(() => {
          this._pendingUnlinks.forEach((entry2, path9) => {
            this.emit(...entry2);
            this.emit(EV_ALL, ...entry2);
            this._pendingUnlinks.delete(path9);
          });
        }, typeof opts.atomic === "number" ? opts.atomic : 100);
        return this;
      }
      if (event === EV_ADD && this._pendingUnlinks.has(path8)) {
        event = args[0] = EV_CHANGE;
        this._pendingUnlinks.delete(path8);
      }
    }
    if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {
      const awfEmit = (err2, stats) => {
        if (err2) {
          event = args[0] = EV_ERROR;
          args[1] = err2;
          this.emitWithAll(event, args);
        } else if (stats) {
          if (args.length > 2) {
            args[2] = stats;
          } else {
            args.push(stats);
          }
          this.emitWithAll(event, args);
        }
      };
      this._awaitWriteFinish(path8, awf.stabilityThreshold, event, awfEmit);
      return this;
    }
    if (event === EV_CHANGE) {
      const isThrottled = !this._throttle(EV_CHANGE, path8, 50);
      if (isThrottled)
        return this;
    }
    if (opts.alwaysStat && val1 === void 0 && (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)) {
      const fullPath = opts.cwd ? sysPath.join(opts.cwd, path8) : path8;
      let stats;
      try {
        stats = await stat(fullPath);
      } catch (err2) {
      }
      if (!stats || this.closed)
        return;
      args.push(stats);
    }
    this.emitWithAll(event, args);
    return this;
  }
  /**
   * Common handler for errors
   * @param {Error} error
   * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag
   */
  _handleError(error3) {
    const code = error3 && error3.code;
    if (error3 && code !== "ENOENT" && code !== "ENOTDIR" && (!this.options.ignorePermissionErrors || code !== "EPERM" && code !== "EACCES")) {
      this.emit(EV_ERROR, error3);
    }
    return error3 || this.closed;
  }
  /**
   * Helper utility for throttling
   * @param {ThrottleType} actionType type being throttled
   * @param {Path} path being acted upon
   * @param {Number} timeout duration of time to suppress duplicate actions
   * @returns {Object|false} tracking object or false if action should be suppressed
   */
  _throttle(actionType, path8, timeout2) {
    if (!this._throttled.has(actionType)) {
      this._throttled.set(actionType, /* @__PURE__ */ new Map());
    }
    const action = this._throttled.get(actionType);
    const actionPath = action.get(path8);
    if (actionPath) {
      actionPath.count++;
      return false;
    }
    let timeoutObject;
    const clear = () => {
      const item = action.get(path8);
      const count = item ? item.count : 0;
      action.delete(path8);
      clearTimeout(timeoutObject);
      if (item)
        clearTimeout(item.timeoutObject);
      return count;
    };
    timeoutObject = setTimeout(clear, timeout2);
    const thr = { timeoutObject, clear, count: 0 };
    action.set(path8, thr);
    return thr;
  }
  _incrReadyCount() {
    return this._readyCount++;
  }
  /**
   * Awaits write operation to finish.
   * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.
   * @param {Path} path being acted upon
   * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished
   * @param {EventName} event
   * @param {Function} awfEmit Callback to be called when ready for event to be emitted.
   */
  _awaitWriteFinish(path8, threshold2, event, awfEmit) {
    let timeoutHandler;
    let fullPath = path8;
    if (this.options.cwd && !sysPath.isAbsolute(path8)) {
      fullPath = sysPath.join(this.options.cwd, path8);
    }
    const now = new Date();
    const awaitWriteFinish = (prevStat) => {
      fs$5.stat(fullPath, (err2, curStat) => {
        if (err2 || !this._pendingWrites.has(path8)) {
          if (err2 && err2.code !== "ENOENT")
            awfEmit(err2);
          return;
        }
        const now2 = Number(new Date());
        if (prevStat && curStat.size !== prevStat.size) {
          this._pendingWrites.get(path8).lastChange = now2;
        }
        const pw = this._pendingWrites.get(path8);
        const df = now2 - pw.lastChange;
        if (df >= threshold2) {
          this._pendingWrites.delete(path8);
          awfEmit(void 0, curStat);
        } else {
          timeoutHandler = setTimeout(
            awaitWriteFinish,
            this.options.awaitWriteFinish.pollInterval,
            curStat
          );
        }
      });
    };
    if (!this._pendingWrites.has(path8)) {
      this._pendingWrites.set(path8, {
        lastChange: now,
        cancelWait: () => {
          this._pendingWrites.delete(path8);
          clearTimeout(timeoutHandler);
          return event;
        }
      });
      timeoutHandler = setTimeout(
        awaitWriteFinish,
        this.options.awaitWriteFinish.pollInterval
      );
    }
  }
  _getGlobIgnored() {
    return [...this._ignoredPaths.values()];
  }
  /**
   * Determines whether user has asked to ignore this path.
   * @param {Path} path filepath or dir
   * @param {fs.Stats=} stats result of fs.stat
   * @returns {Boolean}
   */
  _isIgnored(path8, stats) {
    if (this.options.atomic && DOT_RE.test(path8))
      return true;
    if (!this._userIgnored) {
      const { cwd } = this.options;
      const ign = this.options.ignored;
      const ignored = ign && ign.map(normalizeIgnored(cwd));
      const paths = arrify(ignored).filter((path9) => typeof path9 === STRING_TYPE && !isGlob2(path9)).map((path9) => path9 + SLASH_GLOBSTAR);
      const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);
      this._userIgnored = anymatch(list, void 0, ANYMATCH_OPTS);
    }
    return this._userIgnored([path8, stats]);
  }
  _isntIgnored(path8, stat2) {
    return !this._isIgnored(path8, stat2);
  }
  /**
   * Provides a set of common helpers and properties relating to symlink and glob handling.
   * @param {Path} path file, directory, or glob pattern being watched
   * @param {Number=} depth at any depth > 0, this isn't a glob
   * @returns {WatchHelper} object containing helpers for this path
   */
  _getWatchHelpers(path8, depth2) {
    const watchPath = depth2 || this.options.disableGlobbing || !isGlob2(path8) ? path8 : globParent2(path8);
    const follow = this.options.followSymlinks;
    return new WatchHelper(path8, watchPath, follow, this);
  }
  // Directory helpers
  // -----------------
  /**
   * Provides directory tracking objects
   * @param {String} directory path of the directory
   * @returns {DirEntry} the directory's tracking object
   */
  _getWatchedDir(directory) {
    if (!this._boundRemove)
      this._boundRemove = this._remove.bind(this);
    const dir = sysPath.resolve(directory);
    if (!this._watched.has(dir))
      this._watched.set(dir, new DirEntry(dir, this._boundRemove));
    return this._watched.get(dir);
  }
  // File helpers
  // ------------
  /**
   * Check for read permissions.
   * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405
   * @param {fs.Stats} stats - object, result of fs_stat
   * @returns {Boolean} indicates whether the file can be read
  */
  _hasReadPermissions(stats) {
    if (this.options.ignorePermissionErrors)
      return true;
    const md = stats && Number.parseInt(stats.mode, 10);
    const st = md & 511;
    const it = Number.parseInt(st.toString(8)[0], 10);
    return Boolean(4 & it);
  }
  /**
   * Handles emitting unlink events for
   * files and directories, and via recursion, for
   * files and directories within directories that are unlinked
   * @param {String} directory within which the following item is located
   * @param {String} item      base path of item/directory
   * @returns {void}
  */
  _remove(directory, item, isDirectory2) {
    const path8 = sysPath.join(directory, item);
    const fullPath = sysPath.resolve(path8);
    isDirectory2 = isDirectory2 != null ? isDirectory2 : this._watched.has(path8) || this._watched.has(fullPath);
    if (!this._throttle("remove", path8, 100))
      return;
    if (!isDirectory2 && !this.options.useFsEvents && this._watched.size === 1) {
      this.add(directory, item, true);
    }
    const wp = this._getWatchedDir(path8);
    const nestedDirectoryChildren = wp.getChildren();
    nestedDirectoryChildren.forEach((nested) => this._remove(path8, nested));
    const parent = this._getWatchedDir(directory);
    const wasTracked = parent.has(item);
    parent.remove(item);
    if (this._symlinkPaths.has(fullPath)) {
      this._symlinkPaths.delete(fullPath);
    }
    let relPath = path8;
    if (this.options.cwd)
      relPath = sysPath.relative(this.options.cwd, path8);
    if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {
      const event = this._pendingWrites.get(relPath).cancelWait();
      if (event === EV_ADD)
        return;
    }
    this._watched.delete(path8);
    this._watched.delete(fullPath);
    const eventName = isDirectory2 ? EV_UNLINK_DIR : EV_UNLINK;
    if (wasTracked && !this._isIgnored(path8))
      this._emit(eventName, path8);
    if (!this.options.useFsEvents) {
      this._closePath(path8);
    }
  }
  /**
   * Closes all watchers for a path
   * @param {Path} path
   */
  _closePath(path8) {
    this._closeFile(path8);
    const dir = sysPath.dirname(path8);
    this._getWatchedDir(dir).remove(sysPath.basename(path8));
  }
  /**
   * Closes only file-specific watchers
   * @param {Path} path
   */
  _closeFile(path8) {
    const closers = this._closers.get(path8);
    if (!closers)
      return;
    closers.forEach((closer) => closer());
    this._closers.delete(path8);
  }
  /**
   *
   * @param {Path} path
   * @param {Function} closer
   */
  _addPathCloser(path8, closer) {
    if (!closer)
      return;
    let list = this._closers.get(path8);
    if (!list) {
      list = [];
      this._closers.set(path8, list);
    }
    list.push(closer);
  }
  _readdirp(root, opts) {
    if (this.closed)
      return;
    const options3 = { type: EV_ALL, alwaysStat: true, lstat: true, ...opts };
    let stream4 = readdirp(root, options3);
    this._streams.add(stream4);
    stream4.once(STR_CLOSE, () => {
      stream4 = void 0;
    });
    stream4.once(STR_END, () => {
      if (stream4) {
        this._streams.delete(stream4);
        stream4 = void 0;
      }
    });
    return stream4;
  }
};
chokidar.FSWatcher = FSWatcher;
var watch = (paths, options3) => {
  const watcher = new FSWatcher(options3);
  watcher.add(paths);
  return watcher;
};
chokidar.watch = watch;
var shellQuote$1 = {};
shellQuote$1.quote = function(xs) {
  return xs.map(function(s2) {
    if (s2 && typeof s2 === "object") {
      return s2.op.replace(/(.)/g, "\\$1");
    } else if (/["\s]/.test(s2) && !/'/.test(s2)) {
      return "'" + s2.replace(/(['\\])/g, "\\$1") + "'";
    } else if (/["'\s]/.test(s2)) {
      return '"' + s2.replace(/(["\\$`!])/g, "\\$1") + '"';
    } else {
      return String(s2).replace(/([A-Za-z]:)?([#!"$&'()*,:;<=>?@\[\\\]^`{|}])/g, "$1\\$2");
    }
  }).join(" ");
};
var CONTROL = "(?:" + [
  "\\|\\|",
  "\\&\\&",
  ";;",
  "\\|\\&",
  "\\<\\(",
  ">>",
  ">\\&",
  "[&;()|<>]"
].join("|") + ")";
var META = "|&;()<> \\t";
var BAREWORD = `(\\\\['"` + META + `]|[^\\s'"` + META + "])+";
var SINGLE_QUOTE = '"((\\\\"|[^"])*?)"';
var DOUBLE_QUOTE = "'((\\\\'|[^'])*?)'";
var TOKEN = "";
for (i2 = 0; i2 < 4; i2++) {
  TOKEN += (Math.pow(16, 8) * Math.random()).toString(16);
}
var i2;
shellQuote$1.parse = function(s2, env2, opts) {
  var mapped = parse$5(s2, env2, opts);
  if (typeof env2 !== "function")
    return mapped;
  return mapped.reduce(function(acc, s3) {
    if (typeof s3 === "object")
      return acc.concat(s3);
    var xs = s3.split(RegExp("(" + TOKEN + ".*?" + TOKEN + ")", "g"));
    if (xs.length === 1)
      return acc.concat(xs[0]);
    return acc.concat(xs.filter(Boolean).map(function(x) {
      if (RegExp("^" + TOKEN).test(x)) {
        return JSON.parse(x.split(TOKEN)[1]);
      } else
        return x;
    }));
  }, []);
};
function parse$5(s2, env2, opts) {
  var chunker = new RegExp([
    "(" + CONTROL + ")",
    // control chars
    "(" + BAREWORD + "|" + SINGLE_QUOTE + "|" + DOUBLE_QUOTE + ")*"
  ].join("|"), "g");
  var match = s2.match(chunker).filter(Boolean);
  var commented = false;
  if (!match)
    return [];
  if (!env2)
    env2 = {};
  if (!opts)
    opts = {};
  return match.map(function(s3, j) {
    if (commented) {
      return;
    }
    if (RegExp("^" + CONTROL + "$").test(s3)) {
      return { op: s3 };
    }
    var SQ = "'";
    var DQ = '"';
    var DS = "$";
    var BS = opts.escape || "\\";
    var quote = false;
    var esc = false;
    var out2 = "";
    var isGlob3 = false;
    for (var i2 = 0, len = s3.length; i2 < len; i2++) {
      var c2 = s3.charAt(i2);
      isGlob3 = isGlob3 || !quote && (c2 === "*" || c2 === "?");
      if (esc) {
        out2 += c2;
        esc = false;
      } else if (quote) {
        if (c2 === quote) {
          quote = false;
        } else if (quote == SQ) {
          out2 += c2;
        } else {
          if (c2 === BS) {
            i2 += 1;
            c2 = s3.charAt(i2);
            if (c2 === DQ || c2 === BS || c2 === DS) {
              out2 += c2;
            } else {
              out2 += BS + c2;
            }
          } else if (c2 === DS) {
            out2 += parseEnvVar();
          } else {
            out2 += c2;
          }
        }
      } else if (c2 === DQ || c2 === SQ) {
        quote = c2;
      } else if (RegExp("^" + CONTROL + "$").test(c2)) {
        return { op: s3 };
      } else if (RegExp("^#$").test(c2)) {
        commented = true;
        if (out2.length) {
          return [out2, { comment: s3.slice(i2 + 1) + match.slice(j + 1).join(" ") }];
        }
        return [{ comment: s3.slice(i2 + 1) + match.slice(j + 1).join(" ") }];
      } else if (c2 === BS) {
        esc = true;
      } else if (c2 === DS) {
        out2 += parseEnvVar();
      } else
        out2 += c2;
    }
    if (isGlob3)
      return { op: "glob", pattern: out2 };
    return out2;
    function parseEnvVar() {
      i2 += 1;
      var varend, varname;
      if (s3.charAt(i2) === "{") {
        i2 += 1;
        if (s3.charAt(i2) === "}") {
          throw new Error("Bad substitution: " + s3.substr(i2 - 2, 3));
        }
        varend = s3.indexOf("}", i2);
        if (varend < 0) {
          throw new Error("Bad substitution: " + s3.substr(i2));
        }
        varname = s3.substr(i2, varend - i2);
        i2 = varend;
      } else if (/[*@#?$!_\-]/.test(s3.charAt(i2))) {
        varname = s3.charAt(i2);
        i2 += 1;
      } else {
        varend = s3.substr(i2).match(/[^\w\d_]/);
        if (!varend) {
          varname = s3.substr(i2);
          i2 = s3.length;
        } else {
          varname = s3.substr(i2, varend.index);
          i2 += varend.index - 1;
        }
      }
      return getVar(null, "", varname);
    }
  }).reduce(function(prev, arg) {
    if (arg === void 0) {
      return prev;
    }
    return prev.concat(arg);
  }, []);
  function getVar(_, pre, key) {
    var r3 = typeof env2 === "function" ? env2(key) : env2[key];
    if (r3 === void 0 && key != "")
      r3 = "";
    else if (r3 === void 0)
      r3 = "$";
    if (typeof r3 === "object") {
      return pre + TOKEN + JSON.stringify(r3) + TOKEN;
    } else
      return pre + r3;
  }
}
var osx = {
  "/Applications/Atom.app/Contents/MacOS/Atom": "atom",
  "/Applications/Atom Beta.app/Contents/MacOS/Atom Beta": "/Applications/Atom Beta.app/Contents/MacOS/Atom Beta",
  "/Applications/Brackets.app/Contents/MacOS/Brackets": "brackets",
  "/Applications/Sublime Text.app/Contents/MacOS/Sublime Text": "/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl",
  "/Applications/Sublime Text.app/Contents/MacOS/sublime_text": "/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl",
  "/Applications/Sublime Text 2.app/Contents/MacOS/Sublime Text 2": "/Applications/Sublime Text 2.app/Contents/SharedSupport/bin/subl",
  "/Applications/Sublime Text Dev.app/Contents/MacOS/Sublime Text": "/Applications/Sublime Text Dev.app/Contents/SharedSupport/bin/subl",
  "/Applications/Visual Studio Code.app/Contents/MacOS/Electron": "code",
  "/Applications/Visual Studio Code - Insiders.app/Contents/MacOS/Electron": "code-insiders",
  "/Applications/VSCodium.app/Contents/MacOS/Electron": "codium",
  "/Applications/AppCode.app/Contents/MacOS/appcode": "/Applications/AppCode.app/Contents/MacOS/appcode",
  "/Applications/CLion.app/Contents/MacOS/clion": "/Applications/CLion.app/Contents/MacOS/clion",
  "/Applications/IntelliJ IDEA.app/Contents/MacOS/idea": "/Applications/IntelliJ IDEA.app/Contents/MacOS/idea",
  "/Applications/PhpStorm.app/Contents/MacOS/phpstorm": "/Applications/PhpStorm.app/Contents/MacOS/phpstorm",
  "/Applications/PyCharm.app/Contents/MacOS/pycharm": "/Applications/PyCharm.app/Contents/MacOS/pycharm",
  "/Applications/PyCharm CE.app/Contents/MacOS/pycharm": "/Applications/PyCharm CE.app/Contents/MacOS/pycharm",
  "/Applications/RubyMine.app/Contents/MacOS/rubymine": "/Applications/RubyMine.app/Contents/MacOS/rubymine",
  "/Applications/WebStorm.app/Contents/MacOS/webstorm": "/Applications/WebStorm.app/Contents/MacOS/webstorm",
  "/Applications/MacVim.app/Contents/MacOS/MacVim": "mvim",
  "/Applications/GoLand.app/Contents/MacOS/goland": "/Applications/GoLand.app/Contents/MacOS/goland",
  "/Applications/Rider.app/Contents/MacOS/rider": "/Applications/Rider.app/Contents/MacOS/rider"
};
var linux = {
  atom: "atom",
  Brackets: "brackets",
  code: "code",
  "code-insiders": "code-insiders",
  codium: "codium",
  vscodium: "vscodium",
  emacs: "emacs",
  gvim: "gvim",
  "idea.sh": "idea",
  "phpstorm.sh": "phpstorm",
  "pycharm.sh": "pycharm",
  "rubymine.sh": "rubymine",
  sublime_text: "subl",
  vim: "vim",
  "webstorm.sh": "webstorm",
  "goland.sh": "goland",
  "rider.sh": "rider"
};
var windows$1 = [
  "Brackets.exe",
  "Code.exe",
  "Code - Insiders.exe",
  "VSCodium.exe",
  "atom.exe",
  "sublime_text.exe",
  "notepad++.exe",
  "clion.exe",
  "clion64.exe",
  "idea.exe",
  "idea64.exe",
  "phpstorm.exe",
  "phpstorm64.exe",
  "pycharm.exe",
  "pycharm64.exe",
  "rubymine.exe",
  "rubymine64.exe",
  "webstorm.exe",
  "webstorm64.exe",
  "goland.exe",
  "goland64.exe",
  "rider.exe",
  "rider64.exe"
];
var path$7 = import_path.default;
var shellQuote = shellQuote$1;
var childProcess$2 = import_child_process.default;
var COMMON_EDITORS_OSX = osx;
var COMMON_EDITORS_LINUX = linux;
var COMMON_EDITORS_WIN = windows$1;
var guess = function guessEditor(specifiedEditor) {
  if (specifiedEditor) {
    return shellQuote.parse(specifiedEditor);
  }
  if (process.env.LAUNCH_EDITOR) {
    return [process.env.LAUNCH_EDITOR];
  }
  if (process.versions.webcontainer) {
    return [process.env.EDITOR || "code"];
  }
  try {
    if (process.platform === "darwin") {
      const output = childProcess$2.execSync("ps x -o comm=", {
        stdio: ["pipe", "pipe", "ignore"]
      }).toString();
      const processNames = Object.keys(COMMON_EDITORS_OSX);
      const processList = output.split("\n");
      for (let i2 = 0; i2 < processNames.length; i2++) {
        const processName = processNames[i2];
        if (output.indexOf(processName) !== -1) {
          return [COMMON_EDITORS_OSX[processName]];
        }
        const processNameWithoutApplications = processName.replace("/Applications", "");
        if (output.indexOf(processNameWithoutApplications) !== -1) {
          if (processName !== COMMON_EDITORS_OSX[processName]) {
            return [COMMON_EDITORS_OSX[processName]];
          }
          const runningProcess = processList.find((procName) => procName.endsWith(processNameWithoutApplications));
          if (runningProcess !== void 0) {
            return [runningProcess];
          }
        }
      }
    } else if (process.platform === "win32") {
      const output = childProcess$2.execSync(
        'powershell -NoProfile -Command "Get-CimInstance -Query \\"select executablepath from win32_process where executablepath is not null\\" | % { $_.ExecutablePath }"',
        {
          stdio: ["pipe", "pipe", "ignore"]
        }
      ).toString();
      const runningProcesses = output.split("\r\n");
      for (let i2 = 0; i2 < runningProcesses.length; i2++) {
        const fullProcessPath = runningProcesses[i2].trim();
        const shortProcessName = path$7.basename(fullProcessPath);
        if (COMMON_EDITORS_WIN.indexOf(shortProcessName) !== -1) {
          return [fullProcessPath];
        }
      }
    } else if (process.platform === "linux") {
      const output = childProcess$2.execSync("ps x --no-heading -o comm --sort=comm", {
        stdio: ["pipe", "pipe", "ignore"]
      }).toString();
      const processNames = Object.keys(COMMON_EDITORS_LINUX);
      for (let i2 = 0; i2 < processNames.length; i2++) {
        const processName = processNames[i2];
        if (output.indexOf(processName) !== -1) {
          return [COMMON_EDITORS_LINUX[processName]];
        }
      }
    }
  } catch (error3) {
  }
  if (process.env.VISUAL) {
    return [process.env.VISUAL];
  } else if (process.env.EDITOR) {
    return [process.env.EDITOR];
  }
  return [null];
};
var path$6 = import_path.default;
var getArgs = function getArgumentsForPosition(editor, fileName, lineNumber, columnNumber = 1) {
  const editorBasename = path$6.basename(editor).replace(/\.(exe|cmd|bat)$/i, "");
  switch (editorBasename) {
    case "atom":
    case "Atom":
    case "Atom Beta":
    case "subl":
    case "sublime":
    case "sublime_text":
    case "wstorm":
    case "charm":
      return [`${fileName}:${lineNumber}:${columnNumber}`];
    case "notepad++":
      return ["-n" + lineNumber, "-c" + columnNumber, fileName];
    case "vim":
    case "mvim":
      return [`+call cursor(${lineNumber}, ${columnNumber})`, fileName];
    case "joe":
    case "gvim":
      return [`+${lineNumber}`, fileName];
    case "emacs":
    case "emacsclient":
      return [`+${lineNumber}:${columnNumber}`, fileName];
    case "rmate":
    case "mate":
    case "mine":
      return ["--line", lineNumber, fileName];
    case "code":
    case "Code":
    case "code-insiders":
    case "Code - Insiders":
    case "codium":
    case "vscodium":
    case "VSCodium":
      return ["-r", "-g", `${fileName}:${lineNumber}:${columnNumber}`];
    case "appcode":
    case "clion":
    case "clion64":
    case "idea":
    case "idea64":
    case "phpstorm":
    case "phpstorm64":
    case "pycharm":
    case "pycharm64":
    case "rubymine":
    case "rubymine64":
    case "webstorm":
    case "webstorm64":
    case "goland":
    case "goland64":
    case "rider":
    case "rider64":
      return ["--line", lineNumber, "--column", columnNumber, fileName];
  }
  if (process.env.LAUNCH_EDITOR) {
    return [fileName, lineNumber, columnNumber];
  }
  return [fileName];
};
var fs$4 = import_fs.default;
var os$1 = import_os.default;
var path$5 = import_path.default;
var colors3 = picocolorsExports;
var childProcess$1 = import_child_process.default;
var guessEditor2 = guess;
var getArgumentsForPosition2 = getArgs;
function wrapErrorCallback(cb) {
  return (fileName, errorMessage) => {
    console.log();
    console.log(
      colors3.red("Could not open " + path$5.basename(fileName) + " in the editor.")
    );
    if (errorMessage) {
      if (errorMessage[errorMessage.length - 1] !== ".") {
        errorMessage += ".";
      }
      console.log(
        colors3.red("The editor process exited with an error: " + errorMessage)
      );
    }
    console.log();
    if (cb)
      cb(fileName, errorMessage);
  };
}
function isTerminalEditor(editor) {
  switch (editor) {
    case "vim":
    case "emacs":
    case "nano":
      return true;
  }
  return false;
}
var positionRE = /:(\d+)(:(\d+))?$/;
function parseFile(file) {
  const fileName = file.replace(positionRE, "");
  const match = file.match(positionRE);
  const lineNumber = match && match[1];
  const columnNumber = match && match[3];
  return {
    fileName,
    lineNumber,
    columnNumber
  };
}
var _childProcess = null;
function launchEditor(file, specifiedEditor, onErrorCallback) {
  const parsed = parseFile(file);
  let { fileName } = parsed;
  const { lineNumber, columnNumber } = parsed;
  if (!fs$4.existsSync(fileName)) {
    return;
  }
  if (typeof specifiedEditor === "function") {
    onErrorCallback = specifiedEditor;
    specifiedEditor = void 0;
  }
  onErrorCallback = wrapErrorCallback(onErrorCallback);
  const [editor, ...args] = guessEditor2(specifiedEditor);
  if (!editor) {
    onErrorCallback(fileName, null);
    return;
  }
  if (process.platform === "linux" && fileName.startsWith("/mnt/") && /Microsoft/i.test(os$1.release())) {
    fileName = path$5.relative("", fileName);
  }
  if (lineNumber) {
    const extraArgs = getArgumentsForPosition2(editor, fileName, lineNumber, columnNumber);
    args.push.apply(args, extraArgs);
  } else {
    args.push(fileName);
  }
  if (_childProcess && isTerminalEditor(editor)) {
    _childProcess.kill("SIGKILL");
  }
  if (process.platform === "win32") {
    _childProcess = childProcess$1.spawn(
      "cmd.exe",
      ["/C", editor].concat(args),
      { stdio: "inherit" }
    );
  } else {
    _childProcess = childProcess$1.spawn(editor, args, { stdio: "inherit" });
  }
  _childProcess.on("exit", function(errorCode) {
    _childProcess = null;
    if (errorCode) {
      onErrorCallback(fileName, "(code " + errorCode + ")");
    }
  });
  _childProcess.on("error", function(error3) {
    onErrorCallback(fileName, error3.message);
  });
}
var launchEditor_1 = launchEditor;
var url$2 = import_url3.default;
var path$4 = import_path.default;
var launch = launchEditor_1;
var launchEditorMiddleware = (specifiedEditor, srcRoot, onErrorCallback) => {
  if (typeof specifiedEditor === "function") {
    onErrorCallback = specifiedEditor;
    specifiedEditor = void 0;
  }
  if (typeof srcRoot === "function") {
    onErrorCallback = srcRoot;
    srcRoot = void 0;
  }
  srcRoot = srcRoot || process.cwd();
  return function launchEditorMiddleware2(req2, res, next) {
    const { file } = url$2.parse(req2.url, true).query || {};
    if (!file) {
      res.statusCode = 500;
      res.end(`launch-editor-middleware: required query param "file" is missing.`);
    } else {
      launch(path$4.resolve(srcRoot, file), specifiedEditor, onErrorCallback);
      res.end();
    }
  };
};
async function resolveHttpServer({ proxy }, app, httpsOptions) {
  if (!httpsOptions) {
    const { createServer: createServer2 } = await import("./node_http-VWSF6PJX.js");
    return createServer2(app);
  }
  if (proxy) {
    const { createServer: createServer2 } = await import("./node_https-NC5QVUSD.js");
    return createServer2(httpsOptions, app);
  } else {
    const { createSecureServer } = await import("./node_http2-ETIB6T6X.js");
    return createSecureServer(
      {
        // Manually increase the session memory to prevent 502 ENHANCE_YOUR_CALM
        // errors on large numbers of requests
        maxSessionMemory: 1e3,
        ...httpsOptions,
        allowHTTP1: true
      },
      // @ts-expect-error TODO: is this correct?
      app
    );
  }
}
async function resolveHttpsConfig(https2) {
  if (!https2)
    return void 0;
  const httpsOption = isObject$1(https2) ? { ...https2 } : {};
  const { ca, cert, key, pfx } = httpsOption;
  Object.assign(httpsOption, {
    ca: readFileIfExists(ca),
    cert: readFileIfExists(cert),
    key: readFileIfExists(key),
    pfx: readFileIfExists(pfx)
  });
  return httpsOption;
}
function readFileIfExists(value2) {
  if (typeof value2 === "string") {
    try {
      return import_node_fs4.default.readFileSync(import_node_path4.default.resolve(value2));
    } catch (e3) {
      return value2;
    }
  }
  return value2;
}
async function httpServerStart(httpServer, serverOptions) {
  let { port, strictPort, host, logger: logger2 } = serverOptions;
  return new Promise((resolve4, reject) => {
    const onError = (e3) => {
      if (e3.code === "EADDRINUSE") {
        if (strictPort) {
          httpServer.removeListener("error", onError);
          reject(new Error(`Port ${port} is already in use`));
        } else {
          logger2.info(`Port ${port} is in use, trying another one...`);
          httpServer.listen(++port, host);
        }
      } else {
        httpServer.removeListener("error", onError);
        reject(e3);
      }
    };
    httpServer.on("error", onError);
    httpServer.listen(port, host, () => {
      httpServer.removeListener("error", onError);
      resolve4(port);
    });
  });
}
function setClientErrorHandler(server2, logger2) {
  server2.on("clientError", (err2, socket) => {
    let msg = "400 Bad Request";
    if (err2.code === "HPE_HEADER_OVERFLOW") {
      msg = "431 Request Header Fields Too Large";
      logger2.warn(picocolorsExports.yellow("Server responded with status code 431. See https://vitejs.dev/guide/troubleshooting.html#_431-request-header-fields-too-large."));
    }
    if (err2.code === "ECONNRESET" || !socket.writable) {
      return;
    }
    socket.end(`HTTP/1.1 ${msg}\r
\r
`);
  });
}
var WalkerBase2 = class {
  constructor() {
    this.should_skip = false;
    this.should_remove = false;
    this.replacement = null;
    this.context = {
      skip: () => this.should_skip = true,
      remove: () => this.should_remove = true,
      replace: (node3) => this.replacement = node3
    };
  }
  /**
   * @template {Node} Parent
   * @param {Parent | null | undefined} parent
   * @param {keyof Parent | null | undefined} prop
   * @param {number | null | undefined} index
   * @param {Node} node
   */
  replace(parent, prop, index2, node3) {
    if (parent && prop) {
      if (index2 != null) {
        parent[prop][index2] = node3;
      } else {
        parent[prop] = node3;
      }
    }
  }
  /**
   * @template {Node} Parent
   * @param {Parent | null | undefined} parent
   * @param {keyof Parent | null | undefined} prop
   * @param {number | null | undefined} index
   */
  remove(parent, prop, index2) {
    if (parent && prop) {
      if (index2 !== null && index2 !== void 0) {
        parent[prop].splice(index2, 1);
      } else {
        delete parent[prop];
      }
    }
  }
};
var SyncWalker2 = class extends WalkerBase2 {
  /**
   *
   * @param {SyncHandler} [enter]
   * @param {SyncHandler} [leave]
   */
  constructor(enter, leave) {
    super();
    this.should_skip = false;
    this.should_remove = false;
    this.replacement = null;
    this.context = {
      skip: () => this.should_skip = true,
      remove: () => this.should_remove = true,
      replace: (node3) => this.replacement = node3
    };
    this.enter = enter;
    this.leave = leave;
  }
  /**
   * @template {Node} Parent
   * @param {Node} node
   * @param {Parent | null} parent
   * @param {keyof Parent} [prop]
   * @param {number | null} [index]
   * @returns {Node | null}
   */
  visit(node3, parent, prop, index2) {
    if (node3) {
      if (this.enter) {
        const _should_skip = this.should_skip;
        const _should_remove = this.should_remove;
        const _replacement = this.replacement;
        this.should_skip = false;
        this.should_remove = false;
        this.replacement = null;
        this.enter.call(this.context, node3, parent, prop, index2);
        if (this.replacement) {
          node3 = this.replacement;
          this.replace(parent, prop, index2, node3);
        }
        if (this.should_remove) {
          this.remove(parent, prop, index2);
        }
        const skipped = this.should_skip;
        const removed = this.should_remove;
        this.should_skip = _should_skip;
        this.should_remove = _should_remove;
        this.replacement = _replacement;
        if (skipped)
          return node3;
        if (removed)
          return null;
      }
      let key;
      for (key in node3) {
        const value2 = node3[key];
        if (value2 && typeof value2 === "object") {
          if (Array.isArray(value2)) {
            const nodes = (
              /** @type {Array<unknown>} */
              value2
            );
            for (let i2 = 0; i2 < nodes.length; i2 += 1) {
              const item = nodes[i2];
              if (isNode(item)) {
                if (!this.visit(item, node3, key, i2)) {
                  i2--;
                }
              }
            }
          } else if (isNode(value2)) {
            this.visit(value2, node3, key, null);
          }
        }
      }
      if (this.leave) {
        const _replacement = this.replacement;
        const _should_remove = this.should_remove;
        this.replacement = null;
        this.should_remove = false;
        this.leave.call(this.context, node3, parent, prop, index2);
        if (this.replacement) {
          node3 = this.replacement;
          this.replace(parent, prop, index2, node3);
        }
        if (this.should_remove) {
          this.remove(parent, prop, index2);
        }
        const removed = this.should_remove;
        this.replacement = _replacement;
        this.should_remove = _should_remove;
        if (removed)
          return null;
      }
    }
    return node3;
  }
};
function isNode(value2) {
  return value2 !== null && typeof value2 === "object" && "type" in value2 && typeof value2.type === "string";
}
function walk$1(ast, { enter, leave }) {
  const instance = new SyncWalker2(enter, leave);
  return instance.visit(ast, null);
}
function extract_names(param) {
  return extract_identifiers(param).map((node3) => node3.name);
}
function extract_identifiers(param, nodes = []) {
  switch (param.type) {
    case "Identifier":
      nodes.push(param);
      break;
    case "MemberExpression":
      let object = param;
      while (object.type === "MemberExpression") {
        object = /** @type {any} */
        object.object;
      }
      nodes.push(
        /** @type {any} */
        object
      );
      break;
    case "ObjectPattern":
      const handle_prop = (prop) => {
        if (prop.type === "RestElement") {
          extract_identifiers(prop.argument, nodes);
        } else {
          extract_identifiers(prop.value, nodes);
        }
      };
      param.properties.forEach(handle_prop);
      break;
    case "ArrayPattern":
      const handle_element = (element) => {
        if (element)
          extract_identifiers(element, nodes);
      };
      param.elements.forEach((element) => {
        if (element) {
          handle_element(element);
        }
      });
      break;
    case "RestElement":
      extract_identifiers(param.argument, nodes);
      break;
    case "AssignmentPattern":
      extract_identifiers(param.left, nodes);
      break;
  }
  return nodes;
}
var ssrModuleExportsKey = `__vite_ssr_exports__`;
var ssrImportKey = `__vite_ssr_import__`;
var ssrDynamicImportKey = `__vite_ssr_dynamic_import__`;
var ssrExportAllKey = `__vite_ssr_exportAll__`;
var ssrImportMetaKey = `__vite_ssr_import_meta__`;
async function ssrTransform(code, inMap, url2, originalCode, options3) {
  var _a;
  if (((_a = options3 == null ? void 0 : options3.json) == null ? void 0 : _a.stringify) && isJSONRequest(url2)) {
    return ssrTransformJSON(code, inMap);
  }
  return ssrTransformScript(code, inMap, url2, originalCode);
}
async function ssrTransformJSON(code, inMap) {
  return {
    code: code.replace("export default", `${ssrModuleExportsKey}.default =`),
    map: inMap,
    deps: [],
    dynamicDeps: []
  };
}
async function ssrTransformScript(code, inMap, url2, originalCode) {
  const s2 = new MagicString(code);
  let ast;
  try {
    ast = parser.parse(code, {
      sourceType: "module",
      ecmaVersion: "latest",
      locations: true,
      allowHashBang: true
    });
  } catch (err2) {
    if (!err2.loc || !err2.loc.line)
      throw err2;
    const line = err2.loc.line;
    throw new Error(`Parse failure: ${err2.message}
At file: ${url2}
Contents of line ${line}: ${code.split("\n")[line - 1]}`);
  }
  let uid = 0;
  const deps = /* @__PURE__ */ new Set();
  const dynamicDeps = /* @__PURE__ */ new Set();
  const idToImportMap = /* @__PURE__ */ new Map();
  const declaredConst = /* @__PURE__ */ new Set();
  function defineImport(node3, source) {
    deps.add(source);
    const importId = `__vite_ssr_import_${uid++}__`;
    s2.appendRight(node3.start, `const ${importId} = await ${ssrImportKey}(${JSON.stringify(source)});
`);
    return importId;
  }
  function defineExport(position, name2, local = name2) {
    s2.appendLeft(position, `
Object.defineProperty(${ssrModuleExportsKey}, "${name2}", { enumerable: true, configurable: true, get(){ return ${local} }});`);
  }
  for (const node3 of ast.body) {
    if (node3.type === "ImportDeclaration") {
      s2.remove(node3.start, node3.end);
      const importId = defineImport(node3, node3.source.value);
      for (const spec of node3.specifiers) {
        if (spec.type === "ImportSpecifier") {
          idToImportMap.set(spec.local.name, `${importId}.${spec.imported.name}`);
        } else if (spec.type === "ImportDefaultSpecifier") {
          idToImportMap.set(spec.local.name, `${importId}.default`);
        } else {
          idToImportMap.set(spec.local.name, importId);
        }
      }
    }
  }
  for (const node3 of ast.body) {
    if (node3.type === "ExportNamedDeclaration") {
      if (node3.declaration) {
        if (node3.declaration.type === "FunctionDeclaration" || node3.declaration.type === "ClassDeclaration") {
          defineExport(node3.end, node3.declaration.id.name);
        } else {
          for (const declaration2 of node3.declaration.declarations) {
            const names = extract_names(declaration2.id);
            for (const name2 of names) {
              defineExport(node3.end, name2);
            }
          }
        }
        s2.remove(node3.start, node3.declaration.start);
      } else {
        s2.remove(node3.start, node3.end);
        if (node3.source) {
          const importId = defineImport(node3, node3.source.value);
          for (const spec of node3.specifiers) {
            defineExport(node3.end, spec.exported.name, `${importId}.${spec.local.name}`);
          }
        } else {
          for (const spec of node3.specifiers) {
            const local = spec.local.name;
            const binding = idToImportMap.get(local);
            defineExport(node3.end, spec.exported.name, binding || local);
          }
        }
      }
    }
    if (node3.type === "ExportDefaultDeclaration") {
      const expressionTypes = ["FunctionExpression", "ClassExpression"];
      if ("id" in node3.declaration && node3.declaration.id && !expressionTypes.includes(node3.declaration.type)) {
        const { name: name2 } = node3.declaration.id;
        s2.remove(
          node3.start,
          node3.start + 15
          /* 'export default '.length */
        );
        s2.append(`
Object.defineProperty(${ssrModuleExportsKey}, "default", { enumerable: true, configurable: true, value: ${name2} });`);
      } else {
        s2.update(node3.start, node3.start + 14, `${ssrModuleExportsKey}.default =`);
      }
    }
    if (node3.type === "ExportAllDeclaration") {
      s2.remove(node3.start, node3.end);
      const importId = defineImport(node3, node3.source.value);
      if (node3.exported) {
        defineExport(node3.end, node3.exported.name, `${importId}`);
      } else {
        s2.appendLeft(node3.end, `${ssrExportAllKey}(${importId});`);
      }
    }
  }
  walk(ast, {
    onIdentifier(id, parent, parentStack) {
      const grandparent = parentStack[1];
      const binding = idToImportMap.get(id.name);
      if (!binding) {
        return;
      }
      if (isStaticProperty(parent) && parent.shorthand) {
        if (!isNodeInPattern(parent) || isInDestructuringAssignment(parent, parentStack)) {
          s2.appendLeft(id.end, `: ${binding}`);
        }
      } else if (parent.type === "PropertyDefinition" && (grandparent == null ? void 0 : grandparent.type) === "ClassBody" || parent.type === "ClassDeclaration" && id === parent.superClass) {
        if (!declaredConst.has(id.name)) {
          declaredConst.add(id.name);
          const topNode = parentStack[parentStack.length - 2];
          s2.prependRight(topNode.start, `const ${id.name} = ${binding};
`);
        }
      } else {
        s2.update(id.start, id.end, binding);
      }
    },
    onImportMeta(node3) {
      s2.update(node3.start, node3.end, ssrImportMetaKey);
    },
    onDynamicImport(node3) {
      s2.update(node3.start, node3.start + 6, ssrDynamicImportKey);
      if (node3.type === "ImportExpression" && node3.source.type === "Literal") {
        dynamicDeps.add(node3.source.value);
      }
    }
  });
  let map3 = s2.generateMap({ hires: true });
  if (inMap && inMap.mappings && inMap.sources.length > 0) {
    map3 = combineSourcemaps(url2, [
      {
        ...map3,
        sources: inMap.sources,
        sourcesContent: inMap.sourcesContent
      },
      inMap
    ], false);
  } else {
    map3.sources = [url2];
    map3.sourcesContent = [originalCode];
  }
  return {
    code: s2.toString(),
    map: map3,
    deps: [...deps],
    dynamicDeps: [...dynamicDeps]
  };
}
var isNodeInPatternWeakSet = /* @__PURE__ */ new WeakSet();
var setIsNodeInPattern = (node3) => isNodeInPatternWeakSet.add(node3);
var isNodeInPattern = (node3) => isNodeInPatternWeakSet.has(node3);
function walk(root, { onIdentifier, onImportMeta, onDynamicImport }) {
  const parentStack = [];
  const varKindStack = [];
  const scopeMap = /* @__PURE__ */ new WeakMap();
  const identifiers = [];
  const setScope = (node3, name2) => {
    let scopeIds = scopeMap.get(node3);
    if (scopeIds && scopeIds.has(name2)) {
      return;
    }
    if (!scopeIds) {
      scopeIds = /* @__PURE__ */ new Set();
      scopeMap.set(node3, scopeIds);
    }
    scopeIds.add(name2);
  };
  function isInScope(name2, parents) {
    return parents.some((node3) => {
      var _a;
      return node3 && ((_a = scopeMap.get(node3)) == null ? void 0 : _a.has(name2));
    });
  }
  function handlePattern(p2, parentScope) {
    if (p2.type === "Identifier") {
      setScope(parentScope, p2.name);
    } else if (p2.type === "RestElement") {
      handlePattern(p2.argument, parentScope);
    } else if (p2.type === "ObjectPattern") {
      p2.properties.forEach((property) => {
        if (property.type === "RestElement") {
          setScope(parentScope, property.argument.name);
        } else {
          handlePattern(property.value, parentScope);
        }
      });
    } else if (p2.type === "ArrayPattern") {
      p2.elements.forEach((element) => {
        if (element) {
          handlePattern(element, parentScope);
        }
      });
    } else if (p2.type === "AssignmentPattern") {
      handlePattern(p2.left, parentScope);
    } else {
      setScope(parentScope, p2.name);
    }
  }
  walk$1(root, {
    enter(node3, parent) {
      if (node3.type === "ImportDeclaration") {
        return this.skip();
      }
      if (parent && !(parent.type === "IfStatement" && node3 === parent.alternate)) {
        parentStack.unshift(parent);
      }
      if (node3.type === "VariableDeclaration") {
        varKindStack.unshift(node3.kind);
      }
      if (node3.type === "MetaProperty" && node3.meta.name === "import") {
        onImportMeta(node3);
      } else if (node3.type === "ImportExpression") {
        onDynamicImport(node3);
      }
      if (node3.type === "Identifier") {
        if (!isInScope(node3.name, parentStack) && isRefIdentifier(node3, parent, parentStack)) {
          identifiers.push([node3, parentStack.slice(0)]);
        }
      } else if (isFunction2(node3)) {
        if (node3.type === "FunctionDeclaration") {
          const parentScope = findParentScope(parentStack);
          if (parentScope) {
            setScope(parentScope, node3.id.name);
          }
        }
        node3.params.forEach((p2) => {
          if (p2.type === "ObjectPattern" || p2.type === "ArrayPattern") {
            handlePattern(p2, node3);
            return;
          }
          walk$1(p2.type === "AssignmentPattern" ? p2.left : p2, {
            enter(child, parent2) {
              if ((parent2 == null ? void 0 : parent2.type) === "AssignmentPattern" && (parent2 == null ? void 0 : parent2.right) === child) {
                return this.skip();
              }
              if (child.type !== "Identifier")
                return;
              if (isStaticPropertyKey(child, parent2))
                return;
              if ((parent2 == null ? void 0 : parent2.type) === "TemplateLiteral" && (parent2 == null ? void 0 : parent2.expressions.includes(child)) || (parent2 == null ? void 0 : parent2.type) === "CallExpression" && (parent2 == null ? void 0 : parent2.callee) === child) {
                return;
              }
              setScope(node3, child.name);
            }
          });
        });
      } else if (node3.type === "Property" && parent.type === "ObjectPattern") {
        setIsNodeInPattern(node3);
      } else if (node3.type === "VariableDeclarator") {
        const parentFunction = findParentScope(parentStack, varKindStack[0] === "var");
        if (parentFunction) {
          handlePattern(node3.id, parentFunction);
        }
      } else if (node3.type === "CatchClause" && node3.param) {
        handlePattern(node3.param, node3);
      }
    },
    leave(node3, parent) {
      if (parent && !(parent.type === "IfStatement" && node3 === parent.alternate)) {
        parentStack.shift();
      }
      if (node3.type === "VariableDeclaration") {
        varKindStack.shift();
      }
    }
  });
  identifiers.forEach(([node3, stack]) => {
    if (!isInScope(node3.name, stack))
      onIdentifier(node3, stack[0], stack);
  });
}
function isRefIdentifier(id, parent, parentStack) {
  if (parent.type === "CatchClause" || (parent.type === "VariableDeclarator" || parent.type === "ClassDeclaration") && parent.id === id) {
    return false;
  }
  if (isFunction2(parent)) {
    if (parent.id === id) {
      return false;
    }
    if (parent.params.includes(id)) {
      return false;
    }
  }
  if (parent.type === "MethodDefinition" && !parent.computed) {
    return false;
  }
  if (isStaticPropertyKey(id, parent)) {
    return false;
  }
  if (isNodeInPattern(parent) && parent.value === id) {
    return false;
  }
  if (parent.type === "ArrayPattern" && !isInDestructuringAssignment(parent, parentStack)) {
    return false;
  }
  if (parent.type === "MemberExpression" && parent.property === id && !parent.computed) {
    return false;
  }
  if (parent.type === "ExportSpecifier") {
    return false;
  }
  if (id.name === "arguments") {
    return false;
  }
  return true;
}
var isStaticProperty = (node3) => node3 && node3.type === "Property" && !node3.computed;
var isStaticPropertyKey = (node3, parent) => isStaticProperty(parent) && parent.key === node3;
var functionNodeTypeRE = /Function(?:Expression|Declaration)$|Method$/;
function isFunction2(node3) {
  return functionNodeTypeRE.test(node3.type);
}
function findParentScope(parentStack, isVar = false) {
  const predicate = isVar ? isFunction2 : (node3) => node3.type === "BlockStatement";
  return parentStack.find(predicate);
}
function isInDestructuringAssignment(parent, parentStack) {
  if (parent && (parent.type === "Property" || parent.type === "ArrayPattern")) {
    return parentStack.some((i2) => i2.type === "AssignmentExpression");
  }
  return false;
}
var offset2;
try {
  new Function("throw new Error(1)")();
} catch (e3) {
  const match = /:(\d+):\d+\)$/.exec(e3.stack.split("\n")[1]);
  offset2 = match ? +match[1] - 1 : 0;
}
function ssrRewriteStacktrace(stack, moduleGraph) {
  return stack.split("\n").map((line) => {
    return line.replace(/^ {4}at (?:(\S.*?)\s\()?(.+?):(\d+)(?::(\d+))?\)?/, (input, varName, url2, line2, column) => {
      var _a;
      if (!url2)
        return input;
      const mod = moduleGraph.urlToModuleMap.get(url2);
      const rawSourceMap = (_a = mod == null ? void 0 : mod.ssrTransformResult) == null ? void 0 : _a.map;
      if (!rawSourceMap) {
        return input;
      }
      const traced = new TraceMap(rawSourceMap);
      const pos = originalPositionFor$1(traced, {
        line: Number(line2) - offset2,
        column: Number(column)
      });
      if (!pos.source || pos.line == null || pos.column == null) {
        return input;
      }
      const trimmedVarName = varName.trim();
      const source = `${pos.source}:${pos.line}:${pos.column}`;
      if (!trimmedVarName || trimmedVarName === "eval") {
        return `    at ${source}`;
      } else {
        return `    at ${trimmedVarName} (${source})`;
      }
    });
  }).join("\n");
}
function rebindErrorStacktrace(e3, stacktrace) {
  const { configurable, writable } = Object.getOwnPropertyDescriptor(e3, "stack");
  if (configurable) {
    Object.defineProperty(e3, "stack", {
      value: stacktrace,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else if (writable) {
    e3.stack = stacktrace;
  }
}
var rewroteStacktraces = /* @__PURE__ */ new WeakSet();
function ssrFixStacktrace(e3, moduleGraph) {
  if (!e3.stack)
    return;
  if (rewroteStacktraces.has(e3))
    return;
  const stacktrace = ssrRewriteStacktrace(e3.stack, moduleGraph);
  rebindErrorStacktrace(e3, stacktrace);
  rewroteStacktraces.add(e3);
}
var pendingModules = /* @__PURE__ */ new Map();
var pendingImports = /* @__PURE__ */ new Map();
async function ssrLoadModule(url2, server2, context = { global }, urlStack = [], fixStacktrace) {
  url2 = unwrapId(url2);
  const pending = pendingModules.get(url2);
  if (pending) {
    return pending;
  }
  const modulePromise = instantiateModule(url2, server2, context, urlStack, fixStacktrace);
  pendingModules.set(url2, modulePromise);
  modulePromise.catch(() => {
    pendingImports.delete(url2);
  }).finally(() => {
    pendingModules.delete(url2);
  });
  return modulePromise;
}
async function instantiateModule(url2, server2, context = { global }, urlStack = [], fixStacktrace) {
  const { moduleGraph } = server2;
  const mod = await moduleGraph.ensureEntryFromUrl(url2, true);
  if (mod.ssrError) {
    throw mod.ssrError;
  }
  if (mod.ssrModule) {
    return mod.ssrModule;
  }
  const result = mod.ssrTransformResult || await transformRequest(url2, server2, { ssr: true });
  if (!result) {
    throw new Error(`failed to load module for ssr: ${url2}`);
  }
  const ssrModule = {
    [Symbol.toStringTag]: "Module"
  };
  Object.defineProperty(ssrModule, "__esModule", { value: true });
  mod.ssrModule = ssrModule;
  const ssrImportMeta = {
    // The filesystem URL, matching native Node.js modules
    url: (0, import_node_url3.pathToFileURL)(mod.file).toString()
  };
  urlStack = urlStack.concat(url2);
  const isCircular = (url3) => urlStack.includes(url3);
  const { isProduction, resolve: { dedupe, preserveSymlinks }, root } = server2.config;
  const resolveOptions = {
    mainFields: ["main"],
    browserField: true,
    conditions: [],
    overrideConditions: ["production", "development"],
    extensions: [".js", ".cjs", ".json"],
    dedupe,
    preserveSymlinks,
    isBuild: false,
    isProduction,
    root
  };
  const pendingDeps = [];
  const ssrImport = async (dep) => {
    var _a, _b;
    if (dep[0] !== "." && dep[0] !== "/") {
      return nodeImport(dep, mod.file, resolveOptions);
    }
    dep = unwrapId(dep);
    if (!isCircular(dep) && !((_a = pendingImports.get(dep)) == null ? void 0 : _a.some(isCircular))) {
      pendingDeps.push(dep);
      if (pendingDeps.length === 1) {
        pendingImports.set(url2, pendingDeps);
      }
      const mod2 = await ssrLoadModule(dep, server2, context, urlStack, fixStacktrace);
      if (pendingDeps.length === 1) {
        pendingImports.delete(url2);
      } else {
        pendingDeps.splice(pendingDeps.indexOf(dep), 1);
      }
      return mod2;
    }
    return (_b = moduleGraph.urlToModuleMap.get(dep)) == null ? void 0 : _b.ssrModule;
  };
  const ssrDynamicImport = (dep) => {
    if (dep[0] === ".") {
      dep = import_node_path4.default.posix.resolve(import_node_path4.default.dirname(url2), dep);
    }
    return ssrImport(dep);
  };
  function ssrExportAll(sourceModule) {
    for (const key in sourceModule) {
      if (key !== "default") {
        Object.defineProperty(ssrModule, key, {
          enumerable: true,
          configurable: true,
          get() {
            return sourceModule[key];
          }
        });
      }
    }
  }
  try {
    const AsyncFunction = async function() {
    }.constructor;
    const initModule = new AsyncFunction(`global`, ssrModuleExportsKey, ssrImportMetaKey, ssrImportKey, ssrDynamicImportKey, ssrExportAllKey, '"use strict";' + result.code + `
//# sourceURL=${mod.url}`);
    await initModule(context.global, ssrModule, ssrImportMeta, ssrImport, ssrDynamicImport, ssrExportAll);
  } catch (e3) {
    mod.ssrError = e3;
    if (e3.stack && fixStacktrace) {
      ssrFixStacktrace(e3, moduleGraph);
      server2.config.logger.error(`Error when evaluating SSR module ${url2}:
${e3.stack}`, {
        timestamp: true,
        clear: server2.config.clearScreen,
        error: e3
      });
    }
    throw e3;
  }
  return Object.freeze(ssrModule);
}
async function nodeImport(id, importer, resolveOptions) {
  let url2;
  if (id.startsWith("node:") || isBuiltin(id)) {
    url2 = id;
  } else {
    const resolved = tryNodeResolve(
      id,
      importer,
      // Non-external modules can import ESM-only modules, but only outside
      // of test runs, because we use Node `require` in Jest to avoid segfault.
      // @ts-expect-error jest only exists when running Jest
      typeof jest === "undefined" ? { ...resolveOptions, tryEsmOnly: true } : resolveOptions,
      false
    );
    if (!resolved) {
      const err2 = new Error(`Cannot find module '${id}' imported from '${importer}'`);
      err2.code = "ERR_MODULE_NOT_FOUND";
      throw err2;
    }
    url2 = resolved.id;
    if (usingDynamicImport) {
      url2 = (0, import_node_url3.pathToFileURL)(url2).toString();
    }
  }
  try {
    const mod = await dynamicImport(url2);
    return proxyESM(mod);
  } catch {
  }
}
function proxyESM(mod) {
  if (isPrimitive(mod))
    return { default: mod };
  let defaultExport = "default" in mod ? mod.default : mod;
  if (!isPrimitive(defaultExport) && "__esModule" in defaultExport) {
    mod = defaultExport;
    if ("default" in defaultExport) {
      defaultExport = defaultExport.default;
    }
  }
  return new Proxy(mod, {
    get(mod2, prop) {
      if (prop === "default")
        return defaultExport;
      return mod2[prop] ?? (defaultExport == null ? void 0 : defaultExport[prop]);
    }
  });
}
function isPrimitive(value2) {
  return !value2 || typeof value2 !== "object" && typeof value2 !== "function";
}
var isWslExports = {};
var isWsl$2 = {
  get exports() {
    return isWslExports;
  },
  set exports(v) {
    isWslExports = v;
  }
};
var fs$3 = import_fs.default;
var isDocker$2;
function hasDockerEnv() {
  try {
    fs$3.statSync("/.dockerenv");
    return true;
  } catch (_) {
    return false;
  }
}
function hasDockerCGroup() {
  try {
    return fs$3.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
  } catch (_) {
    return false;
  }
}
var isDocker_1 = () => {
  if (isDocker$2 === void 0) {
    isDocker$2 = hasDockerEnv() || hasDockerCGroup();
  }
  return isDocker$2;
};
var os = import_os.default;
var fs$2 = import_fs.default;
var isDocker$1 = isDocker_1;
var isWsl$1 = () => {
  if (process.platform !== "linux") {
    return false;
  }
  if (os.release().toLowerCase().includes("microsoft")) {
    if (isDocker$1()) {
      return false;
    }
    return true;
  }
  try {
    return fs$2.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft") ? !isDocker$1() : false;
  } catch (_) {
    return false;
  }
};
if (process.env.__IS_WSL_TEST__) {
  isWsl$2.exports = isWsl$1;
} else {
  isWsl$2.exports = isWsl$1();
}
var defineLazyProp = (object, propertyName, fn) => {
  const define2 = (value2) => Object.defineProperty(object, propertyName, { value: value2, enumerable: true, writable: true });
  Object.defineProperty(object, propertyName, {
    configurable: true,
    enumerable: true,
    get() {
      const result = fn();
      define2(result);
      return result;
    },
    set(value2) {
      define2(value2);
    }
  });
  return object;
};
var path$3 = import_path.default;
var childProcess = import_child_process.default;
var { promises: fs$1, constants: fsConstants } = import_fs.default;
var isWsl = isWslExports;
var isDocker = isDocker_1;
var defineLazyProperty = defineLazyProp;
var localXdgOpenPath = path$3.join(__dirname2, "xdg-open");
var { platform, arch } = process;
var getWslDrivesMountPoint = (() => {
  const defaultMountPoint = "/mnt/";
  let mountPoint;
  return async function() {
    if (mountPoint) {
      return mountPoint;
    }
    const configFilePath = "/etc/wsl.conf";
    let isConfigFileExists = false;
    try {
      await fs$1.access(configFilePath, fsConstants.F_OK);
      isConfigFileExists = true;
    } catch {
    }
    if (!isConfigFileExists) {
      return defaultMountPoint;
    }
    const configContent = await fs$1.readFile(configFilePath, { encoding: "utf8" });
    const configMountPoint = new RegExp("(?<!#.*)root\\s*=\\s*(?<mountPoint>.*)", "g").exec(configContent);
    if (!configMountPoint) {
      return defaultMountPoint;
    }
    mountPoint = configMountPoint.groups.mountPoint.trim();
    mountPoint = mountPoint.endsWith("/") ? mountPoint : `${mountPoint}/`;
    return mountPoint;
  };
})();
var pTryEach = async (array2, mapper) => {
  let latestError;
  for (const item of array2) {
    try {
      return await mapper(item);
    } catch (error3) {
      latestError = error3;
    }
  }
  throw latestError;
};
var baseOpen = async (options3) => {
  options3 = {
    wait: false,
    background: false,
    newInstance: false,
    allowNonzeroExitCode: false,
    ...options3
  };
  if (Array.isArray(options3.app)) {
    return pTryEach(options3.app, (singleApp) => baseOpen({
      ...options3,
      app: singleApp
    }));
  }
  let { name: app, arguments: appArguments = [] } = options3.app || {};
  appArguments = [...appArguments];
  if (Array.isArray(app)) {
    return pTryEach(app, (appName) => baseOpen({
      ...options3,
      app: {
        name: appName,
        arguments: appArguments
      }
    }));
  }
  let command;
  const cliArguments = [];
  const childProcessOptions = {};
  if (platform === "darwin") {
    command = "open";
    if (options3.wait) {
      cliArguments.push("--wait-apps");
    }
    if (options3.background) {
      cliArguments.push("--background");
    }
    if (options3.newInstance) {
      cliArguments.push("--new");
    }
    if (app) {
      cliArguments.push("-a", app);
    }
  } else if (platform === "win32" || isWsl && !isDocker()) {
    const mountPoint = await getWslDrivesMountPoint();
    command = isWsl ? `${mountPoint}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe` : `${process.env.SYSTEMROOT}\\System32\\WindowsPowerShell\\v1.0\\powershell`;
    cliArguments.push(
      "-NoProfile",
      "-NonInteractive",
      "–ExecutionPolicy",
      "Bypass",
      "-EncodedCommand"
    );
    if (!isWsl) {
      childProcessOptions.windowsVerbatimArguments = true;
    }
    const encodedArguments = ["Start"];
    if (options3.wait) {
      encodedArguments.push("-Wait");
    }
    if (app) {
      encodedArguments.push(`"\`"${app}\`""`, "-ArgumentList");
      if (options3.target) {
        appArguments.unshift(options3.target);
      }
    } else if (options3.target) {
      encodedArguments.push(`"${options3.target}"`);
    }
    if (appArguments.length > 0) {
      appArguments = appArguments.map((arg) => `"\`"${arg}\`""`);
      encodedArguments.push(appArguments.join(","));
    }
    options3.target = Buffer.from(encodedArguments.join(" "), "utf16le").toString("base64");
  } else {
    if (app) {
      command = app;
    } else {
      const isBundled = !__dirname2 || __dirname2 === "/";
      let exeLocalXdgOpen = false;
      try {
        await fs$1.access(localXdgOpenPath, fsConstants.X_OK);
        exeLocalXdgOpen = true;
      } catch {
      }
      const useSystemXdgOpen = process.versions.electron || platform === "android" || isBundled || !exeLocalXdgOpen;
      command = useSystemXdgOpen ? "xdg-open" : localXdgOpenPath;
    }
    if (appArguments.length > 0) {
      cliArguments.push(...appArguments);
    }
    if (!options3.wait) {
      childProcessOptions.stdio = "ignore";
      childProcessOptions.detached = true;
    }
  }
  if (options3.target) {
    cliArguments.push(options3.target);
  }
  if (platform === "darwin" && appArguments.length > 0) {
    cliArguments.push("--args", ...appArguments);
  }
  const subprocess = childProcess.spawn(command, cliArguments, childProcessOptions);
  if (options3.wait) {
    return new Promise((resolve4, reject) => {
      subprocess.once("error", reject);
      subprocess.once("close", (exitCode) => {
        if (options3.allowNonzeroExitCode && exitCode > 0) {
          reject(new Error(`Exited with code ${exitCode}`));
          return;
        }
        resolve4(subprocess);
      });
    });
  }
  subprocess.unref();
  return subprocess;
};
var open = (target, options3) => {
  if (typeof target !== "string") {
    throw new TypeError("Expected a `target`");
  }
  return baseOpen({
    ...options3,
    target
  });
};
var openApp = (name2, options3) => {
  if (typeof name2 !== "string") {
    throw new TypeError("Expected a `name`");
  }
  const { arguments: appArguments = [] } = options3 || {};
  if (appArguments !== void 0 && appArguments !== null && !Array.isArray(appArguments)) {
    throw new TypeError("Expected `appArguments` as Array type");
  }
  return baseOpen({
    ...options3,
    app: {
      name: name2,
      arguments: appArguments
    }
  });
};
function detectArchBinary(binary3) {
  if (typeof binary3 === "string" || Array.isArray(binary3)) {
    return binary3;
  }
  const { [arch]: archBinary } = binary3;
  if (!archBinary) {
    throw new Error(`${arch} is not supported`);
  }
  return archBinary;
}
function detectPlatformBinary({ [platform]: platformBinary }, { wsl }) {
  if (wsl && isWsl) {
    return detectArchBinary(wsl);
  }
  if (!platformBinary) {
    throw new Error(`${platform} is not supported`);
  }
  return detectArchBinary(platformBinary);
}
var apps = {};
defineLazyProperty(apps, "chrome", () => detectPlatformBinary({
  darwin: "google chrome",
  win32: "chrome",
  linux: ["google-chrome", "google-chrome-stable", "chromium"]
}, {
  wsl: {
    ia32: "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe",
    x64: ["/mnt/c/Program Files/Google/Chrome/Application/chrome.exe", "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe"]
  }
}));
defineLazyProperty(apps, "firefox", () => detectPlatformBinary({
  darwin: "firefox",
  win32: "C:\\Program Files\\Mozilla Firefox\\firefox.exe",
  linux: "firefox"
}, {
  wsl: "/mnt/c/Program Files/Mozilla Firefox/firefox.exe"
}));
defineLazyProperty(apps, "edge", () => detectPlatformBinary({
  darwin: "microsoft edge",
  win32: "msedge",
  linux: ["microsoft-edge", "microsoft-edge-dev"]
}, {
  wsl: "/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe"
}));
open.apps = apps;
open.openApp = openApp;
var open_1 = open;
var crossSpawnExports = {};
var crossSpawn = {
  get exports() {
    return crossSpawnExports;
  },
  set exports(v) {
    crossSpawnExports = v;
  }
};
var windows;
var hasRequiredWindows;
function requireWindows() {
  if (hasRequiredWindows)
    return windows;
  hasRequiredWindows = 1;
  windows = isexe2;
  isexe2.sync = sync2;
  var fs6 = import_fs.default;
  function checkPathExt(path8, options3) {
    var pathext = options3.pathExt !== void 0 ? options3.pathExt : process.env.PATHEXT;
    if (!pathext) {
      return true;
    }
    pathext = pathext.split(";");
    if (pathext.indexOf("") !== -1) {
      return true;
    }
    for (var i2 = 0; i2 < pathext.length; i2++) {
      var p2 = pathext[i2].toLowerCase();
      if (p2 && path8.substr(-p2.length).toLowerCase() === p2) {
        return true;
      }
    }
    return false;
  }
  function checkStat(stat2, path8, options3) {
    if (!stat2.isSymbolicLink() && !stat2.isFile()) {
      return false;
    }
    return checkPathExt(path8, options3);
  }
  function isexe2(path8, options3, cb) {
    fs6.stat(path8, function(er, stat2) {
      cb(er, er ? false : checkStat(stat2, path8, options3));
    });
  }
  function sync2(path8, options3) {
    return checkStat(fs6.statSync(path8), path8, options3);
  }
  return windows;
}
var mode;
var hasRequiredMode;
function requireMode() {
  if (hasRequiredMode)
    return mode;
  hasRequiredMode = 1;
  mode = isexe2;
  isexe2.sync = sync2;
  var fs6 = import_fs.default;
  function isexe2(path8, options3, cb) {
    fs6.stat(path8, function(er, stat2) {
      cb(er, er ? false : checkStat(stat2, options3));
    });
  }
  function sync2(path8, options3) {
    return checkStat(fs6.statSync(path8), options3);
  }
  function checkStat(stat2, options3) {
    return stat2.isFile() && checkMode(stat2, options3);
  }
  function checkMode(stat2, options3) {
    var mod = stat2.mode;
    var uid = stat2.uid;
    var gid = stat2.gid;
    var myUid = options3.uid !== void 0 ? options3.uid : process.getuid && process.getuid();
    var myGid = options3.gid !== void 0 ? options3.gid : process.getgid && process.getgid();
    var u2 = parseInt("100", 8);
    var g = parseInt("010", 8);
    var o3 = parseInt("001", 8);
    var ug = u2 | g;
    var ret = mod & o3 || mod & g && gid === myGid || mod & u2 && uid === myUid || mod & ug && myUid === 0;
    return ret;
  }
  return mode;
}
var core;
if (process.platform === "win32" || commonjsGlobal.TESTING_WINDOWS) {
  core = requireWindows();
} else {
  core = requireMode();
}
var isexe_1 = isexe$1;
isexe$1.sync = sync;
function isexe$1(path8, options3, cb) {
  if (typeof options3 === "function") {
    cb = options3;
    options3 = {};
  }
  if (!cb) {
    if (typeof Promise !== "function") {
      throw new TypeError("callback not provided");
    }
    return new Promise(function(resolve4, reject) {
      isexe$1(path8, options3 || {}, function(er, is) {
        if (er) {
          reject(er);
        } else {
          resolve4(is);
        }
      });
    });
  }
  core(path8, options3 || {}, function(er, is) {
    if (er) {
      if (er.code === "EACCES" || options3 && options3.ignoreErrors) {
        er = null;
        is = false;
      }
    }
    cb(er, is);
  });
}
function sync(path8, options3) {
  try {
    return core.sync(path8, options3 || {});
  } catch (er) {
    if (options3 && options3.ignoreErrors || er.code === "EACCES") {
      return false;
    } else {
      throw er;
    }
  }
}
var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
var path$2 = import_path.default;
var COLON = isWindows ? ";" : ":";
var isexe = isexe_1;
var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
var getPathInfo = (cmd, opt) => {
  const colon = opt.colon || COLON;
  const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
    // windows always checks the cwd first
    ...isWindows ? [process.cwd()] : [],
    ...(opt.path || process.env.PATH || /* istanbul ignore next: very unusual */
    "").split(colon)
  ];
  const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
  const pathExt = isWindows ? pathExtExe.split(colon) : [""];
  if (isWindows) {
    if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
      pathExt.unshift("");
  }
  return {
    pathEnv,
    pathExt,
    pathExtExe
  };
};
var which$1 = (cmd, opt, cb) => {
  if (typeof opt === "function") {
    cb = opt;
    opt = {};
  }
  if (!opt)
    opt = {};
  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
  const found2 = [];
  const step = (i2) => new Promise((resolve4, reject) => {
    if (i2 === pathEnv.length)
      return opt.all && found2.length ? resolve4(found2) : reject(getNotFoundError(cmd));
    const ppRaw = pathEnv[i2];
    const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
    const pCmd = path$2.join(pathPart, cmd);
    const p2 = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
    resolve4(subStep(p2, i2, 0));
  });
  const subStep = (p2, i2, ii) => new Promise((resolve4, reject) => {
    if (ii === pathExt.length)
      return resolve4(step(i2 + 1));
    const ext2 = pathExt[ii];
    isexe(p2 + ext2, { pathExt: pathExtExe }, (er, is) => {
      if (!er && is) {
        if (opt.all)
          found2.push(p2 + ext2);
        else
          return resolve4(p2 + ext2);
      }
      return resolve4(subStep(p2, i2, ii + 1));
    });
  });
  return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
};
var whichSync = (cmd, opt) => {
  opt = opt || {};
  const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
  const found2 = [];
  for (let i2 = 0; i2 < pathEnv.length; i2++) {
    const ppRaw = pathEnv[i2];
    const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
    const pCmd = path$2.join(pathPart, cmd);
    const p2 = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
    for (let j = 0; j < pathExt.length; j++) {
      const cur = p2 + pathExt[j];
      try {
        const is = isexe.sync(cur, { pathExt: pathExtExe });
        if (is) {
          if (opt.all)
            found2.push(cur);
          else
            return cur;
        }
      } catch (ex) {
      }
    }
  }
  if (opt.all && found2.length)
    return found2;
  if (opt.nothrow)
    return null;
  throw getNotFoundError(cmd);
};
var which_1 = which$1;
which$1.sync = whichSync;
var pathKeyExports = {};
var pathKey$1 = {
  get exports() {
    return pathKeyExports;
  },
  set exports(v) {
    pathKeyExports = v;
  }
};
var pathKey = (options3 = {}) => {
  const environment = options3.env || process.env;
  const platform2 = options3.platform || process.platform;
  if (platform2 !== "win32") {
    return "PATH";
  }
  return Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
};
pathKey$1.exports = pathKey;
pathKeyExports.default = pathKey;
var path$1 = import_path.default;
var which = which_1;
var getPathKey = pathKeyExports;
function resolveCommandAttempt(parsed, withoutPathExt) {
  const env2 = parsed.options.env || process.env;
  const cwd = process.cwd();
  const hasCustomCwd = parsed.options.cwd != null;
  const shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
  if (shouldSwitchCwd) {
    try {
      process.chdir(parsed.options.cwd);
    } catch (err2) {
    }
  }
  let resolved;
  try {
    resolved = which.sync(parsed.command, {
      path: env2[getPathKey({ env: env2 })],
      pathExt: withoutPathExt ? path$1.delimiter : void 0
    });
  } catch (e3) {
  } finally {
    if (shouldSwitchCwd) {
      process.chdir(cwd);
    }
  }
  if (resolved) {
    resolved = path$1.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
  }
  return resolved;
}
function resolveCommand$1(parsed) {
  return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
}
var resolveCommand_1 = resolveCommand$1;
var _escape = {};
var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
function escapeCommand(arg) {
  arg = arg.replace(metaCharsRegExp, "^$1");
  return arg;
}
function escapeArgument(arg, doubleEscapeMetaChars) {
  arg = `${arg}`;
  arg = arg.replace(/(\\*)"/g, '$1$1\\"');
  arg = arg.replace(/(\\*)$/, "$1$1");
  arg = `"${arg}"`;
  arg = arg.replace(metaCharsRegExp, "^$1");
  if (doubleEscapeMetaChars) {
    arg = arg.replace(metaCharsRegExp, "^$1");
  }
  return arg;
}
_escape.command = escapeCommand;
_escape.argument = escapeArgument;
var shebangRegex$1 = /^#!(.*)/;
var shebangRegex = shebangRegex$1;
var shebangCommand$1 = (string3 = "") => {
  const match = string3.match(shebangRegex);
  if (!match) {
    return null;
  }
  const [path8, argument] = match[0].replace(/#! ?/, "").split(" ");
  const binary3 = path8.split("/").pop();
  if (binary3 === "env") {
    return argument;
  }
  return argument ? `${binary3} ${argument}` : binary3;
};
var fs4 = import_fs.default;
var shebangCommand = shebangCommand$1;
function readShebang$1(command) {
  const size = 150;
  const buffer = Buffer.alloc(size);
  let fd;
  try {
    fd = fs4.openSync(command, "r");
    fs4.readSync(fd, buffer, 0, size, 0);
    fs4.closeSync(fd);
  } catch (e3) {
  }
  return shebangCommand(buffer.toString());
}
var readShebang_1 = readShebang$1;
var path6 = import_path.default;
var resolveCommand = resolveCommand_1;
var escape$1 = _escape;
var readShebang = readShebang_1;
var isWin$1 = process.platform === "win32";
var isExecutableRegExp = /\.(?:com|exe)$/i;
var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
function detectShebang(parsed) {
  parsed.file = resolveCommand(parsed);
  const shebang = parsed.file && readShebang(parsed.file);
  if (shebang) {
    parsed.args.unshift(parsed.file);
    parsed.command = shebang;
    return resolveCommand(parsed);
  }
  return parsed.file;
}
function parseNonShell(parsed) {
  if (!isWin$1) {
    return parsed;
  }
  const commandFile = detectShebang(parsed);
  const needsShell = !isExecutableRegExp.test(commandFile);
  if (parsed.options.forceShell || needsShell) {
    const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
    parsed.command = path6.normalize(parsed.command);
    parsed.command = escape$1.command(parsed.command);
    parsed.args = parsed.args.map((arg) => escape$1.argument(arg, needsDoubleEscapeMetaChars));
    const shellCommand = [parsed.command].concat(parsed.args).join(" ");
    parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
    parsed.command = process.env.comspec || "cmd.exe";
    parsed.options.windowsVerbatimArguments = true;
  }
  return parsed;
}
function parse$4(command, args, options3) {
  if (args && !Array.isArray(args)) {
    options3 = args;
    args = null;
  }
  args = args ? args.slice(0) : [];
  options3 = Object.assign({}, options3);
  const parsed = {
    command,
    args,
    options: options3,
    file: void 0,
    original: {
      command,
      args
    }
  };
  return options3.shell ? parsed : parseNonShell(parsed);
}
var parse_1 = parse$4;
var isWin = process.platform === "win32";
function notFoundError(original, syscall) {
  return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
    code: "ENOENT",
    errno: "ENOENT",
    syscall: `${syscall} ${original.command}`,
    path: original.command,
    spawnargs: original.args
  });
}
function hookChildProcess(cp2, parsed) {
  if (!isWin) {
    return;
  }
  const originalEmit = cp2.emit;
  cp2.emit = function(name2, arg1) {
    if (name2 === "exit") {
      const err2 = verifyENOENT(arg1, parsed);
      if (err2) {
        return originalEmit.call(cp2, "error", err2);
      }
    }
    return originalEmit.apply(cp2, arguments);
  };
}
function verifyENOENT(status2, parsed) {
  if (isWin && status2 === 1 && !parsed.file) {
    return notFoundError(parsed.original, "spawn");
  }
  return null;
}
function verifyENOENTSync(status2, parsed) {
  if (isWin && status2 === 1 && !parsed.file) {
    return notFoundError(parsed.original, "spawnSync");
  }
  return null;
}
var enoent$1 = {
  hookChildProcess,
  verifyENOENT,
  verifyENOENTSync,
  notFoundError
};
var cp = import_child_process.default;
var parse$3 = parse_1;
var enoent = enoent$1;
function spawn(command, args, options3) {
  const parsed = parse$3(command, args, options3);
  const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
  enoent.hookChildProcess(spawned, parsed);
  return spawned;
}
function spawnSync(command, args, options3) {
  const parsed = parse$3(command, args, options3);
  const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
  result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
  return result;
}
crossSpawn.exports = spawn;
crossSpawnExports.spawn = spawn;
crossSpawnExports.sync = spawnSync;
crossSpawnExports._parse = parse$3;
crossSpawnExports._enoent = enoent;
function openBrowser(url2, opt, logger2) {
  const browser3 = typeof opt === "string" ? opt : process.env.BROWSER || "";
  if (browser3.toLowerCase().endsWith(".js")) {
    return executeNodeScript(browser3, url2, logger2);
  } else if (browser3.toLowerCase() !== "none") {
    const browserArgs = process.env.BROWSER_ARGS ? process.env.BROWSER_ARGS.split(" ") : [];
    return startBrowserProcess(browser3, browserArgs, url2);
  }
  return false;
}
function executeNodeScript(scriptPath, url2, logger2) {
  const extraArgs = process.argv.slice(2);
  const child = crossSpawnExports(process.execPath, [scriptPath, ...extraArgs, url2], {
    stdio: "inherit"
  });
  child.on("close", (code) => {
    if (code !== 0) {
      logger2.error(picocolorsExports.red(`
The script specified as BROWSER environment variable failed.

${picocolorsExports.cyan(scriptPath)} exited with code ${code}.`), { error: null });
    }
  });
  return true;
}
var supportedChromiumBrowsers = [
  "Google Chrome Canary",
  "Google Chrome Dev",
  "Google Chrome Beta",
  "Google Chrome",
  "Microsoft Edge",
  "Brave Browser",
  "Vivaldi",
  "Chromium"
];
function startBrowserProcess(browser3, browserArgs, url2) {
  const preferredOSXBrowser = browser3 === "google chrome" ? "Google Chrome" : browser3;
  const shouldTryOpenChromeWithAppleScript = process.platform === "darwin" && (!preferredOSXBrowser || supportedChromiumBrowsers.includes(preferredOSXBrowser));
  if (shouldTryOpenChromeWithAppleScript) {
    try {
      const ps = (0, import_node_child_process.execSync)("ps cax").toString();
      const openedBrowser = preferredOSXBrowser && ps.includes(preferredOSXBrowser) ? preferredOSXBrowser : supportedChromiumBrowsers.find((b) => ps.includes(b));
      if (openedBrowser) {
        (0, import_node_child_process.execSync)(`osascript openChrome.applescript "${encodeURI(url2)}" "${openedBrowser}"`, {
          cwd: (0, import_node_path4.join)(VITE_PACKAGE_DIR, "bin"),
          stdio: "ignore"
        });
        return true;
      }
    } catch (err2) {
    }
  }
  if (process.platform === "darwin" && browser3 === "open") {
    browser3 = void 0;
  }
  try {
    const options3 = browser3 ? { app: { name: browser3, arguments: browserArgs } } : {};
    open_1(url2, options3).catch(() => {
    });
    return true;
  } catch (err2) {
    return false;
  }
}
function bindShortcuts(server2, opts) {
  if (!server2.httpServer || !process.stdin.isTTY || process.env.CI) {
    return;
  }
  server2._shortcutsOptions = opts;
  if (opts.print) {
    server2.config.logger.info(picocolorsExports.dim(picocolorsExports.green("  ➜")) + picocolorsExports.dim("  press ") + picocolorsExports.bold("h") + picocolorsExports.dim(" to show help"));
  }
  const shortcuts = (opts.customShortcuts ?? []).filter(isDefined).concat(BASE_SHORTCUTS);
  let actionRunning = false;
  const onInput = async (input) => {
    if (input === "" || input === "") {
      await server2.close().finally(() => process.exit(1));
      return;
    }
    if (actionRunning)
      return;
    if (input === "h") {
      server2.config.logger.info([
        "",
        picocolorsExports.bold("  Shortcuts"),
        ...shortcuts.map((shortcut2) => picocolorsExports.dim("  press ") + picocolorsExports.bold(shortcut2.key) + picocolorsExports.dim(` to ${shortcut2.description}`))
      ].join("\n"));
    }
    const shortcut = shortcuts.find((shortcut2) => shortcut2.key === input);
    if (!shortcut)
      return;
    actionRunning = true;
    await shortcut.action(server2);
    actionRunning = false;
  };
  process.stdin.setRawMode(true);
  process.stdin.on("data", onInput).setEncoding("utf8").resume();
  server2.httpServer.on("close", () => {
    process.stdin.off("data", onInput).pause();
  });
}
var BASE_SHORTCUTS = [
  {
    key: "r",
    description: "restart the server",
    async action(server2) {
      await server2.restart();
    }
  },
  {
    key: "u",
    description: "show server url",
    action(server2) {
      server2.config.logger.info("");
      server2.printUrls();
    }
  },
  {
    key: "o",
    description: "open in browser",
    action(server2) {
      var _a;
      const url2 = (_a = server2.resolvedUrls) == null ? void 0 : _a.local[0];
      if (!url2) {
        server2.config.logger.warn("No URL available to open in browser");
        return;
      }
      openBrowser(url2, true, server2.config.logger);
    }
  },
  {
    key: "c",
    description: "clear console",
    action(server2) {
      server2.config.logger.clearScreen("error");
    }
  },
  {
    key: "q",
    description: "quit",
    async action(server2) {
      await server2.close().finally(() => process.exit());
    }
  }
];
var bufferUtilExports = {};
var bufferUtil$1 = {
  get exports() {
    return bufferUtilExports;
  },
  set exports(v) {
    bufferUtilExports = v;
  }
};
var constants = {
  BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
  EMPTY_BUFFER: Buffer.alloc(0),
  GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
  kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
  kListener: Symbol("kListener"),
  kStatusCode: Symbol("status-code"),
  kWebSocket: Symbol("websocket"),
  NOOP: () => {
  }
};
var { EMPTY_BUFFER: EMPTY_BUFFER$3 } = constants;
var FastBuffer$2 = Buffer[Symbol.species];
function concat$1(list, totalLength) {
  if (list.length === 0)
    return EMPTY_BUFFER$3;
  if (list.length === 1)
    return list[0];
  const target = Buffer.allocUnsafe(totalLength);
  let offset3 = 0;
  for (let i2 = 0; i2 < list.length; i2++) {
    const buf = list[i2];
    target.set(buf, offset3);
    offset3 += buf.length;
  }
  if (offset3 < totalLength) {
    return new FastBuffer$2(target.buffer, target.byteOffset, offset3);
  }
  return target;
}
function _mask(source, mask, output, offset3, length) {
  for (let i2 = 0; i2 < length; i2++) {
    output[offset3 + i2] = source[i2] ^ mask[i2 & 3];
  }
}
function _unmask(buffer, mask) {
  for (let i2 = 0; i2 < buffer.length; i2++) {
    buffer[i2] ^= mask[i2 & 3];
  }
}
function toArrayBuffer$1(buf) {
  if (buf.length === buf.buffer.byteLength) {
    return buf.buffer;
  }
  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
}
function toBuffer$2(data2) {
  toBuffer$2.readOnly = true;
  if (Buffer.isBuffer(data2))
    return data2;
  let buf;
  if (data2 instanceof ArrayBuffer) {
    buf = new FastBuffer$2(data2);
  } else if (ArrayBuffer.isView(data2)) {
    buf = new FastBuffer$2(data2.buffer, data2.byteOffset, data2.byteLength);
  } else {
    buf = Buffer.from(data2);
    toBuffer$2.readOnly = false;
  }
  return buf;
}
bufferUtil$1.exports = {
  concat: concat$1,
  mask: _mask,
  toArrayBuffer: toArrayBuffer$1,
  toBuffer: toBuffer$2,
  unmask: _unmask
};
if (!process.env.WS_NO_BUFFER_UTIL) {
  try {
    const bufferUtil2 = require2("bufferutil");
    bufferUtilExports.mask = function(source, mask, output, offset3, length) {
      if (length < 48)
        _mask(source, mask, output, offset3, length);
      else
        bufferUtil2.mask(source, mask, output, offset3, length);
    };
    bufferUtilExports.unmask = function(buffer, mask) {
      if (buffer.length < 32)
        _unmask(buffer, mask);
      else
        bufferUtil2.unmask(buffer, mask);
    };
  } catch (e3) {
  }
}
var kDone = Symbol("kDone");
var kRun = Symbol("kRun");
var Limiter$1 = class Limiter {
  /**
   * Creates a new `Limiter`.
   *
   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
   *     to run concurrently
   */
  constructor(concurrency) {
    this[kDone] = () => {
      this.pending--;
      this[kRun]();
    };
    this.concurrency = concurrency || Infinity;
    this.jobs = [];
    this.pending = 0;
  }
  /**
   * Adds a job to the queue.
   *
   * @param {Function} job The job to run
   * @public
   */
  add(job) {
    this.jobs.push(job);
    this[kRun]();
  }
  /**
   * Removes a job from the queue and runs it if possible.
   *
   * @private
   */
  [kRun]() {
    if (this.pending === this.concurrency)
      return;
    if (this.jobs.length) {
      const job = this.jobs.shift();
      this.pending++;
      job(this[kDone]);
    }
  }
};
var limiter = Limiter$1;
var zlib = import_zlib.default;
var bufferUtil = bufferUtilExports;
var Limiter2 = limiter;
var { kStatusCode: kStatusCode$2 } = constants;
var FastBuffer$1 = Buffer[Symbol.species];
var TRAILER = Buffer.from([0, 0, 255, 255]);
var kPerMessageDeflate = Symbol("permessage-deflate");
var kTotalLength = Symbol("total-length");
var kCallback = Symbol("callback");
var kBuffers = Symbol("buffers");
var kError$1 = Symbol("error");
var zlibLimiter;
var PerMessageDeflate$4 = class PerMessageDeflate {
  /**
   * Creates a PerMessageDeflate instance.
   *
   * @param {Object} [options] Configuration options
   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
   *     for, or request, a custom client window size
   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
   *     acknowledge disabling of client context takeover
   * @param {Number} [options.concurrencyLimit=10] The number of concurrent
   *     calls to zlib
   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
   *     use of a custom server window size
   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
   *     disabling of server context takeover
   * @param {Number} [options.threshold=1024] Size (in bytes) below which
   *     messages should not be compressed if context takeover is disabled
   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
   *     deflate
   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
   *     inflate
   * @param {Boolean} [isServer=false] Create the instance in either server or
   *     client mode
   * @param {Number} [maxPayload=0] The maximum allowed message length
   */
  constructor(options3, isServer, maxPayload) {
    this._maxPayload = maxPayload | 0;
    this._options = options3 || {};
    this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
    this._isServer = !!isServer;
    this._deflate = null;
    this._inflate = null;
    this.params = null;
    if (!zlibLimiter) {
      const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
      zlibLimiter = new Limiter2(concurrency);
    }
  }
  /**
   * @type {String}
   */
  static get extensionName() {
    return "permessage-deflate";
  }
  /**
   * Create an extension negotiation offer.
   *
   * @return {Object} Extension parameters
   * @public
   */
  offer() {
    const params = {};
    if (this._options.serverNoContextTakeover) {
      params.server_no_context_takeover = true;
    }
    if (this._options.clientNoContextTakeover) {
      params.client_no_context_takeover = true;
    }
    if (this._options.serverMaxWindowBits) {
      params.server_max_window_bits = this._options.serverMaxWindowBits;
    }
    if (this._options.clientMaxWindowBits) {
      params.client_max_window_bits = this._options.clientMaxWindowBits;
    } else if (this._options.clientMaxWindowBits == null) {
      params.client_max_window_bits = true;
    }
    return params;
  }
  /**
   * Accept an extension negotiation offer/response.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Object} Accepted configuration
   * @public
   */
  accept(configurations) {
    configurations = this.normalizeParams(configurations);
    this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
    return this.params;
  }
  /**
   * Releases all resources used by the extension.
   *
   * @public
   */
  cleanup() {
    if (this._inflate) {
      this._inflate.close();
      this._inflate = null;
    }
    if (this._deflate) {
      const callback = this._deflate[kCallback];
      this._deflate.close();
      this._deflate = null;
      if (callback) {
        callback(
          new Error(
            "The deflate stream was closed while data was being processed"
          )
        );
      }
    }
  }
  /**
   *  Accept an extension negotiation offer.
   *
   * @param {Array} offers The extension negotiation offers
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsServer(offers) {
    const opts = this._options;
    const accepted = offers.find((params) => {
      if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
        return false;
      }
      return true;
    });
    if (!accepted) {
      throw new Error("None of the extension offers can be accepted");
    }
    if (opts.serverNoContextTakeover) {
      accepted.server_no_context_takeover = true;
    }
    if (opts.clientNoContextTakeover) {
      accepted.client_no_context_takeover = true;
    }
    if (typeof opts.serverMaxWindowBits === "number") {
      accepted.server_max_window_bits = opts.serverMaxWindowBits;
    }
    if (typeof opts.clientMaxWindowBits === "number") {
      accepted.client_max_window_bits = opts.clientMaxWindowBits;
    } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
      delete accepted.client_max_window_bits;
    }
    return accepted;
  }
  /**
   * Accept the extension negotiation response.
   *
   * @param {Array} response The extension negotiation response
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsClient(response) {
    const params = response[0];
    if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
      throw new Error('Unexpected parameter "client_no_context_takeover"');
    }
    if (!params.client_max_window_bits) {
      if (typeof this._options.clientMaxWindowBits === "number") {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      }
    } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
      throw new Error(
        'Unexpected or invalid parameter "client_max_window_bits"'
      );
    }
    return params;
  }
  /**
   * Normalize parameters.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Array} The offers/response with normalized parameters
   * @private
   */
  normalizeParams(configurations) {
    configurations.forEach((params) => {
      Object.keys(params).forEach((key) => {
        let value2 = params[key];
        if (value2.length > 1) {
          throw new Error(`Parameter "${key}" must have only a single value`);
        }
        value2 = value2[0];
        if (key === "client_max_window_bits") {
          if (value2 !== true) {
            const num = +value2;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(
                `Invalid value for parameter "${key}": ${value2}`
              );
            }
            value2 = num;
          } else if (!this._isServer) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value2}`
            );
          }
        } else if (key === "server_max_window_bits") {
          const num = +value2;
          if (!Number.isInteger(num) || num < 8 || num > 15) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value2}`
            );
          }
          value2 = num;
        } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
          if (value2 !== true) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value2}`
            );
          }
        } else {
          throw new Error(`Unknown parameter "${key}"`);
        }
        params[key] = value2;
      });
    });
    return configurations;
  }
  /**
   * Decompress data. Concurrency limited.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  decompress(data2, fin, callback) {
    zlibLimiter.add((done) => {
      this._decompress(data2, fin, (err2, result) => {
        done();
        callback(err2, result);
      });
    });
  }
  /**
   * Compress data. Concurrency limited.
   *
   * @param {(Buffer|String)} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  compress(data2, fin, callback) {
    zlibLimiter.add((done) => {
      this._compress(data2, fin, (err2, result) => {
        done();
        callback(err2, result);
      });
    });
  }
  /**
   * Decompress data.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _decompress(data2, fin, callback) {
    const endpoint = this._isServer ? "client" : "server";
    if (!this._inflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
      this._inflate = zlib.createInflateRaw({
        ...this._options.zlibInflateOptions,
        windowBits
      });
      this._inflate[kPerMessageDeflate] = this;
      this._inflate[kTotalLength] = 0;
      this._inflate[kBuffers] = [];
      this._inflate.on("error", inflateOnError);
      this._inflate.on("data", inflateOnData);
    }
    this._inflate[kCallback] = callback;
    this._inflate.write(data2);
    if (fin)
      this._inflate.write(TRAILER);
    this._inflate.flush(() => {
      const err2 = this._inflate[kError$1];
      if (err2) {
        this._inflate.close();
        this._inflate = null;
        callback(err2);
        return;
      }
      const data3 = bufferUtil.concat(
        this._inflate[kBuffers],
        this._inflate[kTotalLength]
      );
      if (this._inflate._readableState.endEmitted) {
        this._inflate.close();
        this._inflate = null;
      } else {
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];
        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._inflate.reset();
        }
      }
      callback(null, data3);
    });
  }
  /**
   * Compress data.
   *
   * @param {(Buffer|String)} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _compress(data2, fin, callback) {
    const endpoint = this._isServer ? "server" : "client";
    if (!this._deflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
      this._deflate = zlib.createDeflateRaw({
        ...this._options.zlibDeflateOptions,
        windowBits
      });
      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];
      this._deflate.on("data", deflateOnData);
    }
    this._deflate[kCallback] = callback;
    this._deflate.write(data2);
    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
      if (!this._deflate) {
        return;
      }
      let data3 = bufferUtil.concat(
        this._deflate[kBuffers],
        this._deflate[kTotalLength]
      );
      if (fin) {
        data3 = new FastBuffer$1(data3.buffer, data3.byteOffset, data3.length - 4);
      }
      this._deflate[kCallback] = null;
      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];
      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
        this._deflate.reset();
      }
      callback(null, data3);
    });
  }
};
var permessageDeflate = PerMessageDeflate$4;
function deflateOnData(chunk) {
  this[kBuffers].push(chunk);
  this[kTotalLength] += chunk.length;
}
function inflateOnData(chunk) {
  this[kTotalLength] += chunk.length;
  if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
    this[kBuffers].push(chunk);
    return;
  }
  this[kError$1] = new RangeError("Max payload size exceeded");
  this[kError$1].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
  this[kError$1][kStatusCode$2] = 1009;
  this.removeListener("data", inflateOnData);
  this.reset();
}
function inflateOnError(err2) {
  this[kPerMessageDeflate]._inflate = null;
  err2[kStatusCode$2] = 1007;
  this[kCallback](err2);
}
var validationExports = {};
var validation = {
  get exports() {
    return validationExports;
  },
  set exports(v) {
    validationExports = v;
  }
};
var { isUtf8 } = import_buffer.default;
var tokenChars$2 = [
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  // 0 - 15
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  // 16 - 31
  0,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  1,
  1,
  0,
  1,
  1,
  0,
  // 32 - 47
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  // 48 - 63
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  // 64 - 79
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  1,
  1,
  // 80 - 95
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  // 96 - 111
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  0,
  1,
  0
  // 112 - 127
];
function isValidStatusCode$2(code) {
  return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
}
function _isValidUTF8(buf) {
  const len = buf.length;
  let i2 = 0;
  while (i2 < len) {
    if ((buf[i2] & 128) === 0) {
      i2++;
    } else if ((buf[i2] & 224) === 192) {
      if (i2 + 1 === len || (buf[i2 + 1] & 192) !== 128 || (buf[i2] & 254) === 192) {
        return false;
      }
      i2 += 2;
    } else if ((buf[i2] & 240) === 224) {
      if (i2 + 2 >= len || (buf[i2 + 1] & 192) !== 128 || (buf[i2 + 2] & 192) !== 128 || buf[i2] === 224 && (buf[i2 + 1] & 224) === 128 || // Overlong
      buf[i2] === 237 && (buf[i2 + 1] & 224) === 160) {
        return false;
      }
      i2 += 3;
    } else if ((buf[i2] & 248) === 240) {
      if (i2 + 3 >= len || (buf[i2 + 1] & 192) !== 128 || (buf[i2 + 2] & 192) !== 128 || (buf[i2 + 3] & 192) !== 128 || buf[i2] === 240 && (buf[i2 + 1] & 240) === 128 || // Overlong
      buf[i2] === 244 && buf[i2 + 1] > 143 || buf[i2] > 244) {
        return false;
      }
      i2 += 4;
    } else {
      return false;
    }
  }
  return true;
}
validation.exports = {
  isValidStatusCode: isValidStatusCode$2,
  isValidUTF8: _isValidUTF8,
  tokenChars: tokenChars$2
};
if (isUtf8) {
  validationExports.isValidUTF8 = function(buf) {
    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
  };
} else if (!process.env.WS_NO_UTF_8_VALIDATE) {
  try {
    const isValidUTF82 = require2("utf-8-validate");
    validationExports.isValidUTF8 = function(buf) {
      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF82(buf);
    };
  } catch (e3) {
  }
}
var { Writable: Writable$1 } = import_stream.default;
var PerMessageDeflate$3 = permessageDeflate;
var {
  BINARY_TYPES: BINARY_TYPES$1,
  EMPTY_BUFFER: EMPTY_BUFFER$2,
  kStatusCode: kStatusCode$1,
  kWebSocket: kWebSocket$2
} = constants;
var { concat, toArrayBuffer, unmask } = bufferUtilExports;
var { isValidStatusCode: isValidStatusCode$1, isValidUTF8 } = validationExports;
var FastBuffer = Buffer[Symbol.species];
var GET_INFO = 0;
var GET_PAYLOAD_LENGTH_16 = 1;
var GET_PAYLOAD_LENGTH_64 = 2;
var GET_MASK = 3;
var GET_DATA = 4;
var INFLATING = 5;
var Receiver$1 = class Receiver extends Writable$1 {
  /**
   * Creates a Receiver instance.
   *
   * @param {Object} [options] Options object
   * @param {String} [options.binaryType=nodebuffer] The type for binary data
   * @param {Object} [options.extensions] An object containing the negotiated
   *     extensions
   * @param {Boolean} [options.isServer=false] Specifies whether to operate in
   *     client or server mode
   * @param {Number} [options.maxPayload=0] The maximum allowed message length
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   */
  constructor(options3 = {}) {
    super();
    this._binaryType = options3.binaryType || BINARY_TYPES$1[0];
    this._extensions = options3.extensions || {};
    this._isServer = !!options3.isServer;
    this._maxPayload = options3.maxPayload | 0;
    this._skipUTF8Validation = !!options3.skipUTF8Validation;
    this[kWebSocket$2] = void 0;
    this._bufferedBytes = 0;
    this._buffers = [];
    this._compressed = false;
    this._payloadLength = 0;
    this._mask = void 0;
    this._fragmented = 0;
    this._masked = false;
    this._fin = false;
    this._opcode = 0;
    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragments = [];
    this._state = GET_INFO;
    this._loop = false;
  }
  /**
   * Implements `Writable.prototype._write()`.
   *
   * @param {Buffer} chunk The chunk of data to write
   * @param {String} encoding The character encoding of `chunk`
   * @param {Function} cb Callback
   * @private
   */
  _write(chunk, encoding, cb) {
    if (this._opcode === 8 && this._state == GET_INFO)
      return cb();
    this._bufferedBytes += chunk.length;
    this._buffers.push(chunk);
    this.startLoop(cb);
  }
  /**
   * Consumes `n` bytes from the buffered data.
   *
   * @param {Number} n The number of bytes to consume
   * @return {Buffer} The consumed bytes
   * @private
   */
  consume(n3) {
    this._bufferedBytes -= n3;
    if (n3 === this._buffers[0].length)
      return this._buffers.shift();
    if (n3 < this._buffers[0].length) {
      const buf = this._buffers[0];
      this._buffers[0] = new FastBuffer(
        buf.buffer,
        buf.byteOffset + n3,
        buf.length - n3
      );
      return new FastBuffer(buf.buffer, buf.byteOffset, n3);
    }
    const dst = Buffer.allocUnsafe(n3);
    do {
      const buf = this._buffers[0];
      const offset3 = dst.length - n3;
      if (n3 >= buf.length) {
        dst.set(this._buffers.shift(), offset3);
      } else {
        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n3), offset3);
        this._buffers[0] = new FastBuffer(
          buf.buffer,
          buf.byteOffset + n3,
          buf.length - n3
        );
      }
      n3 -= buf.length;
    } while (n3 > 0);
    return dst;
  }
  /**
   * Starts the parsing loop.
   *
   * @param {Function} cb Callback
   * @private
   */
  startLoop(cb) {
    let err2;
    this._loop = true;
    do {
      switch (this._state) {
        case GET_INFO:
          err2 = this.getInfo();
          break;
        case GET_PAYLOAD_LENGTH_16:
          err2 = this.getPayloadLength16();
          break;
        case GET_PAYLOAD_LENGTH_64:
          err2 = this.getPayloadLength64();
          break;
        case GET_MASK:
          this.getMask();
          break;
        case GET_DATA:
          err2 = this.getData(cb);
          break;
        default:
          this._loop = false;
          return;
      }
    } while (this._loop);
    cb(err2);
  }
  /**
   * Reads the first two bytes of a frame.
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getInfo() {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }
    const buf = this.consume(2);
    if ((buf[0] & 48) !== 0) {
      this._loop = false;
      return error2(
        RangeError,
        "RSV2 and RSV3 must be clear",
        true,
        1002,
        "WS_ERR_UNEXPECTED_RSV_2_3"
      );
    }
    const compressed = (buf[0] & 64) === 64;
    if (compressed && !this._extensions[PerMessageDeflate$3.extensionName]) {
      this._loop = false;
      return error2(
        RangeError,
        "RSV1 must be clear",
        true,
        1002,
        "WS_ERR_UNEXPECTED_RSV_1"
      );
    }
    this._fin = (buf[0] & 128) === 128;
    this._opcode = buf[0] & 15;
    this._payloadLength = buf[1] & 127;
    if (this._opcode === 0) {
      if (compressed) {
        this._loop = false;
        return error2(
          RangeError,
          "RSV1 must be clear",
          true,
          1002,
          "WS_ERR_UNEXPECTED_RSV_1"
        );
      }
      if (!this._fragmented) {
        this._loop = false;
        return error2(
          RangeError,
          "invalid opcode 0",
          true,
          1002,
          "WS_ERR_INVALID_OPCODE"
        );
      }
      this._opcode = this._fragmented;
    } else if (this._opcode === 1 || this._opcode === 2) {
      if (this._fragmented) {
        this._loop = false;
        return error2(
          RangeError,
          `invalid opcode ${this._opcode}`,
          true,
          1002,
          "WS_ERR_INVALID_OPCODE"
        );
      }
      this._compressed = compressed;
    } else if (this._opcode > 7 && this._opcode < 11) {
      if (!this._fin) {
        this._loop = false;
        return error2(
          RangeError,
          "FIN must be set",
          true,
          1002,
          "WS_ERR_EXPECTED_FIN"
        );
      }
      if (compressed) {
        this._loop = false;
        return error2(
          RangeError,
          "RSV1 must be clear",
          true,
          1002,
          "WS_ERR_UNEXPECTED_RSV_1"
        );
      }
      if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
        this._loop = false;
        return error2(
          RangeError,
          `invalid payload length ${this._payloadLength}`,
          true,
          1002,
          "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
        );
      }
    } else {
      this._loop = false;
      return error2(
        RangeError,
        `invalid opcode ${this._opcode}`,
        true,
        1002,
        "WS_ERR_INVALID_OPCODE"
      );
    }
    if (!this._fin && !this._fragmented)
      this._fragmented = this._opcode;
    this._masked = (buf[1] & 128) === 128;
    if (this._isServer) {
      if (!this._masked) {
        this._loop = false;
        return error2(
          RangeError,
          "MASK must be set",
          true,
          1002,
          "WS_ERR_EXPECTED_MASK"
        );
      }
    } else if (this._masked) {
      this._loop = false;
      return error2(
        RangeError,
        "MASK must be clear",
        true,
        1002,
        "WS_ERR_UNEXPECTED_MASK"
      );
    }
    if (this._payloadLength === 126)
      this._state = GET_PAYLOAD_LENGTH_16;
    else if (this._payloadLength === 127)
      this._state = GET_PAYLOAD_LENGTH_64;
    else
      return this.haveLength();
  }
  /**
   * Gets extended payload length (7+16).
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getPayloadLength16() {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }
    this._payloadLength = this.consume(2).readUInt16BE(0);
    return this.haveLength();
  }
  /**
   * Gets extended payload length (7+64).
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  getPayloadLength64() {
    if (this._bufferedBytes < 8) {
      this._loop = false;
      return;
    }
    const buf = this.consume(8);
    const num = buf.readUInt32BE(0);
    if (num > Math.pow(2, 53 - 32) - 1) {
      this._loop = false;
      return error2(
        RangeError,
        "Unsupported WebSocket frame: payload length > 2^53 - 1",
        false,
        1009,
        "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
      );
    }
    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
    return this.haveLength();
  }
  /**
   * Payload length has been read.
   *
   * @return {(RangeError|undefined)} A possible error
   * @private
   */
  haveLength() {
    if (this._payloadLength && this._opcode < 8) {
      this._totalPayloadLength += this._payloadLength;
      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
        this._loop = false;
        return error2(
          RangeError,
          "Max payload size exceeded",
          false,
          1009,
          "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
        );
      }
    }
    if (this._masked)
      this._state = GET_MASK;
    else
      this._state = GET_DATA;
  }
  /**
   * Reads mask bytes.
   *
   * @private
   */
  getMask() {
    if (this._bufferedBytes < 4) {
      this._loop = false;
      return;
    }
    this._mask = this.consume(4);
    this._state = GET_DATA;
  }
  /**
   * Reads data bytes.
   *
   * @param {Function} cb Callback
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  getData(cb) {
    let data2 = EMPTY_BUFFER$2;
    if (this._payloadLength) {
      if (this._bufferedBytes < this._payloadLength) {
        this._loop = false;
        return;
      }
      data2 = this.consume(this._payloadLength);
      if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
        unmask(data2, this._mask);
      }
    }
    if (this._opcode > 7)
      return this.controlMessage(data2);
    if (this._compressed) {
      this._state = INFLATING;
      this.decompress(data2, cb);
      return;
    }
    if (data2.length) {
      this._messageLength = this._totalPayloadLength;
      this._fragments.push(data2);
    }
    return this.dataMessage();
  }
  /**
   * Decompresses data.
   *
   * @param {Buffer} data Compressed data
   * @param {Function} cb Callback
   * @private
   */
  decompress(data2, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate$3.extensionName];
    perMessageDeflate.decompress(data2, this._fin, (err2, buf) => {
      if (err2)
        return cb(err2);
      if (buf.length) {
        this._messageLength += buf.length;
        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
          return cb(
            error2(
              RangeError,
              "Max payload size exceeded",
              false,
              1009,
              "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
            )
          );
        }
        this._fragments.push(buf);
      }
      const er = this.dataMessage();
      if (er)
        return cb(er);
      this.startLoop(cb);
    });
  }
  /**
   * Handles a data message.
   *
   * @return {(Error|undefined)} A possible error
   * @private
   */
  dataMessage() {
    if (this._fin) {
      const messageLength = this._messageLength;
      const fragments = this._fragments;
      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragmented = 0;
      this._fragments = [];
      if (this._opcode === 2) {
        let data2;
        if (this._binaryType === "nodebuffer") {
          data2 = concat(fragments, messageLength);
        } else if (this._binaryType === "arraybuffer") {
          data2 = toArrayBuffer(concat(fragments, messageLength));
        } else {
          data2 = fragments;
        }
        this.emit("message", data2, true);
      } else {
        const buf = concat(fragments, messageLength);
        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
          this._loop = false;
          return error2(
            Error,
            "invalid UTF-8 sequence",
            true,
            1007,
            "WS_ERR_INVALID_UTF8"
          );
        }
        this.emit("message", buf, false);
      }
    }
    this._state = GET_INFO;
  }
  /**
   * Handles a control message.
   *
   * @param {Buffer} data Data to handle
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  controlMessage(data2) {
    if (this._opcode === 8) {
      this._loop = false;
      if (data2.length === 0) {
        this.emit("conclude", 1005, EMPTY_BUFFER$2);
        this.end();
      } else {
        const code = data2.readUInt16BE(0);
        if (!isValidStatusCode$1(code)) {
          return error2(
            RangeError,
            `invalid status code ${code}`,
            true,
            1002,
            "WS_ERR_INVALID_CLOSE_CODE"
          );
        }
        const buf = new FastBuffer(
          data2.buffer,
          data2.byteOffset + 2,
          data2.length - 2
        );
        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
          return error2(
            Error,
            "invalid UTF-8 sequence",
            true,
            1007,
            "WS_ERR_INVALID_UTF8"
          );
        }
        this.emit("conclude", code, buf);
        this.end();
      }
    } else if (this._opcode === 9) {
      this.emit("ping", data2);
    } else {
      this.emit("pong", data2);
    }
    this._state = GET_INFO;
  }
};
var receiver = Receiver$1;
function error2(ErrorCtor, message, prefix, statusCode, errorCode) {
  const err2 = new ErrorCtor(
    prefix ? `Invalid WebSocket frame: ${message}` : message
  );
  Error.captureStackTrace(err2, error2);
  err2.code = errorCode;
  err2[kStatusCode$1] = statusCode;
  return err2;
}
var { randomFillSync } = import_crypto.default;
var PerMessageDeflate$2 = permessageDeflate;
var { EMPTY_BUFFER: EMPTY_BUFFER$1 } = constants;
var { isValidStatusCode } = validationExports;
var { mask: applyMask, toBuffer: toBuffer$1 } = bufferUtilExports;
var kByteLength = Symbol("kByteLength");
var maskBuffer = Buffer.alloc(4);
var Sender$1 = class Sender {
  /**
   * Creates a Sender instance.
   *
   * @param {(net.Socket|tls.Socket)} socket The connection socket
   * @param {Object} [extensions] An object containing the negotiated extensions
   * @param {Function} [generateMask] The function used to generate the masking
   *     key
   */
  constructor(socket, extensions2, generateMask) {
    this._extensions = extensions2 || {};
    if (generateMask) {
      this._generateMask = generateMask;
      this._maskBuffer = Buffer.alloc(4);
    }
    this._socket = socket;
    this._firstFragment = true;
    this._compress = false;
    this._bufferedBytes = 0;
    this._deflating = false;
    this._queue = [];
  }
  /**
   * Frames a piece of data according to the HyBi WebSocket protocol.
   *
   * @param {(Buffer|String)} data The data to frame
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @return {(Buffer|String)[]} The framed data
   * @public
   */
  static frame(data2, options3) {
    let mask;
    let merge3 = false;
    let offset3 = 2;
    let skipMasking = false;
    if (options3.mask) {
      mask = options3.maskBuffer || maskBuffer;
      if (options3.generateMask) {
        options3.generateMask(mask);
      } else {
        randomFillSync(mask, 0, 4);
      }
      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
      offset3 = 6;
    }
    let dataLength;
    if (typeof data2 === "string") {
      if ((!options3.mask || skipMasking) && options3[kByteLength] !== void 0) {
        dataLength = options3[kByteLength];
      } else {
        data2 = Buffer.from(data2);
        dataLength = data2.length;
      }
    } else {
      dataLength = data2.length;
      merge3 = options3.mask && options3.readOnly && !skipMasking;
    }
    let payloadLength = dataLength;
    if (dataLength >= 65536) {
      offset3 += 8;
      payloadLength = 127;
    } else if (dataLength > 125) {
      offset3 += 2;
      payloadLength = 126;
    }
    const target = Buffer.allocUnsafe(merge3 ? dataLength + offset3 : offset3);
    target[0] = options3.fin ? options3.opcode | 128 : options3.opcode;
    if (options3.rsv1)
      target[0] |= 64;
    target[1] = payloadLength;
    if (payloadLength === 126) {
      target.writeUInt16BE(dataLength, 2);
    } else if (payloadLength === 127) {
      target[2] = target[3] = 0;
      target.writeUIntBE(dataLength, 4, 6);
    }
    if (!options3.mask)
      return [target, data2];
    target[1] |= 128;
    target[offset3 - 4] = mask[0];
    target[offset3 - 3] = mask[1];
    target[offset3 - 2] = mask[2];
    target[offset3 - 1] = mask[3];
    if (skipMasking)
      return [target, data2];
    if (merge3) {
      applyMask(data2, mask, target, offset3, dataLength);
      return [target];
    }
    applyMask(data2, mask, data2, 0, dataLength);
    return [target, data2];
  }
  /**
   * Sends a close message to the other peer.
   *
   * @param {Number} [code] The status code component of the body
   * @param {(String|Buffer)} [data] The message component of the body
   * @param {Boolean} [mask=false] Specifies whether or not to mask the message
   * @param {Function} [cb] Callback
   * @public
   */
  close(code, data2, mask, cb) {
    let buf;
    if (code === void 0) {
      buf = EMPTY_BUFFER$1;
    } else if (typeof code !== "number" || !isValidStatusCode(code)) {
      throw new TypeError("First argument must be a valid error code number");
    } else if (data2 === void 0 || !data2.length) {
      buf = Buffer.allocUnsafe(2);
      buf.writeUInt16BE(code, 0);
    } else {
      const length = Buffer.byteLength(data2);
      if (length > 123) {
        throw new RangeError("The message must not be greater than 123 bytes");
      }
      buf = Buffer.allocUnsafe(2 + length);
      buf.writeUInt16BE(code, 0);
      if (typeof data2 === "string") {
        buf.write(data2, 2);
      } else {
        buf.set(data2, 2);
      }
    }
    const options3 = {
      [kByteLength]: buf.length,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 8,
      readOnly: false,
      rsv1: false
    };
    if (this._deflating) {
      this.enqueue([this.dispatch, buf, false, options3, cb]);
    } else {
      this.sendFrame(Sender$1.frame(buf, options3), cb);
    }
  }
  /**
   * Sends a ping message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  ping(data2, mask, cb) {
    let byteLength;
    let readOnly;
    if (typeof data2 === "string") {
      byteLength = Buffer.byteLength(data2);
      readOnly = false;
    } else {
      data2 = toBuffer$1(data2);
      byteLength = data2.length;
      readOnly = toBuffer$1.readOnly;
    }
    if (byteLength > 125) {
      throw new RangeError("The data size must not be greater than 125 bytes");
    }
    const options3 = {
      [kByteLength]: byteLength,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 9,
      readOnly,
      rsv1: false
    };
    if (this._deflating) {
      this.enqueue([this.dispatch, data2, false, options3, cb]);
    } else {
      this.sendFrame(Sender$1.frame(data2, options3), cb);
    }
  }
  /**
   * Sends a pong message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  pong(data2, mask, cb) {
    let byteLength;
    let readOnly;
    if (typeof data2 === "string") {
      byteLength = Buffer.byteLength(data2);
      readOnly = false;
    } else {
      data2 = toBuffer$1(data2);
      byteLength = data2.length;
      readOnly = toBuffer$1.readOnly;
    }
    if (byteLength > 125) {
      throw new RangeError("The data size must not be greater than 125 bytes");
    }
    const options3 = {
      [kByteLength]: byteLength,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 10,
      readOnly,
      rsv1: false
    };
    if (this._deflating) {
      this.enqueue([this.dispatch, data2, false, options3, cb]);
    } else {
      this.sendFrame(Sender$1.frame(data2, options3), cb);
    }
  }
  /**
   * Sends a data message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Object} options Options object
   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
   *     or text
   * @param {Boolean} [options.compress=false] Specifies whether or not to
   *     compress `data`
   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Function} [cb] Callback
   * @public
   */
  send(data2, options3, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];
    let opcode = options3.binary ? 2 : 1;
    let rsv1 = options3.compress;
    let byteLength;
    let readOnly;
    if (typeof data2 === "string") {
      byteLength = Buffer.byteLength(data2);
      readOnly = false;
    } else {
      data2 = toBuffer$1(data2);
      byteLength = data2.length;
      readOnly = toBuffer$1.readOnly;
    }
    if (this._firstFragment) {
      this._firstFragment = false;
      if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
        rsv1 = byteLength >= perMessageDeflate._threshold;
      }
      this._compress = rsv1;
    } else {
      rsv1 = false;
      opcode = 0;
    }
    if (options3.fin)
      this._firstFragment = true;
    if (perMessageDeflate) {
      const opts = {
        [kByteLength]: byteLength,
        fin: options3.fin,
        generateMask: this._generateMask,
        mask: options3.mask,
        maskBuffer: this._maskBuffer,
        opcode,
        readOnly,
        rsv1
      };
      if (this._deflating) {
        this.enqueue([this.dispatch, data2, this._compress, opts, cb]);
      } else {
        this.dispatch(data2, this._compress, opts, cb);
      }
    } else {
      this.sendFrame(
        Sender$1.frame(data2, {
          [kByteLength]: byteLength,
          fin: options3.fin,
          generateMask: this._generateMask,
          mask: options3.mask,
          maskBuffer: this._maskBuffer,
          opcode,
          readOnly,
          rsv1: false
        }),
        cb
      );
    }
  }
  /**
   * Dispatches a message.
   *
   * @param {(Buffer|String)} data The message to send
   * @param {Boolean} [compress=false] Specifies whether or not to compress
   *     `data`
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @param {Function} [cb] Callback
   * @private
   */
  dispatch(data2, compress, options3, cb) {
    if (!compress) {
      this.sendFrame(Sender$1.frame(data2, options3), cb);
      return;
    }
    const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];
    this._bufferedBytes += options3[kByteLength];
    this._deflating = true;
    perMessageDeflate.compress(data2, options3.fin, (_, buf) => {
      if (this._socket.destroyed) {
        const err2 = new Error(
          "The socket was closed while data was being compressed"
        );
        if (typeof cb === "function")
          cb(err2);
        for (let i2 = 0; i2 < this._queue.length; i2++) {
          const params = this._queue[i2];
          const callback = params[params.length - 1];
          if (typeof callback === "function")
            callback(err2);
        }
        return;
      }
      this._bufferedBytes -= options3[kByteLength];
      this._deflating = false;
      options3.readOnly = false;
      this.sendFrame(Sender$1.frame(buf, options3), cb);
      this.dequeue();
    });
  }
  /**
   * Executes queued send operations.
   *
   * @private
   */
  dequeue() {
    while (!this._deflating && this._queue.length) {
      const params = this._queue.shift();
      this._bufferedBytes -= params[3][kByteLength];
      Reflect.apply(params[0], this, params.slice(1));
    }
  }
  /**
   * Enqueues a send operation.
   *
   * @param {Array} params Send operation parameters.
   * @private
   */
  enqueue(params) {
    this._bufferedBytes += params[3][kByteLength];
    this._queue.push(params);
  }
  /**
   * Sends a frame.
   *
   * @param {Buffer[]} list The frame to send
   * @param {Function} [cb] Callback
   * @private
   */
  sendFrame(list, cb) {
    if (list.length === 2) {
      this._socket.cork();
      this._socket.write(list[0]);
      this._socket.write(list[1], cb);
      this._socket.uncork();
    } else {
      this._socket.write(list[0], cb);
    }
  }
};
var sender = Sender$1;
var { kForOnEventAttribute: kForOnEventAttribute$1, kListener: kListener$1 } = constants;
var kCode = Symbol("kCode");
var kData = Symbol("kData");
var kError = Symbol("kError");
var kMessage = Symbol("kMessage");
var kReason = Symbol("kReason");
var kTarget = Symbol("kTarget");
var kType = Symbol("kType");
var kWasClean = Symbol("kWasClean");
var Event = class {
  /**
   * Create a new `Event`.
   *
   * @param {String} type The name of the event
   * @throws {TypeError} If the `type` argument is not specified
   */
  constructor(type) {
    this[kTarget] = null;
    this[kType] = type;
  }
  /**
   * @type {*}
   */
  get target() {
    return this[kTarget];
  }
  /**
   * @type {String}
   */
  get type() {
    return this[kType];
  }
};
Object.defineProperty(Event.prototype, "target", { enumerable: true });
Object.defineProperty(Event.prototype, "type", { enumerable: true });
var CloseEvent = class extends Event {
  /**
   * Create a new `CloseEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {Number} [options.code=0] The status code explaining why the
   *     connection was closed
   * @param {String} [options.reason=''] A human-readable string explaining why
   *     the connection was closed
   * @param {Boolean} [options.wasClean=false] Indicates whether or not the
   *     connection was cleanly closed
   */
  constructor(type, options3 = {}) {
    super(type);
    this[kCode] = options3.code === void 0 ? 0 : options3.code;
    this[kReason] = options3.reason === void 0 ? "" : options3.reason;
    this[kWasClean] = options3.wasClean === void 0 ? false : options3.wasClean;
  }
  /**
   * @type {Number}
   */
  get code() {
    return this[kCode];
  }
  /**
   * @type {String}
   */
  get reason() {
    return this[kReason];
  }
  /**
   * @type {Boolean}
   */
  get wasClean() {
    return this[kWasClean];
  }
};
Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
var ErrorEvent = class extends Event {
  /**
   * Create a new `ErrorEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.error=null] The error that generated this event
   * @param {String} [options.message=''] The error message
   */
  constructor(type, options3 = {}) {
    super(type);
    this[kError] = options3.error === void 0 ? null : options3.error;
    this[kMessage] = options3.message === void 0 ? "" : options3.message;
  }
  /**
   * @type {*}
   */
  get error() {
    return this[kError];
  }
  /**
   * @type {String}
   */
  get message() {
    return this[kMessage];
  }
};
Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
var MessageEvent = class extends Event {
  /**
   * Create a new `MessageEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.data=null] The message content
   */
  constructor(type, options3 = {}) {
    super(type);
    this[kData] = options3.data === void 0 ? null : options3.data;
  }
  /**
   * @type {*}
   */
  get data() {
    return this[kData];
  }
};
Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
var EventTarget = {
  /**
   * Register an event listener.
   *
   * @param {String} type A string representing the event type to listen for
   * @param {(Function|Object)} handler The listener to add
   * @param {Object} [options] An options object specifies characteristics about
   *     the event listener
   * @param {Boolean} [options.once=false] A `Boolean` indicating that the
   *     listener should be invoked at most once after being added. If `true`,
   *     the listener would be automatically removed when invoked.
   * @public
   */
  addEventListener(type, handler, options3 = {}) {
    for (const listener2 of this.listeners(type)) {
      if (!options3[kForOnEventAttribute$1] && listener2[kListener$1] === handler && !listener2[kForOnEventAttribute$1]) {
        return;
      }
    }
    let wrapper;
    if (type === "message") {
      wrapper = function onMessage(data2, isBinary) {
        const event = new MessageEvent("message", {
          data: isBinary ? data2 : data2.toString()
        });
        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === "close") {
      wrapper = function onClose(code, message) {
        const event = new CloseEvent("close", {
          code,
          reason: message.toString(),
          wasClean: this._closeFrameReceived && this._closeFrameSent
        });
        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === "error") {
      wrapper = function onError(error3) {
        const event = new ErrorEvent("error", {
          error: error3,
          message: error3.message
        });
        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === "open") {
      wrapper = function onOpen() {
        const event = new Event("open");
        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else {
      return;
    }
    wrapper[kForOnEventAttribute$1] = !!options3[kForOnEventAttribute$1];
    wrapper[kListener$1] = handler;
    if (options3.once) {
      this.once(type, wrapper);
    } else {
      this.on(type, wrapper);
    }
  },
  /**
   * Remove an event listener.
   *
   * @param {String} type A string representing the event type to remove
   * @param {(Function|Object)} handler The listener to remove
   * @public
   */
  removeEventListener(type, handler) {
    for (const listener2 of this.listeners(type)) {
      if (listener2[kListener$1] === handler && !listener2[kForOnEventAttribute$1]) {
        this.removeListener(type, listener2);
        break;
      }
    }
  }
};
var eventTarget = {
  CloseEvent,
  ErrorEvent,
  Event,
  EventTarget,
  MessageEvent
};
function callListener(listener2, thisArg, event) {
  if (typeof listener2 === "object" && listener2.handleEvent) {
    listener2.handleEvent.call(listener2, event);
  } else {
    listener2.call(thisArg, event);
  }
}
var { tokenChars: tokenChars$1 } = validationExports;
function push(dest, name2, elem) {
  if (dest[name2] === void 0)
    dest[name2] = [elem];
  else
    dest[name2].push(elem);
}
function parse$2(header) {
  const offers = /* @__PURE__ */ Object.create(null);
  let params = /* @__PURE__ */ Object.create(null);
  let mustUnescape = false;
  let isEscaping = false;
  let inQuotes = false;
  let extensionName;
  let paramName;
  let start = -1;
  let code = -1;
  let end = -1;
  let i2 = 0;
  for (; i2 < header.length; i2++) {
    code = header.charCodeAt(i2);
    if (extensionName === void 0) {
      if (end === -1 && tokenChars$1[code] === 1) {
        if (start === -1)
          start = i2;
      } else if (i2 !== 0 && (code === 32 || code === 9)) {
        if (end === -1 && start !== -1)
          end = i2;
      } else if (code === 59 || code === 44) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i2}`);
        }
        if (end === -1)
          end = i2;
        const name2 = header.slice(start, end);
        if (code === 44) {
          push(offers, name2, params);
          params = /* @__PURE__ */ Object.create(null);
        } else {
          extensionName = name2;
        }
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i2}`);
      }
    } else if (paramName === void 0) {
      if (end === -1 && tokenChars$1[code] === 1) {
        if (start === -1)
          start = i2;
      } else if (code === 32 || code === 9) {
        if (end === -1 && start !== -1)
          end = i2;
      } else if (code === 59 || code === 44) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i2}`);
        }
        if (end === -1)
          end = i2;
        push(params, header.slice(start, end), true);
        if (code === 44) {
          push(offers, extensionName, params);
          params = /* @__PURE__ */ Object.create(null);
          extensionName = void 0;
        }
        start = end = -1;
      } else if (code === 61 && start !== -1 && end === -1) {
        paramName = header.slice(start, i2);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i2}`);
      }
    } else {
      if (isEscaping) {
        if (tokenChars$1[code] !== 1) {
          throw new SyntaxError(`Unexpected character at index ${i2}`);
        }
        if (start === -1)
          start = i2;
        else if (!mustUnescape)
          mustUnescape = true;
        isEscaping = false;
      } else if (inQuotes) {
        if (tokenChars$1[code] === 1) {
          if (start === -1)
            start = i2;
        } else if (code === 34 && start !== -1) {
          inQuotes = false;
          end = i2;
        } else if (code === 92) {
          isEscaping = true;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i2}`);
        }
      } else if (code === 34 && header.charCodeAt(i2 - 1) === 61) {
        inQuotes = true;
      } else if (end === -1 && tokenChars$1[code] === 1) {
        if (start === -1)
          start = i2;
      } else if (start !== -1 && (code === 32 || code === 9)) {
        if (end === -1)
          end = i2;
      } else if (code === 59 || code === 44) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i2}`);
        }
        if (end === -1)
          end = i2;
        let value2 = header.slice(start, end);
        if (mustUnescape) {
          value2 = value2.replace(/\\/g, "");
          mustUnescape = false;
        }
        push(params, paramName, value2);
        if (code === 44) {
          push(offers, extensionName, params);
          params = /* @__PURE__ */ Object.create(null);
          extensionName = void 0;
        }
        paramName = void 0;
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i2}`);
      }
    }
  }
  if (start === -1 || inQuotes || code === 32 || code === 9) {
    throw new SyntaxError("Unexpected end of input");
  }
  if (end === -1)
    end = i2;
  const token = header.slice(start, end);
  if (extensionName === void 0) {
    push(offers, token, params);
  } else {
    if (paramName === void 0) {
      push(params, token, true);
    } else if (mustUnescape) {
      push(params, paramName, token.replace(/\\/g, ""));
    } else {
      push(params, paramName, token);
    }
    push(offers, extensionName, params);
  }
  return offers;
}
function format$1(extensions2) {
  return Object.keys(extensions2).map((extension2) => {
    let configurations = extensions2[extension2];
    if (!Array.isArray(configurations))
      configurations = [configurations];
    return configurations.map((params) => {
      return [extension2].concat(
        Object.keys(params).map((k) => {
          let values = params[k];
          if (!Array.isArray(values))
            values = [values];
          return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
        })
      ).join("; ");
    }).join(", ");
  }).join(", ");
}
var extension$1 = { format: format$1, parse: parse$2 };
var EventEmitter$1 = import_events.default;
var https$2 = import_https.default;
var http$3 = import_http.default;
var net = import_net.default;
var tls = import_tls.default;
var { randomBytes, createHash: createHash$1 } = import_crypto.default;
var { URL: URL$2 } = import_url3.default;
var PerMessageDeflate$1 = permessageDeflate;
var Receiver2 = receiver;
var Sender2 = sender;
var {
  BINARY_TYPES,
  EMPTY_BUFFER,
  GUID: GUID$1,
  kForOnEventAttribute,
  kListener,
  kStatusCode,
  kWebSocket: kWebSocket$1,
  NOOP
} = constants;
var {
  EventTarget: { addEventListener, removeEventListener }
} = eventTarget;
var { format, parse: parse$1 } = extension$1;
var { toBuffer } = bufferUtilExports;
var closeTimeout = 30 * 1e3;
var kAborted = Symbol("kAborted");
var protocolVersions = [8, 13];
var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
var WebSocket$1 = class WebSocket extends EventEmitter$1 {
  /**
   * Create a new `WebSocket`.
   *
   * @param {(String|URL)} address The URL to which to connect
   * @param {(String|String[])} [protocols] The subprotocols
   * @param {Object} [options] Connection options
   */
  constructor(address, protocols, options3) {
    super();
    this._binaryType = BINARY_TYPES[0];
    this._closeCode = 1006;
    this._closeFrameReceived = false;
    this._closeFrameSent = false;
    this._closeMessage = EMPTY_BUFFER;
    this._closeTimer = null;
    this._extensions = {};
    this._paused = false;
    this._protocol = "";
    this._readyState = WebSocket$1.CONNECTING;
    this._receiver = null;
    this._sender = null;
    this._socket = null;
    if (address !== null) {
      this._bufferedAmount = 0;
      this._isServer = false;
      this._redirects = 0;
      if (protocols === void 0) {
        protocols = [];
      } else if (!Array.isArray(protocols)) {
        if (typeof protocols === "object" && protocols !== null) {
          options3 = protocols;
          protocols = [];
        } else {
          protocols = [protocols];
        }
      }
      initAsClient(this, address, protocols, options3);
    } else {
      this._isServer = true;
    }
  }
  /**
   * This deviates from the WHATWG interface since ws doesn't support the
   * required default "blob" type (instead we define a custom "nodebuffer"
   * type).
   *
   * @type {String}
   */
  get binaryType() {
    return this._binaryType;
  }
  set binaryType(type) {
    if (!BINARY_TYPES.includes(type))
      return;
    this._binaryType = type;
    if (this._receiver)
      this._receiver._binaryType = type;
  }
  /**
   * @type {Number}
   */
  get bufferedAmount() {
    if (!this._socket)
      return this._bufferedAmount;
    return this._socket._writableState.length + this._sender._bufferedBytes;
  }
  /**
   * @type {String}
   */
  get extensions() {
    return Object.keys(this._extensions).join();
  }
  /**
   * @type {Boolean}
   */
  get isPaused() {
    return this._paused;
  }
  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onclose() {
    return null;
  }
  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onerror() {
    return null;
  }
  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onopen() {
    return null;
  }
  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onmessage() {
    return null;
  }
  /**
   * @type {String}
   */
  get protocol() {
    return this._protocol;
  }
  /**
   * @type {Number}
   */
  get readyState() {
    return this._readyState;
  }
  /**
   * @type {String}
   */
  get url() {
    return this._url;
  }
  /**
   * Set up the socket and the internal resources.
   *
   * @param {(net.Socket|tls.Socket)} socket The network socket between the
   *     server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Object} options Options object
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Number} [options.maxPayload=0] The maximum allowed message size
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @private
   */
  setSocket(socket, head, options3) {
    const receiver2 = new Receiver2({
      binaryType: this.binaryType,
      extensions: this._extensions,
      isServer: this._isServer,
      maxPayload: options3.maxPayload,
      skipUTF8Validation: options3.skipUTF8Validation
    });
    this._sender = new Sender2(socket, this._extensions, options3.generateMask);
    this._receiver = receiver2;
    this._socket = socket;
    receiver2[kWebSocket$1] = this;
    socket[kWebSocket$1] = this;
    receiver2.on("conclude", receiverOnConclude);
    receiver2.on("drain", receiverOnDrain);
    receiver2.on("error", receiverOnError);
    receiver2.on("message", receiverOnMessage);
    receiver2.on("ping", receiverOnPing);
    receiver2.on("pong", receiverOnPong);
    socket.setTimeout(0);
    socket.setNoDelay();
    if (head.length > 0)
      socket.unshift(head);
    socket.on("close", socketOnClose);
    socket.on("data", socketOnData);
    socket.on("end", socketOnEnd);
    socket.on("error", socketOnError$1);
    this._readyState = WebSocket$1.OPEN;
    this.emit("open");
  }
  /**
   * Emit the `'close'` event.
   *
   * @private
   */
  emitClose() {
    if (!this._socket) {
      this._readyState = WebSocket$1.CLOSED;
      this.emit("close", this._closeCode, this._closeMessage);
      return;
    }
    if (this._extensions[PerMessageDeflate$1.extensionName]) {
      this._extensions[PerMessageDeflate$1.extensionName].cleanup();
    }
    this._receiver.removeAllListeners();
    this._readyState = WebSocket$1.CLOSED;
    this.emit("close", this._closeCode, this._closeMessage);
  }
  /**
   * Start a closing handshake.
   *
   *          +----------+   +-----------+   +----------+
   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
   *    |     +----------+   +-----------+   +----------+     |
   *          +----------+   +-----------+         |
   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
   *          +----------+   +-----------+   |
   *    |           |                        |   +---+        |
   *                +------------------------+-->|fin| - - - -
   *    |         +---+                      |   +---+
   *     - - - - -|fin|<---------------------+
   *              +---+
   *
   * @param {Number} [code] Status code explaining why the connection is closing
   * @param {(String|Buffer)} [data] The reason why the connection is
   *     closing
   * @public
   */
  close(code, data2) {
    if (this.readyState === WebSocket$1.CLOSED)
      return;
    if (this.readyState === WebSocket$1.CONNECTING) {
      const msg = "WebSocket was closed before the connection was established";
      abortHandshake$1(this, this._req, msg);
      return;
    }
    if (this.readyState === WebSocket$1.CLOSING) {
      if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
        this._socket.end();
      }
      return;
    }
    this._readyState = WebSocket$1.CLOSING;
    this._sender.close(code, data2, !this._isServer, (err2) => {
      if (err2)
        return;
      this._closeFrameSent = true;
      if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
        this._socket.end();
      }
    });
    this._closeTimer = setTimeout(
      this._socket.destroy.bind(this._socket),
      closeTimeout
    );
  }
  /**
   * Pause the socket.
   *
   * @public
   */
  pause() {
    if (this.readyState === WebSocket$1.CONNECTING || this.readyState === WebSocket$1.CLOSED) {
      return;
    }
    this._paused = true;
    this._socket.pause();
  }
  /**
   * Send a ping.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the ping is sent
   * @public
   */
  ping(data2, mask, cb) {
    if (this.readyState === WebSocket$1.CONNECTING) {
      throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
    }
    if (typeof data2 === "function") {
      cb = data2;
      data2 = mask = void 0;
    } else if (typeof mask === "function") {
      cb = mask;
      mask = void 0;
    }
    if (typeof data2 === "number")
      data2 = data2.toString();
    if (this.readyState !== WebSocket$1.OPEN) {
      sendAfterClose(this, data2, cb);
      return;
    }
    if (mask === void 0)
      mask = !this._isServer;
    this._sender.ping(data2 || EMPTY_BUFFER, mask, cb);
  }
  /**
   * Send a pong.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the pong is sent
   * @public
   */
  pong(data2, mask, cb) {
    if (this.readyState === WebSocket$1.CONNECTING) {
      throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
    }
    if (typeof data2 === "function") {
      cb = data2;
      data2 = mask = void 0;
    } else if (typeof mask === "function") {
      cb = mask;
      mask = void 0;
    }
    if (typeof data2 === "number")
      data2 = data2.toString();
    if (this.readyState !== WebSocket$1.OPEN) {
      sendAfterClose(this, data2, cb);
      return;
    }
    if (mask === void 0)
      mask = !this._isServer;
    this._sender.pong(data2 || EMPTY_BUFFER, mask, cb);
  }
  /**
   * Resume the socket.
   *
   * @public
   */
  resume() {
    if (this.readyState === WebSocket$1.CONNECTING || this.readyState === WebSocket$1.CLOSED) {
      return;
    }
    this._paused = false;
    if (!this._receiver._writableState.needDrain)
      this._socket.resume();
  }
  /**
   * Send a data message.
   *
   * @param {*} data The message to send
   * @param {Object} [options] Options object
   * @param {Boolean} [options.binary] Specifies whether `data` is binary or
   *     text
   * @param {Boolean} [options.compress] Specifies whether or not to compress
   *     `data`
   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when data is written out
   * @public
   */
  send(data2, options3, cb) {
    if (this.readyState === WebSocket$1.CONNECTING) {
      throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
    }
    if (typeof options3 === "function") {
      cb = options3;
      options3 = {};
    }
    if (typeof data2 === "number")
      data2 = data2.toString();
    if (this.readyState !== WebSocket$1.OPEN) {
      sendAfterClose(this, data2, cb);
      return;
    }
    const opts = {
      binary: typeof data2 !== "string",
      mask: !this._isServer,
      compress: true,
      fin: true,
      ...options3
    };
    if (!this._extensions[PerMessageDeflate$1.extensionName]) {
      opts.compress = false;
    }
    this._sender.send(data2 || EMPTY_BUFFER, opts, cb);
  }
  /**
   * Forcibly close the connection.
   *
   * @public
   */
  terminate() {
    if (this.readyState === WebSocket$1.CLOSED)
      return;
    if (this.readyState === WebSocket$1.CONNECTING) {
      const msg = "WebSocket was closed before the connection was established";
      abortHandshake$1(this, this._req, msg);
      return;
    }
    if (this._socket) {
      this._readyState = WebSocket$1.CLOSING;
      this._socket.destroy();
    }
  }
};
Object.defineProperty(WebSocket$1, "CONNECTING", {
  enumerable: true,
  value: readyStates.indexOf("CONNECTING")
});
Object.defineProperty(WebSocket$1.prototype, "CONNECTING", {
  enumerable: true,
  value: readyStates.indexOf("CONNECTING")
});
Object.defineProperty(WebSocket$1, "OPEN", {
  enumerable: true,
  value: readyStates.indexOf("OPEN")
});
Object.defineProperty(WebSocket$1.prototype, "OPEN", {
  enumerable: true,
  value: readyStates.indexOf("OPEN")
});
Object.defineProperty(WebSocket$1, "CLOSING", {
  enumerable: true,
  value: readyStates.indexOf("CLOSING")
});
Object.defineProperty(WebSocket$1.prototype, "CLOSING", {
  enumerable: true,
  value: readyStates.indexOf("CLOSING")
});
Object.defineProperty(WebSocket$1, "CLOSED", {
  enumerable: true,
  value: readyStates.indexOf("CLOSED")
});
Object.defineProperty(WebSocket$1.prototype, "CLOSED", {
  enumerable: true,
  value: readyStates.indexOf("CLOSED")
});
[
  "binaryType",
  "bufferedAmount",
  "extensions",
  "isPaused",
  "protocol",
  "readyState",
  "url"
].forEach((property) => {
  Object.defineProperty(WebSocket$1.prototype, property, { enumerable: true });
});
["open", "error", "close", "message"].forEach((method) => {
  Object.defineProperty(WebSocket$1.prototype, `on${method}`, {
    enumerable: true,
    get() {
      for (const listener2 of this.listeners(method)) {
        if (listener2[kForOnEventAttribute])
          return listener2[kListener];
      }
      return null;
    },
    set(handler) {
      for (const listener2 of this.listeners(method)) {
        if (listener2[kForOnEventAttribute]) {
          this.removeListener(method, listener2);
          break;
        }
      }
      if (typeof handler !== "function")
        return;
      this.addEventListener(method, handler, {
        [kForOnEventAttribute]: true
      });
    }
  });
});
WebSocket$1.prototype.addEventListener = addEventListener;
WebSocket$1.prototype.removeEventListener = removeEventListener;
var websocket = WebSocket$1;
function initAsClient(websocket2, address, protocols, options3) {
  const opts = {
    protocolVersion: protocolVersions[1],
    maxPayload: 100 * 1024 * 1024,
    skipUTF8Validation: false,
    perMessageDeflate: true,
    followRedirects: false,
    maxRedirects: 10,
    ...options3,
    createConnection: void 0,
    socketPath: void 0,
    hostname: void 0,
    protocol: void 0,
    timeout: void 0,
    method: "GET",
    host: void 0,
    path: void 0,
    port: void 0
  };
  if (!protocolVersions.includes(opts.protocolVersion)) {
    throw new RangeError(
      `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
    );
  }
  let parsedUrl;
  if (address instanceof URL$2) {
    parsedUrl = address;
    websocket2._url = address.href;
  } else {
    try {
      parsedUrl = new URL$2(address);
    } catch (e3) {
      throw new SyntaxError(`Invalid URL: ${address}`);
    }
    websocket2._url = address;
  }
  const isSecure = parsedUrl.protocol === "wss:";
  const isIpcUrl = parsedUrl.protocol === "ws+unix:";
  let invalidUrlMessage;
  if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
    invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", or "ws+unix:"`;
  } else if (isIpcUrl && !parsedUrl.pathname) {
    invalidUrlMessage = "The URL's pathname is empty";
  } else if (parsedUrl.hash) {
    invalidUrlMessage = "The URL contains a fragment identifier";
  }
  if (invalidUrlMessage) {
    const err2 = new SyntaxError(invalidUrlMessage);
    if (websocket2._redirects === 0) {
      throw err2;
    } else {
      emitErrorAndClose(websocket2, err2);
      return;
    }
  }
  const defaultPort = isSecure ? 443 : 80;
  const key = randomBytes(16).toString("base64");
  const request = isSecure ? https$2.request : http$3.request;
  const protocolSet = /* @__PURE__ */ new Set();
  let perMessageDeflate;
  opts.createConnection = isSecure ? tlsConnect : netConnect;
  opts.defaultPort = opts.defaultPort || defaultPort;
  opts.port = parsedUrl.port || defaultPort;
  opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
  opts.headers = {
    ...opts.headers,
    "Sec-WebSocket-Version": opts.protocolVersion,
    "Sec-WebSocket-Key": key,
    Connection: "Upgrade",
    Upgrade: "websocket"
  };
  opts.path = parsedUrl.pathname + parsedUrl.search;
  opts.timeout = opts.handshakeTimeout;
  if (opts.perMessageDeflate) {
    perMessageDeflate = new PerMessageDeflate$1(
      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
      false,
      opts.maxPayload
    );
    opts.headers["Sec-WebSocket-Extensions"] = format({
      [PerMessageDeflate$1.extensionName]: perMessageDeflate.offer()
    });
  }
  if (protocols.length) {
    for (const protocol of protocols) {
      if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
        throw new SyntaxError(
          "An invalid or duplicated subprotocol was specified"
        );
      }
      protocolSet.add(protocol);
    }
    opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
  }
  if (opts.origin) {
    if (opts.protocolVersion < 13) {
      opts.headers["Sec-WebSocket-Origin"] = opts.origin;
    } else {
      opts.headers.Origin = opts.origin;
    }
  }
  if (parsedUrl.username || parsedUrl.password) {
    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
  }
  if (isIpcUrl) {
    const parts = opts.path.split(":");
    opts.socketPath = parts[0];
    opts.path = parts[1];
  }
  let req2;
  if (opts.followRedirects) {
    if (websocket2._redirects === 0) {
      websocket2._originalIpc = isIpcUrl;
      websocket2._originalSecure = isSecure;
      websocket2._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
      const headers = options3 && options3.headers;
      options3 = { ...options3, headers: {} };
      if (headers) {
        for (const [key2, value2] of Object.entries(headers)) {
          options3.headers[key2.toLowerCase()] = value2;
        }
      }
    } else if (websocket2.listenerCount("redirect") === 0) {
      const isSameHost = isIpcUrl ? websocket2._originalIpc ? opts.socketPath === websocket2._originalHostOrSocketPath : false : websocket2._originalIpc ? false : parsedUrl.host === websocket2._originalHostOrSocketPath;
      if (!isSameHost || websocket2._originalSecure && !isSecure) {
        delete opts.headers.authorization;
        delete opts.headers.cookie;
        if (!isSameHost)
          delete opts.headers.host;
        opts.auth = void 0;
      }
    }
    if (opts.auth && !options3.headers.authorization) {
      options3.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
    }
    req2 = websocket2._req = request(opts);
    if (websocket2._redirects) {
      websocket2.emit("redirect", websocket2.url, req2);
    }
  } else {
    req2 = websocket2._req = request(opts);
  }
  if (opts.timeout) {
    req2.on("timeout", () => {
      abortHandshake$1(websocket2, req2, "Opening handshake has timed out");
    });
  }
  req2.on("error", (err2) => {
    if (req2 === null || req2[kAborted])
      return;
    req2 = websocket2._req = null;
    emitErrorAndClose(websocket2, err2);
  });
  req2.on("response", (res) => {
    const location2 = res.headers.location;
    const statusCode = res.statusCode;
    if (location2 && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
      if (++websocket2._redirects > opts.maxRedirects) {
        abortHandshake$1(websocket2, req2, "Maximum redirects exceeded");
        return;
      }
      req2.abort();
      let addr;
      try {
        addr = new URL$2(location2, address);
      } catch (e3) {
        const err2 = new SyntaxError(`Invalid URL: ${location2}`);
        emitErrorAndClose(websocket2, err2);
        return;
      }
      initAsClient(websocket2, addr, protocols, options3);
    } else if (!websocket2.emit("unexpected-response", req2, res)) {
      abortHandshake$1(
        websocket2,
        req2,
        `Unexpected server response: ${res.statusCode}`
      );
    }
  });
  req2.on("upgrade", (res, socket, head) => {
    websocket2.emit("upgrade", res);
    if (websocket2.readyState !== WebSocket$1.CONNECTING)
      return;
    req2 = websocket2._req = null;
    if (res.headers.upgrade.toLowerCase() !== "websocket") {
      abortHandshake$1(websocket2, socket, "Invalid Upgrade header");
      return;
    }
    const digest = createHash$1("sha1").update(key + GUID$1).digest("base64");
    if (res.headers["sec-websocket-accept"] !== digest) {
      abortHandshake$1(websocket2, socket, "Invalid Sec-WebSocket-Accept header");
      return;
    }
    const serverProt = res.headers["sec-websocket-protocol"];
    let protError;
    if (serverProt !== void 0) {
      if (!protocolSet.size) {
        protError = "Server sent a subprotocol but none was requested";
      } else if (!protocolSet.has(serverProt)) {
        protError = "Server sent an invalid subprotocol";
      }
    } else if (protocolSet.size) {
      protError = "Server sent no subprotocol";
    }
    if (protError) {
      abortHandshake$1(websocket2, socket, protError);
      return;
    }
    if (serverProt)
      websocket2._protocol = serverProt;
    const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
    if (secWebSocketExtensions !== void 0) {
      if (!perMessageDeflate) {
        const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
        abortHandshake$1(websocket2, socket, message);
        return;
      }
      let extensions2;
      try {
        extensions2 = parse$1(secWebSocketExtensions);
      } catch (err2) {
        const message = "Invalid Sec-WebSocket-Extensions header";
        abortHandshake$1(websocket2, socket, message);
        return;
      }
      const extensionNames = Object.keys(extensions2);
      if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate$1.extensionName) {
        const message = "Server indicated an extension that was not requested";
        abortHandshake$1(websocket2, socket, message);
        return;
      }
      try {
        perMessageDeflate.accept(extensions2[PerMessageDeflate$1.extensionName]);
      } catch (err2) {
        const message = "Invalid Sec-WebSocket-Extensions header";
        abortHandshake$1(websocket2, socket, message);
        return;
      }
      websocket2._extensions[PerMessageDeflate$1.extensionName] = perMessageDeflate;
    }
    websocket2.setSocket(socket, head, {
      generateMask: opts.generateMask,
      maxPayload: opts.maxPayload,
      skipUTF8Validation: opts.skipUTF8Validation
    });
  });
  req2.end();
}
function emitErrorAndClose(websocket2, err2) {
  websocket2._readyState = WebSocket$1.CLOSING;
  websocket2.emit("error", err2);
  websocket2.emitClose();
}
function netConnect(options3) {
  options3.path = options3.socketPath;
  return net.connect(options3);
}
function tlsConnect(options3) {
  options3.path = void 0;
  if (!options3.servername && options3.servername !== "") {
    options3.servername = net.isIP(options3.host) ? "" : options3.host;
  }
  return tls.connect(options3);
}
function abortHandshake$1(websocket2, stream4, message) {
  websocket2._readyState = WebSocket$1.CLOSING;
  const err2 = new Error(message);
  Error.captureStackTrace(err2, abortHandshake$1);
  if (stream4.setHeader) {
    stream4[kAborted] = true;
    stream4.abort();
    if (stream4.socket && !stream4.socket.destroyed) {
      stream4.socket.destroy();
    }
    process.nextTick(emitErrorAndClose, websocket2, err2);
  } else {
    stream4.destroy(err2);
    stream4.once("error", websocket2.emit.bind(websocket2, "error"));
    stream4.once("close", websocket2.emitClose.bind(websocket2));
  }
}
function sendAfterClose(websocket2, data2, cb) {
  if (data2) {
    const length = toBuffer(data2).length;
    if (websocket2._socket)
      websocket2._sender._bufferedBytes += length;
    else
      websocket2._bufferedAmount += length;
  }
  if (cb) {
    const err2 = new Error(
      `WebSocket is not open: readyState ${websocket2.readyState} (${readyStates[websocket2.readyState]})`
    );
    process.nextTick(cb, err2);
  }
}
function receiverOnConclude(code, reason) {
  const websocket2 = this[kWebSocket$1];
  websocket2._closeFrameReceived = true;
  websocket2._closeMessage = reason;
  websocket2._closeCode = code;
  if (websocket2._socket[kWebSocket$1] === void 0)
    return;
  websocket2._socket.removeListener("data", socketOnData);
  process.nextTick(resume, websocket2._socket);
  if (code === 1005)
    websocket2.close();
  else
    websocket2.close(code, reason);
}
function receiverOnDrain() {
  const websocket2 = this[kWebSocket$1];
  if (!websocket2.isPaused)
    websocket2._socket.resume();
}
function receiverOnError(err2) {
  const websocket2 = this[kWebSocket$1];
  if (websocket2._socket[kWebSocket$1] !== void 0) {
    websocket2._socket.removeListener("data", socketOnData);
    process.nextTick(resume, websocket2._socket);
    websocket2.close(err2[kStatusCode]);
  }
  websocket2.emit("error", err2);
}
function receiverOnFinish() {
  this[kWebSocket$1].emitClose();
}
function receiverOnMessage(data2, isBinary) {
  this[kWebSocket$1].emit("message", data2, isBinary);
}
function receiverOnPing(data2) {
  const websocket2 = this[kWebSocket$1];
  websocket2.pong(data2, !websocket2._isServer, NOOP);
  websocket2.emit("ping", data2);
}
function receiverOnPong(data2) {
  this[kWebSocket$1].emit("pong", data2);
}
function resume(stream4) {
  stream4.resume();
}
function socketOnClose() {
  const websocket2 = this[kWebSocket$1];
  this.removeListener("close", socketOnClose);
  this.removeListener("data", socketOnData);
  this.removeListener("end", socketOnEnd);
  websocket2._readyState = WebSocket$1.CLOSING;
  let chunk;
  if (!this._readableState.endEmitted && !websocket2._closeFrameReceived && !websocket2._receiver._writableState.errorEmitted && (chunk = websocket2._socket.read()) !== null) {
    websocket2._receiver.write(chunk);
  }
  websocket2._receiver.end();
  this[kWebSocket$1] = void 0;
  clearTimeout(websocket2._closeTimer);
  if (websocket2._receiver._writableState.finished || websocket2._receiver._writableState.errorEmitted) {
    websocket2.emitClose();
  } else {
    websocket2._receiver.on("error", receiverOnFinish);
    websocket2._receiver.on("finish", receiverOnFinish);
  }
}
function socketOnData(chunk) {
  if (!this[kWebSocket$1]._receiver.write(chunk)) {
    this.pause();
  }
}
function socketOnEnd() {
  const websocket2 = this[kWebSocket$1];
  websocket2._readyState = WebSocket$1.CLOSING;
  websocket2._receiver.end();
  this.end();
}
function socketOnError$1() {
  const websocket2 = this[kWebSocket$1];
  this.removeListener("error", socketOnError$1);
  this.on("error", NOOP);
  if (websocket2) {
    websocket2._readyState = WebSocket$1.CLOSING;
    this.destroy();
  }
}
var { tokenChars } = validationExports;
function parse5(header) {
  const protocols = /* @__PURE__ */ new Set();
  let start = -1;
  let end = -1;
  let i2 = 0;
  for (i2; i2 < header.length; i2++) {
    const code = header.charCodeAt(i2);
    if (end === -1 && tokenChars[code] === 1) {
      if (start === -1)
        start = i2;
    } else if (i2 !== 0 && (code === 32 || code === 9)) {
      if (end === -1 && start !== -1)
        end = i2;
    } else if (code === 44) {
      if (start === -1) {
        throw new SyntaxError(`Unexpected character at index ${i2}`);
      }
      if (end === -1)
        end = i2;
      const protocol2 = header.slice(start, end);
      if (protocols.has(protocol2)) {
        throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
      }
      protocols.add(protocol2);
      start = end = -1;
    } else {
      throw new SyntaxError(`Unexpected character at index ${i2}`);
    }
  }
  if (start === -1 || end !== -1) {
    throw new SyntaxError("Unexpected end of input");
  }
  const protocol = header.slice(start, i2);
  if (protocols.has(protocol)) {
    throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
  }
  protocols.add(protocol);
  return protocols;
}
var subprotocol$1 = { parse: parse5 };
var EventEmitter = import_events.default;
var http$2 = import_http.default;
var { createHash } = import_crypto.default;
var extension = extension$1;
var PerMessageDeflate2 = permessageDeflate;
var subprotocol = subprotocol$1;
var WebSocket2 = websocket;
var { GUID, kWebSocket } = constants;
var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
var RUNNING = 0;
var CLOSING = 1;
var CLOSED = 2;
var WebSocketServer = class extends EventEmitter {
  /**
   * Create a `WebSocketServer` instance.
   *
   * @param {Object} options Configuration options
   * @param {Number} [options.backlog=511] The maximum length of the queue of
   *     pending connections
   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
   *     track clients
   * @param {Function} [options.handleProtocols] A hook to handle protocols
   * @param {String} [options.host] The hostname where to bind the server
   * @param {Number} [options.maxPayload=104857600] The maximum allowed message
   *     size
   * @param {Boolean} [options.noServer=false] Enable no server mode
   * @param {String} [options.path] Accept only connections matching this path
   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
   *     permessage-deflate
   * @param {Number} [options.port] The port where to bind the server
   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
   *     server to use
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @param {Function} [options.verifyClient] A hook to reject connections
   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
   *     class to use. It must be the `WebSocket` class or class that extends it
   * @param {Function} [callback] A listener for the `listening` event
   */
  constructor(options3, callback) {
    super();
    options3 = {
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: false,
      perMessageDeflate: false,
      handleProtocols: null,
      clientTracking: true,
      verifyClient: null,
      noServer: false,
      backlog: null,
      // use default (511 as implemented in net.js)
      server: null,
      host: null,
      path: null,
      port: null,
      WebSocket: WebSocket2,
      ...options3
    };
    if (options3.port == null && !options3.server && !options3.noServer || options3.port != null && (options3.server || options3.noServer) || options3.server && options3.noServer) {
      throw new TypeError(
        'One and only one of the "port", "server", or "noServer" options must be specified'
      );
    }
    if (options3.port != null) {
      this._server = http$2.createServer((req2, res) => {
        const body = http$2.STATUS_CODES[426];
        res.writeHead(426, {
          "Content-Length": body.length,
          "Content-Type": "text/plain"
        });
        res.end(body);
      });
      this._server.listen(
        options3.port,
        options3.host,
        options3.backlog,
        callback
      );
    } else if (options3.server) {
      this._server = options3.server;
    }
    if (this._server) {
      const emitConnection = this.emit.bind(this, "connection");
      this._removeListeners = addListeners(this._server, {
        listening: this.emit.bind(this, "listening"),
        error: this.emit.bind(this, "error"),
        upgrade: (req2, socket, head) => {
          this.handleUpgrade(req2, socket, head, emitConnection);
        }
      });
    }
    if (options3.perMessageDeflate === true)
      options3.perMessageDeflate = {};
    if (options3.clientTracking) {
      this.clients = /* @__PURE__ */ new Set();
      this._shouldEmitClose = false;
    }
    this.options = options3;
    this._state = RUNNING;
  }
  /**
   * Returns the bound address, the address family name, and port of the server
   * as reported by the operating system if listening on an IP socket.
   * If the server is listening on a pipe or UNIX domain socket, the name is
   * returned as a string.
   *
   * @return {(Object|String|null)} The address of the server
   * @public
   */
  address() {
    if (this.options.noServer) {
      throw new Error('The server is operating in "noServer" mode');
    }
    if (!this._server)
      return null;
    return this._server.address();
  }
  /**
   * Stop the server from accepting new connections and emit the `'close'` event
   * when all existing connections are closed.
   *
   * @param {Function} [cb] A one-time listener for the `'close'` event
   * @public
   */
  close(cb) {
    if (this._state === CLOSED) {
      if (cb) {
        this.once("close", () => {
          cb(new Error("The server is not running"));
        });
      }
      process.nextTick(emitClose, this);
      return;
    }
    if (cb)
      this.once("close", cb);
    if (this._state === CLOSING)
      return;
    this._state = CLOSING;
    if (this.options.noServer || this.options.server) {
      if (this._server) {
        this._removeListeners();
        this._removeListeners = this._server = null;
      }
      if (this.clients) {
        if (!this.clients.size) {
          process.nextTick(emitClose, this);
        } else {
          this._shouldEmitClose = true;
        }
      } else {
        process.nextTick(emitClose, this);
      }
    } else {
      const server2 = this._server;
      this._removeListeners();
      this._removeListeners = this._server = null;
      server2.close(() => {
        emitClose(this);
      });
    }
  }
  /**
   * See if a given request should be handled by this server instance.
   *
   * @param {http.IncomingMessage} req Request object to inspect
   * @return {Boolean} `true` if the request is valid, else `false`
   * @public
   */
  shouldHandle(req2) {
    if (this.options.path) {
      const index2 = req2.url.indexOf("?");
      const pathname = index2 !== -1 ? req2.url.slice(0, index2) : req2.url;
      if (pathname !== this.options.path)
        return false;
    }
    return true;
  }
  /**
   * Handle a HTTP Upgrade request.
   *
   * @param {http.IncomingMessage} req The request object
   * @param {(net.Socket|tls.Socket)} socket The network socket between the
   *     server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @public
   */
  handleUpgrade(req2, socket, head, cb) {
    socket.on("error", socketOnError);
    const key = req2.headers["sec-websocket-key"];
    const version4 = +req2.headers["sec-websocket-version"];
    if (req2.method !== "GET") {
      const message = "Invalid HTTP method";
      abortHandshakeOrEmitwsClientError(this, req2, socket, 405, message);
      return;
    }
    if (req2.headers.upgrade.toLowerCase() !== "websocket") {
      const message = "Invalid Upgrade header";
      abortHandshakeOrEmitwsClientError(this, req2, socket, 400, message);
      return;
    }
    if (!key || !keyRegex.test(key)) {
      const message = "Missing or invalid Sec-WebSocket-Key header";
      abortHandshakeOrEmitwsClientError(this, req2, socket, 400, message);
      return;
    }
    if (version4 !== 8 && version4 !== 13) {
      const message = "Missing or invalid Sec-WebSocket-Version header";
      abortHandshakeOrEmitwsClientError(this, req2, socket, 400, message);
      return;
    }
    if (!this.shouldHandle(req2)) {
      abortHandshake(socket, 400);
      return;
    }
    const secWebSocketProtocol = req2.headers["sec-websocket-protocol"];
    let protocols = /* @__PURE__ */ new Set();
    if (secWebSocketProtocol !== void 0) {
      try {
        protocols = subprotocol.parse(secWebSocketProtocol);
      } catch (err2) {
        const message = "Invalid Sec-WebSocket-Protocol header";
        abortHandshakeOrEmitwsClientError(this, req2, socket, 400, message);
        return;
      }
    }
    const secWebSocketExtensions = req2.headers["sec-websocket-extensions"];
    const extensions2 = {};
    if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
      const perMessageDeflate = new PerMessageDeflate2(
        this.options.perMessageDeflate,
        true,
        this.options.maxPayload
      );
      try {
        const offers = extension.parse(secWebSocketExtensions);
        if (offers[PerMessageDeflate2.extensionName]) {
          perMessageDeflate.accept(offers[PerMessageDeflate2.extensionName]);
          extensions2[PerMessageDeflate2.extensionName] = perMessageDeflate;
        }
      } catch (err2) {
        const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
        abortHandshakeOrEmitwsClientError(this, req2, socket, 400, message);
        return;
      }
    }
    if (this.options.verifyClient) {
      const info3 = {
        origin: req2.headers[`${version4 === 8 ? "sec-websocket-origin" : "origin"}`],
        secure: !!(req2.socket.authorized || req2.socket.encrypted),
        req: req2
      };
      if (this.options.verifyClient.length === 2) {
        this.options.verifyClient(info3, (verified, code, message, headers) => {
          if (!verified) {
            return abortHandshake(socket, code || 401, message, headers);
          }
          this.completeUpgrade(
            extensions2,
            key,
            protocols,
            req2,
            socket,
            head,
            cb
          );
        });
        return;
      }
      if (!this.options.verifyClient(info3))
        return abortHandshake(socket, 401);
    }
    this.completeUpgrade(extensions2, key, protocols, req2, socket, head, cb);
  }
  /**
   * Upgrade the connection to WebSocket.
   *
   * @param {Object} extensions The accepted extensions
   * @param {String} key The value of the `Sec-WebSocket-Key` header
   * @param {Set} protocols The subprotocols
   * @param {http.IncomingMessage} req The request object
   * @param {(net.Socket|tls.Socket)} socket The network socket between the
   *     server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @throws {Error} If called more than once with the same socket
   * @private
   */
  completeUpgrade(extensions2, key, protocols, req2, socket, head, cb) {
    if (!socket.readable || !socket.writable)
      return socket.destroy();
    if (socket[kWebSocket]) {
      throw new Error(
        "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
      );
    }
    if (this._state > RUNNING)
      return abortHandshake(socket, 503);
    const digest = createHash("sha1").update(key + GUID).digest("base64");
    const headers = [
      "HTTP/1.1 101 Switching Protocols",
      "Upgrade: websocket",
      "Connection: Upgrade",
      `Sec-WebSocket-Accept: ${digest}`
    ];
    const ws = new this.options.WebSocket(null);
    if (protocols.size) {
      const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req2) : protocols.values().next().value;
      if (protocol) {
        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
        ws._protocol = protocol;
      }
    }
    if (extensions2[PerMessageDeflate2.extensionName]) {
      const params = extensions2[PerMessageDeflate2.extensionName].params;
      const value2 = extension.format({
        [PerMessageDeflate2.extensionName]: [params]
      });
      headers.push(`Sec-WebSocket-Extensions: ${value2}`);
      ws._extensions = extensions2;
    }
    this.emit("headers", headers, req2);
    socket.write(headers.concat("\r\n").join("\r\n"));
    socket.removeListener("error", socketOnError);
    ws.setSocket(socket, head, {
      maxPayload: this.options.maxPayload,
      skipUTF8Validation: this.options.skipUTF8Validation
    });
    if (this.clients) {
      this.clients.add(ws);
      ws.on("close", () => {
        this.clients.delete(ws);
        if (this._shouldEmitClose && !this.clients.size) {
          process.nextTick(emitClose, this);
        }
      });
    }
    cb(ws, req2);
  }
};
var websocketServer = WebSocketServer;
function addListeners(server2, map3) {
  for (const event of Object.keys(map3))
    server2.on(event, map3[event]);
  return function removeListeners() {
    for (const event of Object.keys(map3)) {
      server2.removeListener(event, map3[event]);
    }
  };
}
function emitClose(server2) {
  server2._state = CLOSED;
  server2.emit("close");
}
function socketOnError() {
  this.destroy();
}
function abortHandshake(socket, code, message, headers) {
  message = message || http$2.STATUS_CODES[code];
  headers = {
    Connection: "close",
    "Content-Type": "text/html",
    "Content-Length": Buffer.byteLength(message),
    ...headers
  };
  socket.once("finish", socket.destroy);
  socket.end(
    `HTTP/1.1 ${code} ${http$2.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message
  );
}
function abortHandshakeOrEmitwsClientError(server2, req2, socket, code, message) {
  if (server2.listenerCount("wsClientError")) {
    const err2 = new Error(message);
    Error.captureStackTrace(err2, abortHandshakeOrEmitwsClientError);
    server2.emit("wsClientError", err2, socket, req2);
  } else {
    abortHandshake(socket, code, message);
  }
}
var HMR_HEADER = "vite-hmr";
var wsServerEvents = [
  "connection",
  "error",
  "headers",
  "listening",
  "message"
];
function createWebSocketServer(server2, config2, httpsOptions) {
  let wss;
  let httpsServer = void 0;
  const hmr = isObject$1(config2.server.hmr) && config2.server.hmr;
  const hmrServer = hmr && hmr.server;
  const hmrPort = hmr && hmr.port;
  const portsAreCompatible = !hmrPort || hmrPort === config2.server.port;
  const wsServer = hmrServer || portsAreCompatible && server2;
  const customListeners = /* @__PURE__ */ new Map();
  const clientsMap = /* @__PURE__ */ new WeakMap();
  if (wsServer) {
    wss = new websocketServer({ noServer: true });
    wsServer.on("upgrade", (req2, socket, head) => {
      if (req2.headers["sec-websocket-protocol"] === HMR_HEADER) {
        wss.handleUpgrade(req2, socket, head, (ws) => {
          wss.emit("connection", ws, req2);
        });
      }
    });
  } else {
    const websocketServerOptions = {};
    const port = hmrPort || 24678;
    const host = hmr && hmr.host || void 0;
    if (httpsOptions) {
      httpsServer = (0, import_node_https.createServer)(httpsOptions, (req2, res) => {
        const statusCode = 426;
        const body = import_node_http.STATUS_CODES[statusCode];
        if (!body)
          throw new Error(`No body text found for the ${statusCode} status code`);
        res.writeHead(statusCode, {
          "Content-Length": body.length,
          "Content-Type": "text/plain"
        });
        res.end(body);
      });
      httpsServer.listen(port, host);
      websocketServerOptions.server = httpsServer;
    } else {
      websocketServerOptions.port = port;
      if (host) {
        websocketServerOptions.host = host;
      }
    }
    wss = new websocketServer(websocketServerOptions);
  }
  wss.on("connection", (socket) => {
    socket.on("message", (raw) => {
      if (!customListeners.size)
        return;
      let parsed;
      try {
        parsed = JSON.parse(String(raw));
      } catch {
      }
      if (!parsed || parsed.type !== "custom" || !parsed.event)
        return;
      const listeners = customListeners.get(parsed.event);
      if (!(listeners == null ? void 0 : listeners.size))
        return;
      const client = getSocketClient(socket);
      listeners.forEach((listener2) => listener2(parsed.data, client));
    });
    socket.on("error", (err2) => {
      config2.logger.error(`${picocolorsExports.red(`ws error:`)}
${err2.stack}`, {
        timestamp: true,
        error: err2
      });
    });
    socket.send(JSON.stringify({ type: "connected" }));
    if (bufferedError) {
      socket.send(JSON.stringify(bufferedError));
      bufferedError = null;
    }
  });
  wss.on("error", (e3) => {
    if (e3.code === "EADDRINUSE") {
      config2.logger.error(picocolorsExports.red(`WebSocket server error: Port is already in use`), { error: e3 });
    } else {
      config2.logger.error(picocolorsExports.red(`WebSocket server error:
${e3.stack || e3.message}`), { error: e3 });
    }
  });
  function getSocketClient(socket) {
    if (!clientsMap.has(socket)) {
      clientsMap.set(socket, {
        send: (...args) => {
          let payload;
          if (typeof args[0] === "string") {
            payload = {
              type: "custom",
              event: args[0],
              data: args[1]
            };
          } else {
            payload = args[0];
          }
          socket.send(JSON.stringify(payload));
        },
        socket
      });
    }
    return clientsMap.get(socket);
  }
  let bufferedError = null;
  return {
    on: (event, fn) => {
      if (wsServerEvents.includes(event))
        wss.on(event, fn);
      else {
        if (!customListeners.has(event)) {
          customListeners.set(event, /* @__PURE__ */ new Set());
        }
        customListeners.get(event).add(fn);
      }
    },
    off: (event, fn) => {
      var _a;
      if (wsServerEvents.includes(event)) {
        wss.off(event, fn);
      } else {
        (_a = customListeners.get(event)) == null ? void 0 : _a.delete(fn);
      }
    },
    get clients() {
      return new Set(Array.from(wss.clients).map(getSocketClient));
    },
    send(...args) {
      let payload;
      if (typeof args[0] === "string") {
        payload = {
          type: "custom",
          event: args[0],
          data: args[1]
        };
      } else {
        payload = args[0];
      }
      if (payload.type === "error" && !wss.clients.size) {
        bufferedError = payload;
        return;
      }
      const stringified = JSON.stringify(payload);
      wss.clients.forEach((client) => {
        if (client.readyState === 1) {
          client.send(stringified);
        }
      });
    },
    close() {
      return new Promise((resolve4, reject) => {
        wss.clients.forEach((client) => {
          client.terminate();
        });
        wss.close((err2) => {
          if (err2) {
            reject(err2);
          } else {
            if (httpsServer) {
              httpsServer.close((err3) => {
                if (err3) {
                  reject(err3);
                } else {
                  resolve4();
                }
              });
            } else {
              resolve4();
            }
          }
        });
      });
    }
  };
}
function baseMiddleware({ config: config2 }) {
  return function viteBaseMiddleware(req2, res, next) {
    var _a;
    const url2 = req2.url;
    const parsed = new URL(url2, "http://vitejs.dev");
    const path8 = parsed.pathname || "/";
    const base2 = config2.rawBase;
    if (path8.startsWith(base2)) {
      req2.url = stripBase(url2, base2);
      return next();
    }
    if (config2.server.middlewareMode) {
      return next();
    }
    if (path8 === "/" || path8 === "/index.html") {
      res.writeHead(302, {
        Location: base2 + (parsed.search || "") + (parsed.hash || "")
      });
      res.end();
      return;
    } else if ((_a = req2.headers.accept) == null ? void 0 : _a.includes("text/html")) {
      const redirectPath = url2 + "/" !== base2 ? joinUrlSegments(base2, url2) : base2;
      res.writeHead(404, {
        "Content-Type": "text/html"
      });
      res.end(`The server is configured with a public base URL of ${base2} - did you mean to visit <a href="${redirectPath}">${redirectPath}</a> instead?`);
      return;
    }
    next();
  };
}
var httpProxyExports$1 = {};
var httpProxy$3 = {
  get exports() {
    return httpProxyExports$1;
  },
  set exports(v) {
    httpProxyExports$1 = v;
  }
};
var httpProxyExports = {};
var httpProxy$2 = {
  get exports() {
    return httpProxyExports;
  },
  set exports(v) {
    httpProxyExports = v;
  }
};
var eventemitter3Exports = {};
var eventemitter3 = {
  get exports() {
    return eventemitter3Exports;
  },
  set exports(v) {
    eventemitter3Exports = v;
  }
};
(function(module2) {
  var has = Object.prototype.hasOwnProperty, prefix = "~";
  function Events() {
  }
  if (Object.create) {
    Events.prototype = /* @__PURE__ */ Object.create(null);
    if (!new Events().__proto__)
      prefix = false;
  }
  function EE(fn, context, once2) {
    this.fn = fn;
    this.context = context;
    this.once = once2 || false;
  }
  function addListener(emitter, event, fn, context, once2) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener2 = new EE(fn, context || emitter, once2), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener2, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener2);
    else
      emitter._events[evt] = [emitter._events[evt], listener2];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events();
    else
      delete emitter._events[evt];
  }
  function EventEmitter3() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter3.prototype.eventNames = function eventNames() {
    var names = [], events2, name2;
    if (this._eventsCount === 0)
      return names;
    for (name2 in events2 = this._events) {
      if (has.call(events2, name2))
        names.push(prefix ? name2.slice(1) : name2);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events2));
    }
    return names;
  };
  EventEmitter3.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i2 = 0, l2 = handlers.length, ee = new Array(l2); i2 < l2; i2++) {
      ee[i2] = handlers[i2].fn;
    }
    return ee;
  };
  EventEmitter3.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners)
      return 0;
    if (listeners.fn)
      return 1;
    return listeners.length;
  };
  EventEmitter3.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners = this._events[evt], len = arguments.length, args, i2;
    if (listeners.fn) {
      if (listeners.once)
        this.removeListener(event, listeners.fn, void 0, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
        args[i2 - 1] = arguments[i2];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length, j;
      for (i2 = 0; i2 < length; i2++) {
        if (listeners[i2].once)
          this.removeListener(event, listeners[i2].fn, void 0, true);
        switch (len) {
          case 1:
            listeners[i2].fn.call(listeners[i2].context);
            break;
          case 2:
            listeners[i2].fn.call(listeners[i2].context, a1);
            break;
          case 3:
            listeners[i2].fn.call(listeners[i2].context, a1, a2);
            break;
          case 4:
            listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
            listeners[i2].fn.apply(listeners[i2].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter3.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };
  EventEmitter3.prototype.once = function once2(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };
  EventEmitter3.prototype.removeListener = function removeListener(event, fn, context, once2) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once2 || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i2 = 0, events2 = [], length = listeners.length; i2 < length; i2++) {
        if (listeners[i2].fn !== fn || once2 && !listeners[i2].once || context && listeners[i2].context !== context) {
          events2.push(listeners[i2]);
        }
      }
      if (events2.length)
        this._events[evt] = events2.length === 1 ? events2[0] : events2;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter3.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
  EventEmitter3.prototype.addListener = EventEmitter3.prototype.on;
  EventEmitter3.prefixed = prefix;
  EventEmitter3.EventEmitter = EventEmitter3;
  {
    module2.exports = EventEmitter3;
  }
})(eventemitter3);
var common$3 = {};
var requiresPort = function required(port, protocol) {
  protocol = protocol.split(":")[0];
  port = +port;
  if (!port)
    return false;
  switch (protocol) {
    case "http":
    case "ws":
      return port !== 80;
    case "https":
    case "wss":
      return port !== 443;
    case "ftp":
      return port !== 21;
    case "gopher":
      return port !== 70;
    case "file":
      return false;
  }
  return port !== 0;
};
(function(exports3) {
  var common3 = exports3, url2 = import_url3.default, extend2 = import_util.default._extend, required2 = requiresPort;
  var upgradeHeader = /(^|,)\s*upgrade\s*($|,)/i, isSSL = /^https|wss/;
  common3.isSSL = isSSL;
  common3.setupOutgoing = function(outgoing, options3, req2, forward) {
    outgoing.port = options3[forward || "target"].port || (isSSL.test(options3[forward || "target"].protocol) ? 443 : 80);
    [
      "host",
      "hostname",
      "socketPath",
      "pfx",
      "key",
      "passphrase",
      "cert",
      "ca",
      "ciphers",
      "secureProtocol"
    ].forEach(
      function(e3) {
        outgoing[e3] = options3[forward || "target"][e3];
      }
    );
    outgoing.method = options3.method || req2.method;
    outgoing.headers = extend2({}, req2.headers);
    if (options3.headers) {
      extend2(outgoing.headers, options3.headers);
    }
    if (options3.auth) {
      outgoing.auth = options3.auth;
    }
    if (options3.ca) {
      outgoing.ca = options3.ca;
    }
    if (isSSL.test(options3[forward || "target"].protocol)) {
      outgoing.rejectUnauthorized = typeof options3.secure === "undefined" ? true : options3.secure;
    }
    outgoing.agent = options3.agent || false;
    outgoing.localAddress = options3.localAddress;
    if (!outgoing.agent) {
      outgoing.headers = outgoing.headers || {};
      if (typeof outgoing.headers.connection !== "string" || !upgradeHeader.test(outgoing.headers.connection)) {
        outgoing.headers.connection = "close";
      }
    }
    var target = options3[forward || "target"];
    var targetPath = target && options3.prependPath !== false ? target.path || "" : "";
    var outgoingPath = !options3.toProxy ? url2.parse(req2.url).path || "" : req2.url;
    outgoingPath = !options3.ignorePath ? outgoingPath : "";
    outgoing.path = common3.urlJoin(targetPath, outgoingPath);
    if (options3.changeOrigin) {
      outgoing.headers.host = required2(outgoing.port, options3[forward || "target"].protocol) && !hasPort(outgoing.host) ? outgoing.host + ":" + outgoing.port : outgoing.host;
    }
    return outgoing;
  };
  common3.setupSocket = function(socket) {
    socket.setTimeout(0);
    socket.setNoDelay(true);
    socket.setKeepAlive(true, 0);
    return socket;
  };
  common3.getPort = function(req2) {
    var res = req2.headers.host ? req2.headers.host.match(/:(\d+)/) : "";
    return res ? res[1] : common3.hasEncryptedConnection(req2) ? "443" : "80";
  };
  common3.hasEncryptedConnection = function(req2) {
    return Boolean(req2.connection.encrypted || req2.connection.pair);
  };
  common3.urlJoin = function() {
    var args = Array.prototype.slice.call(arguments), lastIndex = args.length - 1, last = args[lastIndex], lastSegs = last.split("?"), retSegs;
    args[lastIndex] = lastSegs.shift();
    retSegs = [
      args.filter(Boolean).join("/").replace(/\/+/g, "/").replace("http:/", "http://").replace("https:/", "https://")
    ];
    retSegs.push.apply(retSegs, lastSegs);
    return retSegs.join("?");
  };
  common3.rewriteCookieProperty = function rewriteCookieProperty(header, config2, property) {
    if (Array.isArray(header)) {
      return header.map(function(headerElement) {
        return rewriteCookieProperty(headerElement, config2, property);
      });
    }
    return header.replace(new RegExp("(;\\s*" + property + "=)([^;]+)", "i"), function(match, prefix, previousValue) {
      var newValue;
      if (previousValue in config2) {
        newValue = config2[previousValue];
      } else if ("*" in config2) {
        newValue = config2["*"];
      } else {
        return match;
      }
      if (newValue) {
        return prefix + newValue;
      } else {
        return "";
      }
    });
  };
  function hasPort(host) {
    return !!~host.indexOf(":");
  }
})(common$3);
var url$1 = import_url3.default;
var common$2 = common$3;
var redirectRegex = /^201|30(1|2|7|8)$/;
var webOutgoing = {
  // <--
  /**
   * If is a HTTP 1.0 request, remove chunk headers
   *
   * @param {ClientRequest} Req Request object
   * @param {IncomingMessage} Res Response object
   * @param {proxyResponse} Res Response object from the proxy request
   *
   * @api private
   */
  removeChunked: function removeChunked(req2, res, proxyRes) {
    if (req2.httpVersion === "1.0") {
      delete proxyRes.headers["transfer-encoding"];
    }
  },
  /**
   * If is a HTTP 1.0 request, set the correct connection header
   * or if connection header not present, then use `keep-alive`
   *
   * @param {ClientRequest} Req Request object
   * @param {IncomingMessage} Res Response object
   * @param {proxyResponse} Res Response object from the proxy request
   *
   * @api private
   */
  setConnection: function setConnection(req2, res, proxyRes) {
    if (req2.httpVersion === "1.0") {
      proxyRes.headers.connection = req2.headers.connection || "close";
    } else if (req2.httpVersion !== "2.0" && !proxyRes.headers.connection) {
      proxyRes.headers.connection = req2.headers.connection || "keep-alive";
    }
  },
  setRedirectHostRewrite: function setRedirectHostRewrite(req2, res, proxyRes, options3) {
    if ((options3.hostRewrite || options3.autoRewrite || options3.protocolRewrite) && proxyRes.headers["location"] && redirectRegex.test(proxyRes.statusCode)) {
      var target = url$1.parse(options3.target);
      var u2 = url$1.parse(proxyRes.headers["location"]);
      if (target.host != u2.host) {
        return;
      }
      if (options3.hostRewrite) {
        u2.host = options3.hostRewrite;
      } else if (options3.autoRewrite) {
        u2.host = req2.headers["host"];
      }
      if (options3.protocolRewrite) {
        u2.protocol = options3.protocolRewrite;
      }
      proxyRes.headers["location"] = u2.format();
    }
  },
  /**
   * Copy headers from proxyResponse to response
   * set each header in response object.
   *
   * @param {ClientRequest} Req Request object
   * @param {IncomingMessage} Res Response object
   * @param {proxyResponse} Res Response object from the proxy request
   * @param {Object} Options options.cookieDomainRewrite: Config to rewrite cookie domain
   *
   * @api private
   */
  writeHeaders: function writeHeaders(req2, res, proxyRes, options3) {
    var rewriteCookieDomainConfig = options3.cookieDomainRewrite, rewriteCookiePathConfig = options3.cookiePathRewrite, preserveHeaderKeyCase = options3.preserveHeaderKeyCase, rawHeaderKeyMap, setHeader = function(key2, header) {
      if (header == void 0)
        return;
      if (rewriteCookieDomainConfig && key2.toLowerCase() === "set-cookie") {
        header = common$2.rewriteCookieProperty(header, rewriteCookieDomainConfig, "domain");
      }
      if (rewriteCookiePathConfig && key2.toLowerCase() === "set-cookie") {
        header = common$2.rewriteCookieProperty(header, rewriteCookiePathConfig, "path");
      }
      res.setHeader(String(key2).trim(), header);
    };
    if (typeof rewriteCookieDomainConfig === "string") {
      rewriteCookieDomainConfig = { "*": rewriteCookieDomainConfig };
    }
    if (typeof rewriteCookiePathConfig === "string") {
      rewriteCookiePathConfig = { "*": rewriteCookiePathConfig };
    }
    if (preserveHeaderKeyCase && proxyRes.rawHeaders != void 0) {
      rawHeaderKeyMap = {};
      for (var i2 = 0; i2 < proxyRes.rawHeaders.length; i2 += 2) {
        var key = proxyRes.rawHeaders[i2];
        rawHeaderKeyMap[key.toLowerCase()] = key;
      }
    }
    Object.keys(proxyRes.headers).forEach(function(key2) {
      var header = proxyRes.headers[key2];
      if (preserveHeaderKeyCase && rawHeaderKeyMap) {
        key2 = rawHeaderKeyMap[key2] || key2;
      }
      setHeader(key2, header);
    });
  },
  /**
   * Set the statusCode from the proxyResponse
   *
   * @param {ClientRequest} Req Request object
   * @param {IncomingMessage} Res Response object
   * @param {proxyResponse} Res Response object from the proxy request
   *
   * @api private
   */
  writeStatusCode: function writeStatusCode(req2, res, proxyRes) {
    if (proxyRes.statusMessage) {
      res.statusCode = proxyRes.statusCode;
      res.statusMessage = proxyRes.statusMessage;
    } else {
      res.statusCode = proxyRes.statusCode;
    }
  }
};
var followRedirectsExports = {};
var followRedirects$1 = {
  get exports() {
    return followRedirectsExports;
  },
  set exports(v) {
    followRedirectsExports = v;
  }
};
var debug$3;
var debug_1 = function() {
  if (!debug$3) {
    try {
      debug$3 = require2("debug")("follow-redirects");
    } catch (error3) {
    }
    if (typeof debug$3 !== "function") {
      debug$3 = function() {
      };
    }
  }
  debug$3.apply(null, arguments);
};
var url = import_url3.default;
var URL$1 = url.URL;
var http$1 = import_http.default;
var https$1 = import_https.default;
var Writable = import_stream.default.Writable;
var assert = import_assert.default;
var debug$2 = debug_1;
var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
var eventHandlers = /* @__PURE__ */ Object.create(null);
events.forEach(function(event) {
  eventHandlers[event] = function(arg1, arg2, arg3) {
    this._redirectable.emit(event, arg1, arg2, arg3);
  };
});
var RedirectionError = createErrorType(
  "ERR_FR_REDIRECTION_FAILURE",
  "Redirected request failed"
);
var TooManyRedirectsError = createErrorType(
  "ERR_FR_TOO_MANY_REDIRECTS",
  "Maximum number of redirects exceeded"
);
var MaxBodyLengthExceededError = createErrorType(
  "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
  "Request body larger than maxBodyLength limit"
);
var WriteAfterEndError = createErrorType(
  "ERR_STREAM_WRITE_AFTER_END",
  "write after end"
);
function RedirectableRequest(options3, responseCallback) {
  Writable.call(this);
  this._sanitizeOptions(options3);
  this._options = options3;
  this._ended = false;
  this._ending = false;
  this._redirectCount = 0;
  this._redirects = [];
  this._requestBodyLength = 0;
  this._requestBodyBuffers = [];
  if (responseCallback) {
    this.on("response", responseCallback);
  }
  var self2 = this;
  this._onNativeResponse = function(response) {
    self2._processResponse(response);
  };
  this._performRequest();
}
RedirectableRequest.prototype = Object.create(Writable.prototype);
RedirectableRequest.prototype.abort = function() {
  abortRequest(this._currentRequest);
  this.emit("abort");
};
RedirectableRequest.prototype.write = function(data2, encoding, callback) {
  if (this._ending) {
    throw new WriteAfterEndError();
  }
  if (!(typeof data2 === "string" || typeof data2 === "object" && "length" in data2)) {
    throw new TypeError("data should be a string, Buffer or Uint8Array");
  }
  if (typeof encoding === "function") {
    callback = encoding;
    encoding = null;
  }
  if (data2.length === 0) {
    if (callback) {
      callback();
    }
    return;
  }
  if (this._requestBodyLength + data2.length <= this._options.maxBodyLength) {
    this._requestBodyLength += data2.length;
    this._requestBodyBuffers.push({ data: data2, encoding });
    this._currentRequest.write(data2, encoding, callback);
  } else {
    this.emit("error", new MaxBodyLengthExceededError());
    this.abort();
  }
};
RedirectableRequest.prototype.end = function(data2, encoding, callback) {
  if (typeof data2 === "function") {
    callback = data2;
    data2 = encoding = null;
  } else if (typeof encoding === "function") {
    callback = encoding;
    encoding = null;
  }
  if (!data2) {
    this._ended = this._ending = true;
    this._currentRequest.end(null, null, callback);
  } else {
    var self2 = this;
    var currentRequest = this._currentRequest;
    this.write(data2, encoding, function() {
      self2._ended = true;
      currentRequest.end(null, null, callback);
    });
    this._ending = true;
  }
};
RedirectableRequest.prototype.setHeader = function(name2, value2) {
  this._options.headers[name2] = value2;
  this._currentRequest.setHeader(name2, value2);
};
RedirectableRequest.prototype.removeHeader = function(name2) {
  delete this._options.headers[name2];
  this._currentRequest.removeHeader(name2);
};
RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
  var self2 = this;
  function destroyOnTimeout(socket) {
    socket.setTimeout(msecs);
    socket.removeListener("timeout", socket.destroy);
    socket.addListener("timeout", socket.destroy);
  }
  function startTimer(socket) {
    if (self2._timeout) {
      clearTimeout(self2._timeout);
    }
    self2._timeout = setTimeout(function() {
      self2.emit("timeout");
      clearTimer();
    }, msecs);
    destroyOnTimeout(socket);
  }
  function clearTimer() {
    if (self2._timeout) {
      clearTimeout(self2._timeout);
      self2._timeout = null;
    }
    self2.removeListener("abort", clearTimer);
    self2.removeListener("error", clearTimer);
    self2.removeListener("response", clearTimer);
    if (callback) {
      self2.removeListener("timeout", callback);
    }
    if (!self2.socket) {
      self2._currentRequest.removeListener("socket", startTimer);
    }
  }
  if (callback) {
    this.on("timeout", callback);
  }
  if (this.socket) {
    startTimer(this.socket);
  } else {
    this._currentRequest.once("socket", startTimer);
  }
  this.on("socket", destroyOnTimeout);
  this.on("abort", clearTimer);
  this.on("error", clearTimer);
  this.on("response", clearTimer);
  return this;
};
[
  "flushHeaders",
  "getHeader",
  "setNoDelay",
  "setSocketKeepAlive"
].forEach(function(method) {
  RedirectableRequest.prototype[method] = function(a2, b) {
    return this._currentRequest[method](a2, b);
  };
});
["aborted", "connection", "socket"].forEach(function(property) {
  Object.defineProperty(RedirectableRequest.prototype, property, {
    get: function() {
      return this._currentRequest[property];
    }
  });
});
RedirectableRequest.prototype._sanitizeOptions = function(options3) {
  if (!options3.headers) {
    options3.headers = {};
  }
  if (options3.host) {
    if (!options3.hostname) {
      options3.hostname = options3.host;
    }
    delete options3.host;
  }
  if (!options3.pathname && options3.path) {
    var searchPos = options3.path.indexOf("?");
    if (searchPos < 0) {
      options3.pathname = options3.path;
    } else {
      options3.pathname = options3.path.substring(0, searchPos);
      options3.search = options3.path.substring(searchPos);
    }
  }
};
RedirectableRequest.prototype._performRequest = function() {
  var protocol = this._options.protocol;
  var nativeProtocol = this._options.nativeProtocols[protocol];
  if (!nativeProtocol) {
    this.emit("error", new TypeError("Unsupported protocol " + protocol));
    return;
  }
  if (this._options.agents) {
    var scheme = protocol.slice(0, -1);
    this._options.agent = this._options.agents[scheme];
  }
  var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
  this._currentUrl = url.format(this._options);
  request._redirectable = this;
  for (var e3 = 0; e3 < events.length; e3++) {
    request.on(events[e3], eventHandlers[events[e3]]);
  }
  if (this._isRedirect) {
    var i2 = 0;
    var self2 = this;
    var buffers = this._requestBodyBuffers;
    (function writeNext(error3) {
      if (request === self2._currentRequest) {
        if (error3) {
          self2.emit("error", error3);
        } else if (i2 < buffers.length) {
          var buffer = buffers[i2++];
          if (!request.finished) {
            request.write(buffer.data, buffer.encoding, writeNext);
          }
        } else if (self2._ended) {
          request.end();
        }
      }
    })();
  }
};
RedirectableRequest.prototype._processResponse = function(response) {
  var statusCode = response.statusCode;
  if (this._options.trackRedirects) {
    this._redirects.push({
      url: this._currentUrl,
      headers: response.headers,
      statusCode
    });
  }
  var location2 = response.headers.location;
  if (!location2 || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
    response.responseUrl = this._currentUrl;
    response.redirects = this._redirects;
    this.emit("response", response);
    this._requestBodyBuffers = [];
    return;
  }
  abortRequest(this._currentRequest);
  response.destroy();
  if (++this._redirectCount > this._options.maxRedirects) {
    this.emit("error", new TooManyRedirectsError());
    return;
  }
  var requestHeaders;
  var beforeRedirect = this._options.beforeRedirect;
  if (beforeRedirect) {
    requestHeaders = Object.assign({
      // The Host header was set by nativeProtocol.request
      Host: response.req.getHeader("host")
    }, this._options.headers);
  }
  var method = this._options.method;
  if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC7231§6.4.4: The 303 (See Other) status code indicates that
  // the server is redirecting the user agent to a different resource […]
  // A user agent can perform a retrieval request targeting that URI
  // (a GET or HEAD request if using HTTP) […]
  statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
    this._options.method = "GET";
    this._requestBodyBuffers = [];
    removeMatchingHeaders(/^content-/i, this._options.headers);
  }
  var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
  var currentUrlParts = url.parse(this._currentUrl);
  var currentHost = currentHostHeader || currentUrlParts.host;
  var currentUrl = /^\w+:/.test(location2) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
  var redirectUrl;
  try {
    redirectUrl = url.resolve(currentUrl, location2);
  } catch (cause) {
    this.emit("error", new RedirectionError(cause));
    return;
  }
  debug$2("redirecting to", redirectUrl);
  this._isRedirect = true;
  var redirectUrlParts = url.parse(redirectUrl);
  Object.assign(this._options, redirectUrlParts);
  if (redirectUrlParts.protocol !== currentUrlParts.protocol && redirectUrlParts.protocol !== "https:" || redirectUrlParts.host !== currentHost && !isSubdomain(redirectUrlParts.host, currentHost)) {
    removeMatchingHeaders(/^(?:authorization|cookie)$/i, this._options.headers);
  }
  if (typeof beforeRedirect === "function") {
    var responseDetails = {
      headers: response.headers,
      statusCode
    };
    var requestDetails = {
      url: currentUrl,
      method,
      headers: requestHeaders
    };
    try {
      beforeRedirect(this._options, responseDetails, requestDetails);
    } catch (err2) {
      this.emit("error", err2);
      return;
    }
    this._sanitizeOptions(this._options);
  }
  try {
    this._performRequest();
  } catch (cause) {
    this.emit("error", new RedirectionError(cause));
  }
};
function wrap2(protocols) {
  var exports3 = {
    maxRedirects: 21,
    maxBodyLength: 10 * 1024 * 1024
  };
  var nativeProtocols = {};
  Object.keys(protocols).forEach(function(scheme) {
    var protocol = scheme + ":";
    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
    var wrappedProtocol = exports3[scheme] = Object.create(nativeProtocol);
    function request(input, options3, callback) {
      if (typeof input === "string") {
        var urlStr = input;
        try {
          input = urlToOptions(new URL$1(urlStr));
        } catch (err2) {
          input = url.parse(urlStr);
        }
      } else if (URL$1 && input instanceof URL$1) {
        input = urlToOptions(input);
      } else {
        callback = options3;
        options3 = input;
        input = { protocol };
      }
      if (typeof options3 === "function") {
        callback = options3;
        options3 = null;
      }
      options3 = Object.assign({
        maxRedirects: exports3.maxRedirects,
        maxBodyLength: exports3.maxBodyLength
      }, input, options3);
      options3.nativeProtocols = nativeProtocols;
      assert.equal(options3.protocol, protocol, "protocol mismatch");
      debug$2("options", options3);
      return new RedirectableRequest(options3, callback);
    }
    function get3(input, options3, callback) {
      var wrappedRequest = wrappedProtocol.request(input, options3, callback);
      wrappedRequest.end();
      return wrappedRequest;
    }
    Object.defineProperties(wrappedProtocol, {
      request: { value: request, configurable: true, enumerable: true, writable: true },
      get: { value: get3, configurable: true, enumerable: true, writable: true }
    });
  });
  return exports3;
}
function noop$1() {
}
function urlToOptions(urlObject) {
  var options3 = {
    protocol: urlObject.protocol,
    hostname: urlObject.hostname.startsWith("[") ? (
      /* istanbul ignore next */
      urlObject.hostname.slice(1, -1)
    ) : urlObject.hostname,
    hash: urlObject.hash,
    search: urlObject.search,
    pathname: urlObject.pathname,
    path: urlObject.pathname + urlObject.search,
    href: urlObject.href
  };
  if (urlObject.port !== "") {
    options3.port = Number(urlObject.port);
  }
  return options3;
}
function removeMatchingHeaders(regex, headers) {
  var lastValue;
  for (var header in headers) {
    if (regex.test(header)) {
      lastValue = headers[header];
      delete headers[header];
    }
  }
  return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
}
function createErrorType(code, defaultMessage) {
  function CustomError(cause) {
    Error.captureStackTrace(this, this.constructor);
    if (!cause) {
      this.message = defaultMessage;
    } else {
      this.message = defaultMessage + ": " + cause.message;
      this.cause = cause;
    }
  }
  CustomError.prototype = new Error();
  CustomError.prototype.constructor = CustomError;
  CustomError.prototype.name = "Error [" + code + "]";
  CustomError.prototype.code = code;
  return CustomError;
}
function abortRequest(request) {
  for (var e3 = 0; e3 < events.length; e3++) {
    request.removeListener(events[e3], eventHandlers[events[e3]]);
  }
  request.on("error", noop$1);
  request.abort();
}
function isSubdomain(subdomain, domain) {
  const dot = subdomain.length - domain.length - 1;
  return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
}
followRedirects$1.exports = wrap2({ http: http$1, https: https$1 });
followRedirectsExports.wrap = wrap2;
var httpNative = import_http.default;
var httpsNative = import_https.default;
var web_o = webOutgoing;
var common$1 = common$3;
var followRedirects = followRedirectsExports;
web_o = Object.keys(web_o).map(function(pass) {
  return web_o[pass];
});
var nativeAgents = { http: httpNative, https: httpsNative };
var webIncoming = {
  /**
   * Sets `content-length` to '0' if request is of DELETE type.
   *
   * @param {ClientRequest} Req Request object
   * @param {IncomingMessage} Res Response object
   * @param {Object} Options Config object passed to the proxy
   *
   * @api private
   */
  deleteLength: function deleteLength(req2, res, options3) {
    if ((req2.method === "DELETE" || req2.method === "OPTIONS") && !req2.headers["content-length"]) {
      req2.headers["content-length"] = "0";
      delete req2.headers["transfer-encoding"];
    }
  },
  /**
   * Sets timeout in request socket if it was specified in options.
   *
   * @param {ClientRequest} Req Request object
   * @param {IncomingMessage} Res Response object
   * @param {Object} Options Config object passed to the proxy
   *
   * @api private
   */
  timeout: function timeout(req2, res, options3) {
    if (options3.timeout) {
      req2.socket.setTimeout(options3.timeout);
    }
  },
  /**
   * Sets `x-forwarded-*` headers if specified in config.
   *
   * @param {ClientRequest} Req Request object
   * @param {IncomingMessage} Res Response object
   * @param {Object} Options Config object passed to the proxy
   *
   * @api private
   */
  XHeaders: function XHeaders(req2, res, options3) {
    if (!options3.xfwd)
      return;
    var encrypted = req2.isSpdy || common$1.hasEncryptedConnection(req2);
    var values = {
      for: req2.connection.remoteAddress || req2.socket.remoteAddress,
      port: common$1.getPort(req2),
      proto: encrypted ? "https" : "http"
    };
    ["for", "port", "proto"].forEach(function(header) {
      req2.headers["x-forwarded-" + header] = (req2.headers["x-forwarded-" + header] || "") + (req2.headers["x-forwarded-" + header] ? "," : "") + values[header];
    });
    req2.headers["x-forwarded-host"] = req2.headers["x-forwarded-host"] || req2.headers["host"] || "";
  },
  /**
   * Does the actual proxying. If `forward` is enabled fires up
   * a ForwardStream, same happens for ProxyStream. The request
   * just dies otherwise.
   *
   * @param {ClientRequest} Req Request object
   * @param {IncomingMessage} Res Response object
   * @param {Object} Options Config object passed to the proxy
   *
   * @api private
   */
  stream: function stream2(req2, res, options3, _, server2, clb) {
    server2.emit("start", req2, res, options3.target || options3.forward);
    var agents = options3.followRedirects ? followRedirects : nativeAgents;
    var http2 = agents.http;
    var https2 = agents.https;
    if (options3.forward) {
      var forwardReq = (options3.forward.protocol === "https:" ? https2 : http2).request(
        common$1.setupOutgoing(options3.ssl || {}, options3, req2, "forward")
      );
      var forwardError = createErrorHandler(forwardReq, options3.forward);
      req2.on("error", forwardError);
      forwardReq.on("error", forwardError);
      (options3.buffer || req2).pipe(forwardReq);
      if (!options3.target) {
        return res.end();
      }
    }
    var proxyReq = (options3.target.protocol === "https:" ? https2 : http2).request(
      common$1.setupOutgoing(options3.ssl || {}, options3, req2)
    );
    proxyReq.on("socket", function(socket) {
      if (server2 && !proxyReq.getHeader("expect")) {
        server2.emit("proxyReq", proxyReq, req2, res, options3);
      }
    });
    if (options3.proxyTimeout) {
      proxyReq.setTimeout(options3.proxyTimeout, function() {
        proxyReq.abort();
      });
    }
    req2.on("aborted", function() {
      proxyReq.abort();
    });
    var proxyError = createErrorHandler(proxyReq, options3.target);
    req2.on("error", proxyError);
    proxyReq.on("error", proxyError);
    function createErrorHandler(proxyReq2, url2) {
      return function proxyError2(err2) {
        if (req2.socket.destroyed && err2.code === "ECONNRESET") {
          server2.emit("econnreset", err2, req2, res, url2);
          return proxyReq2.abort();
        }
        if (clb) {
          clb(err2, req2, res, url2);
        } else {
          server2.emit("error", err2, req2, res, url2);
        }
      };
    }
    (options3.buffer || req2).pipe(proxyReq);
    proxyReq.on("response", function(proxyRes) {
      if (server2) {
        server2.emit("proxyRes", proxyRes, req2, res);
      }
      if (!res.headersSent && !options3.selfHandleResponse) {
        for (var i2 = 0; i2 < web_o.length; i2++) {
          if (web_o[i2](req2, res, proxyRes, options3)) {
            break;
          }
        }
      }
      if (!res.finished) {
        proxyRes.on("end", function() {
          if (server2)
            server2.emit("end", req2, res, proxyRes);
        });
        if (!options3.selfHandleResponse)
          proxyRes.pipe(res);
      } else {
        if (server2)
          server2.emit("end", req2, res, proxyRes);
      }
    });
  }
};
var http = import_http.default;
var https = import_https.default;
var common = common$3;
var wsIncoming = {
  /**
   * WebSocket requests must have the `GET` method and
   * the `upgrade:websocket` header
   *
   * @param {ClientRequest} Req Request object
   * @param {Socket} Websocket
   *
   * @api private
   */
  checkMethodAndHeader: function checkMethodAndHeader(req2, socket) {
    if (req2.method !== "GET" || !req2.headers.upgrade) {
      socket.destroy();
      return true;
    }
    if (req2.headers.upgrade.toLowerCase() !== "websocket") {
      socket.destroy();
      return true;
    }
  },
  /**
   * Sets `x-forwarded-*` headers if specified in config.
   *
   * @param {ClientRequest} Req Request object
   * @param {Socket} Websocket
   * @param {Object} Options Config object passed to the proxy
   *
   * @api private
   */
  XHeaders: function XHeaders2(req2, socket, options3) {
    if (!options3.xfwd)
      return;
    var values = {
      for: req2.connection.remoteAddress || req2.socket.remoteAddress,
      port: common.getPort(req2),
      proto: common.hasEncryptedConnection(req2) ? "wss" : "ws"
    };
    ["for", "port", "proto"].forEach(function(header) {
      req2.headers["x-forwarded-" + header] = (req2.headers["x-forwarded-" + header] || "") + (req2.headers["x-forwarded-" + header] ? "," : "") + values[header];
    });
  },
  /**
   * Does the actual proxying. Make the request and upgrade it
   * send the Switching Protocols request and pipe the sockets.
   *
   * @param {ClientRequest} Req Request object
   * @param {Socket} Websocket
   * @param {Object} Options Config object passed to the proxy
   *
   * @api private
   */
  stream: function stream3(req2, socket, options3, head, server2, clb) {
    var createHttpHeader = function(line, headers) {
      return Object.keys(headers).reduce(function(head2, key) {
        var value2 = headers[key];
        if (!Array.isArray(value2)) {
          head2.push(key + ": " + value2);
          return head2;
        }
        for (var i2 = 0; i2 < value2.length; i2++) {
          head2.push(key + ": " + value2[i2]);
        }
        return head2;
      }, [line]).join("\r\n") + "\r\n\r\n";
    };
    common.setupSocket(socket);
    if (head && head.length)
      socket.unshift(head);
    var proxyReq = (common.isSSL.test(options3.target.protocol) ? https : http).request(
      common.setupOutgoing(options3.ssl || {}, options3, req2)
    );
    if (server2) {
      server2.emit("proxyReqWs", proxyReq, req2, socket, options3, head);
    }
    proxyReq.on("error", onOutgoingError);
    proxyReq.on("response", function(res) {
      if (!res.upgrade) {
        socket.write(createHttpHeader("HTTP/" + res.httpVersion + " " + res.statusCode + " " + res.statusMessage, res.headers));
        res.pipe(socket);
      }
    });
    proxyReq.on("upgrade", function(proxyRes, proxySocket, proxyHead) {
      proxySocket.on("error", onOutgoingError);
      proxySocket.on("end", function() {
        server2.emit("close", proxyRes, proxySocket, proxyHead);
      });
      socket.on("error", function() {
        proxySocket.end();
      });
      common.setupSocket(proxySocket);
      if (proxyHead && proxyHead.length)
        proxySocket.unshift(proxyHead);
      socket.write(createHttpHeader("HTTP/1.1 101 Switching Protocols", proxyRes.headers));
      proxySocket.pipe(socket).pipe(proxySocket);
      server2.emit("open", proxySocket);
      server2.emit("proxySocket", proxySocket);
    });
    return proxyReq.end();
    function onOutgoingError(err2) {
      if (clb) {
        clb(err2, req2, socket);
      } else {
        server2.emit("error", err2, req2, socket);
      }
      socket.end();
    }
  }
};
(function(module2) {
  var httpProxy2 = module2.exports, extend2 = import_util.default._extend, parse_url = import_url3.default.parse, EE3 = eventemitter3Exports, http2 = import_http.default, https2 = import_https.default, web = webIncoming, ws = wsIncoming;
  httpProxy2.Server = ProxyServer2;
  function createRightProxy(type) {
    return function(options3) {
      return function(req2, res) {
        var passes = type === "ws" ? this.wsPasses : this.webPasses, args = [].slice.call(arguments), cntr = args.length - 1, head, cbl;
        if (typeof args[cntr] === "function") {
          cbl = args[cntr];
          cntr--;
        }
        var requestOptions = options3;
        if (!(args[cntr] instanceof Buffer) && args[cntr] !== res) {
          requestOptions = extend2({}, options3);
          extend2(requestOptions, args[cntr]);
          cntr--;
        }
        if (args[cntr] instanceof Buffer) {
          head = args[cntr];
        }
        ["target", "forward"].forEach(function(e3) {
          if (typeof requestOptions[e3] === "string")
            requestOptions[e3] = parse_url(requestOptions[e3]);
        });
        if (!requestOptions.target && !requestOptions.forward) {
          return this.emit("error", new Error("Must provide a proper URL as target"));
        }
        for (var i2 = 0; i2 < passes.length; i2++) {
          if (passes[i2](req2, res, requestOptions, head, this, cbl)) {
            break;
          }
        }
      };
    };
  }
  httpProxy2.createRightProxy = createRightProxy;
  function ProxyServer2(options3) {
    EE3.call(this);
    options3 = options3 || {};
    options3.prependPath = options3.prependPath === false ? false : true;
    this.web = this.proxyRequest = createRightProxy("web")(options3);
    this.ws = this.proxyWebsocketRequest = createRightProxy("ws")(options3);
    this.options = options3;
    this.webPasses = Object.keys(web).map(function(pass) {
      return web[pass];
    });
    this.wsPasses = Object.keys(ws).map(function(pass) {
      return ws[pass];
    });
    this.on("error", this.onError, this);
  }
  import_util.default.inherits(ProxyServer2, EE3);
  ProxyServer2.prototype.onError = function(err2) {
    if (this.listeners("error").length === 1) {
      throw err2;
    }
  };
  ProxyServer2.prototype.listen = function(port, hostname) {
    var self2 = this, closure = function(req2, res) {
      self2.web(req2, res);
    };
    this._server = this.options.ssl ? https2.createServer(this.options.ssl, closure) : http2.createServer(closure);
    if (this.options.ws) {
      this._server.on("upgrade", function(req2, socket, head) {
        self2.ws(req2, socket, head);
      });
    }
    this._server.listen(port, hostname);
    return this;
  };
  ProxyServer2.prototype.close = function(callback) {
    var self2 = this;
    if (this._server) {
      this._server.close(done);
    }
    function done() {
      self2._server = null;
      if (callback) {
        callback.apply(null, arguments);
      }
    }
  };
  ProxyServer2.prototype.before = function(type, passName, callback) {
    if (type !== "ws" && type !== "web") {
      throw new Error("type must be `web` or `ws`");
    }
    var passes = type === "ws" ? this.wsPasses : this.webPasses, i2 = false;
    passes.forEach(function(v, idx) {
      if (v.name === passName)
        i2 = idx;
    });
    if (i2 === false)
      throw new Error("No such pass");
    passes.splice(i2, 0, callback);
  };
  ProxyServer2.prototype.after = function(type, passName, callback) {
    if (type !== "ws" && type !== "web") {
      throw new Error("type must be `web` or `ws`");
    }
    var passes = type === "ws" ? this.wsPasses : this.webPasses, i2 = false;
    passes.forEach(function(v, idx) {
      if (v.name === passName)
        i2 = idx;
    });
    if (i2 === false)
      throw new Error("No such pass");
    passes.splice(i2++, 0, callback);
  };
})(httpProxy$2);
var ProxyServer = httpProxyExports.Server;
function createProxyServer(options3) {
  return new ProxyServer(options3);
}
ProxyServer.createProxyServer = createProxyServer;
ProxyServer.createServer = createProxyServer;
ProxyServer.createProxy = createProxyServer;
var httpProxy$1 = ProxyServer;
(function(module2) {
  module2.exports = httpProxy$1;
})(httpProxy$3);
var httpProxy = getDefaultExportFromCjs(httpProxyExports$1);
var debug$1 = createDebugger("vite:proxy");
function proxyMiddleware(httpServer, options3, config2) {
  const proxies = {};
  Object.keys(options3).forEach((context) => {
    let opts = options3[context];
    if (!opts) {
      return;
    }
    if (typeof opts === "string") {
      opts = { target: opts, changeOrigin: true };
    }
    const proxy = httpProxy.createProxyServer(opts);
    proxy.on("error", (err2, req2, originalRes) => {
      const res = originalRes;
      if ("req" in res) {
        config2.logger.error(`${picocolorsExports.red(`http proxy error at ${originalRes.req.url}:`)}
${err2.stack}`, {
          timestamp: true,
          error: err2
        });
        if (!res.headersSent && !res.writableEnded) {
          res.writeHead(500, {
            "Content-Type": "text/plain"
          }).end();
        }
      } else {
        config2.logger.error(`${picocolorsExports.red(`ws proxy error:`)}
${err2.stack}`, {
          timestamp: true,
          error: err2
        });
        res.end();
      }
    });
    if (opts.configure) {
      opts.configure(proxy, opts);
    }
    proxies[context] = [proxy, { ...opts }];
  });
  if (httpServer) {
    httpServer.on("upgrade", (req2, socket, head) => {
      var _a, _b;
      const url2 = req2.url;
      for (const context in proxies) {
        if (doesProxyContextMatchUrl(context, url2)) {
          const [proxy, opts] = proxies[context];
          if ((opts.ws || ((_a = opts.target) == null ? void 0 : _a.toString().startsWith("ws:")) || ((_b = opts.target) == null ? void 0 : _b.toString().startsWith("wss:"))) && req2.headers["sec-websocket-protocol"] !== HMR_HEADER) {
            if (opts.rewrite) {
              req2.url = opts.rewrite(url2);
            }
            debug$1(`${req2.url} -> ws ${opts.target}`);
            proxy.ws(req2, socket, head);
            return;
          }
        }
      }
    });
  }
  return function viteProxyMiddleware(req2, res, next) {
    const url2 = req2.url;
    for (const context in proxies) {
      if (doesProxyContextMatchUrl(context, url2)) {
        const [proxy, opts] = proxies[context];
        const options4 = {};
        if (opts.bypass) {
          const bypassResult = opts.bypass(req2, res, opts);
          if (typeof bypassResult === "string") {
            req2.url = bypassResult;
            debug$1(`bypass: ${req2.url} -> ${bypassResult}`);
            return next();
          } else if (bypassResult === false) {
            debug$1(`bypass: ${req2.url} -> 404`);
            return res.end(404);
          }
        }
        debug$1(`${req2.url} -> ${opts.target || opts.forward}`);
        if (opts.rewrite) {
          req2.url = opts.rewrite(req2.url);
        }
        proxy.web(req2, res, options4);
        return;
      }
    }
    next();
  };
}
function doesProxyContextMatchUrl(context, url2) {
  return context.startsWith("^") && new RegExp(context).test(url2) || url2.startsWith(context);
}
var libExports = {};
var lib = {
  get exports() {
    return libExports;
  },
  set exports(v) {
    libExports = v;
  }
};
(function(module2, exports3) {
  var url2 = import_url3.default;
  module2.exports = function historyApiFallback(options3) {
    options3 = options3 || {};
    var logger2 = getLogger(options3);
    return function(req2, res, next) {
      var headers = req2.headers;
      if (req2.method !== "GET" && req2.method !== "HEAD") {
        logger2(
          "Not rewriting",
          req2.method,
          req2.url,
          "because the method is not GET or HEAD."
        );
        return next();
      } else if (!headers || typeof headers.accept !== "string") {
        logger2(
          "Not rewriting",
          req2.method,
          req2.url,
          "because the client did not send an HTTP accept header."
        );
        return next();
      } else if (headers.accept.indexOf("application/json") === 0) {
        logger2(
          "Not rewriting",
          req2.method,
          req2.url,
          "because the client prefers JSON."
        );
        return next();
      } else if (!acceptsHtml(headers.accept, options3)) {
        logger2(
          "Not rewriting",
          req2.method,
          req2.url,
          "because the client does not accept HTML."
        );
        return next();
      }
      var parsedUrl = url2.parse(req2.url);
      var rewriteTarget;
      options3.rewrites = options3.rewrites || [];
      for (var i2 = 0; i2 < options3.rewrites.length; i2++) {
        var rewrite = options3.rewrites[i2];
        var match = parsedUrl.pathname.match(rewrite.from);
        if (match !== null) {
          rewriteTarget = evaluateRewriteRule(parsedUrl, match, rewrite.to, req2);
          if (rewriteTarget.charAt(0) !== "/") {
            logger2(
              "We recommend using an absolute path for the rewrite target.",
              "Received a non-absolute rewrite target",
              rewriteTarget,
              "for URL",
              req2.url
            );
          }
          logger2("Rewriting", req2.method, req2.url, "to", rewriteTarget);
          req2.url = rewriteTarget;
          return next();
        }
      }
      var pathname = parsedUrl.pathname;
      if (pathname.lastIndexOf(".") > pathname.lastIndexOf("/") && options3.disableDotRule !== true) {
        logger2(
          "Not rewriting",
          req2.method,
          req2.url,
          "because the path includes a dot (.) character."
        );
        return next();
      }
      rewriteTarget = options3.index || "/index.html";
      logger2("Rewriting", req2.method, req2.url, "to", rewriteTarget);
      req2.url = rewriteTarget;
      next();
    };
  };
  function evaluateRewriteRule(parsedUrl, match, rule, req2) {
    if (typeof rule === "string") {
      return rule;
    } else if (typeof rule !== "function") {
      throw new Error("Rewrite rule can only be of type string or function.");
    }
    return rule({
      parsedUrl,
      match,
      request: req2
    });
  }
  function acceptsHtml(header, options3) {
    options3.htmlAcceptHeaders = options3.htmlAcceptHeaders || ["text/html", "*/*"];
    for (var i2 = 0; i2 < options3.htmlAcceptHeaders.length; i2++) {
      if (header.indexOf(options3.htmlAcceptHeaders[i2]) !== -1) {
        return true;
      }
    }
    return false;
  }
  function getLogger(options3) {
    if (options3 && options3.logger) {
      return options3.logger;
    } else if (options3 && options3.verbose) {
      return console.log.bind(console);
    }
    return function() {
    };
  }
})(lib);
var history = libExports;
function htmlFallbackMiddleware(root, spaFallback) {
  const historyHtmlFallbackMiddleware = history({
    logger: createDebugger("vite:html-fallback"),
    // support /dir/ without explicit index.html
    rewrites: [
      {
        from: /\/$/,
        to({ parsedUrl, request }) {
          const rewritten = decodeURIComponent(parsedUrl.pathname) + "index.html";
          if (import_node_fs4.default.existsSync(import_node_path4.default.join(root, rewritten))) {
            return rewritten;
          }
          return spaFallback ? `/index.html` : request.url;
        }
      }
    ]
  });
  return function viteHtmlFallbackMiddleware(req2, res, next) {
    return historyHtmlFallbackMiddleware(req2, res, next);
  };
}
var debugCache = createDebugger("vite:cache");
var isDebug = !!process.env.DEBUG;
var knownIgnoreList = /* @__PURE__ */ new Set(["/", "/favicon.ico"]);
function transformMiddleware(server2) {
  const { config: { root, logger: logger2 }, moduleGraph } = server2;
  return async function viteTransformMiddleware(req2, res, next) {
    var _a, _b, _c, _d, _e, _f;
    if (req2.method !== "GET" || knownIgnoreList.has(req2.url)) {
      return next();
    }
    let url2;
    try {
      url2 = decodeURI(removeTimestampQuery(req2.url)).replace(NULL_BYTE_PLACEHOLDER, "\0");
    } catch (e3) {
      return next(e3);
    }
    const withoutQuery = cleanUrl(url2);
    try {
      const isSourceMap = withoutQuery.endsWith(".map");
      if (isSourceMap) {
        const depsOptimizer = getDepsOptimizer(server2.config, false);
        if (depsOptimizer == null ? void 0 : depsOptimizer.isOptimizedDepUrl(url2)) {
          const mapFile = url2.startsWith(FS_PREFIX) ? fsPathFromId(url2) : normalizePath$3(ensureVolumeInPath(import_node_path4.default.resolve(root, url2.slice(1))));
          try {
            const map3 = await import_node_fs4.promises.readFile(mapFile, "utf-8");
            return send$1(req2, res, map3, "json", {
              headers: server2.config.server.headers
            });
          } catch (e3) {
            const dummySourceMap = {
              version: 3,
              file: mapFile.replace(/\.map$/, ""),
              sources: [],
              sourcesContent: [],
              names: [],
              mappings: ";;;;;;;;;"
            };
            return send$1(req2, res, JSON.stringify(dummySourceMap), "json", {
              cacheControl: "no-cache",
              headers: server2.config.server.headers
            });
          }
        } else {
          const originalUrl = url2.replace(/\.map($|\?)/, "$1");
          const map3 = (_b = (_a = await moduleGraph.getModuleByUrl(originalUrl, false)) == null ? void 0 : _a.transformResult) == null ? void 0 : _b.map;
          if (map3) {
            return send$1(req2, res, JSON.stringify(map3), "json", {
              headers: server2.config.server.headers
            });
          } else {
            return next();
          }
        }
      }
      const publicDir = normalizePath$3(server2.config.publicDir);
      const rootDir = normalizePath$3(server2.config.root);
      if (publicDir.startsWith(rootDir)) {
        const publicPath = `${publicDir.slice(rootDir.length)}/`;
        if (url2.startsWith(publicPath)) {
          let warning;
          if (isImportRequest(url2)) {
            const rawUrl = removeImportQuery(url2);
            warning = `Assets in public cannot be imported from JavaScript.
Instead of ${picocolorsExports.cyan(rawUrl)}, put the file in the src directory, and use ${picocolorsExports.cyan(rawUrl.replace(publicPath, "/src/"))} instead.`;
          } else {
            warning = `files in the public directory are served at the root path.
Instead of ${picocolorsExports.cyan(url2)}, use ${picocolorsExports.cyan(url2.replace(publicPath, "/"))}.`;
          }
          logger2.warn(picocolorsExports.yellow(warning));
        }
      }
      if (isJSRequest(url2) || isImportRequest(url2) || isCSSRequest(url2) || isHTMLProxy(url2)) {
        url2 = removeImportQuery(url2);
        url2 = unwrapId(url2);
        if (isCSSRequest(url2) && !isDirectRequest(url2) && ((_c = req2.headers.accept) == null ? void 0 : _c.includes("text/css"))) {
          url2 = injectQuery(url2, "direct");
        }
        const ifNoneMatch = req2.headers["if-none-match"];
        if (ifNoneMatch && ((_e = (_d = await moduleGraph.getModuleByUrl(url2, false)) == null ? void 0 : _d.transformResult) == null ? void 0 : _e.etag) === ifNoneMatch) {
          isDebug && debugCache(`[304] ${prettifyUrl(url2, root)}`);
          res.statusCode = 304;
          return res.end();
        }
        const result = await transformRequest(url2, server2, {
          html: (_f = req2.headers.accept) == null ? void 0 : _f.includes("text/html")
        });
        if (result) {
          const depsOptimizer = getDepsOptimizer(server2.config, false);
          const type = isDirectCSSRequest(url2) ? "css" : "js";
          const isDep = DEP_VERSION_RE.test(url2) || (depsOptimizer == null ? void 0 : depsOptimizer.isOptimizedDepUrl(url2));
          return send$1(req2, res, result.code, type, {
            etag: result.etag,
            // allow browser to cache npm deps!
            cacheControl: isDep ? "max-age=31536000,immutable" : "no-cache",
            headers: server2.config.server.headers,
            map: result.map
          });
        }
      }
    } catch (e3) {
      if ((e3 == null ? void 0 : e3.code) === ERR_OPTIMIZE_DEPS_PROCESSING_ERROR) {
        if (!res.writableEnded) {
          res.statusCode = 504;
          res.end();
        }
        logger2.error(e3.message);
        return;
      }
      if ((e3 == null ? void 0 : e3.code) === ERR_OUTDATED_OPTIMIZED_DEP) {
        if (!res.writableEnded) {
          res.statusCode = 504;
          res.end();
        }
        return;
      }
      if ((e3 == null ? void 0 : e3.code) === ERR_LOAD_URL) {
        return next();
      }
      return next(e3);
    }
    next();
  };
}
function createDevHtmlTransformFn(server2) {
  const [preHooks, normalHooks, postHooks] = resolveHtmlTransforms(server2.config.plugins);
  return (url2, html, originalUrl) => {
    return applyHtmlTransforms(html, [
      preImportMapHook(server2.config),
      ...preHooks,
      devHtmlHook,
      ...normalHooks,
      ...postHooks,
      postImportMapHook()
    ], {
      path: url2,
      filename: getHtmlFilename(url2, server2),
      server: server2,
      originalUrl
    });
  };
}
function getHtmlFilename(url2, server2) {
  if (url2.startsWith(FS_PREFIX)) {
    return decodeURIComponent(fsPathFromId(url2));
  } else {
    return decodeURIComponent(normalizePath$3(import_node_path4.default.join(server2.config.root, url2.slice(1))));
  }
}
var startsWithSingleSlashRE = /^\/(?!\/)/;
var processNodeUrl = (attr, sourceCodeLocation, s2, config2, htmlPath, originalUrl, moduleGraph) => {
  let url2 = attr.value || "";
  if (moduleGraph) {
    const mod = moduleGraph.urlToModuleMap.get(url2);
    if (mod && mod.lastHMRTimestamp > 0) {
      url2 = injectQuery(url2, `t=${mod.lastHMRTimestamp}`);
    }
  }
  const devBase = config2.base;
  if (startsWithSingleSlashRE.test(url2)) {
    const fullUrl = import_node_path4.default.posix.join(devBase, url2);
    overwriteAttrValue(s2, sourceCodeLocation, fullUrl);
  } else if (url2.startsWith(".") && originalUrl && originalUrl !== "/" && htmlPath === "/index.html") {
    const replacer = (url3) => import_node_path4.default.posix.join(devBase, url3);
    const processedUrl = attr.name === "srcset" && attr.prefix === void 0 ? processSrcSetSync(url2, ({ url: url3 }) => replacer(url3)) : replacer(url2);
    overwriteAttrValue(s2, sourceCodeLocation, processedUrl);
  }
};
var devHtmlHook = async (html, { path: htmlPath, filename, server: server2, originalUrl }) => {
  const { config: config2, moduleGraph, watcher } = server2;
  const base2 = config2.base || "/";
  let proxyModulePath;
  let proxyModuleUrl;
  const trailingSlash = htmlPath.endsWith("/");
  if (!trailingSlash && import_node_fs4.default.existsSync(filename)) {
    proxyModulePath = htmlPath;
    proxyModuleUrl = joinUrlSegments(base2, htmlPath);
  } else {
    const validPath = `${htmlPath}${trailingSlash ? "index.html" : ""}`;
    proxyModulePath = `\0${validPath}`;
    proxyModuleUrl = wrapId(proxyModulePath);
  }
  const s2 = new MagicString(html);
  let inlineModuleIndex = -1;
  const proxyCacheUrl = cleanUrl(proxyModulePath).replace(normalizePath$3(config2.root), "");
  const styleUrl = [];
  const addInlineModule = (node3, ext2) => {
    inlineModuleIndex++;
    const contentNode = node3.childNodes[0];
    const code = contentNode.value;
    let map3;
    if (!proxyModulePath.startsWith("\0")) {
      map3 = new MagicString(html).snip(contentNode.sourceCodeLocation.startOffset, contentNode.sourceCodeLocation.endOffset).generateMap({ hires: true });
      map3.sources = [filename];
      map3.file = filename;
    }
    addToHTMLProxyCache(config2, proxyCacheUrl, inlineModuleIndex, { code, map: map3 });
    const modulePath = `${proxyModuleUrl}?html-proxy&index=${inlineModuleIndex}.${ext2}`;
    const module2 = server2 == null ? void 0 : server2.moduleGraph.getModuleById(modulePath);
    if (module2) {
      server2 == null ? void 0 : server2.moduleGraph.invalidateModule(module2);
    }
    s2.update(node3.sourceCodeLocation.startOffset, node3.sourceCodeLocation.endOffset, `<script type="module" src="${modulePath}"><\/script>`);
  };
  await traverseHtml(html, filename, (node3) => {
    if (!nodeIsElement(node3)) {
      return;
    }
    if (node3.nodeName === "script") {
      const { src: src3, sourceCodeLocation, isModule } = getScriptInfo(node3);
      if (src3) {
        processNodeUrl(src3, sourceCodeLocation, s2, config2, htmlPath, originalUrl, moduleGraph);
      } else if (isModule && node3.childNodes.length) {
        addInlineModule(node3, "js");
      }
    }
    if (node3.nodeName === "style" && node3.childNodes.length) {
      const children = node3.childNodes[0];
      styleUrl.push({
        start: children.sourceCodeLocation.startOffset,
        end: children.sourceCodeLocation.endOffset,
        code: children.value
      });
    }
    const assetAttrs = assetAttrsConfig[node3.nodeName];
    if (assetAttrs) {
      for (const p2 of node3.attrs) {
        const attrKey = getAttrKey(p2);
        if (p2.value && assetAttrs.includes(attrKey)) {
          processNodeUrl(p2, node3.sourceCodeLocation.attrs[attrKey], s2, config2, htmlPath, originalUrl);
        }
      }
    }
  });
  await Promise.all(styleUrl.map(async ({ start, end, code }, index2) => {
    const url2 = `${proxyModulePath}?html-proxy&direct&index=${index2}.css`;
    const mod = await moduleGraph.ensureEntryFromUrl(url2, false);
    ensureWatchedFile(watcher, mod.file, config2.root);
    const result = await server2.pluginContainer.transform(code, mod.id);
    s2.overwrite(start, end, (result == null ? void 0 : result.code) || "");
  }));
  html = s2.toString();
  return {
    html,
    tags: [
      {
        tag: "script",
        attrs: {
          type: "module",
          src: import_node_path4.default.posix.join(base2, CLIENT_PUBLIC_PATH)
        },
        injectTo: "head-prepend"
      }
    ]
  };
};
function indexHtmlMiddleware(server2) {
  return async function viteIndexHtmlMiddleware(req2, res, next) {
    if (res.writableEnded) {
      return next();
    }
    const url2 = req2.url && cleanUrl(req2.url);
    if ((url2 == null ? void 0 : url2.endsWith(".html")) && req2.headers["sec-fetch-dest"] !== "script") {
      const filename = getHtmlFilename(url2, server2);
      if (import_node_fs4.default.existsSync(filename)) {
        try {
          let html = import_node_fs4.default.readFileSync(filename, "utf-8");
          html = await server2.transformIndexHtml(url2, html, req2.originalUrl);
          return send$1(req2, res, html, "html", {
            headers: server2.config.server.headers
          });
        } catch (e3) {
          return next(e3);
        }
      }
    }
    next();
  };
}
var logTime = createDebugger("vite:time");
function timeMiddleware(root) {
  return function viteTimeMiddleware(req2, res, next) {
    const start = import_node_perf_hooks.performance.now();
    const end = res.end;
    res.end = (...args) => {
      logTime(`${timeFrom(start)} ${prettifyUrl(req2.url, root)}`);
      return end.call(res, ...args);
    };
    next();
  };
}
var ModuleNode = class {
  /**
   * @param setIsSelfAccepting - set `false` to set `isSelfAccepting` later. e.g. #7870
   */
  constructor(url2, setIsSelfAccepting = true) {
    this.id = null;
    this.file = null;
    this.importers = /* @__PURE__ */ new Set();
    this.importedModules = /* @__PURE__ */ new Set();
    this.acceptedHmrDeps = /* @__PURE__ */ new Set();
    this.acceptedHmrExports = null;
    this.importedBindings = null;
    this.transformResult = null;
    this.ssrTransformResult = null;
    this.ssrModule = null;
    this.ssrError = null;
    this.lastHMRTimestamp = 0;
    this.lastInvalidationTimestamp = 0;
    this.url = url2;
    this.type = isDirectCSSRequest(url2) ? "css" : "js";
    if (setIsSelfAccepting) {
      this.isSelfAccepting = false;
    }
  }
};
var ModuleGraph = class {
  constructor(resolveId) {
    this.resolveId = resolveId;
    this.urlToModuleMap = /* @__PURE__ */ new Map();
    this.idToModuleMap = /* @__PURE__ */ new Map();
    this.fileToModulesMap = /* @__PURE__ */ new Map();
    this.safeModulesPath = /* @__PURE__ */ new Set();
  }
  async getModuleByUrl(rawUrl, ssr) {
    const [url2] = await this.resolveUrl(rawUrl, ssr);
    return this.urlToModuleMap.get(url2);
  }
  getModuleById(id) {
    return this.idToModuleMap.get(removeTimestampQuery(id));
  }
  getModulesByFile(file) {
    return this.fileToModulesMap.get(file);
  }
  onFileChange(file) {
    const mods = this.getModulesByFile(file);
    if (mods) {
      const seen2 = /* @__PURE__ */ new Set();
      mods.forEach((mod) => {
        this.invalidateModule(mod, seen2);
      });
    }
  }
  invalidateModule(mod, seen2 = /* @__PURE__ */ new Set(), timestamp3 = Date.now(), isHmr = false) {
    if (seen2.has(mod)) {
      return;
    }
    seen2.add(mod);
    if (isHmr) {
      mod.lastHMRTimestamp = timestamp3;
    } else {
      mod.lastInvalidationTimestamp = timestamp3;
    }
    mod.transformResult = null;
    mod.ssrTransformResult = null;
    mod.ssrModule = null;
    mod.ssrError = null;
    mod.importers.forEach((importer) => {
      if (!importer.acceptedHmrDeps.has(mod)) {
        this.invalidateModule(importer, seen2, timestamp3, isHmr);
      }
    });
  }
  invalidateAll() {
    const timestamp3 = Date.now();
    const seen2 = /* @__PURE__ */ new Set();
    this.idToModuleMap.forEach((mod) => {
      this.invalidateModule(mod, seen2, timestamp3);
    });
  }
  /**
   * Update the module graph based on a module's updated imports information
   * If there are dependencies that no longer have any importers, they are
   * returned as a Set.
   */
  async updateModuleInfo(mod, importedModules, importedBindings, acceptedModules, acceptedExports, isSelfAccepting, ssr) {
    mod.isSelfAccepting = isSelfAccepting;
    const prevImports = mod.importedModules;
    const nextImports = mod.importedModules = /* @__PURE__ */ new Set();
    let noLongerImported;
    for (const imported of importedModules) {
      const dep = typeof imported === "string" ? await this.ensureEntryFromUrl(imported, ssr) : imported;
      dep.importers.add(mod);
      nextImports.add(dep);
    }
    prevImports.forEach((dep) => {
      if (!nextImports.has(dep)) {
        dep.importers.delete(mod);
        if (!dep.importers.size) {
          (noLongerImported || (noLongerImported = /* @__PURE__ */ new Set())).add(dep);
        }
      }
    });
    const deps = mod.acceptedHmrDeps = /* @__PURE__ */ new Set();
    for (const accepted of acceptedModules) {
      const dep = typeof accepted === "string" ? await this.ensureEntryFromUrl(accepted, ssr) : accepted;
      deps.add(dep);
    }
    mod.acceptedHmrExports = acceptedExports;
    mod.importedBindings = importedBindings;
    return noLongerImported;
  }
  async ensureEntryFromUrl(rawUrl, ssr, setIsSelfAccepting = true) {
    const [url2, resolvedId, meta] = await this.resolveUrl(rawUrl, ssr);
    let mod = this.idToModuleMap.get(resolvedId);
    if (!mod) {
      mod = new ModuleNode(url2, setIsSelfAccepting);
      if (meta)
        mod.meta = meta;
      this.urlToModuleMap.set(url2, mod);
      mod.id = resolvedId;
      this.idToModuleMap.set(resolvedId, mod);
      const file = mod.file = cleanUrl(resolvedId);
      let fileMappedModules = this.fileToModulesMap.get(file);
      if (!fileMappedModules) {
        fileMappedModules = /* @__PURE__ */ new Set();
        this.fileToModulesMap.set(file, fileMappedModules);
      }
      fileMappedModules.add(mod);
    } else if (!this.urlToModuleMap.has(url2)) {
      this.urlToModuleMap.set(url2, mod);
    }
    return mod;
  }
  // some deps, like a css file referenced via @import, don't have its own
  // url because they are inlined into the main css import. But they still
  // need to be represented in the module graph so that they can trigger
  // hmr in the importing css file.
  createFileOnlyEntry(file) {
    file = normalizePath$3(file);
    let fileMappedModules = this.fileToModulesMap.get(file);
    if (!fileMappedModules) {
      fileMappedModules = /* @__PURE__ */ new Set();
      this.fileToModulesMap.set(file, fileMappedModules);
    }
    const url2 = `${FS_PREFIX}${file}`;
    for (const m of fileMappedModules) {
      if (m.url === url2 || m.id === file) {
        return m;
      }
    }
    const mod = new ModuleNode(url2);
    mod.file = file;
    fileMappedModules.add(mod);
    return mod;
  }
  // for incoming urls, it is important to:
  // 1. remove the HMR timestamp query (?t=xxxx)
  // 2. resolve its extension so that urls with or without extension all map to
  // the same module
  async resolveUrl(url2, ssr) {
    url2 = removeImportQuery(removeTimestampQuery(url2));
    const resolved = await this.resolveId(url2, !!ssr);
    const resolvedId = (resolved == null ? void 0 : resolved.id) || url2;
    if (url2 !== resolvedId && !url2.includes("\0") && !url2.startsWith(`virtual:`)) {
      const ext2 = (0, import_node_path4.extname)(cleanUrl(resolvedId));
      const { pathname, search, hash: hash2 } = new URL(url2, "relative://");
      if (ext2 && !pathname.endsWith(ext2)) {
        url2 = pathname + ext2 + search + hash2;
      }
    }
    return [url2, resolvedId, resolved == null ? void 0 : resolved.meta];
  }
};
async function createServer(inlineConfig = {}) {
  const config2 = await resolveConfig(inlineConfig, "serve");
  const { root, server: serverConfig } = config2;
  const httpsOptions = await resolveHttpsConfig(config2.server.https);
  const { middlewareMode } = serverConfig;
  const resolvedWatchOptions = resolveChokidarOptions(config2, {
    disableGlobbing: true,
    ...serverConfig.watch
  });
  const middlewares = connect();
  const httpServer = middlewareMode ? null : await resolveHttpServer(serverConfig, middlewares, httpsOptions);
  const ws = createWebSocketServer(httpServer, config2, httpsOptions);
  if (httpServer) {
    setClientErrorHandler(httpServer, config2.logger);
  }
  const watcher = chokidar.watch(import_node_path4.default.resolve(root), resolvedWatchOptions);
  const moduleGraph = new ModuleGraph((url2, ssr) => container.resolveId(url2, void 0, { ssr }));
  const container = await createPluginContainer(config2, moduleGraph, watcher);
  const closeHttpServer = createServerCloseFn(httpServer);
  let exitProcess;
  const server2 = {
    config: config2,
    middlewares,
    httpServer,
    watcher,
    pluginContainer: container,
    ws,
    moduleGraph,
    resolvedUrls: null,
    ssrTransform(code, inMap, url2, originalCode = code) {
      return ssrTransform(code, inMap, url2, originalCode, server2.config);
    },
    transformRequest(url2, options3) {
      return transformRequest(url2, server2, options3);
    },
    transformIndexHtml: null,
    async ssrLoadModule(url2, opts) {
      if (isDepsOptimizerEnabled(config2, true)) {
        await initDevSsrDepsOptimizer(config2, server2);
      }
      await updateCjsSsrExternals(server2);
      return ssrLoadModule(url2, server2, void 0, void 0, opts == null ? void 0 : opts.fixStacktrace);
    },
    ssrFixStacktrace(e3) {
      ssrFixStacktrace(e3, moduleGraph);
    },
    ssrRewriteStacktrace(stack) {
      return ssrRewriteStacktrace(stack, moduleGraph);
    },
    async reloadModule(module2) {
      if (serverConfig.hmr !== false && module2.file) {
        updateModules(module2.file, [module2], Date.now(), server2);
      }
    },
    async listen(port, isRestart) {
      await startServer(server2, port, isRestart);
      if (httpServer) {
        server2.resolvedUrls = await resolveServerUrls(httpServer, config2.server, config2);
      }
      return server2;
    },
    async close() {
      var _a, _b;
      if (!middlewareMode) {
        process.off("SIGTERM", exitProcess);
        if (process.env.CI !== "true") {
          process.stdin.off("end", exitProcess);
        }
      }
      await Promise.allSettled([
        watcher.close(),
        ws.close(),
        container.close(),
        (_a = getDepsOptimizer(server2.config)) == null ? void 0 : _a.close(),
        (_b = getDepsOptimizer(server2.config, true)) == null ? void 0 : _b.close(),
        closeHttpServer()
      ]);
      server2.resolvedUrls = null;
    },
    printUrls() {
      if (server2.resolvedUrls) {
        printServerUrls(server2.resolvedUrls, serverConfig.host, config2.logger.info);
      } else if (middlewareMode) {
        throw new Error("cannot print server URLs in middleware mode.");
      } else {
        throw new Error("cannot print server URLs before server.listen is called.");
      }
    },
    async restart(forceOptimize) {
      if (!server2._restartPromise) {
        server2._forceOptimizeOnRestart = !!forceOptimize;
        server2._restartPromise = restartServer(server2).finally(() => {
          server2._restartPromise = null;
          server2._forceOptimizeOnRestart = false;
        });
      }
      return server2._restartPromise;
    },
    _ssrExternals: null,
    _restartPromise: null,
    _importGlobMap: /* @__PURE__ */ new Map(),
    _forceOptimizeOnRestart: false,
    _pendingRequests: /* @__PURE__ */ new Map(),
    _fsDenyGlob: picomatch$3(config2.server.fs.deny, { matchBase: true }),
    _shortcutsOptions: void 0
  };
  server2.transformIndexHtml = createDevHtmlTransformFn(server2);
  if (!middlewareMode) {
    exitProcess = async () => {
      try {
        await server2.close();
      } finally {
        process.exit();
      }
    };
    process.once("SIGTERM", exitProcess);
    if (process.env.CI !== "true") {
      process.stdin.on("end", exitProcess);
    }
  }
  const { packageCache } = config2;
  const setPackageData = packageCache.set.bind(packageCache);
  packageCache.set = (id, pkg) => {
    if (id.endsWith(".json")) {
      watcher.add(id);
    }
    return setPackageData(id, pkg);
  };
  watcher.on("change", async (file) => {
    file = normalizePath$3(file);
    if (file.endsWith("/package.json")) {
      return invalidatePackageData(packageCache, file);
    }
    moduleGraph.onFileChange(file);
    if (serverConfig.hmr !== false) {
      try {
        await handleHMRUpdate(file, server2);
      } catch (err2) {
        ws.send({
          type: "error",
          err: prepareError(err2)
        });
      }
    }
  });
  watcher.on("add", (file) => {
    handleFileAddUnlink(normalizePath$3(file), server2);
  });
  watcher.on("unlink", (file) => {
    handleFileAddUnlink(normalizePath$3(file), server2);
  });
  ws.on("vite:invalidate", async ({ path: path8, message }) => {
    const mod = moduleGraph.urlToModuleMap.get(path8);
    if (mod && mod.isSelfAccepting && mod.lastHMRTimestamp > 0) {
      config2.logger.info(picocolorsExports.yellow(`hmr invalidate `) + picocolorsExports.dim(path8) + (message ? ` ${message}` : ""), { timestamp: true });
      const file = getShortName(mod.file, config2.root);
      updateModules(file, [...mod.importers], mod.lastHMRTimestamp, server2, true);
    }
  });
  if (!middlewareMode && httpServer) {
    httpServer.once("listening", () => {
      serverConfig.port = httpServer.address().port;
    });
  }
  const postHooks = [];
  for (const hook of config2.getSortedPluginHooks("configureServer")) {
    postHooks.push(await hook(server2));
  }
  if (process.env.DEBUG) {
    middlewares.use(timeMiddleware(root));
  }
  const { cors } = serverConfig;
  if (cors !== false) {
    middlewares.use(libExports$1(typeof cors === "boolean" ? {} : cors));
  }
  const { proxy } = serverConfig;
  if (proxy) {
    middlewares.use(proxyMiddleware(httpServer, proxy, config2));
  }
  if (config2.base !== "/") {
    middlewares.use(baseMiddleware(server2));
  }
  middlewares.use("/__open-in-editor", launchEditorMiddleware());
  if (config2.publicDir) {
    middlewares.use(servePublicMiddleware(config2.publicDir, config2.server.headers));
  }
  middlewares.use(transformMiddleware(server2));
  middlewares.use(serveRawFsMiddleware(server2));
  middlewares.use(serveStaticMiddleware(root, server2));
  if (config2.appType === "spa" || config2.appType === "mpa") {
    middlewares.use(htmlFallbackMiddleware(root, config2.appType === "spa"));
  }
  postHooks.forEach((fn) => fn && fn());
  if (config2.appType === "spa" || config2.appType === "mpa") {
    middlewares.use(indexHtmlMiddleware(server2));
    middlewares.use(function vite404Middleware(_, res) {
      res.statusCode = 404;
      res.end();
    });
  }
  middlewares.use(errorMiddleware(server2, middlewareMode));
  let initingServer;
  let serverInited = false;
  const initServer = async () => {
    if (serverInited) {
      return;
    }
    if (initingServer) {
      return initingServer;
    }
    initingServer = async function() {
      await container.buildStart({});
      if (isDepsOptimizerEnabled(config2, false)) {
        await initDepsOptimizer(config2, server2);
      }
      initingServer = void 0;
      serverInited = true;
    }();
    return initingServer;
  };
  if (!middlewareMode && httpServer) {
    const listen2 = httpServer.listen.bind(httpServer);
    httpServer.listen = async (port, ...args) => {
      try {
        await initServer();
      } catch (e3) {
        httpServer.emit("error", e3);
        return;
      }
      return listen2(port, ...args);
    };
  } else {
    await initServer();
  }
  return server2;
}
async function startServer(server2, inlinePort, isRestart = false) {
  const httpServer = server2.httpServer;
  if (!httpServer) {
    throw new Error("Cannot call server.listen in middleware mode.");
  }
  const options3 = server2.config.server;
  const port = inlinePort ?? options3.port ?? DEFAULT_DEV_PORT;
  const hostname = await resolveHostname(options3.host);
  const protocol = options3.https ? "https" : "http";
  const serverPort = await httpServerStart(httpServer, {
    port,
    strictPort: options3.strictPort,
    host: hostname.host,
    logger: server2.config.logger
  });
  if (options3.open && !isRestart) {
    const path8 = typeof options3.open === "string" ? options3.open : server2.config.base;
    openBrowser(path8.startsWith("http") ? path8 : new URL(path8, `${protocol}://${hostname.name}:${serverPort}`).href, true, server2.config.logger);
  }
}
function createServerCloseFn(server2) {
  if (!server2) {
    return () => {
    };
  }
  let hasListened = false;
  const openSockets = /* @__PURE__ */ new Set();
  server2.on("connection", (socket) => {
    openSockets.add(socket);
    socket.on("close", () => {
      openSockets.delete(socket);
    });
  });
  server2.once("listening", () => {
    hasListened = true;
  });
  return () => new Promise((resolve4, reject) => {
    openSockets.forEach((s2) => s2.destroy());
    if (hasListened) {
      server2.close((err2) => {
        if (err2) {
          reject(err2);
        } else {
          resolve4();
        }
      });
    } else {
      resolve4();
    }
  });
}
function resolvedAllowDir(root, dir) {
  return normalizePath$3(import_node_path4.default.resolve(root, dir));
}
function resolveServerOptions(root, raw, logger2) {
  var _a, _b, _c, _d;
  const server2 = {
    preTransformRequests: true,
    ...raw,
    middlewareMode: !!(raw == null ? void 0 : raw.middlewareMode)
  };
  let allowDirs = (_a = server2.fs) == null ? void 0 : _a.allow;
  const deny = ((_b = server2.fs) == null ? void 0 : _b.deny) || [".env", ".env.*", "*.{crt,pem}"];
  if (!allowDirs) {
    allowDirs = [searchForWorkspaceRoot(root)];
  }
  allowDirs = allowDirs.map((i2) => resolvedAllowDir(root, i2));
  const resolvedClientDir = resolvedAllowDir(root, CLIENT_DIR);
  if (!allowDirs.some((dir) => isParentDirectory(dir, resolvedClientDir))) {
    allowDirs.push(resolvedClientDir);
  }
  server2.fs = {
    strict: ((_c = server2.fs) == null ? void 0 : _c.strict) ?? true,
    allow: allowDirs,
    deny
  };
  if ((_d = server2.origin) == null ? void 0 : _d.endsWith("/")) {
    server2.origin = server2.origin.slice(0, -1);
    logger2.warn(picocolorsExports.yellow(`${picocolorsExports.bold("(!)")} server.origin should not end with "/". Using "${server2.origin}" instead.`));
  }
  return server2;
}
async function restartServer(server2) {
  global.__vite_start_time = import_node_perf_hooks.performance.now();
  const { port: prevPort, host: prevHost } = server2.config.server;
  const shortcutsOptions = server2._shortcutsOptions;
  await server2.close();
  let inlineConfig = server2.config.inlineConfig;
  if (server2._forceOptimizeOnRestart) {
    inlineConfig = mergeConfig(inlineConfig, {
      optimizeDeps: {
        force: true
      }
    });
  }
  let newServer = null;
  try {
    newServer = await createServer(inlineConfig);
  } catch (err2) {
    server2.config.logger.error(err2.message, {
      timestamp: true
    });
    return;
  }
  newServer._restartPromise = server2._restartPromise;
  Object.assign(server2, newServer);
  const { logger: logger2, server: { port, host, middlewareMode } } = server2.config;
  if (!middlewareMode) {
    await server2.listen(port, true);
    logger2.info("server restarted.", { timestamp: true });
    if ((port ?? DEFAULT_DEV_PORT) !== (prevPort ?? DEFAULT_DEV_PORT) || host !== prevHost) {
      logger2.info("");
      server2.printUrls();
    }
  } else {
    logger2.info("server restarted.", { timestamp: true });
  }
  if (shortcutsOptions) {
    shortcutsOptions.print = false;
    bindShortcuts(newServer, shortcutsOptions);
  }
  newServer._restartPromise = null;
}
async function updateCjsSsrExternals(server2) {
  if (!server2._ssrExternals) {
    let knownImports = [];
    const depsOptimizer = getDepsOptimizer(server2.config, false);
    if (depsOptimizer) {
      await depsOptimizer.scanProcessing;
      knownImports = [
        ...Object.keys(depsOptimizer.metadata.optimized),
        ...Object.keys(depsOptimizer.metadata.discovered)
      ];
    }
    server2._ssrExternals = cjsSsrResolveExternals(server2.config, knownImports);
  }
}
var index = {
  __proto__: null,
  createServer,
  resolveServerOptions,
  searchForWorkspaceRoot
};
var noop = () => {
};
var mimes = /text|javascript|\/json|xml/i;
var threshold = 1024;
var level2 = -1;
var brotli = false;
var getChunkSize = (chunk, enc) => chunk ? Buffer.byteLength(chunk, enc) : 0;
function compression() {
  const brotliOpts = typeof brotli === "object" && brotli || {};
  const gzipOpts = {};
  if (!import_node_zlib.default.createBrotliCompress)
    brotli = false;
  return (req2, res, next = noop) => {
    const accept = req2.headers["accept-encoding"] + "";
    const encoding = (brotli && accept.match(/\bbr\b/) || accept.match(/\bgzip\b/) || [])[0];
    if (req2.method === "HEAD" || !encoding)
      return next();
    let compress;
    let pendingStatus;
    let pendingListeners = [];
    let started = false;
    let size = 0;
    function start() {
      started = true;
      size = res.getHeader("Content-Length") | 0 || size;
      const compressible = mimes.test(String(res.getHeader("Content-Type") || "text/plain"));
      const cleartext = !res.getHeader("Content-Encoding");
      const listeners = pendingListeners || [];
      if (compressible && cleartext && size >= threshold) {
        res.setHeader("Content-Encoding", encoding);
        res.removeHeader("Content-Length");
        if (encoding === "br") {
          const params = {
            [import_node_zlib.default.constants.BROTLI_PARAM_QUALITY]: level2,
            [import_node_zlib.default.constants.BROTLI_PARAM_SIZE_HINT]: size
          };
          compress = import_node_zlib.default.createBrotliCompress({
            params: Object.assign(params, brotliOpts)
          });
        } else {
          compress = import_node_zlib.default.createGzip(Object.assign({ level: level2 }, gzipOpts));
        }
        compress.on("data", (chunk) => write.call(res, chunk) === false && compress.pause());
        on.call(res, "drain", () => compress.resume());
        compress.on("end", () => end.call(res));
        listeners.forEach((p2) => compress.on.apply(compress, p2));
      } else {
        pendingListeners = null;
        listeners.forEach((p2) => on.apply(res, p2));
      }
      writeHead.call(res, pendingStatus || res.statusCode);
    }
    const { end, write, on, writeHead } = res;
    res.writeHead = function(status2, reason, headers) {
      if (typeof reason !== "string")
        [headers, reason] = [reason, headers];
      if (headers)
        for (let i2 in headers)
          res.setHeader(i2, headers[i2]);
      pendingStatus = status2;
      return this;
    };
    res.write = function(chunk, enc, cb) {
      size += getChunkSize(chunk, enc);
      if (!started)
        start();
      if (!compress)
        return write.apply(this, arguments);
      return compress.write.apply(compress, arguments);
    };
    res.end = function(chunk, enc, cb) {
      if (arguments.length > 0 && typeof chunk !== "function") {
        size += getChunkSize(chunk, enc);
      }
      if (!started)
        start();
      if (!compress)
        return end.apply(this, arguments);
      return compress.end.apply(compress, arguments);
    };
    res.on = function(type, listener2) {
      if (!pendingListeners || type !== "drain")
        on.call(this, type, listener2);
      else if (compress)
        compress.on(type, listener2);
      else
        pendingListeners.push([type, listener2]);
      return this;
    };
    next();
  };
}
function resolvePreviewOptions(preview2, server2) {
  return {
    port: preview2 == null ? void 0 : preview2.port,
    strictPort: (preview2 == null ? void 0 : preview2.strictPort) ?? server2.strictPort,
    host: (preview2 == null ? void 0 : preview2.host) ?? server2.host,
    https: (preview2 == null ? void 0 : preview2.https) ?? server2.https,
    open: (preview2 == null ? void 0 : preview2.open) ?? server2.open,
    proxy: (preview2 == null ? void 0 : preview2.proxy) ?? server2.proxy,
    cors: (preview2 == null ? void 0 : preview2.cors) ?? server2.cors,
    headers: (preview2 == null ? void 0 : preview2.headers) ?? server2.headers
  };
}
async function preview(inlineConfig = {}) {
  var _a, _b;
  const config2 = await resolveConfig(inlineConfig, "serve", "production", "production");
  const distDir = import_node_path4.default.resolve(config2.root, config2.build.outDir);
  if (!import_node_fs4.default.existsSync(distDir) && // error if no plugins implement `configurePreviewServer`
  config2.plugins.every((plugin) => !plugin.configurePreviewServer) && // error if called in CLI only. programmatic usage could access `httpServer`
  // and affect file serving
  ((_a = process.argv[1]) == null ? void 0 : _a.endsWith(import_node_path4.default.normalize("bin/vite.js"))) && process.argv[2] === "preview") {
    throw new Error(`The directory "${config2.build.outDir}" does not exist. Did you build your project?`);
  }
  const app = connect();
  const httpServer = await resolveHttpServer(config2.preview, app, await resolveHttpsConfig((_b = config2.preview) == null ? void 0 : _b.https));
  setClientErrorHandler(httpServer, config2.logger);
  const postHooks = [];
  for (const hook of config2.getSortedPluginHooks("configurePreviewServer")) {
    postHooks.push(await hook({ middlewares: app, httpServer }));
  }
  const { cors } = config2.preview;
  if (cors !== false) {
    app.use(libExports$1(typeof cors === "boolean" ? {} : cors));
  }
  const { proxy } = config2.preview;
  if (proxy) {
    app.use(proxyMiddleware(httpServer, proxy, config2));
  }
  app.use(compression());
  const previewBase = config2.base === "./" || config2.base === "" ? "/" : config2.base;
  const headers = config2.preview.headers;
  const assetServer = sirv(distDir, {
    etag: true,
    dev: true,
    single: config2.appType === "spa",
    setHeaders(res) {
      if (headers) {
        for (const name2 in headers) {
          res.setHeader(name2, headers[name2]);
        }
      }
    },
    shouldServe(filePath) {
      return shouldServeFile(filePath, distDir);
    }
  });
  app.use(previewBase, assetServer);
  postHooks.forEach((fn) => fn && fn());
  const options3 = config2.preview;
  const hostname = await resolveHostname(options3.host);
  const port = options3.port ?? DEFAULT_PREVIEW_PORT;
  const protocol = options3.https ? "https" : "http";
  const logger2 = config2.logger;
  const serverPort = await httpServerStart(httpServer, {
    port,
    strictPort: options3.strictPort,
    host: hostname.host,
    logger: logger2
  });
  const resolvedUrls = await resolveServerUrls(httpServer, config2.preview, config2);
  if (options3.open) {
    const path8 = typeof options3.open === "string" ? options3.open : previewBase;
    openBrowser(path8.startsWith("http") ? path8 : new URL(path8, `${protocol}://${hostname.name}:${serverPort}`).href, true, logger2);
  }
  return {
    config: config2,
    httpServer,
    resolvedUrls,
    printUrls() {
      printServerUrls(resolvedUrls, options3.host, logger2.info);
    }
  };
}
var preview$1 = {
  __proto__: null,
  preview,
  resolvePreviewOptions
};
function resolveSSROptions(ssr, preserveSymlinks, buildSsrCjsExternalHeuristics) {
  ssr ?? (ssr = {});
  const optimizeDeps2 = ssr.optimizeDeps ?? {};
  let format2 = "esm";
  let target = "node";
  if (buildSsrCjsExternalHeuristics) {
    if (ssr) {
      format2 = "cjs";
    } else {
      target = "node";
      format2 = "cjs";
    }
  }
  return {
    format: format2,
    target,
    ...ssr,
    optimizeDeps: {
      disabled: true,
      ...optimizeDeps2,
      esbuildOptions: {
        preserveSymlinks,
        ...optimizeDeps2.esbuildOptions
      }
    }
  };
}
var debug2 = createDebugger("vite:config");
function defineConfig(config2) {
  return config2;
}
async function resolveConfig(inlineConfig, command, defaultMode = "development", defaultNodeEnv = "development") {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s;
  let config2 = inlineConfig;
  let configFileDependencies = [];
  let mode2 = inlineConfig.mode || defaultMode;
  const isNodeEnvSet = true;
  if (!isNodeEnvSet) {
    process.env.NODE_ENV = defaultNodeEnv;
  }
  const configEnv = {
    mode: mode2,
    command,
    ssrBuild: !!((_a = config2.build) == null ? void 0 : _a.ssr)
  };
  let { configFile: configFile2 } = config2;
  if (configFile2 !== false) {
    const loadResult = await loadConfigFromFile(configEnv, configFile2, config2.root, config2.logLevel);
    if (loadResult) {
      config2 = mergeConfig(loadResult.config, config2);
      configFile2 = loadResult.path;
      configFileDependencies = loadResult.dependencies;
    }
  }
  mode2 = inlineConfig.mode || config2.mode || mode2;
  configEnv.mode = mode2;
  const filterPlugin = (p2) => {
    if (!p2) {
      return false;
    } else if (!p2.apply) {
      return true;
    } else if (typeof p2.apply === "function") {
      return p2.apply({ ...config2, mode: mode2 }, configEnv);
    } else {
      return p2.apply === command;
    }
  };
  const rawWorkerUserPlugins = (await asyncFlatten(((_b = config2.worker) == null ? void 0 : _b.plugins) || [])).filter(filterPlugin);
  const rawUserPlugins = (await asyncFlatten(config2.plugins || [])).filter(filterPlugin);
  const [prePlugins, normalPlugins, postPlugins] = sortUserPlugins(rawUserPlugins);
  const userPlugins = [...prePlugins, ...normalPlugins, ...postPlugins];
  config2 = await runConfigHook(config2, userPlugins, configEnv);
  if (process.env.VITE_TEST_WITHOUT_PLUGIN_COMMONJS) {
    config2 = mergeConfig(config2, {
      optimizeDeps: { disabled: false },
      ssr: { optimizeDeps: { disabled: false } }
    });
    config2.build ?? (config2.build = {});
    config2.build.commonjsOptions = { include: [] };
  }
  const logger2 = createLogger(config2.logLevel, {
    allowClearScreen: config2.clearScreen,
    customLogger: config2.customLogger
  });
  const resolvedRoot = normalizePath$3(config2.root ? import_node_path4.default.resolve(config2.root) : process.cwd());
  const clientAlias = [
    { find: /^\/?@vite\/env/, replacement: ENV_ENTRY },
    { find: /^\/?@vite\/client/, replacement: CLIENT_ENTRY }
  ];
  const resolvedAlias = normalizeAlias(mergeAlias(clientAlias, ((_c = config2.resolve) == null ? void 0 : _c.alias) || []));
  const resolveOptions = {
    mainFields: ((_d = config2.resolve) == null ? void 0 : _d.mainFields) ?? DEFAULT_MAIN_FIELDS,
    browserField: ((_e = config2.resolve) == null ? void 0 : _e.browserField) ?? true,
    conditions: ((_f = config2.resolve) == null ? void 0 : _f.conditions) ?? [],
    extensions: ((_g = config2.resolve) == null ? void 0 : _g.extensions) ?? DEFAULT_EXTENSIONS,
    dedupe: ((_h = config2.resolve) == null ? void 0 : _h.dedupe) ?? [],
    preserveSymlinks: ((_i = config2.resolve) == null ? void 0 : _i.preserveSymlinks) ?? false,
    alias: resolvedAlias
  };
  const envDir = config2.envDir ? normalizePath$3(import_node_path4.default.resolve(resolvedRoot, config2.envDir)) : resolvedRoot;
  const userEnv = inlineConfig.envFile !== false && loadEnv(mode2, envDir, resolveEnvPrefix(config2));
  const userNodeEnv = process.env.VITE_USER_NODE_ENV;
  if (!isNodeEnvSet && userNodeEnv) {
    if (userNodeEnv === "development") {
      process.env.NODE_ENV = "development";
    } else {
      logger2.warn(`NODE_ENV=${userNodeEnv} is not supported in the .env file. Only NODE_ENV=development is supported to create a development build of your project. If you need to set process.env.NODE_ENV, you can set it in the Vite config instead.`);
    }
  }
  const isProduction = false;
  const isBuild = command === "build";
  const relativeBaseShortcut = config2.base === "" || config2.base === "./";
  const resolvedBase = relativeBaseShortcut ? !isBuild || ((_j = config2.build) == null ? void 0 : _j.ssr) ? "/" : "./" : resolveBaseUrl(config2.base, isBuild, logger2) ?? "/";
  const resolvedBuildOptions = resolveBuildOptions(config2.build, logger2);
  const pkgPath = lookupFile(resolvedRoot, [`package.json`], { pathOnly: true });
  const cacheDir = normalizePath$3(config2.cacheDir ? import_node_path4.default.resolve(resolvedRoot, config2.cacheDir) : pkgPath ? import_node_path4.default.join(import_node_path4.default.dirname(pkgPath), `node_modules/.vite`) : import_node_path4.default.join(resolvedRoot, `.vite`));
  const assetsFilter = config2.assetsInclude && (!Array.isArray(config2.assetsInclude) || config2.assetsInclude.length) ? createFilter2(config2.assetsInclude) : () => false;
  const createResolver = (options3) => {
    let aliasContainer;
    let resolverContainer;
    return async (id, importer, aliasOnly, ssr2) => {
      var _a2;
      let container;
      if (aliasOnly) {
        container = aliasContainer || (aliasContainer = await createPluginContainer({
          ...resolved,
          plugins: [alias$1({ entries: resolved.resolve.alias })]
        }));
      } else {
        container = resolverContainer || (resolverContainer = await createPluginContainer({
          ...resolved,
          plugins: [
            alias$1({ entries: resolved.resolve.alias }),
            resolvePlugin({
              ...resolved.resolve,
              root: resolvedRoot,
              isProduction,
              isBuild: command === "build",
              ssrConfig: resolved.ssr,
              asSrc: true,
              preferRelative: false,
              tryIndex: true,
              ...options3
            })
          ]
        }));
      }
      return (_a2 = await container.resolveId(id, importer, {
        ssr: ssr2,
        scan: options3 == null ? void 0 : options3.scan
      })) == null ? void 0 : _a2.id;
    };
  };
  const { publicDir } = config2;
  const resolvedPublicDir = publicDir !== false && publicDir !== "" ? import_node_path4.default.resolve(resolvedRoot, typeof publicDir === "string" ? publicDir : "public") : "";
  const server2 = resolveServerOptions(resolvedRoot, config2.server, logger2);
  const ssr = resolveSSROptions(config2.ssr, resolveOptions.preserveSymlinks, (_k = config2.legacy) == null ? void 0 : _k.buildSsrCjsExternalHeuristics);
  const middlewareMode = (_l = config2 == null ? void 0 : config2.server) == null ? void 0 : _l.middlewareMode;
  const optimizeDeps2 = config2.optimizeDeps || {};
  const BASE_URL = resolvedBase;
  let workerConfig = mergeConfig({}, config2);
  const [workerPrePlugins, workerNormalPlugins, workerPostPlugins] = sortUserPlugins(rawWorkerUserPlugins);
  const workerUserPlugins = [
    ...workerPrePlugins,
    ...workerNormalPlugins,
    ...workerPostPlugins
  ];
  workerConfig = await runConfigHook(workerConfig, workerUserPlugins, configEnv);
  const resolvedWorkerOptions = {
    format: ((_m = workerConfig.worker) == null ? void 0 : _m.format) || "iife",
    plugins: [],
    rollupOptions: ((_n = workerConfig.worker) == null ? void 0 : _n.rollupOptions) || {},
    getSortedPlugins: void 0,
    getSortedPluginHooks: void 0
  };
  const resolvedConfig = {
    configFile: configFile2 ? normalizePath$3(configFile2) : void 0,
    configFileDependencies: configFileDependencies.map((name2) => normalizePath$3(import_node_path4.default.resolve(name2))),
    inlineConfig,
    root: resolvedRoot,
    base: resolvedBase.endsWith("/") ? resolvedBase : resolvedBase + "/",
    rawBase: resolvedBase,
    resolve: resolveOptions,
    publicDir: resolvedPublicDir,
    cacheDir,
    command,
    mode: mode2,
    ssr,
    isWorker: false,
    mainConfig: null,
    isProduction,
    plugins: userPlugins,
    server: server2,
    build: resolvedBuildOptions,
    preview: resolvePreviewOptions(config2.preview, server2),
    env: {
      ...userEnv,
      BASE_URL,
      MODE: mode2,
      DEV: !isProduction,
      PROD: isProduction
    },
    assetsInclude(file) {
      return DEFAULT_ASSETS_RE.test(file) || assetsFilter(file);
    },
    logger: logger2,
    packageCache: /* @__PURE__ */ new Map(),
    createResolver,
    optimizeDeps: {
      disabled: "build",
      ...optimizeDeps2,
      esbuildOptions: {
        preserveSymlinks: resolveOptions.preserveSymlinks,
        ...optimizeDeps2.esbuildOptions
      }
    },
    worker: resolvedWorkerOptions,
    appType: config2.appType ?? (middlewareMode === "ssr" ? "custom" : "spa"),
    experimental: {
      importGlobRestoreExtension: false,
      hmrPartialAccept: false,
      ...config2.experimental
    },
    getSortedPlugins: void 0,
    getSortedPluginHooks: void 0
  };
  const resolved = {
    ...config2,
    ...resolvedConfig
  };
  resolved.plugins = await resolvePlugins(resolved, prePlugins, normalPlugins, postPlugins);
  Object.assign(resolved, createPluginHookUtils(resolved.plugins));
  const workerResolved = {
    ...workerConfig,
    ...resolvedConfig,
    isWorker: true,
    mainConfig: resolved
  };
  resolvedConfig.worker.plugins = await resolvePlugins(workerResolved, workerPrePlugins, workerNormalPlugins, workerPostPlugins);
  Object.assign(resolvedConfig.worker, createPluginHookUtils(resolvedConfig.worker.plugins));
  await Promise.all([
    ...resolved.getSortedPluginHooks("configResolved").map((hook) => hook(resolved)),
    ...resolvedConfig.worker.getSortedPluginHooks("configResolved").map((hook) => hook(workerResolved))
  ]);
  if (middlewareMode === "ssr") {
    logger2.warn(picocolorsExports.yellow(`Setting server.middlewareMode to 'ssr' is deprecated, set server.middlewareMode to \`true\`${config2.appType === "custom" ? "" : ` and appType to 'custom'`} instead`));
  }
  if (middlewareMode === "html") {
    logger2.warn(picocolorsExports.yellow(`Setting server.middlewareMode to 'html' is deprecated, set server.middlewareMode to \`true\` instead`));
  }
  if (((_o = config2.server) == null ? void 0 : _o.force) && !isBuild && ((_p = config2.optimizeDeps) == null ? void 0 : _p.force) === void 0) {
    resolved.optimizeDeps.force = true;
    logger2.warn(picocolorsExports.yellow(`server.force is deprecated, use optimizeDeps.force instead`));
  }
  if (process.env.DEBUG) {
    debug2(`using resolved config: %O`, {
      ...resolved,
      plugins: resolved.plugins.map((p2) => p2.name),
      worker: {
        ...resolved.worker,
        plugins: resolved.worker.plugins.map((p2) => p2.name)
      }
    });
  }
  if (((_q = config2.build) == null ? void 0 : _q.terserOptions) && config2.build.minify !== "terser") {
    logger2.warn(picocolorsExports.yellow(`build.terserOptions is specified but build.minify is not set to use Terser. Note Vite now defaults to use esbuild for minification. If you still prefer Terser, set build.minify to "terser".`));
  }
  const outputOption = ((_s = (_r = config2.build) == null ? void 0 : _r.rollupOptions) == null ? void 0 : _s.output) ?? [];
  if (Array.isArray(outputOption)) {
    const assetFileNamesList = outputOption.map((output) => output.assetFileNames);
    if (assetFileNamesList.length > 1) {
      const firstAssetFileNames = assetFileNamesList[0];
      const hasDifferentReference = assetFileNamesList.some((assetFileNames) => assetFileNames !== firstAssetFileNames);
      if (hasDifferentReference) {
        resolved.logger.warn(picocolorsExports.yellow(`
assetFileNames isn't equal for every build.rollupOptions.output. A single pattern across all outputs is supported by Vite.
`));
      }
    }
  }
  return resolved;
}
function resolveBaseUrl(base2 = "/", isBuild, logger2) {
  if (base2.startsWith(".")) {
    logger2.warn(picocolorsExports.yellow(picocolorsExports.bold(`(!) invalid "base" option: ${base2}. The value can only be an absolute URL, ./, or an empty string.`)));
    return "/";
  }
  const isExternal2 = isExternalUrl(base2);
  if (!isExternal2 && !base2.startsWith("/")) {
    logger2.warn(picocolorsExports.yellow(picocolorsExports.bold(`(!) "base" option should start with a slash.`)));
  }
  if (!isBuild || !isExternal2) {
    base2 = new URL(base2, "http://vitejs.dev").pathname;
    if (!base2.startsWith("/")) {
      base2 = "/" + base2;
    }
  }
  return base2;
}
function sortUserPlugins(plugins2) {
  const prePlugins = [];
  const postPlugins = [];
  const normalPlugins = [];
  if (plugins2) {
    plugins2.flat().forEach((p2) => {
      if (p2.enforce === "pre")
        prePlugins.push(p2);
      else if (p2.enforce === "post")
        postPlugins.push(p2);
      else
        normalPlugins.push(p2);
    });
  }
  return [prePlugins, normalPlugins, postPlugins];
}
async function loadConfigFromFile(configEnv, configFile2, configRoot = process.cwd(), logLevel) {
  const start = import_node_perf_hooks.performance.now();
  const getTime = () => `${(import_node_perf_hooks.performance.now() - start).toFixed(2)}ms`;
  let resolvedPath;
  if (configFile2) {
    resolvedPath = import_node_path4.default.resolve(configFile2);
  } else {
    for (const filename of DEFAULT_CONFIG_FILES) {
      const filePath = import_node_path4.default.resolve(configRoot, filename);
      if (!import_node_fs4.default.existsSync(filePath))
        continue;
      resolvedPath = filePath;
      break;
    }
  }
  if (!resolvedPath) {
    debug2("no config file found.");
    return null;
  }
  let isESM = false;
  if (/\.m[jt]s$/.test(resolvedPath)) {
    isESM = true;
  } else if (/\.c[jt]s$/.test(resolvedPath)) {
    isESM = false;
  } else {
    try {
      const pkg = lookupFile(configRoot, ["package.json"]);
      isESM = !!pkg && JSON.parse(pkg).type === "module";
    } catch (e3) {
    }
  }
  try {
    const bundled = await bundleConfigFile(resolvedPath, isESM);
    const userConfig = await loadConfigFromBundledFile(resolvedPath, bundled.code, isESM);
    debug2(`bundled config file loaded in ${getTime()}`);
    const config2 = await (typeof userConfig === "function" ? userConfig(configEnv) : userConfig);
    if (!isObject$1(config2)) {
      throw new Error(`config must export or return an object.`);
    }
    return {
      path: normalizePath$3(resolvedPath),
      config: config2,
      dependencies: bundled.dependencies
    };
  } catch (e3) {
    createLogger(logLevel).error(picocolorsExports.red(`failed to load config from ${resolvedPath}`), { error: e3 });
    throw e3;
  }
}
async function bundleConfigFile(fileName, isESM) {
  const dirnameVarName = "__vite_injected_original_dirname";
  const filenameVarName = "__vite_injected_original_filename";
  const importMetaUrlVarName = "__vite_injected_original_import_meta_url";
  const result = await (0, import_esbuild.build)({
    absWorkingDir: process.cwd(),
    entryPoints: [fileName],
    outfile: "out.js",
    write: false,
    target: ["node14.18", "node16"],
    platform: "node",
    bundle: true,
    format: isESM ? "esm" : "cjs",
    mainFields: ["main"],
    sourcemap: "inline",
    metafile: true,
    define: {
      __dirname: dirnameVarName,
      __filename: filenameVarName,
      "import.meta.url": importMetaUrlVarName
    },
    plugins: [
      {
        name: "externalize-deps",
        setup(build4) {
          const options3 = {
            root: import_node_path4.default.dirname(fileName),
            isBuild: true,
            isProduction: true,
            preferRelative: false,
            tryIndex: true,
            mainFields: [],
            browserField: false,
            conditions: [],
            overrideConditions: ["node"],
            dedupe: [],
            extensions: DEFAULT_EXTENSIONS,
            preserveSymlinks: false
          };
          build4.onResolve({ filter: /^[^.].*/ }, async ({ path: id, importer, kind }) => {
            var _a;
            if (kind === "entry-point" || import_node_path4.default.isAbsolute(id) || isBuiltin(id)) {
              return;
            }
            if (id.startsWith("npm:")) {
              return { external: true };
            }
            const isIdESM = isESM || kind === "dynamic-import";
            let idFsPath = (_a = tryNodeResolve(id, importer, { ...options3, isRequire: !isIdESM }, false)) == null ? void 0 : _a.id;
            if (idFsPath && isIdESM) {
              idFsPath = (0, import_node_url3.pathToFileURL)(idFsPath).href;
            }
            return {
              path: idFsPath,
              external: true
            };
          });
        }
      },
      {
        name: "inject-file-scope-variables",
        setup(build4) {
          build4.onLoad({ filter: /\.[cm]?[jt]s$/ }, async (args) => {
            const contents = await import_node_fs4.default.promises.readFile(args.path, "utf8");
            const injectValues = `const ${dirnameVarName} = ${JSON.stringify(import_node_path4.default.dirname(args.path))};const ${filenameVarName} = ${JSON.stringify(args.path)};const ${importMetaUrlVarName} = ${JSON.stringify((0, import_node_url3.pathToFileURL)(args.path).href)};`;
            return {
              loader: args.path.endsWith("ts") ? "ts" : "js",
              contents: injectValues + contents
            };
          });
        }
      }
    ]
  });
  const { text } = result.outputFiles[0];
  return {
    code: text,
    dependencies: result.metafile ? Object.keys(result.metafile.inputs) : []
  };
}
var _require = (0, import_node_module.createRequire)(import.meta.url);
async function loadConfigFromBundledFile(fileName, bundledCode, isESM) {
  if (isESM) {
    const fileBase = `${fileName}.timestamp-${Date.now()}`;
    const fileNameTmp = `${fileBase}.mjs`;
    const fileUrl = `${(0, import_node_url3.pathToFileURL)(fileBase)}.mjs`;
    import_node_fs4.default.writeFileSync(fileNameTmp, bundledCode);
    try {
      return (await dynamicImport(fileUrl)).default;
    } finally {
      try {
        import_node_fs4.default.unlinkSync(fileNameTmp);
      } catch {
      }
    }
  } else {
    const extension2 = import_node_path4.default.extname(fileName);
    const realFileName = import_node_fs4.default.realpathSync(fileName);
    const loaderExt = extension2 in _require.extensions ? extension2 : ".js";
    const defaultLoader = _require.extensions[loaderExt];
    _require.extensions[loaderExt] = (module2, filename) => {
      if (filename === realFileName) {
        module2._compile(bundledCode, filename);
      } else {
        defaultLoader(module2, filename);
      }
    };
    delete _require.cache[_require.resolve(fileName)];
    const raw = _require(fileName);
    _require.extensions[loaderExt] = defaultLoader;
    return raw.__esModule ? raw.default : raw;
  }
}
async function runConfigHook(config2, plugins2, configEnv) {
  let conf = config2;
  for (const p2 of getSortedPluginsByHook("config", plugins2)) {
    const hook = p2.config;
    const handler = hook && "handler" in hook ? hook.handler : hook;
    if (handler) {
      const res = await handler(conf, configEnv);
      if (res) {
        conf = mergeConfig(conf, res);
      }
    }
  }
  return conf;
}
function getDepOptimizationConfig(config2, ssr) {
  return ssr ? config2.ssr.optimizeDeps : config2.optimizeDeps;
}
function isDepsOptimizerEnabled(config2, ssr) {
  const { command } = config2;
  const { disabled } = getDepOptimizationConfig(config2, ssr);
  return !(disabled === true || command === "build" && disabled === "build" || command === "serve" && disabled === "dev");
}

// node_modules/.pnpm/vite@4.1.4/node_modules/vite/dist/node/index.js
var import_esbuild2 = __toESM(require_main());
var import_node_fs5 = __toESM(require_node_fs());
var import_node_path6 = __toESM(require_node_path());
var import_node_url5 = __toESM(require_node_url());
var import_node_perf_hooks2 = __toESM(require_node_perf_hooks());
var import_node_module3 = __toESM(require_node_module());
var import_tty2 = __toESM(require_tty());
var import_path2 = __toESM(require_path());
var import_fs2 = __toESM(require_fs());
var import_events2 = __toESM(require_events());
var import_assert2 = __toESM(require_assert());
var import_util2 = __toESM(require_util());
var import_net2 = __toESM(require_net());
var import_url4 = __toESM(require_url());
var import_http2 = __toESM(require_http());
var import_stream2 = __toESM(require_stream());
var import_os2 = __toESM(require_os());
var import_child_process2 = __toESM(require_child_process());
var import_node_os2 = __toESM(require_node_os());
var import_node_crypto2 = __toESM(require_node_crypto());
var import_node_util2 = __toESM(require_node_util());
var import_node_dns2 = __toESM(require_node_dns());
var import_resolve2 = __toESM(require_resolve());
var import_crypto2 = __toESM(require_crypto());
var import_node_buffer2 = __toESM(require_node_buffer());
var import_module2 = __toESM(require_module());
var import_node_assert2 = __toESM(require_node_assert());
var import_node_process8 = __toESM(require_node_process());
var import_node_v82 = __toESM(require_node_v8());
var import_worker_threads2 = __toESM(require_worker_threads());
var import_zlib2 = __toESM(require_zlib());
var import_buffer2 = __toESM(require_buffer());
var import_https2 = __toESM(require_https());
var import_tls2 = __toESM(require_tls());
var import_node_http2 = __toESM(require_node_http());
var import_node_https2 = __toESM(require_node_https());
var import_querystring = __toESM(require_querystring());
var import_node_child_process2 = __toESM(require_node_child_process());
var import_node_readline3 = __toESM(require_node_readline());
var import_node_zlib2 = __toESM(require_node_zlib());
var CSS_LANGS_RE2 = (
  // eslint-disable-next-line regexp/no-unused-capturing-group
  /\.(css|less|sass|scss|styl|stylus|pcss|postcss|sss)(?:$|\?)/
);
var isCSSRequest2 = (request) => CSS_LANGS_RE2.test(request);

// node_modules/.pnpm/@vitejs+plugin-vue@4.2.1_vite@4.1.4_vue@3.2.47/node_modules/@vitejs/plugin-vue/dist/index.mjs
var import_node_fs6 = __toESM(require_node_fs(), 1);
var import_node_module4 = __toESM(require_node_module(), 1);
var import_node_path7 = __toESM(require_node_path(), 1);
var import_node_crypto3 = __toESM(require_node_crypto(), 1);
var import_tty3 = __toESM(require_tty(), 1);
var import_util3 = __toESM(require_util(), 1);
function resolveCompiler(root) {
  const compiler = tryResolveCompiler(root) || tryResolveCompiler();
  if (!compiler) {
    throw new Error(
      `Failed to resolve vue/compiler-sfc.
@vitejs/plugin-vue requires vue (>=3.2.25) to be present in the dependency tree.`
    );
  }
  return compiler;
}
function tryResolveCompiler(root) {
  const vueMeta = tryRequire("vue/package.json", root);
  if (vueMeta && vueMeta.version.split(".")[0] >= 3) {
    return tryRequire("vue/compiler-sfc", root);
  }
}
var _require2 = (0, import_node_module4.createRequire)(import.meta.url);
function tryRequire(id, from) {
  try {
    return from ? _require2(_require2.resolve(id, { paths: [from] })) : _require2(id);
  } catch (e3) {
  }
}
function parseVueRequest(id) {
  const [filename, rawQuery] = id.split(`?`, 2);
  const query = Object.fromEntries(new URLSearchParams(rawQuery));
  if (query.vue != null) {
    query.vue = true;
  }
  if (query.index != null) {
    query.index = Number(query.index);
  }
  if (query.raw != null) {
    query.raw = true;
  }
  if (query.url != null) {
    query.url = true;
  }
  if (query.scoped != null) {
    query.scoped = true;
  }
  return {
    filename,
    query
  };
}
function slash3(path8) {
  const isExtendedLengthPath = /^\\\\\?\\/.test(path8);
  if (isExtendedLengthPath) {
    return path8;
  }
  return path8.replace(/\\/g, "/");
}
var cache = /* @__PURE__ */ new Map();
var prevCache = /* @__PURE__ */ new Map();
function createDescriptor(filename, source, { root, isProduction, sourceMap, compiler }) {
  const { descriptor, errors } = compiler.parse(source, {
    filename,
    sourceMap
  });
  const normalizedPath = slash3(import_node_path7.default.normalize(import_node_path7.default.relative(root, filename)));
  descriptor.id = getHash2(normalizedPath + (isProduction ? source : ""));
  cache.set(filename, descriptor);
  return { descriptor, errors };
}
function getPrevDescriptor(filename) {
  return prevCache.get(filename);
}
function setPrevDescriptor(filename, entry2) {
  prevCache.set(filename, entry2);
}
function getDescriptor(filename, options3, createIfNotFound = true) {
  if (cache.has(filename)) {
    return cache.get(filename);
  }
  if (createIfNotFound) {
    const { descriptor, errors } = createDescriptor(
      filename,
      import_node_fs6.default.readFileSync(filename, "utf-8"),
      options3
    );
    if (errors.length) {
      throw errors[0];
    }
    return descriptor;
  }
}
function getSrcDescriptor(filename, query) {
  if (query.scoped) {
    return cache.get(`${filename}?src=${query.src}`);
  }
  return cache.get(filename);
}
function setSrcDescriptor(filename, entry2, scoped) {
  if (scoped) {
    cache.set(`${filename}?src=${entry2.id}`, entry2);
    return;
  }
  cache.set(filename, entry2);
}
function getHash2(text) {
  return (0, import_node_crypto3.createHash)("sha256").update(text).digest("hex").substring(0, 8);
}
function createRollupError(id, error3) {
  const { message, name: name2, stack } = error3;
  const rollupError = {
    id,
    plugin: "vue",
    message,
    name: name2,
    stack
  };
  if ("code" in error3 && error3.loc) {
    rollupError.loc = {
      file: id,
      line: error3.loc.start.line,
      column: error3.loc.start.column
    };
  }
  return rollupError;
}
async function transformTemplateAsModule(code, descriptor, options3, pluginContext, ssr) {
  const result = compile2(code, descriptor, options3, pluginContext, ssr);
  let returnCode = result.code;
  if (options3.devServer && options3.devServer.config.server.hmr !== false && !ssr && !options3.isProduction) {
    returnCode += `
import.meta.hot.accept(({ render }) => {
      __VUE_HMR_RUNTIME__.rerender(${JSON.stringify(descriptor.id)}, render)
    })`;
  }
  return {
    code: returnCode,
    map: result.map
  };
}
function transformTemplateInMain(code, descriptor, options3, pluginContext, ssr) {
  const result = compile2(code, descriptor, options3, pluginContext, ssr);
  return {
    ...result,
    code: result.code.replace(
      /\nexport (function|const) (render|ssrRender)/,
      "\n$1 _sfc_$2"
    )
  };
}
function compile2(code, descriptor, options3, pluginContext, ssr) {
  const filename = descriptor.filename;
  const result = options3.compiler.compileTemplate({
    ...resolveTemplateCompilerOptions(descriptor, options3, ssr),
    source: code
  });
  if (result.errors.length) {
    result.errors.forEach(
      (error3) => pluginContext.error(
        typeof error3 === "string" ? { id: filename, message: error3 } : createRollupError(filename, error3)
      )
    );
  }
  if (result.tips.length) {
    result.tips.forEach(
      (tip2) => pluginContext.warn({
        id: filename,
        message: tip2
      })
    );
  }
  return result;
}
function resolveTemplateCompilerOptions(descriptor, options3, ssr) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const block = descriptor.template;
  if (!block) {
    return;
  }
  const resolvedScript = getResolvedScript(descriptor, ssr);
  const hasScoped = descriptor.styles.some((s2) => s2.scoped);
  const { id, filename, cssVars } = descriptor;
  let transformAssetUrls = (_a = options3.template) == null ? void 0 : _a.transformAssetUrls;
  let assetUrlOptions;
  if (options3.devServer) {
    if (filename.startsWith(options3.root)) {
      const devBase = options3.devServer.config.base;
      assetUrlOptions = {
        base: (((_b = options3.devServer.config.server) == null ? void 0 : _b.origin) ?? "") + devBase + slash3(import_node_path7.default.relative(options3.root, import_node_path7.default.dirname(filename)))
      };
    }
  } else if (transformAssetUrls !== false) {
    assetUrlOptions = {
      includeAbsolute: true
    };
  }
  if (transformAssetUrls && typeof transformAssetUrls === "object") {
    if (Object.values(transformAssetUrls).some((val) => Array.isArray(val))) {
      transformAssetUrls = {
        ...assetUrlOptions,
        tags: transformAssetUrls
      };
    } else {
      transformAssetUrls = { ...assetUrlOptions, ...transformAssetUrls };
    }
  } else {
    transformAssetUrls = assetUrlOptions;
  }
  let preprocessOptions = block.lang && ((_c = options3.template) == null ? void 0 : _c.preprocessOptions);
  if (block.lang === "pug") {
    preprocessOptions = {
      doctype: "html",
      ...preprocessOptions
    };
  }
  const expressionPlugins = ((_e = (_d = options3.template) == null ? void 0 : _d.compilerOptions) == null ? void 0 : _e.expressionPlugins) || [];
  const lang = ((_f = descriptor.scriptSetup) == null ? void 0 : _f.lang) || ((_g = descriptor.script) == null ? void 0 : _g.lang);
  if (lang && /tsx?$/.test(lang) && !expressionPlugins.includes("typescript")) {
    expressionPlugins.push("typescript");
  }
  return {
    ...options3.template,
    id,
    filename,
    scoped: hasScoped,
    slotted: descriptor.slotted,
    isProd: options3.isProduction,
    inMap: block.src ? void 0 : block.map,
    ssr,
    ssrCssVars: cssVars,
    transformAssetUrls,
    preprocessLang: block.lang,
    preprocessOptions,
    compilerOptions: {
      ...(_h = options3.template) == null ? void 0 : _h.compilerOptions,
      scopeId: hasScoped ? `data-v-${id}` : void 0,
      bindingMetadata: resolvedScript ? resolvedScript.bindings : void 0,
      expressionPlugins,
      sourceMap: options3.sourceMap
    }
  };
}
var clientCache = /* @__PURE__ */ new WeakMap();
var ssrCache = /* @__PURE__ */ new WeakMap();
var typeDepToSFCMap = /* @__PURE__ */ new Map();
function invalidateScript(filename) {
  const desc = cache.get(filename);
  if (desc) {
    clientCache.delete(desc);
    ssrCache.delete(desc);
  }
}
function getResolvedScript(descriptor, ssr) {
  return (ssr ? ssrCache : clientCache).get(descriptor);
}
function setResolvedScript(descriptor, script, ssr) {
  (ssr ? ssrCache : clientCache).set(descriptor, script);
}
function isUseInlineTemplate(descriptor, isProd) {
  var _a;
  return isProd && !!descriptor.scriptSetup && !((_a = descriptor.template) == null ? void 0 : _a.src);
}
var scriptIdentifier = `_sfc_main`;
function resolveScript(descriptor, options3, ssr) {
  if (!descriptor.script && !descriptor.scriptSetup) {
    return null;
  }
  const cacheToUse = ssr ? ssrCache : clientCache;
  const cached = cacheToUse.get(descriptor);
  if (cached) {
    return cached;
  }
  let resolved = null;
  resolved = options3.compiler.compileScript(descriptor, {
    ...options3.script,
    id: descriptor.id,
    isProd: options3.isProduction,
    inlineTemplate: isUseInlineTemplate(descriptor, !options3.devServer),
    reactivityTransform: options3.reactivityTransform !== false,
    templateOptions: resolveTemplateCompilerOptions(descriptor, options3, ssr),
    sourceMap: options3.sourceMap,
    genDefaultAs: canInlineMain(descriptor, options3) ? scriptIdentifier : void 0
  });
  if (!options3.isProduction && (resolved == null ? void 0 : resolved.deps)) {
    for (const [key, sfcs] of typeDepToSFCMap) {
      if (sfcs.has(descriptor.filename) && !resolved.deps.includes(key)) {
        sfcs.delete(descriptor.filename);
      }
    }
    for (const dep of resolved.deps) {
      const existingSet = typeDepToSFCMap.get(dep);
      if (!existingSet) {
        typeDepToSFCMap.set(dep, /* @__PURE__ */ new Set([descriptor.filename]));
      } else {
        existingSet.add(descriptor.filename);
      }
    }
  }
  cacheToUse.set(descriptor, resolved);
  return resolved;
}
function canInlineMain(descriptor, options3) {
  var _a, _b, _c, _d;
  if (((_a = descriptor.script) == null ? void 0 : _a.src) || ((_b = descriptor.scriptSetup) == null ? void 0 : _b.src)) {
    return false;
  }
  const lang = ((_c = descriptor.script) == null ? void 0 : _c.lang) || ((_d = descriptor.scriptSetup) == null ? void 0 : _d.lang);
  if (!lang) {
    return true;
  }
  if (lang === "ts" && options3.devServer) {
    return true;
  }
  return false;
}
var comma2 = ",".charCodeAt(0);
var semicolon2 = ";".charCodeAt(0);
var chars2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var intToChar2 = new Uint8Array(64);
var charToInt2 = new Uint8Array(128);
for (let i2 = 0; i2 < chars2.length; i2++) {
  const c2 = chars2.charCodeAt(i2);
  intToChar2[i2] = c2;
  charToInt2[c2] = i2;
}
var td2 = typeof TextDecoder !== "undefined" ? new TextDecoder() : typeof Buffer !== "undefined" ? {
  decode(buf) {
    const out2 = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
    return out2.toString();
  }
} : {
  decode(buf) {
    let out2 = "";
    for (let i2 = 0; i2 < buf.length; i2++) {
      out2 += String.fromCharCode(buf[i2]);
    }
    return out2;
  }
};
function decode2(mappings) {
  const state = new Int32Array(5);
  const decoded = [];
  let index2 = 0;
  do {
    const semi = indexOf2(mappings, index2);
    const line = [];
    let sorted = true;
    let lastCol = 0;
    state[0] = 0;
    for (let i2 = index2; i2 < semi; i2++) {
      let seg;
      i2 = decodeInteger2(mappings, i2, state, 0);
      const col = state[0];
      if (col < lastCol)
        sorted = false;
      lastCol = col;
      if (hasMoreVlq2(mappings, i2, semi)) {
        i2 = decodeInteger2(mappings, i2, state, 1);
        i2 = decodeInteger2(mappings, i2, state, 2);
        i2 = decodeInteger2(mappings, i2, state, 3);
        if (hasMoreVlq2(mappings, i2, semi)) {
          i2 = decodeInteger2(mappings, i2, state, 4);
          seg = [col, state[1], state[2], state[3], state[4]];
        } else {
          seg = [col, state[1], state[2], state[3]];
        }
      } else {
        seg = [col];
      }
      line.push(seg);
    }
    if (!sorted)
      sort2(line);
    decoded.push(line);
    index2 = semi + 1;
  } while (index2 <= mappings.length);
  return decoded;
}
function indexOf2(mappings, index2) {
  const idx = mappings.indexOf(";", index2);
  return idx === -1 ? mappings.length : idx;
}
function decodeInteger2(mappings, pos, state, j) {
  let value2 = 0;
  let shift = 0;
  let integer = 0;
  do {
    const c2 = mappings.charCodeAt(pos++);
    integer = charToInt2[c2];
    value2 |= (integer & 31) << shift;
    shift += 5;
  } while (integer & 32);
  const shouldNegate = value2 & 1;
  value2 >>>= 1;
  if (shouldNegate) {
    value2 = -2147483648 | -value2;
  }
  state[j] += value2;
  return pos;
}
function hasMoreVlq2(mappings, i2, length) {
  if (i2 >= length)
    return false;
  return mappings.charCodeAt(i2) !== comma2;
}
function sort2(line) {
  line.sort(sortComparator$12);
}
function sortComparator$12(a2, b) {
  return a2[0] - b[0];
}
function encode2(decoded) {
  const state = new Int32Array(5);
  const bufLength = 1024 * 16;
  const subLength = bufLength - 36;
  const buf = new Uint8Array(bufLength);
  const sub = buf.subarray(0, subLength);
  let pos = 0;
  let out2 = "";
  for (let i2 = 0; i2 < decoded.length; i2++) {
    const line = decoded[i2];
    if (i2 > 0) {
      if (pos === bufLength) {
        out2 += td2.decode(buf);
        pos = 0;
      }
      buf[pos++] = semicolon2;
    }
    if (line.length === 0)
      continue;
    state[0] = 0;
    for (let j = 0; j < line.length; j++) {
      const segment = line[j];
      if (pos > subLength) {
        out2 += td2.decode(sub);
        buf.copyWithin(0, subLength, pos);
        pos -= subLength;
      }
      if (j > 0)
        buf[pos++] = comma2;
      pos = encodeInteger2(buf, pos, state, segment, 0);
      if (segment.length === 1)
        continue;
      pos = encodeInteger2(buf, pos, state, segment, 1);
      pos = encodeInteger2(buf, pos, state, segment, 2);
      pos = encodeInteger2(buf, pos, state, segment, 3);
      if (segment.length === 4)
        continue;
      pos = encodeInteger2(buf, pos, state, segment, 4);
    }
  }
  return out2 + td2.decode(buf.subarray(0, pos));
}
function encodeInteger2(buf, pos, state, segment, j) {
  const next = segment[j];
  let num = next - state[j];
  state[j] = next;
  num = num < 0 ? -num << 1 | 1 : num << 1;
  do {
    let clamped = num & 31;
    num >>>= 5;
    if (num > 0)
      clamped |= 32;
    buf[pos++] = intToChar2[clamped];
  } while (num > 0);
  return pos;
}
var schemeRegex2 = /^[\w+.-]+:\/\//;
var urlRegex2 = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
var fileRegex2 = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
var UrlType2;
(function(UrlType3) {
  UrlType3[UrlType3["Empty"] = 1] = "Empty";
  UrlType3[UrlType3["Hash"] = 2] = "Hash";
  UrlType3[UrlType3["Query"] = 3] = "Query";
  UrlType3[UrlType3["RelativePath"] = 4] = "RelativePath";
  UrlType3[UrlType3["AbsolutePath"] = 5] = "AbsolutePath";
  UrlType3[UrlType3["SchemeRelative"] = 6] = "SchemeRelative";
  UrlType3[UrlType3["Absolute"] = 7] = "Absolute";
})(UrlType2 || (UrlType2 = {}));
function isAbsoluteUrl2(input) {
  return schemeRegex2.test(input);
}
function isSchemeRelativeUrl2(input) {
  return input.startsWith("//");
}
function isAbsolutePath2(input) {
  return input.startsWith("/");
}
function isFileUrl2(input) {
  return input.startsWith("file:");
}
function isRelative2(input) {
  return /^[.?#]/.test(input);
}
function parseAbsoluteUrl2(input) {
  const match = urlRegex2.exec(input);
  return makeUrl2(match[1], match[2] || "", match[3], match[4] || "", match[5] || "/", match[6] || "", match[7] || "");
}
function parseFileUrl2(input) {
  const match = fileRegex2.exec(input);
  const path8 = match[2];
  return makeUrl2("file:", "", match[1] || "", "", isAbsolutePath2(path8) ? path8 : "/" + path8, match[3] || "", match[4] || "");
}
function makeUrl2(scheme, user, host, port, path8, query, hash2) {
  return {
    scheme,
    user,
    host,
    port,
    path: path8,
    query,
    hash: hash2,
    type: UrlType2.Absolute
  };
}
function parseUrl2(input) {
  if (isSchemeRelativeUrl2(input)) {
    const url3 = parseAbsoluteUrl2("http:" + input);
    url3.scheme = "";
    url3.type = UrlType2.SchemeRelative;
    return url3;
  }
  if (isAbsolutePath2(input)) {
    const url3 = parseAbsoluteUrl2("http://foo.com" + input);
    url3.scheme = "";
    url3.host = "";
    url3.type = UrlType2.AbsolutePath;
    return url3;
  }
  if (isFileUrl2(input))
    return parseFileUrl2(input);
  if (isAbsoluteUrl2(input))
    return parseAbsoluteUrl2(input);
  const url2 = parseAbsoluteUrl2("http://foo.com/" + input);
  url2.scheme = "";
  url2.host = "";
  url2.type = input ? input.startsWith("?") ? UrlType2.Query : input.startsWith("#") ? UrlType2.Hash : UrlType2.RelativePath : UrlType2.Empty;
  return url2;
}
function stripPathFilename2(path8) {
  if (path8.endsWith("/.."))
    return path8;
  const index2 = path8.lastIndexOf("/");
  return path8.slice(0, index2 + 1);
}
function mergePaths2(url2, base2) {
  normalizePath3(base2, base2.type);
  if (url2.path === "/") {
    url2.path = base2.path;
  } else {
    url2.path = stripPathFilename2(base2.path) + url2.path;
  }
}
function normalizePath3(url2, type) {
  const rel = type <= UrlType2.RelativePath;
  const pieces = url2.path.split("/");
  let pointer = 1;
  let positive = 0;
  let addTrailingSlash = false;
  for (let i2 = 1; i2 < pieces.length; i2++) {
    const piece = pieces[i2];
    if (!piece) {
      addTrailingSlash = true;
      continue;
    }
    addTrailingSlash = false;
    if (piece === ".")
      continue;
    if (piece === "..") {
      if (positive) {
        addTrailingSlash = true;
        positive--;
        pointer--;
      } else if (rel) {
        pieces[pointer++] = piece;
      }
      continue;
    }
    pieces[pointer++] = piece;
    positive++;
  }
  let path8 = "";
  for (let i2 = 1; i2 < pointer; i2++) {
    path8 += "/" + pieces[i2];
  }
  if (!path8 || addTrailingSlash && !path8.endsWith("/..")) {
    path8 += "/";
  }
  url2.path = path8;
}
function resolve$12(input, base2) {
  if (!input && !base2)
    return "";
  const url2 = parseUrl2(input);
  let inputType = url2.type;
  if (base2 && inputType !== UrlType2.Absolute) {
    const baseUrl = parseUrl2(base2);
    const baseType = baseUrl.type;
    switch (inputType) {
      case UrlType2.Empty:
        url2.hash = baseUrl.hash;
      case UrlType2.Hash:
        url2.query = baseUrl.query;
      case UrlType2.Query:
      case UrlType2.RelativePath:
        mergePaths2(url2, baseUrl);
      case UrlType2.AbsolutePath:
        url2.user = baseUrl.user;
        url2.host = baseUrl.host;
        url2.port = baseUrl.port;
      case UrlType2.SchemeRelative:
        url2.scheme = baseUrl.scheme;
    }
    if (baseType > inputType)
      inputType = baseType;
  }
  normalizePath3(url2, inputType);
  const queryHash = url2.query + url2.hash;
  switch (inputType) {
    case UrlType2.Hash:
    case UrlType2.Query:
      return queryHash;
    case UrlType2.RelativePath: {
      const path8 = url2.path.slice(1);
      if (!path8)
        return queryHash || ".";
      if (isRelative2(base2 || input) && !isRelative2(path8)) {
        return "./" + path8 + queryHash;
      }
      return path8 + queryHash;
    }
    case UrlType2.AbsolutePath:
      return url2.path + queryHash;
    default:
      return url2.scheme + "//" + url2.user + url2.host + url2.port + url2.path + queryHash;
  }
}
function resolve3(input, base2) {
  if (base2 && !base2.endsWith("/"))
    base2 += "/";
  return resolve$12(input, base2);
}
function stripFilename2(path8) {
  if (!path8)
    return "";
  const index2 = path8.lastIndexOf("/");
  return path8.slice(0, index2 + 1);
}
var COLUMN$1 = 0;
function maybeSort2(mappings, owned) {
  const unsortedIndex = nextUnsortedSegmentLine2(mappings, 0);
  if (unsortedIndex === mappings.length)
    return mappings;
  if (!owned)
    mappings = mappings.slice();
  for (let i2 = unsortedIndex; i2 < mappings.length; i2 = nextUnsortedSegmentLine2(mappings, i2 + 1)) {
    mappings[i2] = sortSegments2(mappings[i2], owned);
  }
  return mappings;
}
function nextUnsortedSegmentLine2(mappings, start) {
  for (let i2 = start; i2 < mappings.length; i2++) {
    if (!isSorted2(mappings[i2]))
      return i2;
  }
  return mappings.length;
}
function isSorted2(line) {
  for (let j = 1; j < line.length; j++) {
    if (line[j][COLUMN$1] < line[j - 1][COLUMN$1]) {
      return false;
    }
  }
  return true;
}
function sortSegments2(line, owned) {
  if (!owned)
    line = line.slice();
  return line.sort(sortComparator2);
}
function sortComparator2(a2, b) {
  return a2[COLUMN$1] - b[COLUMN$1];
}
function memoizedState2() {
  return {
    lastKey: -1,
    lastNeedle: -1,
    lastIndex: -1
  };
}
var decodedMappings2;
var eachMapping;
var TraceMap2 = class {
  constructor(map3, mapUrl) {
    const isString3 = typeof map3 === "string";
    if (!isString3 && map3._decodedMemo)
      return map3;
    const parsed = isString3 ? JSON.parse(map3) : map3;
    const { version: version4, file, names, sourceRoot, sources, sourcesContent } = parsed;
    this.version = version4;
    this.file = file;
    this.names = names;
    this.sourceRoot = sourceRoot;
    this.sources = sources;
    this.sourcesContent = sourcesContent;
    const from = resolve3(sourceRoot || "", stripFilename2(mapUrl));
    this.resolvedSources = sources.map((s2) => resolve3(s2 || "", from));
    const { mappings } = parsed;
    if (typeof mappings === "string") {
      this._encoded = mappings;
      this._decoded = void 0;
    } else {
      this._encoded = void 0;
      this._decoded = maybeSort2(mappings, isString3);
    }
    this._decodedMemo = memoizedState2();
    this._bySources = void 0;
    this._bySourceMemos = void 0;
  }
};
(() => {
  decodedMappings2 = (map3) => {
    return map3._decoded || (map3._decoded = decode2(map3._encoded));
  };
  eachMapping = (map3, cb) => {
    const decoded = decodedMappings2(map3);
    const { names, resolvedSources } = map3;
    for (let i2 = 0; i2 < decoded.length; i2++) {
      const line = decoded[i2];
      for (let j = 0; j < line.length; j++) {
        const seg = line[j];
        const generatedLine = i2 + 1;
        const generatedColumn = seg[0];
        let source = null;
        let originalLine = null;
        let originalColumn = null;
        let name2 = null;
        if (seg.length !== 1) {
          source = resolvedSources[seg[1]];
          originalLine = seg[2] + 1;
          originalColumn = seg[3];
        }
        if (seg.length === 5)
          name2 = names[seg[4]];
        cb({
          generatedLine,
          generatedColumn,
          source,
          originalLine,
          originalColumn,
          name: name2
        });
      }
    }
  };
})();
var get2;
var put2;
var SetArray2 = class {
  constructor() {
    this._indexes = { __proto__: null };
    this.array = [];
  }
};
(() => {
  get2 = (strarr, key) => strarr._indexes[key];
  put2 = (strarr, key) => {
    const index2 = get2(strarr, key);
    if (index2 !== void 0)
      return index2;
    const { array: array2, _indexes: indexes } = strarr;
    return indexes[key] = array2.push(key) - 1;
  };
})();
var COLUMN2 = 0;
var SOURCES_INDEX2 = 1;
var SOURCE_LINE2 = 2;
var SOURCE_COLUMN2 = 3;
var NAMES_INDEX2 = 4;
var NO_NAME = -1;
var addMapping;
var toDecodedMap;
var toEncodedMap;
var fromMap;
var addSegmentInternal;
var GenMapping2 = class {
  constructor({ file, sourceRoot } = {}) {
    this._names = new SetArray2();
    this._sources = new SetArray2();
    this._sourcesContent = [];
    this._mappings = [];
    this.file = file;
    this.sourceRoot = sourceRoot;
  }
};
(() => {
  addMapping = (map3, mapping) => {
    return addMappingInternal(false, map3, mapping);
  };
  toDecodedMap = (map3) => {
    const { file, sourceRoot, _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = map3;
    removeEmptyFinalLines(mappings);
    return {
      version: 3,
      file: file || void 0,
      names: names.array,
      sourceRoot: sourceRoot || void 0,
      sources: sources.array,
      sourcesContent,
      mappings
    };
  };
  toEncodedMap = (map3) => {
    const decoded = toDecodedMap(map3);
    return Object.assign(Object.assign({}, decoded), { mappings: encode2(decoded.mappings) });
  };
  fromMap = (input) => {
    const map3 = new TraceMap2(input);
    const gen = new GenMapping2({ file: map3.file, sourceRoot: map3.sourceRoot });
    putAll(gen._names, map3.names);
    putAll(gen._sources, map3.sources);
    gen._sourcesContent = map3.sourcesContent || map3.sources.map(() => null);
    gen._mappings = decodedMappings2(map3);
    return gen;
  };
  addSegmentInternal = (skipable, map3, genLine, genColumn, source, sourceLine, sourceColumn, name2, content) => {
    const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = map3;
    const line = getLine2(mappings, genLine);
    const index2 = getColumnIndex2(line, genColumn);
    if (!source) {
      if (skipable && skipSourceless(line, index2))
        return;
      return insert2(line, index2, [genColumn]);
    }
    const sourcesIndex = put2(sources, source);
    const namesIndex = name2 ? put2(names, name2) : NO_NAME;
    if (sourcesIndex === sourcesContent.length)
      sourcesContent[sourcesIndex] = content !== null && content !== void 0 ? content : null;
    if (skipable && skipSource(line, index2, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {
      return;
    }
    return insert2(line, index2, name2 ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex] : [genColumn, sourcesIndex, sourceLine, sourceColumn]);
  };
})();
function getLine2(mappings, index2) {
  for (let i2 = mappings.length; i2 <= index2; i2++) {
    mappings[i2] = [];
  }
  return mappings[index2];
}
function getColumnIndex2(line, genColumn) {
  let index2 = line.length;
  for (let i2 = index2 - 1; i2 >= 0; index2 = i2--) {
    const current2 = line[i2];
    if (genColumn >= current2[COLUMN2])
      break;
  }
  return index2;
}
function insert2(array2, index2, value2) {
  for (let i2 = array2.length; i2 > index2; i2--) {
    array2[i2] = array2[i2 - 1];
  }
  array2[index2] = value2;
}
function removeEmptyFinalLines(mappings) {
  const { length } = mappings;
  let len = length;
  for (let i2 = len - 1; i2 >= 0; len = i2, i2--) {
    if (mappings[i2].length > 0)
      break;
  }
  if (len < length)
    mappings.length = len;
}
function putAll(strarr, array2) {
  for (let i2 = 0; i2 < array2.length; i2++)
    put2(strarr, array2[i2]);
}
function skipSourceless(line, index2) {
  if (index2 === 0)
    return true;
  const prev = line[index2 - 1];
  return prev.length === 1;
}
function skipSource(line, index2, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
  if (index2 === 0)
    return false;
  const prev = line[index2 - 1];
  if (prev.length === 1)
    return false;
  return sourcesIndex === prev[SOURCES_INDEX2] && sourceLine === prev[SOURCE_LINE2] && sourceColumn === prev[SOURCE_COLUMN2] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX2] : NO_NAME);
}
function addMappingInternal(skipable, map3, mapping) {
  const { generated, source, original, name: name2, content } = mapping;
  if (!source) {
    return addSegmentInternal(skipable, map3, generated.line - 1, generated.column, null, null, null, null, null);
  }
  const s2 = source;
  return addSegmentInternal(skipable, map3, generated.line - 1, generated.column, s2, original.line - 1, original.column, name2, content);
}
function getDefaultExportFromCjs2(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var srcExports2 = {};
var src2 = {
  get exports() {
    return srcExports2;
  },
  set exports(v) {
    srcExports2 = v;
  }
};
var browserExports2 = {};
var browser2 = {
  get exports() {
    return browserExports2;
  },
  set exports(v) {
    browserExports2 = v;
  }
};
var ms2;
var hasRequiredMs2;
function requireMs2() {
  if (hasRequiredMs2)
    return ms2;
  hasRequiredMs2 = 1;
  var s2 = 1e3;
  var m = s2 * 60;
  var h = m * 60;
  var d2 = h * 24;
  var w = d2 * 7;
  var y = d2 * 365.25;
  ms2 = function(val, options3) {
    options3 = options3 || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse7(val);
    } else if (type === "number" && isFinite(val)) {
      return options3.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse7(str2) {
    str2 = String(str2);
    if (str2.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str2
    );
    if (!match) {
      return;
    }
    var n3 = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n3 * y;
      case "weeks":
      case "week":
      case "w":
        return n3 * w;
      case "days":
      case "day":
      case "d":
        return n3 * d2;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n3 * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n3 * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n3 * s2;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n3;
      default:
        return void 0;
    }
  }
  function fmtShort(ms3) {
    var msAbs = Math.abs(ms3);
    if (msAbs >= d2) {
      return Math.round(ms3 / d2) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms3 / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms3 / m) + "m";
    }
    if (msAbs >= s2) {
      return Math.round(ms3 / s2) + "s";
    }
    return ms3 + "ms";
  }
  function fmtLong(ms3) {
    var msAbs = Math.abs(ms3);
    if (msAbs >= d2) {
      return plural(ms3, msAbs, d2, "day");
    }
    if (msAbs >= h) {
      return plural(ms3, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms3, msAbs, m, "minute");
    }
    if (msAbs >= s2) {
      return plural(ms3, msAbs, s2, "second");
    }
    return ms3 + " ms";
  }
  function plural(ms3, msAbs, n3, name2) {
    var isPlural = msAbs >= n3 * 1.5;
    return Math.round(ms3 / n3) + " " + name2 + (isPlural ? "s" : "");
  }
  return ms2;
}
var common2;
var hasRequiredCommon2;
function requireCommon2() {
  if (hasRequiredCommon2)
    return common2;
  hasRequiredCommon2 = 1;
  function setup(env2) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs2();
    createDebug.destroy = destroy;
    Object.keys(env2).forEach((key) => {
      createDebug[key] = env2[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash2 = 0;
      for (let i2 = 0; i2 < namespace.length; i2++) {
        hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i2);
        hash2 |= 0;
      }
      return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug4(...args) {
        if (!debug4.enabled) {
          return;
        }
        const self2 = debug4;
        const curr = Number(new Date());
        const ms3 = curr - (prevTime || curr);
        self2.diff = ms3;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
          if (match === "%%") {
            return "%";
          }
          index2++;
          const formatter2 = createDebug.formatters[format2];
          if (typeof formatter2 === "function") {
            const val = args[index2];
            match = formatter2.call(self2, val);
            args.splice(index2, 1);
            index2--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug4.namespace = namespace;
      debug4.useColors = createDebug.useColors();
      debug4.color = createDebug.selectColor(namespace);
      debug4.extend = extend2;
      debug4.destroy = createDebug.destroy;
      Object.defineProperty(debug4, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug4);
      }
      return debug4;
    }
    function extend2(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i2;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i2 = 0; i2 < len; i2++) {
        if (!split[i2]) {
          continue;
        }
        namespaces = split[i2].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name2) {
      if (name2[name2.length - 1] === "*") {
        return true;
      }
      let i2;
      let len;
      for (i2 = 0, len = createDebug.skips.length; i2 < len; i2++) {
        if (createDebug.skips[i2].test(name2)) {
          return false;
        }
      }
      for (i2 = 0, len = createDebug.names.length; i2 < len; i2++) {
        if (createDebug.names[i2].test(name2)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common2 = setup;
  return common2;
}
var hasRequiredBrowser2;
function requireBrowser2() {
  if (hasRequiredBrowser2)
    return browserExports2;
  hasRequiredBrowser2 = 1;
  (function(module2, exports3) {
    exports3.formatArgs = formatArgs;
    exports3.save = save;
    exports3.load = load2;
    exports3.useColors = useColors;
    exports3.storage = localstorage();
    exports3.destroy = (() => {
      let warned2 = false;
      return () => {
        if (!warned2) {
          warned2 = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports3.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c2 = "color: " + this.color;
      args.splice(1, 0, c2, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index2++;
        if (match === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c2);
    }
    exports3.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports3.storage.setItem("debug", namespaces);
        } else {
          exports3.storage.removeItem("debug");
        }
      } catch (error3) {
      }
    }
    function load2() {
      let r3;
      try {
        r3 = exports3.storage.getItem("debug");
      } catch (error3) {
      }
      if (!r3 && typeof process !== "undefined" && "env" in process) {
        r3 = process.env.DEBUG;
      }
      return r3;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error3) {
      }
    }
    module2.exports = requireCommon2()(exports3);
    const { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error3) {
        return "[UnexpectedJSONParseError]: " + error3.message;
      }
    };
  })(browser2, browserExports2);
  return browserExports2;
}
var nodeExports2 = {};
var node2 = {
  get exports() {
    return nodeExports2;
  },
  set exports(v) {
    nodeExports2 = v;
  }
};
var hasRequiredNode2;
function requireNode2() {
  if (hasRequiredNode2)
    return nodeExports2;
  hasRequiredNode2 = 1;
  (function(module2, exports3) {
    const tty2 = import_tty3.default;
    const util2 = import_util3.default;
    exports3.init = init2;
    exports3.log = log8;
    exports3.formatArgs = formatArgs;
    exports3.save = save;
    exports3.load = load2;
    exports3.useColors = useColors;
    exports3.destroy = util2.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports3.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor2 = __require("supports-color");
      if (supportsColor2 && (supportsColor2.stderr || supportsColor2).level >= 2) {
        exports3.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error3) {
    }
    exports3.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports3.inspectOpts ? Boolean(exports3.inspectOpts.colors) : tty2.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name2, useColors: useColors2 } = this;
      if (useColors2) {
        const c2 = this.color;
        const colorCode = "\x1B[3" + (c2 < 8 ? c2 : "8;5;" + c2);
        const prefix = `  ${colorCode};1m${name2} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name2 + " " + args[0];
      }
    }
    function getDate() {
      if (exports3.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    function log8(...args) {
      return process.stderr.write(util2.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load2() {
      return process.env.DEBUG;
    }
    function init2(debug4) {
      debug4.inspectOpts = {};
      const keys = Object.keys(exports3.inspectOpts);
      for (let i2 = 0; i2 < keys.length; i2++) {
        debug4.inspectOpts[keys[i2]] = exports3.inspectOpts[keys[i2]];
      }
    }
    module2.exports = requireCommon2()(exports3);
    const { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map((str2) => str2.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
  })(node2, nodeExports2);
  return nodeExports2;
}
(function(module2) {
  if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
    module2.exports = requireBrowser2();
  } else {
    module2.exports = requireNode2();
  }
})(src2);
var _debug2 = getDefaultExportFromCjs2(srcExports2);
var debug3 = _debug2("vite:hmr");
var directRequestRE2 = /(?:\?|&)direct\b/;
async function handleHotUpdate({ file, modules, read: read2 }, options3) {
  const prevDescriptor = getDescriptor(file, options3, false);
  if (!prevDescriptor) {
    return;
  }
  setPrevDescriptor(file, prevDescriptor);
  const content = await read2();
  const { descriptor } = createDescriptor(file, content, options3);
  let needRerender = false;
  const affectedModules = /* @__PURE__ */ new Set();
  const mainModule = getMainModule(modules);
  const templateModule = modules.find((m) => /type=template/.test(m.url));
  const scriptChanged = hasScriptChanged(prevDescriptor, descriptor);
  if (scriptChanged) {
    affectedModules.add(getScriptModule(modules) || mainModule);
  }
  if (!isEqualBlock(descriptor.template, prevDescriptor.template)) {
    if (!scriptChanged) {
      setResolvedScript(
        descriptor,
        getResolvedScript(prevDescriptor, false),
        false
      );
    }
    affectedModules.add(templateModule);
    needRerender = true;
  }
  let didUpdateStyle = false;
  const prevStyles = prevDescriptor.styles || [];
  const nextStyles = descriptor.styles || [];
  if (prevDescriptor.cssVars.join("") !== descriptor.cssVars.join("")) {
    affectedModules.add(mainModule);
  }
  if (prevStyles.some((s2) => s2.scoped) !== nextStyles.some((s2) => s2.scoped)) {
    affectedModules.add(templateModule);
    affectedModules.add(mainModule);
  }
  for (let i2 = 0; i2 < nextStyles.length; i2++) {
    const prev = prevStyles[i2];
    const next = nextStyles[i2];
    if (!prev || !isEqualBlock(prev, next)) {
      didUpdateStyle = true;
      const mod = modules.find(
        (m) => m.url.includes(`type=style&index=${i2}`) && m.url.endsWith(`.${next.lang || "css"}`) && !directRequestRE2.test(m.url)
      );
      if (mod) {
        affectedModules.add(mod);
        if (mod.url.includes("&inline")) {
          affectedModules.add(mainModule);
        }
      } else {
        affectedModules.add(mainModule);
      }
    }
  }
  if (prevStyles.length > nextStyles.length) {
    affectedModules.add(mainModule);
  }
  const prevCustoms = prevDescriptor.customBlocks || [];
  const nextCustoms = descriptor.customBlocks || [];
  if (prevCustoms.length !== nextCustoms.length) {
    affectedModules.add(mainModule);
  } else {
    for (let i2 = 0; i2 < nextCustoms.length; i2++) {
      const prev = prevCustoms[i2];
      const next = nextCustoms[i2];
      if (!prev || !isEqualBlock(prev, next)) {
        const mod = modules.find(
          (m) => m.url.includes(`type=${prev.type}&index=${i2}`)
        );
        if (mod) {
          affectedModules.add(mod);
        } else {
          affectedModules.add(mainModule);
        }
      }
    }
  }
  const updateType = [];
  if (needRerender) {
    updateType.push(`template`);
    if (!templateModule) {
      affectedModules.add(mainModule);
    } else if (mainModule && !affectedModules.has(mainModule)) {
      const styleImporters = [...mainModule.importers].filter(
        (m) => isCSSRequest2(m.url)
      );
      styleImporters.forEach((m) => affectedModules.add(m));
    }
  }
  if (didUpdateStyle) {
    updateType.push(`style`);
  }
  if (updateType.length) {
    debug3(`[vue:update(${updateType.join("&")})] ${file}`);
  }
  return [...affectedModules].filter(Boolean);
}
function isEqualBlock(a2, b) {
  if (!a2 && !b)
    return true;
  if (!a2 || !b)
    return false;
  if (a2.src && b.src && a2.src === b.src)
    return true;
  if (a2.content !== b.content)
    return false;
  const keysA = Object.keys(a2.attrs);
  const keysB = Object.keys(b.attrs);
  if (keysA.length !== keysB.length) {
    return false;
  }
  return keysA.every((key) => a2.attrs[key] === b.attrs[key]);
}
function isOnlyTemplateChanged(prev, next) {
  return !hasScriptChanged(prev, next) && prev.styles.length === next.styles.length && prev.styles.every((s2, i2) => isEqualBlock(s2, next.styles[i2])) && prev.customBlocks.length === next.customBlocks.length && prev.customBlocks.every((s2, i2) => isEqualBlock(s2, next.customBlocks[i2]));
}
function hasScriptChanged(prev, next) {
  if (!isEqualBlock(prev.script, next.script)) {
    return true;
  }
  if (!isEqualBlock(prev.scriptSetup, next.scriptSetup)) {
    return true;
  }
  const prevResolvedScript = getResolvedScript(prev, false);
  const prevImports = prevResolvedScript == null ? void 0 : prevResolvedScript.imports;
  if (prevImports) {
    return !next.template || next.shouldForceReload(prevImports);
  }
  return false;
}
function getMainModule(modules) {
  return modules.filter((m) => !/type=/.test(m.url) || /type=script/.test(m.url)).sort((m1, m2) => {
    return m1.url.length - m2.url.length;
  })[0];
}
function getScriptModule(modules) {
  return modules.find((m) => /type=script.*&lang\.\w+$/.test(m.url));
}
function handleTypeDepChange(affectedComponents, { modules, server: { moduleGraph } }) {
  const affected = /* @__PURE__ */ new Set();
  for (const file of affectedComponents) {
    invalidateScript(file);
    const mods = moduleGraph.getModulesByFile(file);
    if (mods) {
      const arr = [...mods];
      affected.add(getScriptModule(arr) || getMainModule(arr));
    }
  }
  return [...modules, ...affected];
}
var EXPORT_HELPER_ID = "\0plugin-vue:export-helper";
var helperCode = `
export default (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
}
`;
async function transformMain(code, filename, options3, pluginContext, ssr, asCustomElement) {
  var _a, _b, _c, _d, _e, _f;
  const { devServer, isProduction, devToolsEnabled } = options3;
  const prevDescriptor = getPrevDescriptor(filename);
  const { descriptor, errors } = createDescriptor(filename, code, options3);
  if (errors.length) {
    errors.forEach(
      (error3) => pluginContext.error(createRollupError(filename, error3))
    );
    return null;
  }
  const attachedProps = [];
  const hasScoped = descriptor.styles.some((s2) => s2.scoped);
  const { code: scriptCode, map: scriptMap } = await genScriptCode(
    descriptor,
    options3,
    pluginContext,
    ssr
  );
  const hasTemplateImport = descriptor.template && !isUseInlineTemplate(descriptor, !devServer);
  let templateCode = "";
  let templateMap = void 0;
  if (hasTemplateImport) {
    ({ code: templateCode, map: templateMap } = await genTemplateCode(
      descriptor,
      options3,
      pluginContext,
      ssr
    ));
  }
  if (hasTemplateImport) {
    attachedProps.push(
      ssr ? ["ssrRender", "_sfc_ssrRender"] : ["render", "_sfc_render"]
    );
  } else {
    if (prevDescriptor && !isEqualBlock(descriptor.template, prevDescriptor.template)) {
      attachedProps.push([ssr ? "ssrRender" : "render", "() => {}"]);
    }
  }
  const stylesCode = await genStyleCode(
    descriptor,
    pluginContext,
    asCustomElement,
    attachedProps
  );
  const customBlocksCode = await genCustomBlockCode(descriptor, pluginContext);
  const output = [
    scriptCode,
    templateCode,
    stylesCode,
    customBlocksCode
  ];
  if (hasScoped) {
    attachedProps.push([`__scopeId`, JSON.stringify(`data-v-${descriptor.id}`)]);
  }
  if (devToolsEnabled || devServer && !isProduction) {
    attachedProps.push([
      `__file`,
      JSON.stringify(isProduction ? import_node_path7.default.basename(filename) : filename)
    ]);
  }
  if (devServer && devServer.config.server.hmr !== false && !ssr && !isProduction) {
    output.push(`_sfc_main.__hmrId = ${JSON.stringify(descriptor.id)}`);
    output.push(
      `typeof __VUE_HMR_RUNTIME__ !== 'undefined' && __VUE_HMR_RUNTIME__.createRecord(_sfc_main.__hmrId, _sfc_main)`
    );
    if (prevDescriptor && isOnlyTemplateChanged(prevDescriptor, descriptor)) {
      output.push(`export const _rerender_only = true`);
    }
    output.push(
      `import.meta.hot.accept(mod => {`,
      `  if (!mod) return`,
      `  const { default: updated, _rerender_only } = mod`,
      `  if (_rerender_only) {`,
      `    __VUE_HMR_RUNTIME__.rerender(updated.__hmrId, updated.render)`,
      `  } else {`,
      `    __VUE_HMR_RUNTIME__.reload(updated.__hmrId, updated)`,
      `  }`,
      `})`
    );
  }
  if (ssr) {
    const normalizedFilename = normalizePath$3(
      import_node_path7.default.relative(options3.root, filename)
    );
    output.push(
      `import { useSSRContext as __vite_useSSRContext } from 'vue'`,
      `const _sfc_setup = _sfc_main.setup`,
      `_sfc_main.setup = (props, ctx) => {`,
      `  const ssrContext = __vite_useSSRContext()`,
      `  ;(ssrContext.modules || (ssrContext.modules = new Set())).add(${JSON.stringify(
        normalizedFilename
      )})`,
      `  return _sfc_setup ? _sfc_setup(props, ctx) : undefined`,
      `}`
    );
  }
  let resolvedMap = void 0;
  if (options3.sourceMap) {
    if (scriptMap && templateMap) {
      const gen = fromMap(
        // version property of result.map is declared as string
        // but actually it is `3`
        scriptMap
      );
      const tracer = new TraceMap2(
        // same above
        templateMap
      );
      const offset3 = (((_a = scriptCode.match(/\r?\n/g)) == null ? void 0 : _a.length) ?? 0) + 1;
      eachMapping(tracer, (m) => {
        if (m.source == null)
          return;
        addMapping(gen, {
          source: m.source,
          original: { line: m.originalLine, column: m.originalColumn },
          generated: {
            line: m.generatedLine + offset3,
            column: m.generatedColumn
          }
        });
      });
      resolvedMap = toEncodedMap(gen);
      resolvedMap.sourcesContent = templateMap.sourcesContent;
    } else {
      resolvedMap = scriptMap ?? templateMap;
    }
  }
  if (!attachedProps.length) {
    output.push(`export default _sfc_main`);
  } else {
    output.push(
      `import _export_sfc from '${EXPORT_HELPER_ID}'`,
      `export default /*#__PURE__*/_export_sfc(_sfc_main, [${attachedProps.map(([key, val]) => `['${key}',${val}]`).join(",")}])`
    );
  }
  let resolvedCode = output.join("\n");
  const lang = ((_b = descriptor.scriptSetup) == null ? void 0 : _b.lang) || ((_c = descriptor.script) == null ? void 0 : _c.lang);
  if (lang && /tsx?$/.test(lang) && !((_d = descriptor.script) == null ? void 0 : _d.src)) {
    const { code: code2, map: map3 } = await transformWithEsbuild(
      resolvedCode,
      filename,
      {
        loader: "ts",
        target: "esnext",
        sourcemap: options3.sourceMap
      },
      resolvedMap
    );
    resolvedCode = code2;
    resolvedMap = resolvedMap ? map3 : resolvedMap;
  }
  return {
    code: resolvedCode,
    map: resolvedMap || {
      mappings: ""
    },
    meta: {
      vite: {
        lang: ((_e = descriptor.script) == null ? void 0 : _e.lang) || ((_f = descriptor.scriptSetup) == null ? void 0 : _f.lang) || "js"
      }
    }
  };
}
async function genTemplateCode(descriptor, options3, pluginContext, ssr) {
  const template = descriptor.template;
  const hasScoped = descriptor.styles.some((style) => style.scoped);
  if (!template.lang && !template.src) {
    return transformTemplateInMain(
      template.content,
      descriptor,
      options3,
      pluginContext,
      ssr
    );
  } else {
    if (template.src) {
      await linkSrcToDescriptor(
        template.src,
        descriptor,
        pluginContext,
        hasScoped
      );
    }
    const src3 = template.src || descriptor.filename;
    const srcQuery = template.src ? hasScoped ? `&src=${descriptor.id}` : "&src=true" : "";
    const scopedQuery = hasScoped ? `&scoped=${descriptor.id}` : ``;
    const attrsQuery = attrsToQuery(template.attrs, "js", true);
    const query = `?vue&type=template${srcQuery}${scopedQuery}${attrsQuery}`;
    const request = JSON.stringify(src3 + query);
    const renderFnName = ssr ? "ssrRender" : "render";
    return {
      code: `import { ${renderFnName} as _sfc_${renderFnName} } from ${request}`,
      map: void 0
    };
  }
}
async function genScriptCode(descriptor, options3, pluginContext, ssr) {
  var _a;
  let scriptCode = `const ${scriptIdentifier} = {}`;
  let map3;
  const script = resolveScript(descriptor, options3, ssr);
  if (script) {
    if (canInlineMain(descriptor, options3)) {
      if (!options3.compiler.version) {
        const userPlugins = ((_a = options3.script) == null ? void 0 : _a.babelParserPlugins) || [];
        const defaultPlugins = script.lang === "ts" ? userPlugins.includes("decorators") ? ["typescript"] : ["typescript", "decorators-legacy"] : [];
        scriptCode = options3.compiler.rewriteDefault(
          script.content,
          scriptIdentifier,
          [...defaultPlugins, ...userPlugins]
        );
      } else {
        scriptCode = script.content;
      }
      map3 = script.map;
    } else {
      if (script.src) {
        await linkSrcToDescriptor(script.src, descriptor, pluginContext, false);
      }
      const src3 = script.src || descriptor.filename;
      const langFallback = script.src && import_node_path7.default.extname(src3).slice(1) || "js";
      const attrsQuery = attrsToQuery(script.attrs, langFallback);
      const srcQuery = script.src ? `&src=true` : ``;
      const query = `?vue&type=script${srcQuery}${attrsQuery}`;
      const request = JSON.stringify(src3 + query);
      scriptCode = `import _sfc_main from ${request}
export * from ${request}`;
    }
  }
  return {
    code: scriptCode,
    map: map3
  };
}
async function genStyleCode(descriptor, pluginContext, asCustomElement, attachedProps) {
  let stylesCode = ``;
  let cssModulesMap;
  if (descriptor.styles.length) {
    for (let i2 = 0; i2 < descriptor.styles.length; i2++) {
      const style = descriptor.styles[i2];
      if (style.src) {
        await linkSrcToDescriptor(
          style.src,
          descriptor,
          pluginContext,
          style.scoped
        );
      }
      const src3 = style.src || descriptor.filename;
      const attrsQuery = attrsToQuery(style.attrs, "css");
      const srcQuery = style.src ? style.scoped ? `&src=${descriptor.id}` : "&src=true" : "";
      const directQuery = asCustomElement ? `&inline` : ``;
      const scopedQuery = style.scoped ? `&scoped=${descriptor.id}` : ``;
      const query = `?vue&type=style&index=${i2}${srcQuery}${directQuery}${scopedQuery}`;
      const styleRequest = src3 + query + attrsQuery;
      if (style.module) {
        if (asCustomElement) {
          throw new Error(
            `<style module> is not supported in custom elements mode.`
          );
        }
        const [importCode, nameMap] = genCSSModulesCode(
          i2,
          styleRequest,
          style.module
        );
        stylesCode += importCode;
        Object.assign(cssModulesMap || (cssModulesMap = {}), nameMap);
      } else {
        if (asCustomElement) {
          stylesCode += `
import _style_${i2} from ${JSON.stringify(
            styleRequest
          )}`;
        } else {
          stylesCode += `
import ${JSON.stringify(styleRequest)}`;
        }
      }
    }
    if (asCustomElement) {
      attachedProps.push([
        `styles`,
        `[${descriptor.styles.map((_, i2) => `_style_${i2}`).join(",")}]`
      ]);
    }
  }
  if (cssModulesMap) {
    const mappingCode = Object.entries(cssModulesMap).reduce(
      (code, [key, value2]) => code + `"${key}":${value2},
`,
      "{\n"
    ) + "}";
    stylesCode += `
const cssModules = ${mappingCode}`;
    attachedProps.push([`__cssModules`, `cssModules`]);
  }
  return stylesCode;
}
function genCSSModulesCode(index2, request, moduleName) {
  const styleVar = `style${index2}`;
  const exposedName = typeof moduleName === "string" ? moduleName : "$style";
  const moduleRequest = request.replace(/\.(\w+)$/, ".module.$1");
  return [
    `
import ${styleVar} from ${JSON.stringify(moduleRequest)}`,
    { [exposedName]: styleVar }
  ];
}
async function genCustomBlockCode(descriptor, pluginContext) {
  let code = "";
  for (let index2 = 0; index2 < descriptor.customBlocks.length; index2++) {
    const block = descriptor.customBlocks[index2];
    if (block.src) {
      await linkSrcToDescriptor(block.src, descriptor, pluginContext, false);
    }
    const src3 = block.src || descriptor.filename;
    const attrsQuery = attrsToQuery(block.attrs, block.type);
    const srcQuery = block.src ? `&src=true` : ``;
    const query = `?vue&type=${block.type}&index=${index2}${srcQuery}${attrsQuery}`;
    const request = JSON.stringify(src3 + query);
    code += `import block${index2} from ${request}
`;
    code += `if (typeof block${index2} === 'function') block${index2}(_sfc_main)
`;
  }
  return code;
}
async function linkSrcToDescriptor(src3, descriptor, pluginContext, scoped) {
  var _a;
  const srcFile = ((_a = await pluginContext.resolve(src3, descriptor.filename)) == null ? void 0 : _a.id) || src3;
  setSrcDescriptor(srcFile.replace(/\?.*$/, ""), descriptor, scoped);
}
var ignoreList = ["id", "index", "src", "type", "lang", "module", "scoped"];
function attrsToQuery(attrs, langFallback, forceLangFallback = false) {
  let query = ``;
  for (const name2 in attrs) {
    const value2 = attrs[name2];
    if (!ignoreList.includes(name2)) {
      query += `&${encodeURIComponent(name2)}${value2 ? `=${encodeURIComponent(value2)}` : ``}`;
    }
  }
  if (langFallback || attrs.lang) {
    query += `lang` in attrs ? forceLangFallback ? `&lang.${langFallback}` : `&lang.${attrs.lang}` : `&lang.${langFallback}`;
  }
  return query;
}
async function transformStyle(code, descriptor, index2, options3, pluginContext, filename) {
  const block = descriptor.styles[index2];
  const result = await options3.compiler.compileStyleAsync({
    ...options3.style,
    filename: descriptor.filename,
    id: `data-v-${descriptor.id}`,
    isProd: options3.isProduction,
    source: code,
    scoped: block.scoped,
    ...options3.cssDevSourcemap ? {
      postcssOptions: {
        map: {
          from: filename,
          inline: false,
          annotation: false
        }
      }
    } : {}
  });
  if (result.errors.length) {
    result.errors.forEach((error3) => {
      if (error3.line && error3.column) {
        error3.loc = {
          file: descriptor.filename,
          line: error3.line + block.loc.start.line,
          column: error3.column
        };
      }
      pluginContext.error(error3);
    });
    return null;
  }
  const map3 = result.map ? await formatPostcssSourceMap(
    // version property of result.map is declared as string
    // but actually it is a number
    result.map,
    filename
  ) : { mappings: "" };
  return {
    code: result.code,
    map: map3
  };
}
function vuePlugin(rawOptions = {}) {
  const {
    include = /\.vue$/,
    exclude,
    customElement = /\.ce\.vue$/,
    reactivityTransform = false
  } = rawOptions;
  const filter2 = createFilter2(include, exclude);
  const customElementFilter = typeof customElement === "boolean" ? () => customElement : createFilter2(customElement);
  const refTransformFilter = reactivityTransform === false ? () => false : reactivityTransform === true ? createFilter2(/\.(j|t)sx?$/, /node_modules/) : createFilter2(reactivityTransform);
  let options3 = {
    isProduction: false,
    compiler: null,
    // to be set in buildStart
    ...rawOptions,
    include,
    exclude,
    customElement,
    reactivityTransform,
    root: process.cwd(),
    sourceMap: true,
    cssDevSourcemap: false,
    devToolsEnabled: true
  };
  return {
    name: "vite:vue",
    handleHotUpdate(ctx2) {
      if (options3.compiler.invalidateTypeCache) {
        options3.compiler.invalidateTypeCache(ctx2.file);
      }
      if (typeDepToSFCMap.has(ctx2.file)) {
        return handleTypeDepChange(typeDepToSFCMap.get(ctx2.file), ctx2);
      }
      if (filter2(ctx2.file)) {
        return handleHotUpdate(ctx2, options3);
      }
    },
    config(config2) {
      var _a, _b, _c, _d;
      return {
        resolve: {
          dedupe: ((_a = config2.build) == null ? void 0 : _a.ssr) ? [] : ["vue"]
        },
        define: {
          __VUE_OPTIONS_API__: ((_b = config2.define) == null ? void 0 : _b.__VUE_OPTIONS_API__) ?? true,
          __VUE_PROD_DEVTOOLS__: ((_c = config2.define) == null ? void 0 : _c.__VUE_PROD_DEVTOOLS__) ?? false
        },
        ssr: {
          external: ((_d = config2.legacy) == null ? void 0 : _d.buildSsrCjsExternalHeuristics) ? ["vue", "@vue/server-renderer"] : []
        }
      };
    },
    configResolved(config2) {
      var _a;
      options3 = {
        ...options3,
        root: config2.root,
        sourceMap: config2.command === "build" ? !!config2.build.sourcemap : true,
        cssDevSourcemap: ((_a = config2.css) == null ? void 0 : _a.devSourcemap) ?? false,
        isProduction: config2.isProduction,
        devToolsEnabled: !!config2.define.__VUE_PROD_DEVTOOLS__ || !config2.isProduction
      };
    },
    configureServer(server2) {
      options3.devServer = server2;
    },
    buildStart() {
      var _a;
      const compiler = options3.compiler = options3.compiler || resolveCompiler(options3.root);
      if (compiler.invalidateTypeCache) {
        (_a = options3.devServer) == null ? void 0 : _a.watcher.on("unlink", (file) => {
          compiler.invalidateTypeCache(file);
        });
      }
    },
    async resolveId(id) {
      if (id === EXPORT_HELPER_ID) {
        return id;
      }
      if (parseVueRequest(id).query.vue) {
        return id;
      }
    },
    load(id, opt) {
      const ssr = (opt == null ? void 0 : opt.ssr) === true;
      if (id === EXPORT_HELPER_ID) {
        return helperCode;
      }
      const { filename, query } = parseVueRequest(id);
      if (query.vue) {
        if (query.src) {
          return import_node_fs6.default.readFileSync(filename, "utf-8");
        }
        const descriptor = getDescriptor(filename, options3);
        let block;
        if (query.type === "script") {
          block = getResolvedScript(descriptor, ssr);
        } else if (query.type === "template") {
          block = descriptor.template;
        } else if (query.type === "style") {
          block = descriptor.styles[query.index];
        } else if (query.index != null) {
          block = descriptor.customBlocks[query.index];
        }
        if (block) {
          return {
            code: block.content,
            map: block.map
          };
        }
      }
    },
    transform(code, id, opt) {
      const ssr = (opt == null ? void 0 : opt.ssr) === true;
      const { filename, query } = parseVueRequest(id);
      if (query.raw || query.url) {
        return;
      }
      if (!filter2(filename) && !query.vue) {
        if (!query.vue && refTransformFilter(filename) && options3.compiler.shouldTransformRef(code)) {
          return options3.compiler.transformRef(code, {
            filename,
            sourceMap: true
          });
        }
        return;
      }
      if (!query.vue) {
        return transformMain(
          code,
          filename,
          options3,
          this,
          ssr,
          customElementFilter(filename)
        );
      } else {
        const descriptor = query.src ? getSrcDescriptor(filename, query) : getDescriptor(filename, options3);
        if (query.type === "template") {
          return transformTemplateAsModule(code, descriptor, options3, this, ssr);
        } else if (query.type === "style") {
          return transformStyle(
            code,
            descriptor,
            Number(query.index),
            options3,
            this,
            filename
          );
        }
      }
    }
  };
}

// node_modules/.pnpm/@vuepress+bundler-vite@2.0.0-beta.61/node_modules/@vuepress/bundler-vite/dist/index.js
var import_autoprefixer = __toESM(require_autoprefixer());
var import_connect_history_api_fallback = __toESM(require_lib3());
var import_postcss_load_config = __toESM(require_src());
var import_module3 = __toESM(require_module());
var pageComponentFileRegexp = /\.html\.vue($|\?)/;
var vueTemplateRegexp = /<template>[\s\S]*<\/template>/;
var jsStringBreaker = "​";
var vueTemplateBreaker = "<wbr>";
var constantsReplacementPlugin = (app) => {
  const pagesDirPrefix = `${app.dir.temp("pages")}/`;
  let constantsRegexp;
  const replaceConstants = (code, breaker) => code.replace(
    constantsRegexp,
    (constant) => `${constant[0]}${breaker}${constant.slice(1)}`
  );
  return {
    name: "vuepress:constants-replacement",
    enforce: "pre",
    configResolved(resolvedConfig) {
      const constants2 = ["process.env"];
      if (app.env.isBuild) {
        constants2.push("import.meta");
        if (resolvedConfig.define) {
          constants2.push(...Object.keys(resolvedConfig.define));
        }
      }
      constantsRegexp = new RegExp(
        `\\b(${constants2.map((item) => item.replace(/[-[\]/{}()*+?.\\^$|]/g, "\\$&")).join("|")})`,
        "g"
      );
    },
    transform(code, id) {
      if (!id.startsWith(pagesDirPrefix))
        return;
      if (!pageComponentFileRegexp.test(id)) {
        return replaceConstants(code, jsStringBreaker);
      }
      const match = code.match(vueTemplateRegexp);
      if (match === null)
        return;
      return code.substring(0, match.index) + replaceConstants(match[0], vueTemplateBreaker) + code.substring(match.index + match[0].length);
    }
  };
};
var mainPlugin = ({
  app,
  isBuild,
  isServer
}) => ({
  name: "vuepress:main",
  config: async () => {
    if (!isBuild) {
      await app.writeTemp(
        "vite-root/index.html",
        import_fs_extra.default.readFileSync(app.options.templateDev).toString().replace(
          /<\/body>/,
          `<script type="module">
import '@vuepress/client/app'
<\/script>
</body>`
        )
      );
    }
    const clientPackages = [
      "@vuepress/client",
      ...app.pluginApi.plugins.filter(({ name: name2 }) => name2 !== "user-config").map(({ name: name2 }) => name2)
    ];
    let postcssPlugins;
    try {
      const postcssConfigResult = await (0, import_postcss_load_config.default)();
      postcssPlugins = postcssConfigResult.plugins;
    } catch (error3) {
      postcssPlugins = [import_autoprefixer.default];
    }
    return {
      root: app.dir.temp("vite-root"),
      base: app.options.base,
      mode: !isBuild || app.env.isDebug ? "development" : "production",
      define: await resolveDefine({ app, isBuild, isServer }),
      publicDir: app.dir.public(),
      cacheDir: app.dir.cache(),
      resolve: {
        alias: await resolveAlias({ app, isServer })
      },
      css: {
        postcss: {
          plugins: isServer ? [] : postcssPlugins
        },
        preprocessorOptions: {
          scss: { charset: false }
        }
      },
      server: {
        host: app.options.host,
        port: app.options.port,
        open: app.options.open
      },
      build: {
        ssr: isServer,
        outDir: isServer ? app.dir.temp(".server") : app.dir.dest(),
        emptyOutDir: false,
        cssCodeSplit: false,
        rollupOptions: {
          input: app.dir.client(
            import_fs_extra.default.readJsonSync(app.dir.client("package.json")).exports["./app"]
          ),
          output: {
            sanitizeFileName,
            ...isServer ? {
              // also add hash to ssr entry file, so that users could build multiple sites in a single process
              entryFileNames: `[name].[hash].mjs`
            } : {
              manualChunks(id) {
                if (id.includes("plugin-vue:export-helper") || /node_modules\/@vuepress\/shared\//.test(id) || /node_modules\/vue(-router)?\//.test(id)) {
                  return "framework";
                }
                return void 0;
              }
            }
          },
          preserveEntrySignatures: "allow-extension"
        },
        minify: isServer ? false : !app.env.isDebug
      },
      optimizeDeps: {
        exclude: clientPackages
      },
      ssr: {
        format: "esm",
        noExternal: clientPackages
      }
    };
  },
  generateBundle(_, bundle) {
    if (isServer) {
      Object.keys(bundle).forEach((key) => {
        if (bundle[key].type === "asset") {
          delete bundle[key];
        }
      });
    }
  },
  configureServer(server2) {
    return () => {
      server2.middlewares.use(
        (0, import_connect_history_api_fallback.default)({
          rewrites: [
            {
              from: /\.html$/,
              to: "/index.html"
            }
          ]
        })
      );
    };
  }
});
var resolveAlias = async ({
  app,
  isServer
}) => {
  const alias2 = {
    "@internal": app.dir.temp("internal"),
    "@temp": app.dir.temp(),
    "@source": app.dir.source()
  };
  const aliasResult = await app.pluginApi.hooks.alias.process(app, isServer);
  aliasResult.forEach(
    (aliasObject) => Object.entries(aliasObject).forEach(([key, value2]) => {
      alias2[key] = value2;
    })
  );
  return [
    ...Object.keys(alias2).map((item) => ({
      find: item,
      replacement: alias2[item]
    })),
    ...isServer ? [] : [
      {
        find: /^vue$/,
        replacement: "vue/dist/vue.runtime.esm-bundler.js"
      },
      {
        find: /^vue-router$/,
        replacement: "vue-router/dist/vue-router.esm-bundler.js"
      }
    ]
  ];
};
var resolveDefine = async ({
  app,
  isBuild,
  isServer
}) => {
  const define2 = {
    __VUEPRESS_VERSION__: JSON.stringify(app.version),
    __VUEPRESS_BASE__: JSON.stringify(app.options.base),
    __VUEPRESS_DEV__: JSON.stringify(!isBuild),
    __VUEPRESS_SSR__: JSON.stringify(isServer),
    // @see http://link.vuejs.org/feature-flags
    // enable options API by default
    __VUE_OPTIONS_API__: JSON.stringify(true),
    __VUE_PROD_DEVTOOLS__: JSON.stringify(app.env.isDebug)
  };
  if (app.env.isDebug) {
    define2["process.env.NODE_ENV"] = JSON.stringify("development");
  }
  const defineResult = await app.pluginApi.hooks.define.process(app, isServer);
  defineResult.forEach(
    (defineObject) => Object.entries(defineObject).forEach(([key, value2]) => {
      define2[key] = JSON.stringify(value2);
    })
  );
  return define2;
};
var userConfigPlugin = (options3) => ({
  name: "vuepress:user-config",
  config: () => options3.viteOptions ?? {}
});
var resolveViteConfig = async ({
  app,
  options: options3,
  isBuild,
  isServer
}) => {
  return mergeConfig(
    {
      clearScreen: false,
      configFile: false,
      logLevel: !isBuild || app.env.isDebug ? "info" : "warn",
      esbuild: {
        charset: "utf8"
      },
      plugins: [
        vuePlugin(options3.vuePluginOptions),
        constantsReplacementPlugin(app),
        mainPlugin({ app, isBuild, isServer }),
        userConfigPlugin(options3)
      ]
    },
    // some vite options would not take effect inside a plugin, so we still need to merge them here in addition to userConfigPlugin
    options3.viteOptions ?? {}
  );
};
var renderPagePrefetchLinks = ({
  app,
  outputEntryChunk,
  pageChunkFiles
}) => {
  const shouldPrefetch = app.options.shouldPrefetch;
  if (shouldPrefetch === false) {
    return "";
  }
  const prefetchFiles = outputEntryChunk.dynamicImports.filter(
    (item) => !pageChunkFiles.some((file) => file === item)
  );
  return prefetchFiles.map((item) => {
    const type = item.endsWith(".js") ? "script" : item.endsWith(".css") ? "style" : "";
    if (shouldPrefetch !== true && !shouldPrefetch(item, type)) {
      return "";
    }
    return `<link rel="prefetch" href="${app.options.base}${item}" as="${type}">`;
  }).join("");
};
var renderPagePreloadLinks = ({
  app,
  outputEntryChunk,
  pageChunkFiles
}) => {
  const shouldPreload = app.options.shouldPreload;
  if (shouldPreload === false) {
    return "";
  }
  const preloadFiles = Array.from(
    /* @__PURE__ */ new Set([
      outputEntryChunk.fileName,
      ...outputEntryChunk.imports,
      ...pageChunkFiles
    ])
  );
  return preloadFiles.map((item) => {
    const type = item.endsWith(".js") ? "script" : item.endsWith(".css") ? "style" : "";
    if (shouldPreload === true && type !== "script" && type !== "style") {
      return "";
    }
    if (shouldPreload !== true && !shouldPreload(item, type)) {
      return "";
    }
    if (type === "script") {
      return `<link rel="modulepreload" href="${app.options.base}${item}">`;
    }
    return `<link rel="preload" href="${app.options.base}${item}"${type !== "" ? ` as="${type}"` : ""}>`;
  }).join("");
};
var renderPageScripts = ({
  app,
  outputEntryChunk
}) => `<script type="module" src="${app.options.base}${outputEntryChunk.fileName}" defer><\/script>`;
var renderPageStyles = ({
  app,
  outputCssAsset
}) => outputCssAsset ? [
  `<link rel="preload" href="${app.options.base}${outputCssAsset.fileName}" as="style">`,
  `<link rel="stylesheet" href="${app.options.base}${outputCssAsset.fileName}">`
].join("") : "";
var resolvePageChunkFiles = ({
  page,
  output
}) => output.filter(
  (item) => item.type === "chunk" && (item.facadeModuleId === page.componentFilePath || item.facadeModuleId === page.dataFilePath)
).flatMap(({ fileName, imports, dynamicImports }) => [
  fileName,
  ...imports,
  ...dynamicImports
]);
var renderPage = async ({
  app,
  page,
  vueApp,
  vueRouter,
  renderToString,
  ssrTemplate,
  output,
  outputEntryChunk,
  outputCssAsset
}) => {
  await vueRouter.push(page.path);
  await vueRouter.isReady();
  delete vueApp._context.provides[ssrContextKey];
  const ssrContext = {
    lang: "en",
    head: []
  };
  const pageRendered = await renderToString(vueApp, ssrContext);
  const pageChunkFiles = resolvePageChunkFiles({ page, output });
  const html = ssrTemplate.replace("{{ version }}", app.version).replace("{{ lang }}", ssrContext.lang).replace(
    "<!--vuepress-ssr-head-->",
    ssrContext.head.map(renderHead).join("")
  ).replace(
    "<!--vuepress-ssr-resources-->",
    `${renderPagePreloadLinks({
      app,
      outputEntryChunk,
      pageChunkFiles
    })}${renderPagePrefetchLinks({
      app,
      outputEntryChunk,
      pageChunkFiles
    })}`
  ).replace(
    "<!--vuepress-ssr-styles-->",
    renderPageStyles({ app, outputCssAsset })
  ).replace("<!--vuepress-ssr-app-->", () => pageRendered).replace(
    "<!--vuepress-ssr-scripts-->",
    renderPageScripts({ app, outputEntryChunk })
  );
  await import_fs_extra.default.outputFile(page.htmlFilePath, html);
};
var log = (0, import_debug.default)("vuepress:bundler-vite/build");
var build2 = async (options3, app) => {
  await app.pluginApi.hooks.extendsBundlerOptions.process(options3, app);
  log("compiling start");
  let clientOutput;
  let serverOutput;
  await withSpinner("Compiling with vite")(async () => {
    const clientConfig = await resolveViteConfig({
      app,
      options: options3,
      isBuild: true,
      isServer: false
    });
    const serverConfig = await resolveViteConfig({
      app,
      options: options3,
      isBuild: true,
      isServer: true
    });
    [clientOutput, serverOutput] = await Promise.all([
      build(clientConfig),
      build(serverConfig)
    ]);
  });
  log("compiling finish");
  await withSpinner(`Rendering ${app.pages.length} pages`)(async (spinner) => {
    const ssrTemplate = (await import_fs_extra.default.readFile(app.options.templateBuild)).toString();
    const clientEntryChunk = clientOutput.output.find(
      (item) => item.type === "chunk" && item.isEntry
    );
    const clientCssAsset = clientOutput.output.find(
      (item) => item.type === "asset" && item.fileName.endsWith(".css")
    );
    const serverEntryChunk = serverOutput.output.find(
      (item) => item.type === "chunk" && item.isEntry
    );
    const serverEntryPath = app.dir.temp(".server", serverEntryChunk.fileName);
    const { createVueApp } = await importFile(serverEntryPath);
    const { app: vueApp, router: vueRouter } = await createVueApp();
    const { renderToString } = await import("./server-renderer-FPL6NCUM.js");
    for (const page of app.pages) {
      if (spinner)
        spinner.text = `Rendering pages ${import_picocolors.default.magenta(page.path)}`;
      await renderPage({
        app,
        page,
        vueApp,
        vueRouter,
        renderToString,
        ssrTemplate,
        output: clientOutput.output,
        outputEntryChunk: clientEntryChunk,
        outputCssAsset: clientCssAsset
      });
    }
  });
  if (!app.env.isDebug) {
    await import_fs_extra.default.remove(app.dir.temp(".server"));
  }
};
var require22 = (0, import_module3.createRequire)(import.meta.url);
var dev = async (options3, app) => {
  await app.pluginApi.hooks.extendsBundlerOptions.process(options3, app);
  const viteConfig = await resolveViteConfig({
    app,
    options: options3,
    isBuild: false,
    isServer: false
  });
  const server2 = await createServer(viteConfig);
  await server2.listen();
  const viteVersion = import_fs_extra.default.readJsonSync(
    require22.resolve("vite/package.json")
  ).version;
  server2.config.logger.info(
    import_picocolors.default.cyan(`
  vite v${viteVersion}`) + import_picocolors.default.green(` dev server running at:
`),
    {
      clear: !server2.config.logger.hasWarned
    }
  );
  server2.printUrls();
  return server2.close.bind(server2);
};
var viteBundler = (options3 = {}) => ({
  name: "@vuepress/bundler-vite",
  dev: (app) => dev(options3, app),
  build: (app) => build2(options3, app)
});

// node_modules/.pnpm/@vuepress+cli@2.0.0-beta.61/node_modules/@vuepress/cli/dist/index.js
var import_process2 = __toESM(require_process());

// node_modules/.pnpm/@mdit-vue+shared@0.12.0/node_modules/@mdit-vue/shared/dist/index.mjs
var htmlEscapeMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  "'": "&#39;",
  '"': "&quot;"
};
var htmlEscapeRegexp = /[&<>'"]/g;
var htmlEscape = (str2) => str2.replace(
  htmlEscapeRegexp,
  (char) => htmlEscapeMap[char]
);
var resolveTitleFromToken = (token, { shouldAllowHtml, shouldEscapeText }) => {
  const children = token.children ?? [];
  const titleTokenTypes = ["text", "emoji", "code_inline"];
  if (shouldAllowHtml) {
    titleTokenTypes.push("html_inline");
  }
  const titleTokens = children.filter(
    (item) => {
      var _a;
      return titleTokenTypes.includes(item.type) && // filter permalink symbol that generated by markdown-it-anchor
      !((_a = item.meta) == null ? void 0 : _a.isPermalinkSymbol);
    }
  );
  return titleTokens.reduce((result, item) => {
    if (shouldEscapeText) {
      if (item.type === "code_inline" || item.type === "text") {
        return `${result}${htmlEscape(item.content)}`;
      }
    }
    return `${result}${item.content}`;
  }, "").trim();
};
var resolveHeadersFromTokens = (tokens, {
  level: level3,
  shouldAllowHtml,
  shouldAllowNested,
  shouldEscapeText,
  slugify: slugify2,
  format: format2
}) => {
  const headers = [];
  const stack = [];
  const push2 = (header) => {
    while (stack.length !== 0 && header.level <= stack[0].level) {
      stack.shift();
    }
    if (stack.length === 0) {
      headers.push(header);
      stack.push(header);
    } else {
      stack[0].children.push(header);
      stack.unshift(header);
    }
  };
  for (let i2 = 0; i2 < tokens.length; i2 += 1) {
    const token = tokens[i2];
    if ((token == null ? void 0 : token.type) !== "heading_open") {
      continue;
    }
    if ((token == null ? void 0 : token.level) !== 0 && !shouldAllowNested) {
      continue;
    }
    const headerLevel = Number.parseInt(token.tag.slice(1), 10);
    if (!level3.includes(headerLevel)) {
      continue;
    }
    const nextToken = tokens[i2 + 1];
    if (!nextToken) {
      continue;
    }
    const title = resolveTitleFromToken(nextToken, {
      shouldAllowHtml,
      shouldEscapeText
    });
    const slug = token.attrGet("id") ?? slugify2(title);
    push2({
      level: headerLevel,
      title: (format2 == null ? void 0 : format2(title)) ?? title,
      slug,
      link: `#${slug}`,
      children: []
    });
  }
  return headers;
};
var rControl = /[\u0000-\u001f]/g;
var rSpecial = /[\s~`!@#$%^&*()\-_+=[\]{}|\\;:"'“”‘’<>,.?/]+/g;
var rCombining = /[\u0300-\u036F]/g;
var slugify = (str2) => str2.normalize("NFKD").replace(rCombining, "").replace(rControl, "").replace(rSpecial, "-").replace(/-{2,}/g, "-").replace(/^-+|-+$/g, "").replace(/^(\d)/, "_$1").toLowerCase();

// node_modules/.pnpm/@vuepress+markdown@2.0.0-beta.61/node_modules/@vuepress/markdown/dist/index.js
var import_markdown_it = __toESM(require_markdown_it());

// node_modules/.pnpm/@mdit-vue+plugin-component@0.12.0/node_modules/@mdit-vue/plugin-component/dist/index.mjs
var import_html_blocks = __toESM(require_html_blocks(), 1);
var attr_name = "[a-zA-Z_:@][a-zA-Z0-9:._-]*";
var unquoted = "[^\"'=<>`\\x00-\\x20]+";
var single_quoted = "'[^']*'";
var double_quoted = '"[^"]*"';
var attr_value = "(?:" + unquoted + "|" + single_quoted + "|" + double_quoted + ")";
var attribute = "(?:\\s+" + attr_name + "(?:\\s*=\\s*" + attr_value + ")?)";
var open_tag = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/?>";
var close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
var comment = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
var processing = "<[?][\\s\\S]*?[?]>";
var declaration = "<![A-Z]+\\s+[^>]*>";
var cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
var HTML_TAG_RE = new RegExp(
  "^(?:" + open_tag + "|" + close_tag + "|" + comment + "|" + processing + "|" + declaration + "|" + cdata + ")"
);
var HTML_OPEN_CLOSE_TAG_RE = new RegExp(
  "^(?:" + open_tag + "|" + close_tag + ")"
);
var HTML_SELF_CLOSING_TAG_RE = new RegExp(
  "^<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/>"
);
var HTML_OPEN_AND_CLOSE_TAG_IN_THE_SAME_LINE_RE = new RegExp(
  "^<([A-Za-z][A-Za-z0-9\\-]*)" + attribute + "*\\s*>.*<\\/\\1\\s*>"
);
var TAGS_BLOCK = import_html_blocks.default;
var TAGS_INLINE = [
  "a",
  "abbr",
  "acronym",
  "audio",
  "b",
  "bdi",
  "bdo",
  "big",
  "br",
  "button",
  "canvas",
  "cite",
  "code",
  "data",
  "datalist",
  "del",
  "dfn",
  "em",
  "embed",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "map",
  "mark",
  "meter",
  "noscript",
  "object",
  "output",
  "picture",
  "progress",
  "q",
  "ruby",
  "s",
  "samp",
  "script",
  "select",
  "slot",
  "small",
  "span",
  "strong",
  "sub",
  "sup",
  "svg",
  "template",
  "textarea",
  "time",
  "u",
  "tt",
  "var",
  "video",
  "wbr"
];
var TAGS_VUE_RESERVED = [
  "template",
  "component",
  "transition",
  "transition-group",
  "keep-alive",
  "slot",
  "teleport"
];
var createHtmlSequences = ({
  blockTags,
  inlineTags
}) => {
  const forceBlockTags = [...blockTags, ...TAGS_BLOCK];
  const forceInlineTags = [
    ...inlineTags,
    ...TAGS_INLINE.filter((item) => !TAGS_VUE_RESERVED.includes(item))
  ];
  const HTML_SEQUENCES = [
    [/^<(script|pre|style)(?=(\s|>|$))/i, /<\/(script|pre|style)>/i, true],
    [/^<!--/, /-->/, true],
    [/^<\?/, /\?>/, true],
    [/^<![A-Z]/, />/, true],
    [/^<!\[CDATA\[/, /\]\]>/, true],
    // MODIFIED: Support extra block tags from user options
    [
      new RegExp("^</?(" + forceBlockTags.join("|") + ")(?=(\\s|/?>|$))", "i"),
      /^$/,
      true
    ],
    // ADDED: Matching component tags (all unknown tags) (i = 6)
    [
      new RegExp(
        "^</?(?!(" + forceInlineTags.join("|") + ")(?![\\w-]))[A-Za-z][A-Za-z0-9\\-]*(?=(\\s|/?>|$))"
      ),
      /^$/,
      true
    ],
    // this line is to treat a line that only have a single self-closed html tag
    // as html_block, even if it's a self-closed inline tag
    // MODIFIED: Tweak the original HTML_OPEN_CLOSE_TAG_RE
    [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"), /^$/, false]
  ];
  return HTML_SEQUENCES;
};
var createHtmlBlockRule = (options3) => {
  const HTML_SEQUENCES = createHtmlSequences(options3);
  return (state, startLine, endLine, silent) => {
    let i2;
    let nextLine;
    let lineText;
    let pos = state.bMarks[startLine] + state.tShift[startLine];
    let max = state.eMarks[startLine];
    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    if (!state.md.options.html) {
      return false;
    }
    if (state.src.charCodeAt(pos) !== 60) {
      return false;
    }
    lineText = state.src.slice(pos, max);
    for (i2 = 0; i2 < HTML_SEQUENCES.length; i2++) {
      if (HTML_SEQUENCES[i2][0].test(lineText)) {
        break;
      }
    }
    if (i2 === HTML_SEQUENCES.length) {
      return false;
    }
    if (silent) {
      return HTML_SEQUENCES[i2][2];
    }
    if (i2 === 6) {
      const match = (
        // if the component tag is self-closing
        lineText.match(HTML_SELF_CLOSING_TAG_RE) ?? // or has open and close tag in the same line
        lineText.match(HTML_OPEN_AND_CLOSE_TAG_IN_THE_SAME_LINE_RE)
      );
      if (match) {
        state.line = startLine + 1;
        let token2 = state.push("html_inline", "", 0);
        token2.content = match[0];
        token2.map = [startLine, state.line];
        token2 = state.push("inline", "", 0);
        token2.content = lineText.slice(match[0].length);
        token2.map = [startLine, state.line];
        token2.children = [];
        return true;
      }
    }
    nextLine = startLine + 1;
    if (!HTML_SEQUENCES[i2][1].test(lineText)) {
      for (; nextLine < endLine; nextLine++) {
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        pos = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];
        lineText = state.src.slice(pos, max);
        if (HTML_SEQUENCES[i2][1].test(lineText)) {
          if (lineText.length !== 0) {
            nextLine++;
          }
          break;
        }
      }
    }
    state.line = nextLine;
    const token = state.push("html_block", "", 0);
    token.map = [startLine, nextLine];
    token.content = state.getLines(startLine, nextLine, state.blkIndent, true);
    return true;
  };
};
var isLetter = (ch) => {
  const lc = ch | 32;
  return lc >= 97 && lc <= 122;
};
var htmlInlineRule = (state, silent) => {
  const { pos } = state;
  if (!state.md.options.html) {
    return false;
  }
  const max = state.posMax;
  if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max) {
    return false;
  }
  const ch = state.src.charCodeAt(pos + 1);
  if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter(ch)) {
    return false;
  }
  const match = state.src.slice(pos).match(HTML_TAG_RE);
  if (!match) {
    return false;
  }
  if (!silent) {
    const token = state.push("html_inline", "", 0);
    token.content = state.src.slice(pos, pos + match[0].length);
  }
  state.pos += match[0].length;
  return true;
};
var componentPlugin = (md, { blockTags = [], inlineTags = [] } = {}) => {
  const htmlBlockRule = createHtmlBlockRule({
    blockTags,
    inlineTags
  });
  md.block.ruler.at("html_block", htmlBlockRule, {
    alt: ["paragraph", "reference", "blockquote"]
  });
  md.inline.ruler.at("html_inline", htmlInlineRule);
};

// node_modules/.pnpm/@mdit-vue+plugin-frontmatter@0.12.0/node_modules/@mdit-vue/plugin-frontmatter/dist/index.mjs
var import_gray_matter = __toESM(require_gray_matter(), 1);
var frontmatterPlugin = (md, { grayMatterOptions, renderExcerpt = true } = {}) => {
  const render = md.render.bind(md);
  md.render = (src3, env2 = {}) => {
    const { data: data2, content, excerpt = "" } = (0, import_gray_matter.default)(src3, grayMatterOptions);
    env2.content = content;
    env2.frontmatter = {
      // allow providing default value
      ...env2.frontmatter,
      ...data2
    };
    env2.excerpt = renderExcerpt && excerpt ? (
      // render the excerpt with original markdown-it render method.
      // here we spread `env` to avoid mutating the original object.
      // using deep clone might be a safer choice.
      render(excerpt, { ...env2 })
    ) : (
      // use the raw excerpt directly
      excerpt
    );
    return render(content, env2);
  };
};

// node_modules/.pnpm/@mdit-vue+plugin-headers@0.12.0/node_modules/@mdit-vue/plugin-headers/dist/index.mjs
var headersPlugin = (md, {
  level: level3 = [2, 3],
  shouldAllowNested = false,
  slugify: slugify$1 = slugify,
  format: format2
} = {}) => {
  const render = md.renderer.render.bind(md.renderer);
  md.renderer.render = (tokens, options3, env2) => {
    env2.headers = resolveHeadersFromTokens(tokens, {
      level: level3,
      shouldAllowHtml: false,
      shouldAllowNested,
      shouldEscapeText: false,
      slugify: slugify$1,
      format: format2
    });
    return render(tokens, options3, env2);
  };
};

// node_modules/.pnpm/@mdit-vue+plugin-sfc@0.12.0/node_modules/@mdit-vue/plugin-sfc/dist/index.mjs
var TAG_NAME_SCRIPT = "script";
var TAG_NAME_STYLE = "style";
var TAG_NAME_TEMPLATE = "template";
var SCRIPT_SETUP_TAG_OPEN_REGEXP = /^<script\s+.*?\bsetup\b.*?>$/is;
var createSfcRegexp = ({
  customBlocks
}) => {
  const sfcTags = Array.from(
    /* @__PURE__ */ new Set([TAG_NAME_SCRIPT, TAG_NAME_STYLE, ...customBlocks])
  ).join("|");
  return new RegExp(
    `^\\s*(?<content>(?<tagOpen><(?<type>${sfcTags})\\s?.*?>)(?<contentStripped>.*)(?<tagClose><\\/\\k<type>\\s*>))\\s*$`,
    "is"
  );
};
var sfcPlugin = (md, { customBlocks = [] } = {}) => {
  const sfcRegexp = createSfcRegexp({ customBlocks });
  const render = md.render.bind(md);
  md.render = (src3, env2 = {}) => {
    env2.sfcBlocks = {
      template: null,
      script: null,
      scriptSetup: null,
      scripts: [],
      styles: [],
      customBlocks: []
    };
    const rendered = render(src3, env2);
    env2.sfcBlocks.template = {
      type: TAG_NAME_TEMPLATE,
      content: `<${TAG_NAME_TEMPLATE}>${rendered}</${TAG_NAME_TEMPLATE}>`,
      contentStripped: rendered,
      tagOpen: `<${TAG_NAME_TEMPLATE}>`,
      tagClose: `</${TAG_NAME_TEMPLATE}>`
    };
    return rendered;
  };
  const htmlBlockRule = md.renderer.rules.html_block;
  md.renderer.rules.html_block = (tokens, idx, options3, env2, self2) => {
    if (!env2.sfcBlocks) {
      return htmlBlockRule(tokens, idx, options3, env2, self2);
    }
    const token = tokens[idx];
    const content = token.content;
    const match = content.match(sfcRegexp);
    if (!match) {
      return htmlBlockRule(tokens, idx, options3, env2, self2);
    }
    const sfcBlock = match.groups;
    if (sfcBlock.type === TAG_NAME_SCRIPT) {
      env2.sfcBlocks.scripts.push(sfcBlock);
      if (SCRIPT_SETUP_TAG_OPEN_REGEXP.test(sfcBlock.tagOpen)) {
        env2.sfcBlocks.scriptSetup = sfcBlock;
      } else {
        env2.sfcBlocks.script = sfcBlock;
      }
    } else if (sfcBlock.type === TAG_NAME_STYLE) {
      env2.sfcBlocks.styles.push(sfcBlock);
    } else {
      env2.sfcBlocks.customBlocks.push(sfcBlock);
    }
    return "";
  };
};

// node_modules/.pnpm/@mdit-vue+plugin-title@0.12.0/node_modules/@mdit-vue/plugin-title/dist/index.mjs
var titlePlugin = (md) => {
  const render = md.renderer.render.bind(md.renderer);
  md.renderer.render = (tokens, options3, env2) => {
    const tokenIdx = tokens.findIndex((token) => token.tag === "h1");
    env2.title = tokenIdx > -1 ? resolveTitleFromToken(tokens[tokenIdx + 1], {
      shouldAllowHtml: false,
      shouldEscapeText: false
    }) : "";
    return render(tokens, options3, env2);
  };
};

// node_modules/.pnpm/@mdit-vue+plugin-toc@0.12.0/node_modules/@mdit-vue/plugin-toc/dist/index.mjs
var createRenderHeaders = ({
  listTag,
  listClass,
  itemClass,
  linkTag,
  linkClass
}) => {
  const listTagString = htmlEscape(listTag);
  const listClassString = listClass ? ` class="${htmlEscape(listClass)}"` : "";
  const itemTagString = "li";
  const itemClassString = itemClass ? ` class="${htmlEscape(itemClass)}"` : "";
  const linkTagString = htmlEscape(linkTag);
  const linkClassString = linkClass ? ` class="${htmlEscape(linkClass)}"` : "";
  const linkTo = (link) => linkTag === "router-link" ? ` to="${link}"` : ` href="${link}"`;
  const renderHeaders = (headers) => `<${listTagString}${listClassString}>${headers.map(
    (header) => `<${itemTagString}${itemClassString}${itemClassString}><${linkTagString}${linkClassString}${linkTo(header.link)}>${header.title}</${linkTagString}>${header.children.length > 0 ? renderHeaders(header.children) : ""}</${itemTagString}>`
  ).join("")}</${listTagString}>`;
  return renderHeaders;
};
var createTocBlockRule = ({
  pattern: pattern2,
  containerTag,
  containerClass
}) => {
  return (state, startLine, endLine, silent) => {
    if (state.sCount[startLine] - state.blkIndent >= 4) {
      return false;
    }
    const pos = state.bMarks[startLine] + state.tShift[startLine];
    const max = state.eMarks[startLine];
    const lineFirstToken = state.src.slice(pos, max).split(" ")[0];
    if (!pattern2.test(lineFirstToken))
      return false;
    if (silent)
      return true;
    state.line = startLine + 1;
    const tokenOpen = state.push("toc_open", containerTag, 1);
    tokenOpen.markup = "";
    tokenOpen.map = [startLine, state.line];
    if (containerClass) {
      tokenOpen.attrSet("class", containerClass);
    }
    const tokenBody = state.push("toc_body", "", 0);
    tokenBody.markup = lineFirstToken;
    tokenBody.map = [startLine, state.line];
    tokenBody.hidden = true;
    const tokenClose = state.push("toc_close", containerTag, -1);
    tokenClose.markup = "";
    tokenBody.map = [startLine, state.line];
    return true;
  };
};
var tocPlugin = (md, {
  pattern: pattern2 = /^\[\[toc\]\]$/i,
  slugify: slugify$1 = slugify,
  format: format2,
  level: level3 = [2, 3],
  shouldAllowNested = false,
  containerTag = "nav",
  containerClass = "table-of-contents",
  listTag = "ul",
  listClass = "",
  itemClass = "",
  linkTag = "a",
  linkClass = ""
} = {}) => {
  md.block.ruler.before(
    "heading",
    "toc",
    createTocBlockRule({
      pattern: pattern2,
      containerTag,
      containerClass
    }),
    {
      alt: ["paragraph", "reference", "blockquote"]
    }
  );
  const renderHeaders = createRenderHeaders({
    listTag,
    listClass,
    itemClass,
    linkTag,
    linkClass
  });
  md.renderer.rules.toc_body = (tokens) => renderHeaders(
    resolveHeadersFromTokens(tokens, {
      level: level3,
      shouldAllowHtml: true,
      shouldAllowNested,
      shouldEscapeText: true,
      slugify: slugify$1,
      format: format2
    })
  );
};

// node_modules/.pnpm/markdown-it-anchor@8.6.7_@types+markdown-it@12.2.3_markdown-it@13.0.1/node_modules/markdown-it-anchor/dist/markdownItAnchor.mjs
var e2 = false;
var n2 = { false: "push", true: "unshift", after: "push", before: "unshift" };
var t2 = { isPermalinkSymbol: true };
function r2(r3, a2, i2, l2) {
  var o3;
  if (!e2) {
    var c2 = "Using deprecated markdown-it-anchor permalink option, see https://github.com/valeriangalliat/markdown-it-anchor#permalinks";
    "object" == typeof process && process && process.emitWarning ? process.emitWarning(c2) : console.warn(c2), e2 = true;
  }
  var s2 = [Object.assign(new i2.Token("link_open", "a", 1), { attrs: [].concat(a2.permalinkClass ? [["class", a2.permalinkClass]] : [], [["href", a2.permalinkHref(r3, i2)]], Object.entries(a2.permalinkAttrs(r3, i2))) }), Object.assign(new i2.Token("html_block", "", 0), { content: a2.permalinkSymbol, meta: t2 }), new i2.Token("link_close", "a", -1)];
  a2.permalinkSpace && i2.tokens[l2 + 1].children[n2[a2.permalinkBefore]](Object.assign(new i2.Token("text", "", 0), { content: " " })), (o3 = i2.tokens[l2 + 1].children)[n2[a2.permalinkBefore]].apply(o3, s2);
}
function a(e3) {
  return "#" + e3;
}
function i(e3) {
  return {};
}
var l = { class: "header-anchor", symbol: "#", renderHref: a, renderAttrs: i };
function o2(e3) {
  function n3(t3) {
    return t3 = Object.assign({}, n3.defaults, t3), function(n4, r3, a2, i2) {
      return e3(n4, t3, r3, a2, i2);
    };
  }
  return n3.defaults = Object.assign({}, l), n3.renderPermalinkImpl = e3, n3;
}
var c = o2(function(e3, r3, a2, i2, l2) {
  var o3, c2 = [Object.assign(new i2.Token("link_open", "a", 1), { attrs: [].concat(r3.class ? [["class", r3.class]] : [], [["href", r3.renderHref(e3, i2)]], r3.ariaHidden ? [["aria-hidden", "true"]] : [], Object.entries(r3.renderAttrs(e3, i2))) }), Object.assign(new i2.Token("html_inline", "", 0), { content: r3.symbol, meta: t2 }), new i2.Token("link_close", "a", -1)];
  if (r3.space) {
    var s2 = "string" == typeof r3.space ? r3.space : " ";
    i2.tokens[l2 + 1].children[n2[r3.placement]](Object.assign(new i2.Token("string" == typeof r3.space ? "html_inline" : "text", "", 0), { content: s2 }));
  }
  (o3 = i2.tokens[l2 + 1].children)[n2[r3.placement]].apply(o3, c2);
});
Object.assign(c.defaults, { space: true, placement: "after", ariaHidden: false });
var s = o2(c.renderPermalinkImpl);
s.defaults = Object.assign({}, c.defaults, { ariaHidden: true });
var u = o2(function(e3, n3, t3, r3, a2) {
  var i2 = [Object.assign(new r3.Token("link_open", "a", 1), { attrs: [].concat(n3.class ? [["class", n3.class]] : [], [["href", n3.renderHref(e3, r3)]], Object.entries(n3.renderAttrs(e3, r3))) })].concat(n3.safariReaderFix ? [new r3.Token("span_open", "span", 1)] : [], r3.tokens[a2 + 1].children, n3.safariReaderFix ? [new r3.Token("span_close", "span", -1)] : [], [new r3.Token("link_close", "a", -1)]);
  r3.tokens[a2 + 1] = Object.assign(new r3.Token("inline", "", 0), { children: i2 });
});
Object.assign(u.defaults, { safariReaderFix: false });
var d = o2(function(e3, r3, a2, i2, l2) {
  var o3;
  if (!["visually-hidden", "aria-label", "aria-describedby", "aria-labelledby"].includes(r3.style))
    throw new Error("`permalink.linkAfterHeader` called with unknown style option `" + r3.style + "`");
  if (!["aria-describedby", "aria-labelledby"].includes(r3.style) && !r3.assistiveText)
    throw new Error("`permalink.linkAfterHeader` called without the `assistiveText` option in `" + r3.style + "` style");
  if ("visually-hidden" === r3.style && !r3.visuallyHiddenClass)
    throw new Error("`permalink.linkAfterHeader` called without the `visuallyHiddenClass` option in `visually-hidden` style");
  var c2 = i2.tokens[l2 + 1].children.filter(function(e4) {
    return "text" === e4.type || "code_inline" === e4.type;
  }).reduce(function(e4, n3) {
    return e4 + n3.content;
  }, ""), s2 = [], u2 = [];
  if (r3.class && u2.push(["class", r3.class]), u2.push(["href", r3.renderHref(e3, i2)]), u2.push.apply(u2, Object.entries(r3.renderAttrs(e3, i2))), "visually-hidden" === r3.style) {
    if (s2.push(Object.assign(new i2.Token("span_open", "span", 1), { attrs: [["class", r3.visuallyHiddenClass]] }), Object.assign(new i2.Token("text", "", 0), { content: r3.assistiveText(c2) }), new i2.Token("span_close", "span", -1)), r3.space) {
      var d2 = "string" == typeof r3.space ? r3.space : " ";
      s2[n2[r3.placement]](Object.assign(new i2.Token("string" == typeof r3.space ? "html_inline" : "text", "", 0), { content: d2 }));
    }
    s2[n2[r3.placement]](Object.assign(new i2.Token("span_open", "span", 1), { attrs: [["aria-hidden", "true"]] }), Object.assign(new i2.Token("html_inline", "", 0), { content: r3.symbol, meta: t2 }), new i2.Token("span_close", "span", -1));
  } else
    s2.push(Object.assign(new i2.Token("html_inline", "", 0), { content: r3.symbol, meta: t2 }));
  "aria-label" === r3.style ? u2.push(["aria-label", r3.assistiveText(c2)]) : ["aria-describedby", "aria-labelledby"].includes(r3.style) && u2.push([r3.style, e3]);
  var f2 = [Object.assign(new i2.Token("link_open", "a", 1), { attrs: u2 })].concat(s2, [new i2.Token("link_close", "a", -1)]);
  (o3 = i2.tokens).splice.apply(o3, [l2 + 3, 0].concat(f2)), r3.wrapper && (i2.tokens.splice(l2, 0, Object.assign(new i2.Token("html_block", "", 0), { content: r3.wrapper[0] + "\n" })), i2.tokens.splice(l2 + 3 + f2.length + 1, 0, Object.assign(new i2.Token("html_block", "", 0), { content: r3.wrapper[1] + "\n" })));
});
function f(e3, n3, t3, r3) {
  var a2 = e3, i2 = r3;
  if (t3 && Object.prototype.hasOwnProperty.call(n3, a2))
    throw new Error("User defined `id` attribute `" + e3 + "` is not unique. Please fix it in your Markdown to continue.");
  for (; Object.prototype.hasOwnProperty.call(n3, a2); )
    a2 = e3 + "-" + i2, i2 += 1;
  return n3[a2] = true, a2;
}
function p(e3, n3) {
  n3 = Object.assign({}, p.defaults, n3), e3.core.ruler.push("anchor", function(e4) {
    for (var t3, a2 = {}, i2 = e4.tokens, l2 = Array.isArray(n3.level) ? (t3 = n3.level, function(e5) {
      return t3.includes(e5);
    }) : function(e5) {
      return function(n4) {
        return n4 >= e5;
      };
    }(n3.level), o3 = 0; o3 < i2.length; o3++) {
      var c2 = i2[o3];
      if ("heading_open" === c2.type && l2(Number(c2.tag.substr(1)))) {
        var s2 = n3.getTokensText(i2[o3 + 1].children), u2 = c2.attrGet("id");
        u2 = null == u2 ? f(n3.slugify(s2), a2, false, n3.uniqueSlugStartIndex) : f(u2, a2, true, n3.uniqueSlugStartIndex), c2.attrSet("id", u2), false !== n3.tabIndex && c2.attrSet("tabindex", "" + n3.tabIndex), "function" == typeof n3.permalink ? n3.permalink(u2, n3, e4, o3) : (n3.permalink || n3.renderPermalink && n3.renderPermalink !== r2) && n3.renderPermalink(u2, n3, e4, o3), o3 = i2.indexOf(c2), n3.callback && n3.callback(c2, { slug: u2, title: s2 });
      }
    }
  });
}
Object.assign(d.defaults, { style: "visually-hidden", space: true, placement: "after", wrapper: null }), p.permalink = { __proto__: null, legacy: r2, renderHref: a, renderAttrs: i, makePermalink: o2, linkInsideHeader: c, ariaHidden: s, headerLink: u, linkAfterHeader: d }, p.defaults = { level: 1, slugify: function(e3) {
  return encodeURIComponent(String(e3).trim().toLowerCase().replace(/\s+/g, "-"));
}, uniqueSlugStartIndex: 1, tabIndex: "-1", getTokensText: function(e3) {
  return e3.filter(function(e4) {
    return ["text", "code_inline"].includes(e4.type);
  }).map(function(e4) {
    return e4.content;
  }).join("");
}, permalink: false, renderPermalink: r2, permalinkClass: s.defaults.class, permalinkSpace: s.defaults.space, permalinkSymbol: "¶", permalinkBefore: "before" === s.defaults.placement, permalinkHref: s.defaults.renderHref, permalinkAttrs: s.defaults.renderAttrs }, p.default = p;

// node_modules/.pnpm/@vuepress+markdown@2.0.0-beta.61/node_modules/@vuepress/markdown/dist/index.js
var import_mdurl = __toESM(require_mdurl());
var import_markdown_it_emoji = __toESM(require_markdown_it_emoji());
var __defProp = Object.defineProperty;
var __export2 = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var resolveLink = (link, relativePathPrefix, env2) => {
  let resolvedLink = (0, import_mdurl.decode)(link);
  if (/^\.{1,2}\//.test(link) && env2.filePathRelative) {
    resolvedLink = `${relativePathPrefix}/${import_upath.default.join(
      import_upath.default.dirname(env2.filePathRelative),
      resolvedLink
    )}`;
  }
  return resolvedLink;
};
var assetsPlugin = (md, { relativePathPrefix = "@source" } = {}) => {
  const rawImageRule = md.renderer.rules.image;
  md.renderer.rules.image = (tokens, idx, options3, env2, self2) => {
    const token = tokens[idx];
    const link = token.attrGet("src");
    if (link) {
      token.attrSet("src", resolveLink(link, relativePathPrefix, env2));
    }
    return rawImageRule(tokens, idx, options3, env2, self2);
  };
  const createHtmlRule = (rawHtmlRule) => (tokens, idx, options3, env2, self2) => {
    tokens[idx].content = tokens[idx].content.replace(
      /(<img\b.*?src=)(['"])([^\2]*?)\2/gs,
      (_, prefix, quote, src3) => `${prefix}${quote}${resolveLink(
        src3.trim(),
        relativePathPrefix,
        env2
      )}${quote}`
    ).replace(
      /(<img\b.*?srcset=)(['"])([^\2]*?)\2/gs,
      (_, prefix, quote, srcset) => `${prefix}${quote}${srcset.split(",").map(
        (item) => item.trim().replace(
          /^([^ ]*?)([ \n].*)?$/,
          (_2, url2, descriptor = "") => `${resolveLink(
            url2.trim(),
            relativePathPrefix,
            env2
          )}${descriptor.replace(/[ \n]+/g, " ").trimEnd()}`
        )
      ).join(", ")}${quote}`
    );
    return rawHtmlRule(tokens, idx, options3, env2, self2);
  };
  const rawHtmlBlockRule = md.renderer.rules.html_block;
  const rawHtmlInlineRule = md.renderer.rules.html_inline;
  md.renderer.rules.html_block = createHtmlRule(rawHtmlBlockRule);
  md.renderer.rules.html_inline = createHtmlRule(rawHtmlInlineRule);
};
var resolveHighlightLines = (info3) => {
  const match = info3.match(/{([\d,-]+)}/);
  if (match === null) {
    return null;
  }
  return match[1].split(",").map((item) => {
    const range2 = item.split("-");
    if (range2.length === 1) {
      range2.push(range2[0]);
    }
    return range2.map((str2) => Number.parseInt(str2, 10));
  });
};
var isHighlightLine = (lineNumber, ranges) => ranges.some(([start, end]) => lineNumber >= start && lineNumber <= end);
var languages_exports = {};
__export2(languages_exports, {
  languageBash: () => languageBash,
  languageCsharp: () => languageCsharp,
  languageDocker: () => languageDocker,
  languageFsharp: () => languageFsharp,
  languageJavascript: () => languageJavascript,
  languageKotlin: () => languageKotlin,
  languageMarkdown: () => languageMarkdown,
  languagePython: () => languagePython,
  languageRuby: () => languageRuby,
  languageRust: () => languageRust,
  languageStylus: () => languageStylus,
  languageTypescript: () => languageTypescript,
  languageYaml: () => languageYaml
});
var languageBash = {
  name: "bash",
  ext: "sh",
  aliases: ["bash", "sh", "shell", "zsh"]
};
var languageCsharp = {
  name: "csharp",
  ext: "cs",
  aliases: ["cs", "csharp"]
};
var languageDocker = {
  name: "docker",
  ext: "docker",
  aliases: ["docker", "dockerfile"]
};
var languageFsharp = {
  name: "fsharp",
  ext: "fs",
  aliases: ["fs", "fsharp"]
};
var languageJavascript = {
  name: "javascript",
  ext: "js",
  aliases: ["javascript", "js"]
};
var languageKotlin = {
  name: "kotlin",
  ext: "kt",
  aliases: ["kotlin", "kt"]
};
var languageMarkdown = {
  name: "markdown",
  ext: "md",
  aliases: ["markdown", "md"]
};
var languagePython = {
  name: "python",
  ext: "py",
  aliases: ["py", "python"]
};
var languageRuby = {
  name: "ruby",
  ext: "rb",
  aliases: ["rb", "ruby"]
};
var languageRust = {
  name: "rust",
  ext: "rs",
  aliases: ["rs", "rust"]
};
var languageStylus = {
  name: "stylus",
  ext: "styl",
  aliases: ["styl", "stylus"]
};
var languageTypescript = {
  name: "typescript",
  ext: "ts",
  aliases: ["ts", "typescript"]
};
var languageYaml = {
  name: "yaml",
  ext: "yml",
  aliases: ["yaml", "yml"]
};
var languagesMap;
var getLanguagesMap = () => {
  if (!languagesMap) {
    languagesMap = Object.values(languages_exports).reduce((result, item) => {
      item.aliases.forEach((alias2) => {
        result[alias2] = item;
      });
      return result;
    }, {});
  }
  return languagesMap;
};
var resolveLanguage = (info3) => {
  var _a;
  const alias2 = ((_a = info3.match(/^([^ :[{]+)/)) == null ? void 0 : _a[1]) || "text";
  return getLanguagesMap()[alias2] ?? {
    name: alias2,
    ext: alias2,
    aliases: [alias2]
  };
};
var resolveLineNumbers = (info3) => {
  if (/:line-numbers\b/.test(info3)) {
    return true;
  }
  if (/:no-line-numbers\b/.test(info3)) {
    return false;
  }
  return null;
};
var resolveVPre = (info3) => {
  if (/:v-pre\b/.test(info3)) {
    return true;
  }
  if (/:no-v-pre\b/.test(info3)) {
    return false;
  }
  return null;
};
var codePlugin = (md, {
  highlightLines = true,
  lineNumbers = true,
  preWrapper = true,
  vPre: { block: vPreBlock = true, inline: vPreInline = true } = {}
} = {}) => {
  md.renderer.rules.fence = (tokens, idx, options3, env2, slf) => {
    var _a;
    const token = tokens[idx];
    const info3 = token.info ? md.utils.unescapeAll(token.info).trim() : "";
    const language = resolveLanguage(info3);
    const languageClass = `${options3.langPrefix}${language.name}`;
    const code = ((_a = options3.highlight) == null ? void 0 : _a.call(options3, token.content, language.name, "")) || md.utils.escapeHtml(token.content);
    token.attrJoin("class", languageClass);
    let result = code.startsWith("<pre") ? code : `<pre${slf.renderAttrs(token)}><code>${code}</code></pre>`;
    const useVPre = resolveVPre(info3) ?? vPreBlock;
    if (useVPre) {
      result = `<pre v-pre${result.slice("<pre".length)}`;
    }
    if (!preWrapper) {
      return result;
    }
    const lines = code.split("\n").slice(0, -1);
    const highlightLinesRanges = highlightLines ? resolveHighlightLines(info3) : null;
    if (highlightLinesRanges) {
      const highlightLinesCode = lines.map((_, index2) => {
        if (isHighlightLine(index2 + 1, highlightLinesRanges)) {
          return '<div class="highlight-line">&nbsp;</div>';
        }
        return "<br>";
      }).join("");
      result = `${result}<div class="highlight-lines">${highlightLinesCode}</div>`;
    }
    const useLineNumbers = resolveLineNumbers(info3) ?? (typeof lineNumbers === "number" ? lines.length >= lineNumbers : lineNumbers);
    if (useLineNumbers) {
      const lineNumbersCode = lines.map(() => `<div class="line-number"></div>`).join("");
      result = `${result}<div class="line-numbers" aria-hidden="true">${lineNumbersCode}</div>`;
    }
    result = `<div class="${languageClass}${useLineNumbers ? " line-numbers-mode" : ""}" data-ext="${language.ext}">${result}</div>`;
    return result;
  };
  if (vPreInline) {
    const rawInlineCodeRule = md.renderer.rules.code_inline;
    md.renderer.rules.code_inline = (tokens, idx, options3, env2, slf) => {
      const result = rawInlineCodeRule(tokens, idx, options3, env2, slf);
      return `<code v-pre${result.slice("<code".length)}`;
    };
  }
};
var MIN_LENGTH = 9;
var START_CODES = [64, 91, 99, 111, 100, 101];
var SYNTAX_RE = /^@\[code(?:{(?:(\d+)?-(\d+)?)})?(?: ([^\]]+))?\]\(([^)]*)\)/;
var createImportCodeBlockRule = ({ handleImportPath = (str2) => str2 }) => (state, startLine, endLine, silent) => {
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  const pos = state.bMarks[startLine] + state.tShift[startLine];
  const max = state.eMarks[startLine];
  if (pos + MIN_LENGTH > max)
    return false;
  for (let i2 = 0; i2 < START_CODES.length; i2 += 1) {
    if (state.src.charCodeAt(pos + i2) !== START_CODES[i2]) {
      return false;
    }
  }
  const match = state.src.slice(pos, max).match(SYNTAX_RE);
  if (!match)
    return false;
  if (silent)
    return true;
  const [, lineStart, lineEnd, info3, importPath] = match;
  const meta = {
    importPath: handleImportPath(importPath),
    lineStart: lineStart ? Number.parseInt(lineStart, 10) : 0,
    lineEnd: lineEnd ? Number.parseInt(lineEnd, 10) : void 0
  };
  const token = state.push("import_code", "code", 0);
  token.info = info3 ?? import_upath.default.extname(meta.importPath).slice(1);
  token.markup = "```";
  token.map = [startLine, startLine + 1];
  token.meta = meta;
  state.line = startLine + 1;
  return true;
};
var resolveImportCode = ({ importPath, lineStart, lineEnd }, { filePath }) => {
  let importFilePath = importPath;
  if (!import_upath.default.isAbsolute(importPath)) {
    if (!filePath) {
      logger.error(
        `Import file ${import_picocolors.default.magenta(importPath)} can not be resolved`
      );
      return {
        importFilePath: null,
        importCode: "Error when resolving path"
      };
    }
    importFilePath = import_upath.default.resolve(filePath, "..", importPath);
  }
  if (!import_fs_extra.default.existsSync(importFilePath)) {
    logger.error(`Import file ${import_picocolors.default.magenta(importPath)} not found`);
    return {
      importFilePath,
      importCode: "File not found"
    };
  }
  const fileContent = import_fs_extra.default.readFileSync(importFilePath).toString();
  return {
    importFilePath,
    importCode: fileContent.split("\n").slice(lineStart ? lineStart - 1 : lineStart, lineEnd).join("\n").replace(/\n?$/, "\n")
  };
};
var importCodePlugin = (md, options3 = {}) => {
  md.block.ruler.before(
    "fence",
    "import_code",
    createImportCodeBlockRule(options3),
    {
      alt: ["paragraph", "reference", "blockquote", "list"]
    }
  );
  md.renderer.rules.import_code = (tokens, idx, options22, env2, slf) => {
    const token = tokens[idx];
    const { importFilePath, importCode } = resolveImportCode(token.meta, env2);
    token.content = importCode;
    if (importFilePath) {
      const importedFiles = env2.importedFiles || (env2.importedFiles = []);
      importedFiles.push(importFilePath);
    }
    return md.renderer.rules.fence(tokens, idx, options22, env2, slf);
  };
};
var resolvePaths = (rawPath, base2, filePathRelative) => {
  let absolutePath;
  let relativePath;
  if (rawPath.startsWith("/")) {
    if (rawPath.endsWith(".md")) {
      absolutePath = import_upath.default.join(base2, rawPath);
      relativePath = removeLeadingSlash(rawPath);
    } else {
      absolutePath = rawPath;
      relativePath = import_upath.default.relative(base2, absolutePath);
    }
  } else {
    if (filePathRelative) {
      relativePath = import_upath.default.join(
        // file path may contain non-ASCII characters
        import_upath.default.dirname(encodeURI(filePathRelative)),
        rawPath
      );
      absolutePath = import_upath.default.join(base2, relativePath);
    } else {
      relativePath = rawPath.replace(/^(?:\.\/)?(.*)$/, "$1");
      absolutePath = relativePath;
    }
  }
  return {
    absolutePath,
    relativePath
  };
};
var linksPlugin = (md, options3 = {}) => {
  const internalTag = options3.internalTag || "RouterLink";
  const externalAttrs = {
    target: "_blank",
    rel: "noopener noreferrer",
    ...options3.externalAttrs
  };
  let hasOpenInternalLink = false;
  const handleLinkOpen = (tokens, idx, env2) => {
    const token = tokens[idx];
    const hrefIndex = token.attrIndex("href");
    if (hrefIndex < 0) {
      return;
    }
    const hrefAttr = token.attrs[hrefIndex];
    const hrefLink = hrefAttr[1];
    const { base: base2 = "/", filePathRelative = null } = env2;
    if (isLinkExternal(hrefLink, base2)) {
      Object.entries(externalAttrs).forEach(
        ([key, val]) => token.attrSet(key, val)
      );
      return;
    }
    const internalLinkMatch = hrefLink.match(
      /^((?:.*)(?:\/|\.md|\.html))(#.*)?$/
    );
    if (!internalLinkMatch) {
      return;
    }
    const rawPath = internalLinkMatch[1];
    const rawHash = internalLinkMatch[2] || "";
    const { relativePath, absolutePath } = resolvePaths(
      rawPath,
      base2,
      filePathRelative
    );
    const normalizedPath = absolutePath.replace(new RegExp(`^${base2}`), "/").replace(/(^|\/)(README|index).md$/i, "$1").replace(/\.md$/, ".html");
    if (internalTag === "RouterLink") {
      token.tag = internalTag;
      hrefAttr[0] = "to";
      hasOpenInternalLink = true;
    }
    hrefAttr[1] = `${normalizedPath}${rawHash}`;
    const links = env2.links || (env2.links = []);
    links.push({
      raw: hrefLink,
      relative: relativePath,
      absolute: absolutePath
    });
  };
  md.renderer.rules.link_open = (tokens, idx, options22, env2, self2) => {
    handleLinkOpen(tokens, idx, env2);
    return self2.renderToken(tokens, idx, options22);
  };
  md.renderer.rules.link_close = (tokens, idx, options22, env2, self2) => {
    if (hasOpenInternalLink) {
      hasOpenInternalLink = false;
      tokens[idx].tag = internalTag;
    }
    return self2.renderToken(tokens, idx, options22);
  };
};
var createMarkdown = ({
  anchor,
  assets,
  code,
  component,
  emoji,
  frontmatter,
  headers,
  title,
  importCode,
  links,
  sfc,
  slugify: slugify2 = slugify,
  toc,
  ...markdownItOptions
} = {}) => {
  const md = (0, import_markdown_it.default)({
    ...markdownItOptions,
    // should always enable html option
    html: true
  });
  if (anchor !== false) {
    md.use(p, {
      level: [1, 2, 3, 4, 5, 6],
      slugify: slugify2,
      permalink: p.permalink.ariaHidden({
        class: "header-anchor",
        symbol: "#",
        space: true,
        placement: "before"
      }),
      ...anchor
    });
  }
  if (assets !== false) {
    md.use(assetsPlugin, assets);
  }
  if (code !== false) {
    md.use(codePlugin, code);
  }
  if (component !== false) {
    md.use(componentPlugin);
  }
  if (emoji !== false) {
    md.use(import_markdown_it_emoji.default, emoji);
  }
  if (frontmatter !== false) {
    md.use(frontmatterPlugin, {
      ...frontmatter,
      grayMatterOptions: {
        excerpt: false,
        ...frontmatter == null ? void 0 : frontmatter.grayMatterOptions
      }
    });
  }
  if (headers !== false) {
    md.use(headersPlugin, {
      level: [2, 3],
      slugify: slugify2,
      ...headers
    });
  }
  if (importCode !== false) {
    md.use(importCodePlugin, importCode);
  }
  if (links !== false) {
    md.use(linksPlugin, links);
  }
  if (sfc !== false) {
    md.use(sfcPlugin, sfc);
  }
  if (toc !== false) {
    md.use(tocPlugin, {
      level: [2, 3],
      slugify: slugify2,
      linkTag: "router-link",
      ...toc
    });
  }
  if (title !== false) {
    md.use(titlePlugin);
  }
  return md;
};

// node_modules/.pnpm/@vuepress+core@2.0.0-beta.61/node_modules/@vuepress/core/dist/index.js
var import_module4 = __toESM(require_module());
var import_module5 = __toESM(require_module());
var import_module6 = __toESM(require_module());
var prepareClientConfigs = async (app) => {
  const clientConfigFiles = await app.pluginApi.hooks.clientConfigFile.process(
    app
  );
  const content = `${clientConfigFiles.map((filePath, index2) => `import clientConfig${index2} from '${filePath}'`).join("\n")}

export const clientConfigs = [
${clientConfigFiles.map((_, index2) => `  clientConfig${index2},`).join("\n")}
]
`;
  await app.writeTemp("internal/clientConfigs.js", content);
};
var preparePageComponent = async (app, page) => {
  var _a, _b, _c, _d, _e;
  await app.writeTemp(
    page.componentFilePathRelative,
    [
      // #688: wrap the content of `<template>` with a `<div>` to avoid some potential issues of fragment component
      `${(_a = page.sfcBlocks.template) == null ? void 0 : _a.tagOpen}<div>${(_b = page.sfcBlocks.template) == null ? void 0 : _b.contentStripped}</div>${(_c = page.sfcBlocks.template) == null ? void 0 : _c.tagClose}
`,
      // hoist `<script>`, `<style>` and other custom blocks
      (_d = page.sfcBlocks.script) == null ? void 0 : _d.content,
      (_e = page.sfcBlocks.scriptSetup) == null ? void 0 : _e.content,
      ...page.sfcBlocks.styles.map((item) => item.content),
      ...page.sfcBlocks.customBlocks.map((item) => item.content)
    ].join("\n")
  );
};
var HMR_CODE = `
if (import.meta.webpackHot) {
  import.meta.webpackHot.accept()
  if (__VUE_HMR_RUNTIME__.updatePageData) {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  }
}

if (import.meta.hot) {
  import.meta.hot.accept(({ data }) => {
    __VUE_HMR_RUNTIME__.updatePageData(data)
  })
}
`;
var preparePageData = async (app, page) => {
  let content = `export const data = JSON.parse(${JSON.stringify(
    JSON.stringify(page.data)
  )})
`;
  if (app.env.isDev) {
    content += HMR_CODE;
  }
  await app.writeTemp(page.dataFilePathRelative, content);
};
var preparePagesComponents = async (app) => {
  const content = `import { defineAsyncComponent } from 'vue'

export const pagesComponents = {${app.pages.map(
    ({ key, path: path9, componentFilePath, componentFileChunkName }) => `
  // path: ${path9}
  ${JSON.stringify(key)}: defineAsyncComponent(() => import(${componentFileChunkName ? `/* webpackChunkName: "${componentFileChunkName}" */` : ""}${JSON.stringify(componentFilePath)})),`
  ).join("")}
}
`;
  await app.writeTemp("internal/pagesComponents.js", content);
};
var preparePagesData = async (app) => {
  const content = `export const pagesData = {${app.pages.map(
    ({ key, path: path9, dataFilePath, dataFileChunkName }) => `
  // path: ${path9}
  ${JSON.stringify(key)}: () => import(${dataFileChunkName ? `/* webpackChunkName: "${dataFileChunkName}" */` : ""}${JSON.stringify(dataFilePath)}).then(({ data }) => data),`
  ).join("")}
}
`;
  await app.writeTemp("internal/pagesData.js", content);
};
var resolvePageRouteItem = ({
  key,
  path: path9,
  pathInferred,
  filePathRelative,
  routeMeta
}) => {
  const redirectsSet = /* @__PURE__ */ new Set();
  redirectsSet.add(decodeURI(path9));
  if (path9.endsWith("/")) {
    redirectsSet.add(path9 + "index.html");
  } else {
    redirectsSet.add(path9.replace(/.html$/, ""));
  }
  if (pathInferred !== null) {
    redirectsSet.add(pathInferred);
    redirectsSet.add(encodeURI(pathInferred));
  }
  if (filePathRelative !== null) {
    const filenamePath = ensureLeadingSlash(filePathRelative);
    redirectsSet.add(filenamePath);
    redirectsSet.add(encodeURI(filenamePath));
  }
  redirectsSet.delete(path9);
  return [key, path9, routeMeta, [...redirectsSet]];
};
var preparePagesRoutes = async (app) => {
  const routeItems = app.pages.map(resolvePageRouteItem);
  const content = `export const pagesRoutes = [${routeItems.map((routeItem) => `
  ${JSON.stringify(routeItem)},`).join("")}
]
`;
  await app.writeTemp("internal/pagesRoutes.js", content);
};
var HMR_CODE2 = `
if (import.meta.webpackHot) {
  import.meta.webpackHot.accept()
  if (__VUE_HMR_RUNTIME__.updateSiteData) {
    __VUE_HMR_RUNTIME__.updateSiteData(siteData)
  }
}

if (import.meta.hot) {
  import.meta.hot.accept(({ siteData }) => {
    __VUE_HMR_RUNTIME__.updateSiteData(siteData)
  })
}
`;
var prepareSiteData = async (app) => {
  let content = `export const siteData = JSON.parse(${JSON.stringify(
    JSON.stringify(app.siteData)
  )})
`;
  if (app.env.isDev) {
    content += HMR_CODE2;
  }
  await app.writeTemp("internal/siteData.js", content);
};
var resolveAppMarkdown = async (app) => {
  await app.pluginApi.hooks.extendsMarkdownOptions.process(
    app.options.markdown,
    app
  );
  const markdown = createMarkdown(app.options.markdown);
  await app.pluginApi.hooks.extendsMarkdown.process(markdown, app);
  return markdown;
};
var inferPagePath = ({
  app,
  filePathRelative
}) => {
  if (!filePathRelative) {
    return {
      pathInferred: null,
      pathLocale: "/"
    };
  }
  const pathInferred = ensureLeadingSlash(filePathRelative).replace(/\.md$/, ".html").replace(/\/(README|index).html$/i, "/");
  const pathLocale = resolveLocalePath(app.siteData.locales, pathInferred);
  return {
    pathInferred,
    pathLocale
  };
};
var renderPageContent = ({
  app,
  content,
  filePath,
  filePathRelative,
  options: options3
}) => {
  const markdownEnv = {
    base: app.options.base,
    filePath,
    filePathRelative,
    frontmatter: { ...options3.frontmatter }
  };
  const contentRendered = app.markdown.render(content, markdownEnv);
  const {
    frontmatter = {},
    headers = [],
    importedFiles = [],
    links = [],
    sfcBlocks = {
      template: null,
      script: null,
      scriptSetup: null,
      scripts: [],
      styles: [],
      customBlocks: []
    },
    title = "",
    ...extraMarkdownEnv
  } = markdownEnv;
  return {
    contentRendered,
    deps: importedFiles,
    frontmatter,
    headers,
    links,
    markdownEnv: omit(
      extraMarkdownEnv,
      "base",
      "content",
      "filePath",
      "filePathRelative",
      "frontmatter"
    ),
    sfcBlocks,
    title: frontmatter.title ?? title
  };
};
var resolvePageComponentInfo = async ({
  app,
  htmlFilePathRelative,
  key
}) => {
  const componentFilePathRelative = import_upath.default.join(
    "pages",
    `${htmlFilePathRelative}.vue`
  );
  const componentFilePath = app.dir.temp(componentFilePathRelative);
  const componentFileChunkName = key;
  return {
    componentFilePath,
    componentFilePathRelative,
    componentFileChunkName
  };
};
var resolvePageDataInfo = ({
  app,
  htmlFilePathRelative,
  key
}) => {
  const dataFilePathRelative = import_upath.default.join("pages", `${htmlFilePathRelative}.js`);
  const dataFilePath = app.dir.temp(dataFilePathRelative);
  const dataFileChunkName = key;
  return {
    dataFilePath,
    dataFilePathRelative,
    dataFileChunkName
  };
};
var FILENAME_DATE_RE = /^(\d{4})-(\d{1,2})(?:-(\d{1,2}))?-(.*)$/;
var DIRNAME_DATE_RE = /(\d{4})\/(\d{1,2})(?:\/(\d{1,2}))?(\/|$)/;
var DEFAULT_DATE = "0000-00-00";
var resolvePageDate = ({
  frontmatter,
  filePathRelative
}) => {
  if (frontmatter.date instanceof Date) {
    return formatDateString(
      [
        frontmatter.date.getUTCFullYear(),
        frontmatter.date.getUTCMonth() + 1,
        frontmatter.date.getUTCDate()
      ].join("-"),
      DEFAULT_DATE
    );
  }
  if (isString(frontmatter.date)) {
    return formatDateString(frontmatter.date, DEFAULT_DATE);
  }
  if (filePathRelative === null) {
    return DEFAULT_DATE;
  }
  const filename = import_upath.default.parse(filePathRelative).name;
  if (filename) {
    const matches2 = filename.match(FILENAME_DATE_RE);
    if (matches2) {
      return formatDateString(
        `${matches2[1]}-${matches2[2]}-${matches2[3] ?? "01"}`,
        DEFAULT_DATE
      );
    }
  }
  const dirname2 = import_upath.default.dirname(filePathRelative);
  if (dirname2 !== ".") {
    const matches2 = dirname2.match(DIRNAME_DATE_RE);
    if (matches2) {
      return formatDateString(
        `${matches2[1]}-${matches2[2]}-${matches2[3] ?? "01"}`,
        DEFAULT_DATE
      );
    }
  }
  return DEFAULT_DATE;
};
var log2 = (0, import_debug.default)("vuepress:core/page");
var resolvePageFileContent = async ({
  filePath,
  options: options3
}) => {
  if (filePath) {
    try {
      const content = await import_fs_extra.default.readFile(filePath, "utf-8");
      return content;
    } catch (e3) {
      log2(e3 instanceof Error ? e3.message : e3);
    }
  }
  return options3.content ?? "";
};
var resolvePageFilePath = ({
  app,
  options: options3
}) => {
  if (!options3.filePath) {
    return {
      filePath: null,
      filePathRelative: null
    };
  }
  if (!import_upath.default.isAbsolute(options3.filePath)) {
    throw logger.createError(
      `filePath is not absolute file path: ${options3.filePath}}`
    );
  }
  return {
    filePath: options3.filePath,
    filePathRelative: import_upath.default.relative(app.dir.source(), options3.filePath)
  };
};
var resolvePageHtmlInfo = ({
  app,
  path: pagePath
}) => {
  const htmlFilePathRelative = removeLeadingSlash(
    decodeURI(pagePath.replace(/\/$/, "/index.html"))
  );
  const htmlFilePath = app.dir.dest(htmlFilePathRelative);
  return {
    htmlFilePath,
    htmlFilePathRelative
  };
};
var resolvePageKey = ({ path: path9 }) => `v-${(0, import_hash_sum.default)(path9)}`;
var resolvePageLang = ({
  app,
  frontmatter,
  pathLocale
}) => {
  var _a;
  if (isString(frontmatter.lang) && frontmatter.lang) {
    return frontmatter.lang;
  }
  return ((_a = app.siteData.locales[pathLocale]) == null ? void 0 : _a.lang) ?? app.siteData.lang;
};
var resolvePagePath = ({
  permalink,
  pathInferred,
  options: options3
}) => {
  let pagePath = options3.path || permalink || pathInferred;
  if (!pagePath) {
    throw logger.createError(
      `page path is empty, page options: ${JSON.stringify(options3, null, 2)}`
    );
  }
  if (!pagePath.endsWith(".html")) {
    pagePath = ensureEndingSlash(pagePath);
  }
  return encodeURI(pagePath.split("/").map(sanitizeFileName).join("/"));
};
var resolvePagePermalink = ({
  app,
  frontmatter,
  slug,
  date,
  pathInferred,
  pathLocale
}) => {
  if (isString(frontmatter.permalink)) {
    return frontmatter.permalink;
  }
  const permalinkPattern = getPermalinkPattern({ app, frontmatter });
  if (permalinkPattern === null) {
    return null;
  }
  const [year, month, day] = date.split("-");
  const link = import_upath.default.join(
    pathLocale,
    permalinkPattern.replace(/:year/, year).replace(/:month/, month).replace(/:day/, day).replace(/:slug/, slug).replace(/:raw/, (pathInferred == null ? void 0 : pathInferred.replace(/^\//, "")) ?? "")
  );
  return ensureLeadingSlash(link);
};
var getPermalinkPattern = ({
  app,
  frontmatter
}) => {
  if (frontmatter.permalinkPattern === null) {
    return null;
  }
  if (isString(frontmatter.permalinkPattern)) {
    return frontmatter.permalinkPattern;
  }
  return app.options.permalinkPattern;
};
var resolvePageRouteMeta = ({
  frontmatter
}) => frontmatter.routeMeta ?? {};
var DATE_RE = /(\d{4}-\d{1,2}(-\d{1,2})?)-(.*)/;
var resolvePageSlug = ({
  filePathRelative
}) => {
  if (!filePathRelative) {
    return "";
  }
  const filename = import_upath.default.parse(filePathRelative).name;
  const match = filename.match(DATE_RE);
  return match ? match[3] : filename;
};
var createPage = async (app, options3) => {
  await app.pluginApi.hooks.extendsPageOptions.process(options3, app);
  const { filePath, filePathRelative } = resolvePageFilePath({
    app,
    options: options3
  });
  const content = await resolvePageFileContent({ filePath, options: options3 });
  const {
    contentRendered,
    deps,
    frontmatter,
    headers,
    links,
    markdownEnv,
    sfcBlocks,
    title
  } = renderPageContent({
    app,
    content,
    filePath,
    filePathRelative,
    options: options3
  });
  const routeMeta = resolvePageRouteMeta({ frontmatter });
  const slug = resolvePageSlug({ filePathRelative });
  const date = resolvePageDate({ frontmatter, filePathRelative });
  const { pathInferred, pathLocale } = inferPagePath({ app, filePathRelative });
  const lang = resolvePageLang({ app, frontmatter, pathLocale });
  const permalink = resolvePagePermalink({
    app,
    frontmatter,
    slug,
    date,
    pathInferred,
    pathLocale
  });
  const path9 = resolvePagePath({ permalink, pathInferred, options: options3 });
  const key = resolvePageKey({ path: path9 });
  const { htmlFilePath, htmlFilePathRelative } = resolvePageHtmlInfo({
    app,
    path: path9
  });
  const {
    componentFilePath,
    componentFilePathRelative,
    componentFileChunkName
  } = await resolvePageComponentInfo({
    app,
    htmlFilePathRelative,
    key
  });
  const { dataFilePath, dataFilePathRelative, dataFileChunkName } = resolvePageDataInfo({ app, htmlFilePathRelative, key });
  const page = {
    // page data
    data: {
      key,
      path: path9,
      title,
      lang,
      frontmatter,
      headers
    },
    // base fields
    key,
    path: path9,
    title,
    lang,
    frontmatter,
    headers,
    // extra fields
    content,
    contentRendered,
    date,
    deps,
    links,
    markdownEnv,
    pathInferred,
    pathLocale,
    permalink,
    routeMeta,
    sfcBlocks,
    slug,
    // file info
    filePath,
    filePathRelative,
    componentFilePath,
    componentFilePathRelative,
    componentFileChunkName,
    dataFilePath,
    dataFilePathRelative,
    dataFileChunkName,
    htmlFilePath,
    htmlFilePathRelative
  };
  await app.pluginApi.hooks.extendsPage.process(page, app);
  return page;
};
var log22 = (0, import_debug.default)("vuepress:core/app");
var resolveAppPages = async (app) => {
  log22("resolveAppPages start");
  const pageFilePaths = await globby(app.options.pagePatterns, {
    absolute: true,
    cwd: app.dir.source()
  });
  const pages = await Promise.all(
    pageFilePaths.map((filePath) => createPage(app, { filePath }))
  );
  if (!pages.some((page) => page.path === "/404.html")) {
    pages.push(
      await createPage(app, {
        path: "/404.html",
        frontmatter: {
          layout: "NotFound"
        }
      })
    );
  }
  log22("resolveAppPages finish");
  return pages;
};
var log3 = (0, import_debug.default)("vuepress:core/app");
var appInit = async (app) => {
  log3("init start");
  app.pluginApi.registerHooks();
  app.markdown = await resolveAppMarkdown(app);
  app.pages = await resolveAppPages(app);
  await app.pluginApi.hooks.onInitialized.process(app);
  log3("init finish");
};
var log4 = (0, import_debug.default)("vuepress:core/app");
var appPrepare = async (app) => {
  log4("prepare start");
  for (const page of app.pages) {
    await preparePageComponent(app, page);
  }
  await preparePagesComponents(app);
  for (const page of app.pages) {
    await preparePageData(app, page);
  }
  await preparePagesData(app);
  await preparePagesRoutes(app);
  await prepareSiteData(app);
  await prepareClientConfigs(app);
  await app.pluginApi.hooks.onPrepared.process(app);
  log4("prepare finish");
};
var resolvePluginObject = (app, plugin) => isFunction(plugin) ? plugin(app) : plugin;
var log5 = (0, import_debug.default)("vuepress:core/app");
var appUse = (app, rawPlugin) => {
  const pluginObject = resolvePluginObject(app, rawPlugin);
  if (!pluginObject.name) {
    warn(`an anonymous plugin or theme was detected and ignored`);
    return app;
  }
  log5(`use plugin ${import_picocolors.default.magenta(pluginObject.name)}`);
  if (pluginObject.multiple !== true) {
    const duplicateIndex = app.pluginApi.plugins.findIndex(
      ({ name: name2 }) => name2 === pluginObject.name
    );
    if (duplicateIndex !== -1) {
      app.pluginApi.plugins.splice(duplicateIndex, 1);
      warn(
        `plugin ${import_picocolors.default.magenta(
          pluginObject.name
        )} has been used multiple times, only the last one will take effect`
      );
    }
  }
  app.pluginApi.plugins.push(pluginObject);
  return app;
};
var log6 = (0, import_debug.default)("vuepress:core/plugin-api");
var createHookQueue = (name2) => {
  const items = [];
  const hookQueue = {
    name: name2,
    items,
    add: (item) => {
      items.push(item);
    },
    process: async (...args) => {
      const results = [];
      for (const item of items) {
        log6(
          `process ${import_picocolors.default.magenta(name2)} from ${import_picocolors.default.magenta(
            item.pluginName
          )}`
        );
        try {
          const result = await item.hook(...args);
          if (result !== void 0) {
            results.push(result);
          }
        } catch (e3) {
          logger.error(
            `error in hook ${import_picocolors.default.magenta(name2)} from ${import_picocolors.default.magenta(
              item.pluginName
            )}`
          );
          throw e3;
        }
      }
      return results;
    }
  };
  return hookQueue;
};
var createPluginApiHooks = () => ({
  // life cycle hooks
  onInitialized: createHookQueue("onInitialized"),
  onPrepared: createHookQueue("onPrepared"),
  onWatched: createHookQueue("onWatched"),
  onGenerated: createHookQueue("onGenerated"),
  // extends hooks
  extendsMarkdownOptions: createHookQueue("extendsMarkdownOptions"),
  extendsMarkdown: createHookQueue("extendsMarkdown"),
  extendsPageOptions: createHookQueue("extendsPageOptions"),
  extendsPage: createHookQueue("extendsPage"),
  extendsBundlerOptions: createHookQueue("extendsBundlerOptions"),
  // client config file hooks
  clientConfigFile: createHookQueue("clientConfigFile"),
  // bundler hooks
  alias: createHookQueue("alias"),
  define: createHookQueue("define")
});
var normalizeAliasDefineHook = (hook) => async (app, isServer) => isFunction(hook) ? hook(app, isServer) : hook;
var normalizeClientConfigFileHook = (hook) => async (app) => {
  const clientConfigFileResult = isFunction(hook) ? await hook(app) : hook;
  const isExisted = await import_fs_extra.default.pathExists(clientConfigFileResult);
  if (!isExisted) {
    throw logger.createError(
      `client config file does not exist: ${clientConfigFileResult}`
    );
  }
  return clientConfigFileResult;
};
var createPluginApiRegisterHooks = (plugins2, hooks) => () => {
  plugins2.forEach(
    ({
      name: pluginName,
      multiple,
      alias: alias2,
      define: define2,
      clientConfigFile,
      ...commonHooks
    }) => {
      if (alias2) {
        hooks.alias.add({
          pluginName,
          hook: normalizeAliasDefineHook(alias2)
        });
      }
      if (define2) {
        hooks.define.add({
          pluginName,
          hook: normalizeAliasDefineHook(define2)
        });
      }
      if (clientConfigFile) {
        hooks.clientConfigFile.add({
          pluginName,
          hook: normalizeClientConfigFileHook(clientConfigFile)
        });
      }
      Object.keys(commonHooks).forEach((key) => {
        if (hooks[key] && commonHooks[key]) {
          hooks[key].add({
            pluginName,
            hook: commonHooks[key]
          });
        }
      });
    }
  );
};
var createPluginApi = () => {
  const plugins2 = [];
  const hooks = createPluginApiHooks();
  const registerHooks = createPluginApiRegisterHooks(plugins2, hooks);
  return {
    plugins: plugins2,
    hooks,
    registerHooks
  };
};
var require23 = (0, import_module4.createRequire)(import.meta.url);
var createAppDirFunction = (baseDir) => {
  return (...args) => import_upath.default.resolve(baseDir, ...args);
};
var resolveAppDir = (options3) => {
  const cache2 = createAppDirFunction(options3.cache);
  const temp = createAppDirFunction(options3.temp);
  const source = createAppDirFunction(options3.source);
  const dest = createAppDirFunction(options3.dest);
  const publicDir = createAppDirFunction(options3.public);
  const client = createAppDirFunction(
    import_upath.default.resolve(require23.resolve("@vuepress/client/package.json"), "..")
  );
  return {
    cache: cache2,
    temp,
    source,
    dest,
    client,
    public: publicDir
  };
};
var resolveAppEnv = (options3, isBuild) => ({
  isBuild,
  isDev: !isBuild,
  isDebug: options3.debug
});
var require3 = (0, import_module5.createRequire)(import.meta.url);
var resolveAppOptions = ({
  // site config
  base: base2 = "/",
  lang = "en-US",
  title = "",
  description: description2 = "",
  head = [],
  locales = {},
  // directory config
  source,
  dest = import_upath.default.resolve(source, ".vuepress/dist"),
  temp = import_upath.default.resolve(source, ".vuepress/.temp"),
  cache: cache2 = import_upath.default.resolve(source, ".vuepress/.cache"),
  public: publicDir = import_upath.default.resolve(source, ".vuepress/public"),
  // dev config
  host = "0.0.0.0",
  port = 8080,
  open: open2 = false,
  templateDev = import_upath.default.normalize(
    require3.resolve("@vuepress/client/templates/dev.html")
  ),
  // build config
  shouldPreload = true,
  shouldPrefetch = true,
  templateBuild = import_upath.default.normalize(
    require3.resolve("@vuepress/client/templates/build.html")
  ),
  // common config
  bundler,
  debug: debug7 = false,
  markdown = {},
  pagePatterns = ["**/*.md", "!.vuepress", "!node_modules"],
  permalinkPattern = null,
  plugins: plugins2 = [],
  theme
}) => ({
  base: base2,
  lang,
  title,
  description: description2,
  head,
  locales,
  source,
  dest,
  temp,
  cache: cache2,
  public: publicDir,
  host,
  port,
  open: open2,
  templateDev,
  shouldPreload,
  shouldPrefetch,
  templateBuild,
  bundler,
  debug: debug7,
  markdown,
  pagePatterns,
  permalinkPattern,
  plugins: plugins2,
  theme
});
var resolveAppSiteData = (options3) => ({
  base: options3.base,
  lang: options3.lang,
  title: options3.title,
  description: options3.description,
  head: options3.head,
  locales: options3.locales
});
var require4 = (0, import_module6.createRequire)(import.meta.url);
var resolveAppVersion = () => {
  const pkgJson = import_fs_extra.default.readJsonSync(
    require4.resolve("@vuepress/core/package.json")
  );
  return pkgJson.version;
};
var resolveAppWriteTemp = (dir) => {
  const writeTemp = async (file, content) => {
    const filePath = dir.temp(file);
    await import_fs_extra.default.outputFile(filePath, content);
    return filePath;
  };
  return writeTemp;
};
var resolveThemeInfo = (app, theme) => {
  const themeObject = resolvePluginObject(app, theme);
  const themeInfo = {
    plugins: [...themeObject.plugins ?? [], themeObject],
    templateBuild: themeObject.templateBuild,
    templateDev: themeObject.templateDev
  };
  if (!themeObject.extends) {
    return themeInfo;
  }
  const parentThemeInfo = resolveThemeInfo(app, themeObject.extends);
  return {
    plugins: [...parentThemeInfo.plugins, ...themeInfo.plugins],
    templateBuild: themeObject.templateBuild ?? parentThemeInfo.templateBuild,
    templateDev: themeObject.templateDev ?? parentThemeInfo.templateDev
  };
};
var setupAppThemeAndPlugins = (app, config2) => {
  const themeInfo = resolveThemeInfo(app, app.options.theme);
  app.options.templateDev = config2.templateDev ?? themeInfo.templateDev ?? app.options.templateDev;
  app.options.templateBuild = config2.templateBuild ?? themeInfo.templateBuild ?? app.options.templateBuild;
  [...themeInfo.plugins, ...app.options.plugins].flat().forEach((plugin) => app.use(plugin));
};
var createBaseApp = (config2, isBuild = false) => {
  const options3 = resolveAppOptions(config2);
  const dir = resolveAppDir(options3);
  const env2 = resolveAppEnv(options3, isBuild);
  const pluginApi = createPluginApi();
  const siteData = resolveAppSiteData(options3);
  const version4 = resolveAppVersion();
  const writeTemp = resolveAppWriteTemp(dir);
  const app = {
    options: options3,
    siteData,
    version: version4,
    // utils
    dir,
    env: env2,
    pluginApi,
    writeTemp,
    // methods
    use: (plugin) => appUse(app, plugin),
    init: () => appInit(app),
    prepare: () => appPrepare(app)
  };
  setupAppThemeAndPlugins(app, config2);
  return app;
};
var createBuildApp = (config2) => {
  const app = createBaseApp(config2, true);
  app.build = () => app.options.bundler.build(app);
  return app;
};
var createDevApp = (config2) => {
  const app = createBaseApp(config2, false);
  app.dev = () => app.options.bundler.dev(app);
  return app;
};

// node_modules/.pnpm/@vuepress+cli@2.0.0-beta.61/node_modules/@vuepress/cli/dist/index.js
var import_url5 = __toESM(require_url());
var import_esbuild3 = __toESM(require_main());
var import_process3 = __toESM(require_process());
var import_process4 = __toESM(require_process());
var import_process5 = __toESM(require_process());
var import_process6 = __toESM(require_process());
var import_process7 = __toESM(require_process());
var import_chokidar = __toESM(require_chokidar());
var import_process8 = __toESM(require_process());
var import_chokidar2 = __toESM(require_chokidar());
var import_envinfo = __toESM(require_envinfo());
var import_module7 = __toESM(require_module());
var import_process9 = __toESM(require_process());

// node_modules/.pnpm/cac@6.7.14/node_modules/cac/dist/index.mjs
var import_events3 = __toESM(require_events(), 1);
function toArr(any) {
  return any == null ? [] : Array.isArray(any) ? any : [any];
}
function toVal(out2, key, val, opts) {
  var x, old2 = out2[key], nxt = !!~opts.string.indexOf(key) ? val == null || val === true ? "" : String(val) : typeof val === "boolean" ? val : !!~opts.boolean.indexOf(key) ? val === "false" ? false : val === "true" || (out2._.push((x = +val, x * 0 === 0) ? x : val), !!val) : (x = +val, x * 0 === 0) ? x : val;
  out2[key] = old2 == null ? nxt : Array.isArray(old2) ? old2.concat(nxt) : [old2, nxt];
}
function mri2(args, opts) {
  args = args || [];
  opts = opts || {};
  var k, arr, arg, name2, val, out2 = { _: [] };
  var i2 = 0, j = 0, idx = 0, len = args.length;
  const alibi = opts.alias !== void 0;
  const strict = opts.unknown !== void 0;
  const defaults = opts.default !== void 0;
  opts.alias = opts.alias || {};
  opts.string = toArr(opts.string);
  opts.boolean = toArr(opts.boolean);
  if (alibi) {
    for (k in opts.alias) {
      arr = opts.alias[k] = toArr(opts.alias[k]);
      for (i2 = 0; i2 < arr.length; i2++) {
        (opts.alias[arr[i2]] = arr.concat(k)).splice(i2, 1);
      }
    }
  }
  for (i2 = opts.boolean.length; i2-- > 0; ) {
    arr = opts.alias[opts.boolean[i2]] || [];
    for (j = arr.length; j-- > 0; )
      opts.boolean.push(arr[j]);
  }
  for (i2 = opts.string.length; i2-- > 0; ) {
    arr = opts.alias[opts.string[i2]] || [];
    for (j = arr.length; j-- > 0; )
      opts.string.push(arr[j]);
  }
  if (defaults) {
    for (k in opts.default) {
      name2 = typeof opts.default[k];
      arr = opts.alias[k] = opts.alias[k] || [];
      if (opts[name2] !== void 0) {
        opts[name2].push(k);
        for (i2 = 0; i2 < arr.length; i2++) {
          opts[name2].push(arr[i2]);
        }
      }
    }
  }
  const keys = strict ? Object.keys(opts.alias) : [];
  for (i2 = 0; i2 < len; i2++) {
    arg = args[i2];
    if (arg === "--") {
      out2._ = out2._.concat(args.slice(++i2));
      break;
    }
    for (j = 0; j < arg.length; j++) {
      if (arg.charCodeAt(j) !== 45)
        break;
    }
    if (j === 0) {
      out2._.push(arg);
    } else if (arg.substring(j, j + 3) === "no-") {
      name2 = arg.substring(j + 3);
      if (strict && !~keys.indexOf(name2)) {
        return opts.unknown(arg);
      }
      out2[name2] = false;
    } else {
      for (idx = j + 1; idx < arg.length; idx++) {
        if (arg.charCodeAt(idx) === 61)
          break;
      }
      name2 = arg.substring(j, idx);
      val = arg.substring(++idx) || (i2 + 1 === len || ("" + args[i2 + 1]).charCodeAt(0) === 45 || args[++i2]);
      arr = j === 2 ? [name2] : name2;
      for (idx = 0; idx < arr.length; idx++) {
        name2 = arr[idx];
        if (strict && !~keys.indexOf(name2))
          return opts.unknown("-".repeat(j) + name2);
        toVal(out2, name2, idx + 1 < arr.length || val, opts);
      }
    }
  }
  if (defaults) {
    for (k in opts.default) {
      if (out2[k] === void 0) {
        out2[k] = opts.default[k];
      }
    }
  }
  if (alibi) {
    for (k in out2) {
      arr = opts.alias[k] || [];
      while (arr.length > 0) {
        out2[arr.shift()] = out2[k];
      }
    }
  }
  return out2;
}
var removeBrackets = (v) => v.replace(/[<[].+/, "").trim();
var findAllBrackets = (v) => {
  const ANGLED_BRACKET_RE_GLOBAL = /<([^>]+)>/g;
  const SQUARE_BRACKET_RE_GLOBAL = /\[([^\]]+)\]/g;
  const res = [];
  const parse7 = (match) => {
    let variadic = false;
    let value2 = match[1];
    if (value2.startsWith("...")) {
      value2 = value2.slice(3);
      variadic = true;
    }
    return {
      required: match[0].startsWith("<"),
      value: value2,
      variadic
    };
  };
  let angledMatch;
  while (angledMatch = ANGLED_BRACKET_RE_GLOBAL.exec(v)) {
    res.push(parse7(angledMatch));
  }
  let squareMatch;
  while (squareMatch = SQUARE_BRACKET_RE_GLOBAL.exec(v)) {
    res.push(parse7(squareMatch));
  }
  return res;
};
var getMriOptions = (options3) => {
  const result = { alias: {}, boolean: [] };
  for (const [index2, option] of options3.entries()) {
    if (option.names.length > 1) {
      result.alias[option.names[0]] = option.names.slice(1);
    }
    if (option.isBoolean) {
      if (option.negated) {
        const hasStringTypeOption = options3.some((o3, i2) => {
          return i2 !== index2 && o3.names.some((name2) => option.names.includes(name2)) && typeof o3.required === "boolean";
        });
        if (!hasStringTypeOption) {
          result.boolean.push(option.names[0]);
        }
      } else {
        result.boolean.push(option.names[0]);
      }
    }
  }
  return result;
};
var findLongest = (arr) => {
  return arr.sort((a2, b) => {
    return a2.length > b.length ? -1 : 1;
  })[0];
};
var padRight = (str2, length) => {
  return str2.length >= length ? str2 : `${str2}${" ".repeat(length - str2.length)}`;
};
var camelcase = (input) => {
  return input.replace(/([a-z])-([a-z])/g, (_, p1, p2) => {
    return p1 + p2.toUpperCase();
  });
};
var setDotProp = (obj, keys, val) => {
  let i2 = 0;
  let length = keys.length;
  let t3 = obj;
  let x;
  for (; i2 < length; ++i2) {
    x = t3[keys[i2]];
    t3 = t3[keys[i2]] = i2 === length - 1 ? val : x != null ? x : !!~keys[i2 + 1].indexOf(".") || !(+keys[i2 + 1] > -1) ? {} : [];
  }
};
var setByType = (obj, transforms) => {
  for (const key of Object.keys(transforms)) {
    const transform2 = transforms[key];
    if (transform2.shouldTransform) {
      obj[key] = Array.prototype.concat.call([], obj[key]);
      if (typeof transform2.transformFunction === "function") {
        obj[key] = obj[key].map(transform2.transformFunction);
      }
    }
  }
};
var getFileName = (input) => {
  const m = /([^\\\/]+)$/.exec(input);
  return m ? m[1] : "";
};
var camelcaseOptionName = (name2) => {
  return name2.split(".").map((v, i2) => {
    return i2 === 0 ? camelcase(v) : v;
  }).join(".");
};
var CACError = class extends Error {
  constructor(message) {
    super(message);
    this.name = this.constructor.name;
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error(message).stack;
    }
  }
};
var Option = class {
  constructor(rawName, description2, config2) {
    this.rawName = rawName;
    this.description = description2;
    this.config = Object.assign({}, config2);
    rawName = rawName.replace(/\.\*/g, "");
    this.negated = false;
    this.names = removeBrackets(rawName).split(",").map((v) => {
      let name2 = v.trim().replace(/^-{1,2}/, "");
      if (name2.startsWith("no-")) {
        this.negated = true;
        name2 = name2.replace(/^no-/, "");
      }
      return camelcaseOptionName(name2);
    }).sort((a2, b) => a2.length > b.length ? 1 : -1);
    this.name = this.names[this.names.length - 1];
    if (this.negated && this.config.default == null) {
      this.config.default = true;
    }
    if (rawName.includes("<")) {
      this.required = true;
    } else if (rawName.includes("[")) {
      this.required = false;
    } else {
      this.isBoolean = true;
    }
  }
};
var processArgs = process.argv;
var platformInfo = `${process.platform}-${process.arch} node-${process.version}`;
var Command = class {
  constructor(rawName, description2, config2 = {}, cli2) {
    this.rawName = rawName;
    this.description = description2;
    this.config = config2;
    this.cli = cli2;
    this.options = [];
    this.aliasNames = [];
    this.name = removeBrackets(rawName);
    this.args = findAllBrackets(rawName);
    this.examples = [];
  }
  usage(text) {
    this.usageText = text;
    return this;
  }
  allowUnknownOptions() {
    this.config.allowUnknownOptions = true;
    return this;
  }
  ignoreOptionDefaultValue() {
    this.config.ignoreOptionDefaultValue = true;
    return this;
  }
  version(version4, customFlags = "-v, --version") {
    this.versionNumber = version4;
    this.option(customFlags, "Display version number");
    return this;
  }
  example(example2) {
    this.examples.push(example2);
    return this;
  }
  option(rawName, description2, config2) {
    const option = new Option(rawName, description2, config2);
    this.options.push(option);
    return this;
  }
  alias(name2) {
    this.aliasNames.push(name2);
    return this;
  }
  action(callback) {
    this.commandAction = callback;
    return this;
  }
  isMatched(name2) {
    return this.name === name2 || this.aliasNames.includes(name2);
  }
  get isDefaultCommand() {
    return this.name === "" || this.aliasNames.includes("!");
  }
  get isGlobalCommand() {
    return this instanceof GlobalCommand;
  }
  hasOption(name2) {
    name2 = name2.split(".")[0];
    return this.options.find((option) => {
      return option.names.includes(name2);
    });
  }
  outputHelp() {
    const { name: name2, commands } = this.cli;
    const {
      versionNumber,
      options: globalOptions,
      helpCallback
    } = this.cli.globalCommand;
    let sections = [
      {
        body: `${name2}${versionNumber ? `/${versionNumber}` : ""}`
      }
    ];
    sections.push({
      title: "Usage",
      body: `  $ ${name2} ${this.usageText || this.rawName}`
    });
    const showCommands = (this.isGlobalCommand || this.isDefaultCommand) && commands.length > 0;
    if (showCommands) {
      const longestCommandName = findLongest(commands.map((command) => command.rawName));
      sections.push({
        title: "Commands",
        body: commands.map((command) => {
          return `  ${padRight(command.rawName, longestCommandName.length)}  ${command.description}`;
        }).join("\n")
      });
      sections.push({
        title: `For more info, run any command with the \`--help\` flag`,
        body: commands.map((command) => `  $ ${name2}${command.name === "" ? "" : ` ${command.name}`} --help`).join("\n")
      });
    }
    let options3 = this.isGlobalCommand ? globalOptions : [...this.options, ...globalOptions || []];
    if (!this.isGlobalCommand && !this.isDefaultCommand) {
      options3 = options3.filter((option) => option.name !== "version");
    }
    if (options3.length > 0) {
      const longestOptionName = findLongest(options3.map((option) => option.rawName));
      sections.push({
        title: "Options",
        body: options3.map((option) => {
          return `  ${padRight(option.rawName, longestOptionName.length)}  ${option.description} ${option.config.default === void 0 ? "" : `(default: ${option.config.default})`}`;
        }).join("\n")
      });
    }
    if (this.examples.length > 0) {
      sections.push({
        title: "Examples",
        body: this.examples.map((example2) => {
          if (typeof example2 === "function") {
            return example2(name2);
          }
          return example2;
        }).join("\n")
      });
    }
    if (helpCallback) {
      sections = helpCallback(sections) || sections;
    }
    console.log(sections.map((section) => {
      return section.title ? `${section.title}:
${section.body}` : section.body;
    }).join("\n\n"));
  }
  outputVersion() {
    const { name: name2 } = this.cli;
    const { versionNumber } = this.cli.globalCommand;
    if (versionNumber) {
      console.log(`${name2}/${versionNumber} ${platformInfo}`);
    }
  }
  checkRequiredArgs() {
    const minimalArgsCount = this.args.filter((arg) => arg.required).length;
    if (this.cli.args.length < minimalArgsCount) {
      throw new CACError(`missing required args for command \`${this.rawName}\``);
    }
  }
  checkUnknownOptions() {
    const { options: options3, globalCommand } = this.cli;
    if (!this.config.allowUnknownOptions) {
      for (const name2 of Object.keys(options3)) {
        if (name2 !== "--" && !this.hasOption(name2) && !globalCommand.hasOption(name2)) {
          throw new CACError(`Unknown option \`${name2.length > 1 ? `--${name2}` : `-${name2}`}\``);
        }
      }
    }
  }
  checkOptionValue() {
    const { options: parsedOptions, globalCommand } = this.cli;
    const options3 = [...globalCommand.options, ...this.options];
    for (const option of options3) {
      const value2 = parsedOptions[option.name.split(".")[0]];
      if (option.required) {
        const hasNegated = options3.some((o3) => o3.negated && o3.names.includes(option.name));
        if (value2 === true || value2 === false && !hasNegated) {
          throw new CACError(`option \`${option.rawName}\` value is missing`);
        }
      }
    }
  }
};
var GlobalCommand = class extends Command {
  constructor(cli2) {
    super("@@global@@", "", {}, cli2);
  }
};
var __assign = Object.assign;
var CAC = class extends import_events3.EventEmitter {
  constructor(name2 = "") {
    super();
    this.name = name2;
    this.commands = [];
    this.rawArgs = [];
    this.args = [];
    this.options = {};
    this.globalCommand = new GlobalCommand(this);
    this.globalCommand.usage("<command> [options]");
  }
  usage(text) {
    this.globalCommand.usage(text);
    return this;
  }
  command(rawName, description2, config2) {
    const command = new Command(rawName, description2 || "", config2, this);
    command.globalCommand = this.globalCommand;
    this.commands.push(command);
    return command;
  }
  option(rawName, description2, config2) {
    this.globalCommand.option(rawName, description2, config2);
    return this;
  }
  help(callback) {
    this.globalCommand.option("-h, --help", "Display this message");
    this.globalCommand.helpCallback = callback;
    this.showHelpOnExit = true;
    return this;
  }
  version(version4, customFlags = "-v, --version") {
    this.globalCommand.version(version4, customFlags);
    this.showVersionOnExit = true;
    return this;
  }
  example(example2) {
    this.globalCommand.example(example2);
    return this;
  }
  outputHelp() {
    if (this.matchedCommand) {
      this.matchedCommand.outputHelp();
    } else {
      this.globalCommand.outputHelp();
    }
  }
  outputVersion() {
    this.globalCommand.outputVersion();
  }
  setParsedInfo({ args, options: options3 }, matchedCommand, matchedCommandName) {
    this.args = args;
    this.options = options3;
    if (matchedCommand) {
      this.matchedCommand = matchedCommand;
    }
    if (matchedCommandName) {
      this.matchedCommandName = matchedCommandName;
    }
    return this;
  }
  unsetMatchedCommand() {
    this.matchedCommand = void 0;
    this.matchedCommandName = void 0;
  }
  parse(argv = processArgs, {
    run = true
  } = {}) {
    this.rawArgs = argv;
    if (!this.name) {
      this.name = argv[1] ? getFileName(argv[1]) : "cli";
    }
    let shouldParse = true;
    for (const command of this.commands) {
      const parsed = this.mri(argv.slice(2), command);
      const commandName = parsed.args[0];
      if (command.isMatched(commandName)) {
        shouldParse = false;
        const parsedInfo = __assign(__assign({}, parsed), {
          args: parsed.args.slice(1)
        });
        this.setParsedInfo(parsedInfo, command, commandName);
        this.emit(`command:${commandName}`, command);
      }
    }
    if (shouldParse) {
      for (const command of this.commands) {
        if (command.name === "") {
          shouldParse = false;
          const parsed = this.mri(argv.slice(2), command);
          this.setParsedInfo(parsed, command);
          this.emit(`command:!`, command);
        }
      }
    }
    if (shouldParse) {
      const parsed = this.mri(argv.slice(2));
      this.setParsedInfo(parsed);
    }
    if (this.options.help && this.showHelpOnExit) {
      this.outputHelp();
      run = false;
      this.unsetMatchedCommand();
    }
    if (this.options.version && this.showVersionOnExit && this.matchedCommandName == null) {
      this.outputVersion();
      run = false;
      this.unsetMatchedCommand();
    }
    const parsedArgv = { args: this.args, options: this.options };
    if (run) {
      this.runMatchedCommand();
    }
    if (!this.matchedCommand && this.args[0]) {
      this.emit("command:*");
    }
    return parsedArgv;
  }
  mri(argv, command) {
    const cliOptions = [
      ...this.globalCommand.options,
      ...command ? command.options : []
    ];
    const mriOptions = getMriOptions(cliOptions);
    let argsAfterDoubleDashes = [];
    const doubleDashesIndex = argv.indexOf("--");
    if (doubleDashesIndex > -1) {
      argsAfterDoubleDashes = argv.slice(doubleDashesIndex + 1);
      argv = argv.slice(0, doubleDashesIndex);
    }
    let parsed = mri2(argv, mriOptions);
    parsed = Object.keys(parsed).reduce((res, name2) => {
      return __assign(__assign({}, res), {
        [camelcaseOptionName(name2)]: parsed[name2]
      });
    }, { _: [] });
    const args = parsed._;
    const options3 = {
      "--": argsAfterDoubleDashes
    };
    const ignoreDefault = command && command.config.ignoreOptionDefaultValue ? command.config.ignoreOptionDefaultValue : this.globalCommand.config.ignoreOptionDefaultValue;
    let transforms = /* @__PURE__ */ Object.create(null);
    for (const cliOption of cliOptions) {
      if (!ignoreDefault && cliOption.config.default !== void 0) {
        for (const name2 of cliOption.names) {
          options3[name2] = cliOption.config.default;
        }
      }
      if (Array.isArray(cliOption.config.type)) {
        if (transforms[cliOption.name] === void 0) {
          transforms[cliOption.name] = /* @__PURE__ */ Object.create(null);
          transforms[cliOption.name]["shouldTransform"] = true;
          transforms[cliOption.name]["transformFunction"] = cliOption.config.type[0];
        }
      }
    }
    for (const key of Object.keys(parsed)) {
      if (key !== "_") {
        const keys = key.split(".");
        setDotProp(options3, keys, parsed[key]);
        setByType(options3, transforms);
      }
    }
    return {
      args,
      options: options3
    };
  }
  runMatchedCommand() {
    const { args, options: options3, matchedCommand: command } = this;
    if (!command || !command.commandAction)
      return;
    command.checkUnknownOptions();
    command.checkOptionValue();
    command.checkRequiredArgs();
    const actionArgs = [];
    command.args.forEach((arg, index2) => {
      if (arg.variadic) {
        actionArgs.push(args.slice(index2));
      } else {
        actionArgs.push(args[index2]);
      }
    });
    actionArgs.push(options3);
    return command.commandAction.apply(this, actionArgs);
  }
};
var cac = (name2 = "") => new CAC(name2);

// node_modules/.pnpm/@vuepress+cli@2.0.0-beta.61/node_modules/@vuepress/cli/dist/index.js
var defineUserConfig = (config2) => config2;
var loadUserConfig = async (userConfigPath) => {
  var _a;
  if (!userConfigPath) {
    return {
      userConfig: {},
      userConfigDependencies: []
    };
  }
  const dirnameVarName = "__vite_injected_original_dirname";
  const filenameVarName = "__vite_injected_original_filename";
  const importMetaUrlVarName = "__vite_injected_original_import_meta_url";
  const result = await (0, import_esbuild3.build)({
    absWorkingDir: process.cwd(),
    entryPoints: [userConfigPath],
    outfile: "out.js",
    write: false,
    target: ["node14.18", "node16"],
    platform: "node",
    bundle: true,
    format: "esm",
    sourcemap: "inline",
    metafile: true,
    define: {
      "__dirname": dirnameVarName,
      "__filename": filenameVarName,
      "import.meta.url": importMetaUrlVarName
    },
    plugins: [
      {
        name: "externalize-deps",
        setup(build22) {
          build22.onResolve({ filter: /.*/ }, ({ path: id }) => {
            if (id[0] !== "." && !import_upath.default.isAbsolute(id)) {
              return {
                external: true
              };
            }
            return null;
          });
        }
      },
      {
        name: "inject-file-scope-variables",
        setup(build22) {
          build22.onLoad({ filter: /\.[cm]?[jt]s$/ }, async (args) => {
            const contents = await import_fs_extra.default.readFile(args.path, "utf8");
            const injectValues = `const ${dirnameVarName} = ${JSON.stringify(
              import_upath.default.dirname(args.path)
            )};const ${filenameVarName} = ${JSON.stringify(args.path)};const ${importMetaUrlVarName} = ${JSON.stringify(
              (0, import_url5.pathToFileURL)(args.path).href
            )};`;
            return {
              loader: args.path.endsWith("ts") ? "ts" : "js",
              contents: injectValues + contents
            };
          });
        }
      }
    ]
  });
  const { text } = result.outputFiles[0];
  const tempFilePath = `${userConfigPath}.${(0, import_hash_sum.default)(text)}.mjs`;
  let userConfig;
  try {
    await import_fs_extra.default.writeFile(tempFilePath, text);
    userConfig = await importFileDefault(tempFilePath);
  } finally {
    await import_fs_extra.default.rm(tempFilePath);
  }
  return {
    userConfig,
    userConfigDependencies: Object.keys(((_a = result.metafile) == null ? void 0 : _a.inputs) ?? {})
  };
};
var resolveAppConfig = ({
  defaultAppConfig,
  cliAppConfig,
  userConfig
}) => {
  const appConfig = {
    // allow setting default app config via `cli()`
    // for example, set different default bundler in `vuepress` and `vuepress-vite` package
    ...defaultAppConfig,
    // use cli options to override config file
    ...userConfig,
    ...cliAppConfig
  };
  if (appConfig.bundler === void 0 || appConfig.theme === void 0) {
    logger.error(
      `${import_picocolors.default.magenta("bundler")} and ${import_picocolors.default.magenta("theme")} are required`
    );
    return null;
  }
  if (appConfig.base && !(appConfig.base.startsWith("/") && appConfig.base.endsWith("/"))) {
    const rawBase = appConfig.base;
    appConfig.base = ensureLeadingSlash(ensureEndingSlash(rawBase));
    logger.warn(
      `${import_picocolors.default.magenta("base")} should start and end with a slash (/), so it has been normalized from ${import_picocolors.default.magenta(rawBase)} to ${import_picocolors.default.magenta(appConfig.base)}`
    );
  }
  if (appConfig.dest && isChildPath(appConfig.source, appConfig.dest)) {
    logger.warn(
      `${import_picocolors.default.magenta("dest")} directory would be emptied during build, so we fallback it to the default directory for the safety of your source files`
    );
    delete appConfig.dest;
  }
  return appConfig;
};
var OPTIONS_COMMON = ["debug", "open", "port", "host"];
var OPTIONS_DIRECTORY = ["cache", "dest", "temp"];
var resolveCliAppConfig = (sourceDir, commandOptions, cwd = import_process3.default.cwd()) => {
  const source = import_upath.default.resolve(cwd, sourceDir);
  const appConfig = {
    source
  };
  OPTIONS_COMMON.forEach((name2) => {
    if (commandOptions[name2] !== void 0) {
      appConfig[name2] = commandOptions[name2];
    }
  });
  OPTIONS_DIRECTORY.forEach((name2) => {
    if (commandOptions[name2] !== void 0) {
      appConfig[name2] = import_upath.default.resolve(cwd, commandOptions[name2]);
    }
  });
  return appConfig;
};
var resolveUserConfigConventionalPath = (source, cwd = import_process4.default.cwd()) => [
  import_upath.default.resolve(cwd, "vuepress.config.ts"),
  import_upath.default.resolve(cwd, "vuepress.config.js"),
  import_upath.default.resolve(cwd, "vuepress.config.mjs"),
  import_upath.default.resolve(source, ".vuepress/config.ts"),
  import_upath.default.resolve(source, ".vuepress/config.js"),
  import_upath.default.resolve(source, ".vuepress/config.mjs")
].find((item) => import_fs_extra.default.pathExistsSync(item));
var resolveUserConfigPath = (config2, cwd = import_process5.default.cwd()) => {
  const configPath = import_upath.default.resolve(cwd, config2);
  if (!import_fs_extra.default.pathExistsSync(configPath)) {
    throw logger.createError(
      `config file does not exist: ${import_picocolors.default.magenta(config2)}`
    );
  }
  return configPath;
};
var transformUserConfigToPlugin = (userConfig, source, cwd = import_process6.default.cwd()) => {
  const userConfigPlugin2 = {
    name: "user-config",
    ...userConfig
  };
  if (userConfigPlugin2.clientConfigFile === void 0) {
    userConfigPlugin2.clientConfigFile = [
      import_upath.default.resolve(cwd, "vuepress.client.ts"),
      import_upath.default.resolve(cwd, "vuepress.client.js"),
      import_upath.default.resolve(cwd, "vuepress.client.mjs"),
      import_upath.default.resolve(source, ".vuepress/client.ts"),
      import_upath.default.resolve(source, ".vuepress/client.js"),
      import_upath.default.resolve(source, ".vuepress/client.mjs")
    ].find((item) => import_fs_extra.default.pathExistsSync(item));
  }
  return userConfigPlugin2;
};
var log7 = (0, import_debug.default)("vuepress:cli/build");
var createBuild = (defaultAppConfig) => async (sourceDir = ".", commandOptions = {}) => {
  const start = Date.now();
  log7(`commandOptions:`, commandOptions);
  if (import_process2.default.env.NODE_ENV === void 0) {
    import_process2.default.env.NODE_ENV = "production";
  }
  const cliAppConfig = resolveCliAppConfig(sourceDir, commandOptions);
  const userConfigPath = commandOptions.config ? resolveUserConfigPath(commandOptions.config) : resolveUserConfigConventionalPath(cliAppConfig.source);
  log7(`userConfigPath:`, userConfigPath);
  const { userConfig } = await loadUserConfig(userConfigPath);
  const appConfig = resolveAppConfig({
    defaultAppConfig,
    cliAppConfig,
    userConfig
  });
  if (appConfig === null) {
    return;
  }
  const app = createBuildApp(appConfig);
  app.use(transformUserConfigToPlugin(userConfig, cliAppConfig.source));
  if (commandOptions.cleanTemp === true) {
    await withSpinner("Cleaning temp")(() => {
      return import_fs_extra.default.remove(app.dir.temp());
    });
  }
  if (commandOptions.cleanCache === true) {
    await withSpinner("Cleaning cache")(() => {
      return import_fs_extra.default.remove(app.dir.cache());
    });
  }
  await import_fs_extra.default.emptyDir(app.dir.dest());
  await withSpinner("Initializing and preparing data")(async () => {
    await app.init();
    await app.prepare();
  });
  await app.build();
  await app.pluginApi.hooks.onGenerated.process(app);
  logger.success(
    `VuePress build completed in ${formatMs(Date.now() - start)}!`
  );
};
var handlePageAdd = async (app, filePath) => {
  const pageIndex = app.pages.findIndex((page2) => page2.filePath === filePath);
  if (pageIndex !== -1) {
    return null;
  }
  const page = await createPage(app, {
    filePath
  });
  app.pages.push(page);
  await preparePageComponent(app, page);
  await preparePageData(app, page);
  await preparePagesComponents(app);
  await preparePagesData(app);
  await preparePagesRoutes(app);
  return page;
};
var handlePageChange = async (app, filePath) => {
  const pageIndex = app.pages.findIndex((page) => page.filePath === filePath);
  if (pageIndex === -1) {
    return null;
  }
  const pageOld = app.pages[pageIndex];
  const pageNew = await createPage(app, {
    filePath
  });
  app.pages.splice(pageIndex, 1, pageNew);
  await preparePageComponent(app, pageNew);
  await preparePageData(app, pageNew);
  const isPathChanged = pageOld.path !== pageNew.path;
  const isRouteMetaChanged = JSON.stringify(pageOld.routeMeta) !== JSON.stringify(pageNew.routeMeta);
  if (isPathChanged) {
    await preparePagesComponents(app);
    await preparePagesData(app);
  }
  if (isPathChanged || isRouteMetaChanged) {
    await preparePagesRoutes(app);
  }
  return [pageOld, pageNew];
};
var handlePageUnlink = async (app, filePath) => {
  const pageIndex = app.pages.findIndex((page2) => page2.filePath === filePath);
  if (pageIndex === -1) {
    return null;
  }
  const page = app.pages[pageIndex];
  app.pages.splice(pageIndex, 1);
  await preparePagesComponents(app);
  await preparePagesData(app);
  await preparePagesRoutes(app);
  return page;
};
var createPageDepsHelper = () => {
  const store = /* @__PURE__ */ new Map();
  return {
    add: ({ deps, filePathRelative }) => {
      const depsAdded = [];
      if (filePathRelative) {
        deps.forEach((item) => {
          var _a;
          if (!store.has(item)) {
            store.set(item, /* @__PURE__ */ new Set());
            depsAdded.push(item);
          }
          (_a = store.get(item)) == null ? void 0 : _a.add(filePathRelative);
        });
      }
      return depsAdded;
    },
    remove: ({ deps, filePathRelative }) => {
      const depsRemoved = [];
      if (filePathRelative) {
        deps.forEach((item) => {
          const pagePathsSet = store.get(item);
          pagePathsSet == null ? void 0 : pagePathsSet.delete(filePathRelative);
          if ((pagePathsSet == null ? void 0 : pagePathsSet.size) === 0) {
            store.delete(item);
            depsRemoved.push(item);
          }
        });
      }
      return depsRemoved;
    },
    get: (dep) => {
      const pagePathsSet = store.get(dep);
      return pagePathsSet ? [...pagePathsSet] : [];
    }
  };
};
var watchPageFiles = (app) => {
  const depsWatcher = import_chokidar.default.watch([], {
    disableGlobbing: true,
    ignoreInitial: true
  });
  const depsHelper = createPageDepsHelper();
  const addDeps = (page) => {
    const depsToAdd = depsHelper.add(page);
    depsWatcher.add(depsToAdd);
  };
  const removeDeps = (page) => {
    const depsToRemove = depsHelper.remove(page);
    depsWatcher.unwatch(depsToRemove);
  };
  const depsListener = async (dep) => {
    const pagePaths = depsHelper.get(dep);
    if (!pagePaths)
      return;
    for (const filePathRelative of pagePaths) {
      logger.info(
        `dependency of page ${import_picocolors.default.magenta(filePathRelative)} is modified`
      );
      await handlePageChange(app, app.dir.source(filePathRelative));
    }
  };
  depsWatcher.on("add", depsListener);
  depsWatcher.on("change", depsListener);
  depsWatcher.on("unlink", depsListener);
  app.pages.forEach((page) => addDeps(page));
  const pagesWatcher = import_chokidar.default.watch(app.options.pagePatterns, {
    cwd: app.dir.source(),
    ignoreInitial: true
  });
  pagesWatcher.on("add", async (filePathRelative) => {
    logger.info(`page ${import_picocolors.default.magenta(filePathRelative)} is created`);
    const page = await handlePageAdd(app, app.dir.source(filePathRelative));
    if (page === null)
      return;
    addDeps(page);
  });
  pagesWatcher.on("change", async (filePathRelative) => {
    logger.info(`page ${import_picocolors.default.magenta(filePathRelative)} is modified`);
    const result = await handlePageChange(app, app.dir.source(filePathRelative));
    if (result === null)
      return;
    const [pageOld, pageNew] = result;
    removeDeps(pageOld);
    addDeps(pageNew);
  });
  pagesWatcher.on("unlink", async (filePathRelative) => {
    logger.info(`page ${import_picocolors.default.magenta(filePathRelative)} is removed`);
    const page = await handlePageUnlink(app, app.dir.source(filePathRelative));
    if (page === null)
      return;
    removeDeps(page);
  });
  return [pagesWatcher, depsWatcher];
};
var watchUserConfigFile = ({
  userConfigPath,
  userConfigDependencies,
  restart
}) => {
  const cwd = import_process8.default.cwd();
  const configWatcher = import_chokidar2.default.watch(userConfigPath, {
    cwd,
    ignoreInitial: true
  });
  configWatcher.on("change", (configFile2) => {
    logger.info(`config ${import_picocolors.default.magenta(configFile2)} is modified`);
    restart();
  });
  const depsWatcher = import_chokidar2.default.watch(userConfigDependencies, {
    cwd,
    ignoreInitial: true
  });
  depsWatcher.on("change", (depFile) => {
    logger.info(`config dependency ${import_picocolors.default.magenta(depFile)} is modified`);
    restart();
  });
  return [configWatcher, depsWatcher];
};
var log23 = (0, import_debug.default)("vuepress:cli/dev");
var createDev = (defaultAppConfig) => {
  const dev2 = async (sourceDir = ".", commandOptions = {}) => {
    log23(`commandOptions:`, commandOptions);
    if (import_process7.default.env.NODE_ENV === void 0) {
      import_process7.default.env.NODE_ENV = "development";
    }
    const cliAppConfig = resolveCliAppConfig(sourceDir, commandOptions);
    const userConfigPath = commandOptions.config ? resolveUserConfigPath(commandOptions.config) : resolveUserConfigConventionalPath(cliAppConfig.source);
    log23(`userConfigPath:`, userConfigPath);
    const { userConfig, userConfigDependencies } = await loadUserConfig(
      userConfigPath
    );
    const appConfig = resolveAppConfig({
      defaultAppConfig,
      cliAppConfig,
      userConfig
    });
    if (appConfig === null) {
      return;
    }
    const app = createDevApp(appConfig);
    app.use(transformUserConfigToPlugin(userConfig, cliAppConfig.source));
    if (commandOptions.cleanTemp === true) {
      await withSpinner("Cleaning temp")(() => {
        return import_fs_extra.default.remove(app.dir.temp());
      });
    }
    if (commandOptions.cleanCache === true) {
      await withSpinner("Cleaning cache")(() => {
        return import_fs_extra.default.remove(app.dir.cache());
      });
    }
    await withSpinner("Initializing and preparing data")(async () => {
      await app.init();
      await app.prepare();
    });
    const close2 = await app.dev();
    if (commandOptions.watch === false) {
      return;
    }
    const watchers = [];
    const restart = async () => {
      await Promise.all([
        // close all watchers
        ...watchers.map((item) => item.close()),
        // close current dev server
        close2()
      ]);
      await dev2(sourceDir, {
        ...commandOptions,
        // do not clean cache and temp on restart
        cleanCache: false,
        cleanTemp: false
      });
      logger.tip(`dev server has restarted, please refresh your browser`);
    };
    watchers.push(...watchPageFiles(app));
    if (userConfigPath) {
      watchers.push(
        ...watchUserConfigFile({
          userConfigPath,
          userConfigDependencies,
          restart
        })
      );
    }
    await app.pluginApi.hooks.onWatched.process(app, watchers, restart);
  };
  return dev2;
};
var info2 = async () => {
  const spinner = ora();
  spinner.start("Collecting Environment Info");
  const result = await import_envinfo.default.run(
    {
      System: ["OS", "CPU", "Memory", "Shell"],
      Binaries: ["Node", "Yarn", "npm"],
      Utilities: ["Git"],
      Browsers: ["Chrome", "Edge", "Firefox", "Safari"],
      npmPackages: [
        "@vuepress/bundler-vite",
        "@vuepress/bundler-webpack",
        "@vuepress/cli",
        "@vuepress/client",
        "@vuepress/core",
        "@vuepress/markdown",
        "@vuepress/plugin-active-header-links",
        "@vuepress/plugin-back-to-top",
        "@vuepress/plugin-container",
        "@vuepress/plugin-docsearch",
        "@vuepress/plugin-external-link-icon",
        "@vuepress/plugin-git",
        "@vuepress/plugin-google-analytics",
        "@vuepress/plugin-medium-zoom",
        "@vuepress/plugin-nprogress",
        "@vuepress/plugin-palette",
        "@vuepress/plugin-prismjs",
        "@vuepress/plugin-pwa",
        "@vuepress/plugin-pwa-popup",
        "@vuepress/plugin-register-components",
        "@vuepress/plugin-search",
        "@vuepress/plugin-shiki",
        "@vuepress/plugin-theme-data",
        "@vuepress/plugin-toc",
        "@vuepress/shared",
        "@vuepress/theme-default",
        "@vuepress/utils",
        "vuepress",
        "vuepress-vite",
        "vuepress-webpack",
        "vue",
        "vue-router",
        "vue-loader"
      ]
    },
    {
      showNotFound: true,
      duplicates: true,
      fullTree: true
    }
  );
  spinner.stop();
  console.info(result);
};
var require24 = (0, import_module7.createRequire)(import.meta.url);
var cli = (defaultAppConfig = {}) => {
  const program = cac("vuepress");
  const versionCli = require24("../package.json").version;
  const versionCore = require24("@vuepress/core/package.json").version;
  program.version(`core@${versionCore} vuepress/cli@${versionCli}`);
  program.help();
  program.command("dev [sourceDir]", "Start development server").option("-c, --config <config>", "Set path to config file").option("-p, --port <port>", "Use specified port (default: 8080)").option("-t, --temp <temp>", "Set the directory of the temporary files").option("--host <host>", "Use specified host (default: 0.0.0.0)").option("--cache <cache>", "Set the directory of the cache files").option("--clean-temp", "Clean the temporary files before dev").option("--clean-cache", "Clean the cache files before dev").option("--open", "Open browser when ready").option("--debug", "Enable debug mode").option("--no-watch", "Disable watching page and config files").action(createDev(defaultAppConfig));
  program.command("build [sourceDir]", "Build to static site").option("-c, --config <config>", "Set path to config file").option(
    "-d, --dest <dest>",
    "Set the directory build output (default: .vuepress/dist)"
  ).option("-t, --temp <temp>", "Set the directory of the temporary files").option("--cache <cache>", "Set the directory of the cache files").option("--clean-temp", "Clean the temporary files before build").option("--clean-cache", "Clean the cache files before build").option("--debug", "Enable debug mode").action(createBuild(defaultAppConfig));
  program.command("info", "Display environment information").action(info2);
  program.parse(import_process9.default.argv, { run: false });
  if (program.matchedCommand) {
    program.runMatchedCommand().catch((err2) => {
      console.error(import_picocolors.default.red(err2.stack));
      import_process9.default.exit(1);
    });
  } else {
    program.outputHelp();
  }
};

// node_modules/.pnpm/vuepress-vite@2.0.0-beta.61_@vuepress+client@2.0.0-beta.61_vue@3.2.47/node_modules/vuepress-vite/lib/index.js
__reExport(lib_exports, theme_default_star);
import * as theme_default_star from "@vuepress/theme-default";

// node_modules/.pnpm/vuepress@2.0.0-beta.61_@vuepress+client@2.0.0-beta.61_vue@3.2.47/node_modules/vuepress/lib/index.js
__reExport(lib_exports2, lib_exports);
export {
  appInit,
  appPrepare,
  appUse,
  cli,
  createAppDirFunction,
  createBaseApp,
  createBuild,
  createBuildApp,
  createDev,
  createDevApp,
  createHookQueue,
  createPage,
  createPluginApi,
  createPluginApiHooks,
  createPluginApiRegisterHooks,
  defineUserConfig,
  handlePageAdd,
  handlePageChange,
  handlePageUnlink,
  inferPagePath,
  info2 as info,
  loadUserConfig,
  normalizeAliasDefineHook,
  normalizeClientConfigFileHook,
  prepareClientConfigs,
  preparePageComponent,
  preparePageData,
  preparePagesComponents,
  preparePagesData,
  preparePagesRoutes,
  prepareSiteData,
  renderPageContent,
  resolveAppConfig,
  resolveAppDir,
  resolveAppEnv,
  resolveAppOptions,
  resolveAppPages,
  resolveAppSiteData,
  resolveAppVersion,
  resolveAppWriteTemp,
  resolveCliAppConfig,
  resolvePageComponentInfo,
  resolvePageDataInfo,
  resolvePageDate,
  resolvePageFileContent,
  resolvePageFilePath,
  resolvePageHtmlInfo,
  resolvePageKey,
  resolvePageLang,
  resolvePagePath,
  resolvePagePermalink,
  resolvePageRouteMeta,
  resolvePageSlug,
  resolvePluginObject,
  resolveThemeInfo,
  resolveUserConfigConventionalPath,
  resolveUserConfigPath,
  transformUserConfigToPlugin,
  viteBundler,
  watchPageFiles,
  watchUserConfigFile
};
/*! Bundled license information:

is-extglob/index.js:
  (*!
   * is-extglob <https://github.com/jonschlinkert/is-extglob>
   *
   * Copyright (c) 2014-2016, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

is-glob/index.js:
  (*!
   * is-glob <https://github.com/jonschlinkert/is-glob>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

is-number/index.js:
  (*!
   * is-number <https://github.com/jonschlinkert/is-number>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

to-regex-range/index.js:
  (*!
   * to-regex-range <https://github.com/micromatch/to-regex-range>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

fill-range/index.js:
  (*!
   * fill-range <https://github.com/jonschlinkert/fill-range>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

queue-microtask/index.js:
  (*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

run-parallel/index.js:
  (*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

fraction.js/fraction.js:
  (**
   * @license Fraction.js v4.2.0 05/03/2022
   * https://www.xarg.org/2014/03/rational-numbers-in-javascript/
   *
   * Copyright (c) 2021, Robert Eisele (robert@xarg.org)
   * Dual licensed under the MIT or GPL Version 2 licenses.
   **)

postcss-load-config/src/index.js:
  (**
   * Autoload Config for PostCSS
   *
   * @author Michael Ciniawsky @michael-ciniawsky <michael.ciniawsky@gmail.com>
   * @license MIT
   *
   * @module postcss-load-config
   * @version 2.1.0
   *
   * @requires comsiconfig
   * @requires ./options
   * @requires ./plugins
   *)

is-extendable/index.js:
  (*!
   * is-extendable <https://github.com/jonschlinkert/is-extendable>
   *
   * Copyright (c) 2015, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

strip-bom-string/index.js:
  (*!
   * strip-bom-string <https://github.com/jonschlinkert/strip-bom-string>
   *
   * Copyright (c) 2015, 2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

normalize-path/index.js:
  (*!
   * normalize-path <https://github.com/jonschlinkert/normalize-path>
   *
   * Copyright (c) 2014-2018, Jon Schlinkert.
   * Released under the MIT License.
   *)

vite/dist/node/chunks/dep-ca21228b.js:
  (*!
   * is-extglob <https://github.com/jonschlinkert/is-extglob>
   *
   * Copyright (c) 2014-2016, Jon Schlinkert.
   * Licensed under the MIT License.
   *)
  (*!
   * is-glob <https://github.com/jonschlinkert/is-glob>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)
  (*!
   * is-number <https://github.com/jonschlinkert/is-number>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   *)
  (*!
   * to-regex-range <https://github.com/micromatch/to-regex-range>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   *)
  (*!
   * fill-range <https://github.com/jonschlinkert/fill-range>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Licensed under the MIT License.
   *)
  (*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (**
   * Autoload Config for PostCSS
   *
   * @author Michael Ciniawsky @michael-ciniawsky <michael.ciniawsky@gmail.com>
   * @license MIT
   *
   * @module postcss-load-config
   * @version 2.1.0
   *
   * @requires comsiconfig
   * @requires ./options
   * @requires ./plugins
   *)
  (*!
   * etag
   * Copyright(c) 2014-2016 Douglas Christopher Wilson
   * MIT Licensed
   *)
  (*!
   * encodeurl
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   *)
  (*!
   * escape-html
   * Copyright(c) 2012-2013 TJ Holowaychuk
   * Copyright(c) 2015 Andreas Lubbe
   * Copyright(c) 2015 Tiancheng "Timothy" Gu
   * MIT Licensed
   *)
  (*!
   * ee-first
   * Copyright(c) 2014 Jonathan Ong
   * MIT Licensed
   *)
  (*!
   * on-finished
   * Copyright(c) 2013 Jonathan Ong
   * Copyright(c) 2014 Douglas Christopher Wilson
   * MIT Licensed
   *)
  (*!
   * parseurl
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   *)
  (*!
   * statuses
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   *)
  (*!
   * unpipe
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)
  (*!
   * finalhandler
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   *)
  (*!
   * connect
   * Copyright(c) 2010 Sencha Inc.
   * Copyright(c) 2011 TJ Holowaychuk
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)
  (*!
   * vary
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   *)
  (*!
   * normalize-path <https://github.com/jonschlinkert/normalize-path>
   *
   * Copyright (c) 2014-2018, Jon Schlinkert.
   * Released under the MIT License.
   *)
  (*!
   * Array of passes.
   *
   * A `pass` is just a function that is executed on `req, res, options`
   * so that you can easily add new checks while still keeping the base
   * flexible.
   *)
  (*!
   * Array of passes.
   *
   * A `pass` is just a function that is executed on `req, socket, options`
   * so that you can easily add new checks while still keeping the base
   * flexible.
   *)
  (*!
   * Caron dimonio, con occhi di bragia
   * loro accennando, tutte le raccoglie;
   * batte col remo qualunque s’adagia 
   *
   * Charon the demon, with the eyes of glede,
   * Beckoning to them, collects them all together,
   * Beats with his oar whoever lags behind
   *          
   *          Dante - The Divine Comedy (Canto III)
   *)
*/
//# sourceMappingURL=vuepress.js.map
