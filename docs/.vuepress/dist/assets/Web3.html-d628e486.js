import{_ as s,M as n,p as c,q as i,R as a,t as e,N as o,a1 as r}from"./framework-f7ec573f.js";const l="/Web3/solidity.png",d={},p=r('<h1 id="web3" tabindex="-1"><a class="header-anchor" href="#web3" aria-hidden="true">#</a> Web3</h1><p><strong>首先说一下web1.0和2.0</strong></p><p>在Web1.0时代，互联网只可读不可写，类似于我们只能看抖音，无法评论。Web2.0我们可以读可写。</p><p>Web2.0的特点就是中心化，所有信息都在各个服务器中。中心化的弊端在于容易形成垄断，侵犯用户隐私。</p><p>什么是Web3？Web3.0致力于实现去中心化，自己创造保存信息</p><p><strong>web3的目标</strong></p><p>Web3的目标是实现去中心化、安全、隐私保护和用户掌握数据的网络环境。</p><ol><li>去中心化：Web3强调去中心化的原则，通过使用分布式账本技术（如区块链）来消除单点故障和中心化控制。这使得用户可以直接与其他用户进行交互，而无需依赖中间人或中央权威机构。</li><li>区块链技术：区块链是Web3的核心技术之一。它是一个分布式的、不可篡改的账本，可以记录交易和信息的历史，并确保其安全性和可验证性。区块链技术为Web3提供了可信、透明和安全的数据存储和交换机制。</li><li>智能合约：智能合约是在区块链上执行的可编程代码，可以自动执行合同条款和逻辑。它们使得去中心化应用（DApps）成为可能，用户可以通过智能合约进行交互和执行各种操作，而无需信任第三方。</li><li>去中心化身份和隐私保护：Web3致力于改善用户的身份验证和隐私保护。通过去中心化身份验证系统，用户可以掌握自己的身份数据，并选择与其他实体共享的方式。此外，加密技术和隐私保护协议也被广泛应用于Web3应用程序中，以保障用户的隐私和数据安全。</li><li>互操作性：Web3鼓励不同的应用程序和网络之间的互操作性，使得不同的系统能够无缝地协同工作和共享数据。这通过标准化协议、开放API和去中心化标准组织来实现。</li></ol><h2 id="以太网虚拟机-evm" tabindex="-1"><a class="header-anchor" href="#以太网虚拟机-evm" aria-hidden="true">#</a> 以太网虚拟机 EVM</h2><p>概念：以太坊虚拟机 EVM 是智能合约的运行环境。它不仅是沙盒封装的，而且是完全隔离的，也就是说在 EVM 中运行代码是无法访问网络、文件系统和其他进程的。甚至智能合约之间的访问也是受限的。</p><h3 id="账户" tabindex="-1"><a class="header-anchor" href="#账户" aria-hidden="true">#</a> 账户</h3><p>以太坊中有两类账户（它们共用同一个地址空间）： <strong>外部账户</strong> 由公钥-私钥对（也就是人）控制； <strong>合约账户</strong> 由和账户一起存储的代码控制.外部账户的地址是由公钥决定的，而合约账户的地址是在创建该合约时确定的（这个地址通过合约创建者的地址和从该地址发出过的交易数量计算得到的，也就是所谓的“nonce”）</p><p>无论帐户是否存储代码，这两类账户对 EVM 来说是一样的。</p><p>每个账户都有一个键值对形式的持久化存储。其中 key 和 value 的长度都是256位，我们称之为 <strong>存储</strong> 。</p><p>此外，每个账户有一个以太币余额（ <strong>balance</strong> ）（单位是“Wei”, <code>1 ether</code> 是 <code>10**18 wei</code>），余额会因为发送包含以太币的交易而改变。</p><h3 id="交易" tabindex="-1"><a class="header-anchor" href="#交易" aria-hidden="true">#</a> 交易</h3><p>交易可以看作是从一个帐户发送到另一个帐户的消息（这里的账户，可能是相同的或特殊的零帐户，请参阅下文）。它能包含一个二进制数据（合约负载）和以太币。</p><p>如果目标账户含有代码，此代码会被执行，并以 payload 作为入参。</p><p>如果目标账户是零账户（账户地址为 <code>0</code> )，此交易将创建一个 <strong>新合约</strong> 。 如前文所述，合约的地址不是零地址，而是通过合约创建者的地址和从该地址发出过的交易数量计算得到的（所谓的“nonce”）。 这个用来创建合约的交易的 payload 会被转换为 EVM 字节码并执行。执行的输出将作为合约代码被永久存储。这意味着，为创建一个合约，你不需要发送实际的合约代码，而是发送能够产生合约代码的代码。</p><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>在合约创建的过程中，它的代码还是空的。所以直到构造函数执行结束，你都不应该在其中调用合约自己函数。</p></div><h3 id="gas" tabindex="-1"><a class="header-anchor" href="#gas" aria-hidden="true">#</a> Gas</h3><p>一经创建，每笔交易都收取一定数量的 <strong>gas</strong> ，必须由原始交易发起人（ <code>tx.orgin</code> ）支付。 EVM 执行交易时，gas 将按特定规则逐渐耗尽。 无论执行到什么位置，一旦 gas 被耗尽（比如降为负值），将会触发一个 out-of-gas 异常。当前调用帧（call frame）所做的所有状态修改都将被回滚。</p><p>Gas机制激励了对EVM执行时间的经济使用，同时也补偿了 EVM 执行者（即矿工）的工作。 由于每个区块有一个最大的Gas数量(区块 gas limit)，它也限制了验证一个区块所需的工作量。</p><p><strong>gas price</strong> 是交易发送者设置的一个值，发送者账户需要预付的手续费= <code>gas_price * gas</code> 。如果交易执行后还有剩余， gas 会原路返还。 如果出现异常（exception），回退交易，已经用完的Gas就不会被退还。</p><p>由于EVM执行者可以选择是否包括交易。交易发送者不能通过设置一个低的Gas价格来滥用系统。</p><h3 id="存储-内存和栈" tabindex="-1"><a class="header-anchor" href="#存储-内存和栈" aria-hidden="true">#</a> 存储，内存和栈</h3><p>以太坊虚拟机有 3 个区域用来存储数据： 存储（storage）, 内存（memory） 和 栈（stack）.</p><p>每个账户有一块持久化内存区称为 <strong>存储</strong> 。 存储是将256位字映射到256位字的键值存储区。 在合约中枚举存储是不可能的，且读存储的相对开销很高，修改存储的开销甚至更高。合约只能读写存储区内属于自己的部分。</p><p>第二个内存区称为 <strong>内存</strong> ，合约会试图为每一次消息调用获取一块被重新擦拭干净的内存实例。 内存是线性的，可按字节级寻址，但读的长度被限制为256位，而写的长度可以是8位或256位。当访问（无论是读还是写）之前从未访问过的内存字（word）时（无论是偏移到该字内的任何位置），内存将按字进行扩展（每个字是256位）。扩容也将消耗一定的gas。 随着内存使用量的增长，其费用也会增高（以平方级别）。</p><p>EVM 不是基于寄存器的，而是基于栈的，因此所有的计算都在一个被称为 <strong>栈（stack）</strong> 的区域执行。 栈最大有1024个元素，每个元素长度是一个字（256位）。对栈的访问只限于其顶端，限制方式为：允许拷贝最顶端的16个元素中的一个到栈顶，或者是交换栈顶元素和下面16个元素中的一个。所有其他操作都只能取最顶的两个（或一个，或更多，取决于具体的操作）元素，运算后，把结果压入栈顶。当然可以把栈上的元素放到存储或内存中。但是无法只访问栈上指定深度的那个元素，除非先从栈顶移除其他元素。</p><h3 id="消息调用" tabindex="-1"><a class="header-anchor" href="#消息调用" aria-hidden="true">#</a> 消息调用</h3><p>合约可以通过消息调用的方式来调用其它合约或者发送以太币到非合约账户。消息调用和交易非常类似，它们都有一个源、目标、数据、以太币、gas和返回数据。事实上每个交易都由一个顶层消息调用组成，这个消息调用又可创建更多的消息调用。</p><p>合约可以决定在其内部的消息调用中，对于剩余的 <strong>gas</strong> ，应发送和保留多少。如果在内部消息调用时发生了out-of-gas异常（或其他任何异常），这将由一个被压入栈顶的错误值所指明。此时，只有与该内部消息调用一起发送的gas会被消耗掉。并且，Solidity中，发起调用的合约默认会触发一个手工的异常，以便异常可以从调用栈里“冒泡出来”。 如前文所述，被调用的合约（可以和调用者是同一个合约）会获得一块刚刚清空过的内存，并可以访问调用的payload——由被称为 calldata 的独立区域所提供的数据。调用执行结束后，返回数据将被存放在调用方预先分配好的一块内存中。 调用深度被 <strong>限制</strong> 为 1024 ，因此对于更加复杂的操作，我们应使用循环而不是递归。</p><h3 id="失效和自毁" tabindex="-1"><a class="header-anchor" href="#失效和自毁" aria-hidden="true">#</a> 失效和自毁</h3><p>合约代码从区块链上移除的唯一方式是合约在合约地址上的执行自毁操作 <code>selfdestruct</code> 。合约账户上剩余的以太币会发送给指定的目标，然后其存储和代码从状态中被移除。移除一个合约听上去不错，但其实有潜在的危险，如果有人发送以太币到移除的合约，这些以太币将永远丢失</p><p>即使一个合约被 <code>selfdestruct</code> 删除，它仍然是区块链历史的一部分，可能被大多数以太坊节点保留。 因此，使用 <code>selfdestruct</code> 与从硬盘上删除数据是不同的。</p><p>即便一个合约的代码中没有显式地调用 <code>selfdestruct</code> ，它仍然有可能通过 <code>delegatecall</code> 或 <code>callcode</code> 执行自毁操作。</p><h2 id="以太坊ethereum" tabindex="-1"><a class="header-anchor" href="#以太坊ethereum" aria-hidden="true">#</a> 以太坊Ethereum</h2><p>以太坊是什么？</p><ul><li>庞大的开发者社区，目前最大的区块链开发平台</li><li>资料多</li><li>与js结合紧密</li></ul><h2 id="solidity" tabindex="-1"><a class="header-anchor" href="#solidity" aria-hidden="true">#</a> Solidity</h2><p>特点：</p><ul><li><p>Solidity是一门面向合约的，为实现智能合约而创建的高级编程语言。</p></li><li><p>该语言是静态类型，支持继承、库和复杂用户定义类型。</p></li><li><p>除了常见数据类型还有独特的address等以太坊独有类型。</p></li><li><p>语言层面提供payable关键字支持支付。</p></li><li><p>在数据存储方式上，需要确定好使用内存还是区块链存储</p></li><li><p>运行环境在于去中心化的网络上。</p></li><li><p>错误处理机制比较特殊，一旦出现一场所有执行被回撤，保证合约的原子性。</p></li><li><p>每次交易方式将字节码部署到以太坊网络，每次成功部署都会产生一个新的智能合约账户。</p></li></ul><h3 id="solidity编译器" tabindex="-1"><a class="header-anchor" href="#solidity编译器" aria-hidden="true">#</a> Solidity编译器</h3><p>Remix基于web浏览器的编译器。或者第二种方式安装编译器 solcjs<code>npm install -g solc</code></p><p><img src="'+l+'" alt=""></p><h3 id="关键字" tabindex="-1"><a class="header-anchor" href="#关键字" aria-hidden="true">#</a> 关键字</h3><p>1.<code>pragma</code>告知编译器如何处理源代码的通用指令</p><p>2.<code>public</code>声明了一个可以被公开访问的状态变量</p><p>3.<code>address</code>类型是一个160位的值，且不允许任何算数操作。这种类型适合存储合约地址或外部人员的密钥对。关键字 <code>public</code> 自动生成一个函数，允许你在这个合约之外访问这个状态变量的当前值。如果没有这个关键字，其他的合约没有办法访问这个变量。由编译器生成的函数的代码大致如下所示（暂时忽略 external 和 view）：<code>function minter() external view returns (address) { return minter; }</code></p>',50),h={start:"4"},u={href:"https://learnblockchain.cn/docs/solidity/control-structures.html#assert-and-require",target:"_blank",rel:"noopener noreferrer"},b=r(`<h3 id="模块化" tabindex="-1"><a class="header-anchor" href="#模块化" aria-hidden="true">#</a> 模块化</h3><p>Solidity 支持的导入语句来模块化代码，其语法跟 JavaScript（从 ES6 起）非常类似。 尽管 Solidity 不支持 <code>default export</code>。</p><p>在全局层面上，可使用如下格式的导入语句：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token string">&quot;filename&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这种形式已经不建议使用，因为它会无法预测地污染当前命名空间。 如果在“filename”中添加新的符号，则会自动添加出现在所有导入 “filename” 的文件中。 更好的方式是明确导入的具体 符号。</p><p>像下面这样，创建了新的 <code>symbolName</code> 全局符号，他的成员都来自与导入的 <code>&quot;filename&quot;</code> 文件中的全局符号，如： .. code-block:: solidity</p><blockquote><p>import * as symbolName from “filename”;</p></blockquote><p>然后所有全局符号都以<code>symbolName.symbol</code>格式提供。 此语法的变体不属于ES6，但可能有用：<code>import &quot;filename&quot; as symbolName;</code>它等价于 <code>import * as symbolName from &quot;filename&quot;;</code>。</p><p>如果存在命名冲突，则可以在导入时重命名符号。例如，下面的代码创建了新的全局符号 <code>alias</code> 和 <code>symbol2</code> ，引用的 <code>symbol1</code> 和 <code>symbol2</code> 来自 “filename” 。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span>symbol1 <span class="token keyword">as</span> alias<span class="token punctuation">,</span> symbol2<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;filename&quot;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="合约结构" tabindex="-1"><a class="header-anchor" href="#合约结构" aria-hidden="true">#</a> 合约结构</h3><p>在 Solidity 语言中，合约类似于其他面向对象编程语言中的<strong>类</strong>。合约中有用于数据持久化的状态变量，和可以修改状态变量的函数。 调用另一个合约实例的函数时，会执行一个 EVM 函数调用，这个操作会切换执行时的上下文，这样，前一个合约的状态变量就不能访问了。</p>`,12),m={href:"https://learnblockchain.cn/docs/solidity/structure-of-a-contract.html#structure-state-variables",target:"_blank",rel:"noopener noreferrer"},f={href:"https://learnblockchain.cn/docs/solidity/structure-of-a-contract.html#structure-functions",target:"_blank",rel:"noopener noreferrer"},g={href:"https://learnblockchain.cn/docs/solidity/structure-of-a-contract.html#structure-function-modifiers",target:"_blank",rel:"noopener noreferrer"},_={href:"https://learnblockchain.cn/docs/solidity/structure-of-a-contract.html#structure-events",target:"_blank",rel:"noopener noreferrer"},k={href:"https://learnblockchain.cn/docs/solidity/structure-of-a-contract.html#structure-errors",target:"_blank",rel:"noopener noreferrer"},y={href:"https://learnblockchain.cn/docs/solidity/structure-of-a-contract.html#structure-struct-types",target:"_blank",rel:"noopener noreferrer"},v={href:"https://learnblockchain.cn/docs/solidity/structure-of-a-contract.html#structure-enum-types",target:"_blank",rel:"noopener noreferrer"},x={href:"https://learnblockchain.cn/docs/solidity/contracts.html#libraries",target:"_blank",rel:"noopener noreferrer"},E={href:"https://learnblockchain.cn/docs/solidity/contracts.html#interfaces",target:"_blank",rel:"noopener noreferrer"},W={href:"https://learnblockchain.cn/docs/solidity/contracts.html#constructor",target:"_blank",rel:"noopener noreferrer"},q=a("code",null,"constructor",-1);function V(w,M){const t=n("ExternalLinkIcon");return c(),i("div",null,[p,a("ol",h,[a("li",null,[a("a",u,[e("require"),o(t)]),e(" 用来检查某些条件，如果不满足这些条件就会回推所有的状态变化。")])]),b,a("p",null,[e("每个合约中可以包含 "),a("a",m,[e("状态变量"),o(t)]),e("、 "),a("a",f,[e("函数"),o(t)]),e("、 "),a("a",g,[e("函数 "),o(t)]),e(", "),a("a",_,[e("事件 Event"),o(t)]),e(", "),a("a",k,[e("错误(Errors)"),o(t)]),e(", "),a("a",y,[e("结构体"),o(t)]),e(" 和 "),a("a",v,[e("枚举类型"),o(t)]),e(" 的声明，且合约可以从其他合约继承。还有一些特殊的合约，如： "),a("a",x,[e("库"),o(t)]),e(" 和 "),a("a",E,[e("接口"),o(t)]),e(".")]),a("p",null,[e("创建合约时， 合约的 "),a("a",W,[e("构造函数"),o(t)]),e(" (一个用关键字 "),q,e(" 声明的函数)会执行一次。 构造函数是可选的。只允许有一个构造函数，这意味着不支持重载。")])])}const N=s(d,[["render",V],["__file","Web3.html.vue"]]);export{N as default};
